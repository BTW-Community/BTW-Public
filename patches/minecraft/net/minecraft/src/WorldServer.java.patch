--- a/minecraft/net/minecraft/src/WorldServer.java
+++ b/minecraft/net/minecraft/src/WorldServer.java
@@ -1,9 +1,15 @@
 package net.minecraft.src;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
@@ -13,7 +19,12 @@
 {
     private final MinecraftServer mcServer;
     private final EntityTracker theEntityTracker;
-    private final PlayerManager thePlayerManager;
+	// FCMOD: Changed
+	//private final PlayerManager thePlayerManager;
+	private final FCChunkTracker m_chunkTracker;
+	// END FCMOD
+
+	// FCNOTE: Contains NextTickListEntry objects with updates scheduled for blocks
     private Set field_73064_N;
 
     /** All work to do in future ticks. */
@@ -48,9 +59,19 @@
     {
         super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
         this.mcServer = par1MinecraftServer;
+
+		// FCMOD: Added
+		saveHandler.LoadModSpecificData( this );
+		// END FCMOD
+
         this.theEntityTracker = new EntityTracker(this);
-        this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
 
+		// FCMOD: Changed
+		//this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
+		m_chunkTracker = new FCChunkTracker( this, 
+				par1MinecraftServer.getConfigurationManager().getViewDistance());
+		// END FCMOD
+
         if (this.entityIdMap == null)
         {
             this.entityIdMap = new IntHashMap();
@@ -91,6 +112,12 @@
         {
             this.difficultySetting = 3;
         }
+		// FCMOD: Added to eliminate peaceful and easy difficulties
+		else if ( difficultySetting < 2 )
+		{
+			difficultySetting = 2;
+		}
+		// END FCMOD
 
         this.provider.worldChunkMgr.cleanupCache();
 
@@ -115,7 +142,12 @@
 
         if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
         {
+			// FCMOD: Code change to prevent animal spawning after chunk generation
+			/*
             SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
+			 */
+			SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, false);
+			// END FCMOD
         }
 
         this.theProfiler.endStartSection("chunkSource");
@@ -134,10 +166,15 @@
         this.theProfiler.endStartSection("tickTiles");
         this.tickBlocksAndAmbiance();
         this.theProfiler.endStartSection("chunkMap");
-        this.thePlayerManager.updatePlayerInstances();
+		// FCMOD: Changed
+		//this.thePlayerManager.updatePlayerInstances();
+		m_chunkTracker.Update();
+		// END FCMOD
         this.theProfiler.endStartSection("village");
         this.villageCollectionObj.tick();
-        this.villageSiegeObj.tick();
+		// FCMOD: Removed
+		//this.villageSiegeObj.tick();
+		// END FCMOD
         this.theProfiler.endStartSection("portalForcer");
         this.field_85177_Q.removeStalePortalLocations(this.getTotalWorldTime());
         this.theProfiler.endSection();
@@ -264,7 +301,10 @@
         super.tickBlocksAndAmbiance();
         int var1 = 0;
         int var2 = 0;
-        Iterator var3 = this.activeChunkSet.iterator();
+		// FCMOD: Changed
+		//Iterator var3 = this.activeChunkSet.iterator();
+		Iterator<ChunkCoordIntPair> var3 = m_activeChunksCoordsList.iterator();
+		// END FCMOD
 
         while (var3.hasNext())
         {
@@ -282,7 +322,10 @@
             int var10;
             int var11;
 
-            if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+			// FCMOD: Changed
+			//if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+			if ( rand.nextInt( 50000 ) == 0 && isRaining() && isThundering() )
+				// END FCMOD 
             {
                 this.updateLCG = this.updateLCG * 3 + 1013904223;
                 var8 = this.updateLCG >> 2;
@@ -290,11 +333,25 @@
                 var10 = var6 + (var8 >> 8 & 15);
                 var11 = this.getPrecipitationHeight(var9, var10);
 
-                if (this.canLightningStrikeAt(var9, var11, var10))
+		// FCMOD: Changed
+		//if (this.canLightningStrikeAt(var9, var11, var10))
+		if ( CanLightningStrikeAtPos( var9, var11, var10 ) )
+			// END FCMOD
                 {
-                    this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
+			// FCMOD: Changed
+			//this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
+			FCUtilsBlockPos strikePos = new FCUtilsBlockPos( var9, var11, var10 );
+
+			AdjustLightningPosForSurroundings( strikePos );
+
+			if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
+			{
+				addWeatherEffect( new FCEntityLightningBolt( this, (double)strikePos.i + 0.5D, 
+						(double)strikePos.j, (double)strikePos.k + 0.5D ) );
                 }
+			// END FCMOD
             }
+			}
 
             this.theProfiler.endStartSection("iceandsnow");
             int var13;
@@ -316,12 +373,21 @@
                 {
                     this.setBlock(var9 + var5, var11, var10 + var6, Block.snow.blockID);
                 }
+				// FCMOD: Added
+				else if (this.isRaining() && this.canSnowAt(var9 + var5, var11 + 1, var10 + var6))
+				{
+					setBlock(var9 + var5, var11 + 1, var10 + var6, Block.snow.blockID);
+				}
+				// END FCMOD
 
                 if (this.isRaining())
                 {
                     BiomeGenBase var12 = this.getBiomeGenForCoords(var9 + var5, var10 + var6);
 
-                    if (var12.canSpawnLightningBolt())
+					// FCMOD: Changed for clarity
+					//if (var12.canSpawnLightningBolt())
+					if ( var12.CanRainInBiome() )
+						// END FCMOD
                     {
                         var13 = this.getBlockId(var9 + var5, var11 - 1, var10 + var6);
 
@@ -339,25 +405,30 @@
 
             for (var10 = 0; var10 < var9; ++var10)
             {
-                ExtendedBlockStorage var20 = var19[var10];
+				ExtendedBlockStorage var21 = var19[var10];
 
-                if (var20 != null && var20.getNeedsRandomTick())
+				if (var21 != null && var21.getNeedsRandomTick())
                 {
-                    for (int var21 = 0; var21 < 3; ++var21)
+					for (int var20 = 0; var20 < 3; ++var20)
                     {
                         this.updateLCG = this.updateLCG * 3 + 1013904223;
                         var13 = this.updateLCG >> 2;
                         int var14 = var13 & 15;
                         int var15 = var13 >> 8 & 15;
                         int var16 = var13 >> 16 & 15;
-                        int var17 = var20.getExtBlockID(var14, var16, var15);
+					int var17 = var21.getExtBlockID(var14, var16, var15);
                         ++var2;
                         Block var18 = Block.blocksList[var17];
 
                         if (var18 != null && var18.getTickRandomly())
                         {
                             ++var1;
-                            var18.updateTick(this, var14 + var5, var16 + var20.getYLocation(), var15 + var6, this.rand);
+						// FCMOD: Code changed
+						/*
+                            var18.updateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, this.rand);
+						 */
+						var18.RandomUpdateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, rand);
+						// END FCMOD
                         }
                     }
                 }
@@ -365,10 +436,15 @@
 
             this.theProfiler.endSection();
         }
+
+		// FCMOD: Added
+		ModUpdateTick();
+		// END FCMOD
     }
 
     /**
      * Returns true if the given block will receive a scheduled tick in the future. Args: X, Y, Z, blockID
+	 * FCNOTE: This is actually whether the block is about to be ticked THIS UPDATE.
      */
     public boolean isBlockTickScheduled(int par1, int par2, int par3, int par4)
     {
@@ -387,13 +463,21 @@
     public void func_82740_a(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
-        byte var8 = 0;
+		// FCMOD: Removed
+		//byte var8 = 0;
+		// END FCMOD
 
         if (this.scheduledUpdatesAreImmediate && par4 > 0)
         {
             if (Block.blocksList[par4].func_82506_l())
             {
+				// FCCHUNK: Decide on updates around original spawn
+				// FCMOD: Changed
+				/*
                 if (this.checkChunksExist(var7.xCoord - var8, var7.yCoord - var8, var7.zCoord - var8, var7.xCoord + var8, var7.yCoord + var8, var7.zCoord + var8))
+				 */
+				if ( IsBlockPosActive( var7.xCoord, var7.yCoord, var7.zCoord ) )
+					// END FCMOD
                 {
                     int var9 = this.getBlockId(var7.xCoord, var7.yCoord, var7.zCoord);
 
@@ -409,7 +493,13 @@
             par5 = 1;
         }
 
+		// FCCHUNK: Decide on updates around original spawn
+		// FCMOD: Changed
+		/*
         if (this.checkChunksExist(par1 - var8, par2 - var8, par3 - var8, par1 + var8, par2 + var8, par3 + var8))
+		 */
+		if ( IsBlockPosActive( par1, par2, par3 ) )
+			// END FCMOD
         {
             if (par4 > 0)
             {
@@ -450,6 +540,8 @@
      */
     public void updateEntities()
     {
+		// FCMOD: Removed pausing of updates when no players in world.  Replaced elsewhere
+		/*
         if (this.playerEntities.isEmpty())
         {
             if (this.updateEntityTick++ >= 1200)
@@ -461,6 +553,8 @@
         {
             this.resetUpdateEntityTick();
         }
+		 */
+		// END FCMOD
 
         super.updateEntities();
     }
@@ -516,9 +610,16 @@
             {
                 var4 = (NextTickListEntry)var14.next();
                 var14.remove();
+				// FCCHUNK: Decide on updates around original spawn
+				// FCMOD: Changed to prevent neighboring chunks inadvertantly being loaded during
+				// updates.  This was causing stuff like fire loading a ton of chunks in the nether.
+				/*
                 byte var5 = 0;
 
                 if (this.checkChunksExist(var4.xCoord - var5, var4.yCoord - var5, var4.zCoord - var5, var4.xCoord + var5, var4.yCoord + var5, var4.zCoord + var5))
+				 */
+				if ( IsBlockPosActive( var4.xCoord, var4.yCoord, var4.zCoord ) )
+					// END FCMOD
                 {
                     int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
 
@@ -548,10 +649,19 @@
                         }
                     }
                 }
+				// FCCHUNK: Decide on updates around original spawn
+				// FCMOD: Removed to reduce unnecessary overhead of recheduling ticks in inactive chunks
+				/*
                 else
                 {
-                    this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
+                	// FCMOD: Changed to not immediately retick on next update to ease on performance
+                    //this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
+                    scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 
+                    	Block.blocksList[var4.blockID].tickRate( this ) );
+                    // END FCMOD
                 }
+				 */
+				// END FCMOD
             }
 
             this.theProfiler.endSection();
@@ -630,7 +740,23 @@
 
         if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
         {
+			// Added so that creatures in periphery chunks can still despawn
+			int iEntityI = MathHelper.floor_double( par1Entity.posX );
+			int iEntityK = MathHelper.floor_double( par1Entity.posZ );
+
+			if ( par2 && !IsBlockPosActive( iEntityI, 0, iEntityK ) && par1Entity.addedToChunk  )
+			{
+				if ( par1Entity.ridingEntity == null )
+				{
+					par1Entity.OutOfUpdateRangeUpdate();
+				}
+
+				return; // intentionally skip super call
+			}
+			// END FCMOD
+
             super.updateEntityWithOptionalForce(par1Entity, par2);
+
         }
     }
 
@@ -652,6 +778,14 @@
         return this.theChunkProviderServer;
     }
 
+	// FCMOD: Added (server only) alias to match client
+	/*
+    public List getAllTileEntityInBox( int par1, int par2, int par3, int par4, int par5, int par6 )
+    {
+    	return getTileEntityList( par1, par2, par3, par4, par5, par6 );
+    }
+	 */
+	// END FCMOD
     /**
      * pars: min x,y,z , max x,y,z
      */
@@ -760,7 +894,10 @@
      */
     protected void createBonusChest()
     {
-        WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
+		// FCMOD: Changed
+		//WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
+		FCWorldGeneratorBonusBasket var1 = new FCWorldGeneratorBonusBasket();
+		// END FCMOD
 
         for (int var2 = 0; var2 < 10; ++var2)
         {
@@ -803,6 +940,10 @@
             }
 
             this.chunkProvider.saveChunks(par1, par2IProgressUpdate);
+
+			// FCMOD: Added
+			saveHandler.SaveModSpecificData( this );
+			// END FCMOD
         }
     }
 
@@ -875,7 +1016,19 @@
     {
         if (super.addWeatherEffect(par1Entity))
         {
-            this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+			// FCMOD: Changed to avoid modding Packet71Weather        	
+			//this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+			Packet71Weather packet = new Packet71Weather( par1Entity );
+
+			if ( par1Entity instanceof FCEntityLightningBolt )
+			{
+				packet.isLightningBolt = 1;
+			}
+
+			this.mcServer.getConfigurationManager().sendToAllNear(
+					par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, provider.dimensionId, 
+					packet );
+			// END FCMOD
             return true;
         }
         else
@@ -992,6 +1145,8 @@
     /**
      * Updates all weather states.
      */
+	// FCMOD: Removed and replaced later
+	/*
     protected void updateWeather()
     {
         boolean var1 = this.isRaining();
@@ -1009,6 +1164,8 @@
             }
         }
     }
+	 */
+	// END FCMOD
 
     /**
      * Gets the MinecraftServer.
@@ -1026,13 +1183,460 @@
         return this.theEntityTracker;
     }
 
+	// FCMOD: Removed
+	/*
     public PlayerManager getPlayerManager()
     {
         return this.thePlayerManager;
     }
+	 */
+	// END FCMOD
 
     public Teleporter getDefaultTeleporter()
     {
         return this.field_85177_Q;
     }
+
+	// FCMOD: Added
+	private boolean m_bHasTicked = false;
+
+	protected LinkedList<ChunkCoordIntPair> m_chunksToCheckForUnloadList = 
+			new LinkedList<ChunkCoordIntPair>();
+
+	private long m_lNoPlayersOnServerTickCount = 0;
+
+	// MinecraftServer loads out to 192 blocks, or 12 chunks. One more for wiggle.
+
+	private final int m_iChunksAroundSpawnToCheckForUnload = 13;  
+
+	@Override
+	public void ModSpecificTick()
+	{
+		if ( !m_bHasTicked )
+		{
+			m_bHasTicked = true;
+
+			MarkChunksAroundSpawnToCheckForUnload();
 }
+
+		CheckChunksToUnloadList();
+	}    
+
+	public void AddChunkToCheckForUnloadList( int iChunkX, int iChunkZ )
+	{
+		m_chunksToCheckForUnloadList.add( new ChunkCoordIntPair( iChunkX, iChunkZ ) );
+	}
+
+	public void AddChunkRangeToCheckForUnloadList( int iMinChunkX, int iMinChunkZ, 
+			int iMaxChunkX, int iMaxChunkZ )
+	{
+		for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
+		{
+			for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
+			{
+				AddChunkToCheckForUnloadList( iTempChunkX, iTempChunkZ );
+			}
+		}
+	}
+
+	private void CheckChunksToUnloadList()
+	{
+		if ( !m_chunksToCheckForUnloadList.isEmpty() )
+		{
+			Iterator<ChunkCoordIntPair> tempIterator = m_chunksToCheckForUnloadList.iterator();
+
+			while ( tempIterator.hasNext() )
+			{
+				ChunkCoordIntPair tempCoord = tempIterator.next();
+
+				if ( CheckChunkShouldBeUnloaded( tempCoord.chunkXPos, tempCoord.chunkZPos ) )
+				{
+					theChunkProviderServer.ForceAddToChunksToUnload( 
+							tempCoord.chunkXPos, tempCoord.chunkZPos );
+				}
+			}
+
+			m_chunksToCheckForUnloadList.clear();
+		}
+	}
+
+	private boolean CheckChunkShouldBeUnloaded( int iChunkX, int iChunkZ )
+	{
+		return chunkExists( iChunkX, iChunkZ ) && 
+				!m_chunkTracker.IsChunkBeingWatched( iChunkX, iChunkZ  )&&
+				!theChunkProviderServer.IsSpawnChunk( iChunkX, iChunkZ );
+	}
+
+	private void MarkChunksAroundSpawnToCheckForUnload()
+	{
+		// this function cleans up extra useless overworld chunks loaded by 
+		// MinecraftServer.initialWorldChunkLoad()
+
+		if ( provider.canRespawnHere() )
+		{
+			int iSpawnChunkX = worldInfo.getSpawnX() >> 4;
+			int iSpawnChunkZ = worldInfo.getSpawnZ() >> 4;
+
+			AddChunkRangeToCheckForUnloadList( 
+					iSpawnChunkX - m_iChunksAroundSpawnToCheckForUnload, 
+					iSpawnChunkZ - m_iChunksAroundSpawnToCheckForUnload,
+					iSpawnChunkX + m_iChunksAroundSpawnToCheckForUnload, 
+					iSpawnChunkZ + m_iChunksAroundSpawnToCheckForUnload );        
+		}
+	}
+
+	@Override
+	public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
+	{
+		NextTickListEntry tempEntry = new NextTickListEntry( i, j, k, iBlockID );
+
+		return field_73064_N.contains( tempEntry );
+	}
+
+	@Override
+	protected void updateWeather()
+	{
+		// Vanilla code replaced to fix storms not relaying state to clients and a couple of other little oddities like the state
+		// changes for weather not being communicated immeditately
+
+		super.updateWeather();
+
+		if ( worldInfo.m_bPreviouslyRaining != worldInfo.isRaining() )
+		{
+			if ( worldInfo.isRaining() )
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 1, 0 ) );
+			}
+			else
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 2, 0 ) );
+			}
+
+			worldInfo.m_bPreviouslyRaining = worldInfo.isRaining();
+		}
+
+		if ( worldInfo.m_bPreviouslyThundering != worldInfo.isThundering() )
+		{
+			if ( worldInfo.isThundering() )
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 7, 0 ) );
+			}
+			else
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 8, 0 ) );
+			}
+
+			worldInfo.m_bPreviouslyThundering = worldInfo.isThundering();
+		}
+	}
+
+	private void ModUpdateTick()
+	{
+		ValidateMagneticPointList();
+
+		ValidateLootingBeaconList();
+
+		ValidateSpawnLocationList();
+	}
+
+	private void ValidateMagneticPointList()
+	{
+		// periodically check the magnetic point list for dead points
+
+		int iTimeFactor = (int)getWorldTime();
+
+		if ( ( iTimeFactor & 15 ) == 0 )
+		{
+			int iListLength = m_MagneticPointList.m_MagneticPoints.size();
+
+			if ( iListLength > 0 )
+			{
+				iTimeFactor = iTimeFactor >> 4;
+
+		int iTempIndex = (int)( iTimeFactor % iListLength );
+
+		FCMagneticPoint tempPoint = (FCMagneticPoint)m_MagneticPointList.m_MagneticPoints.get( iTempIndex );
+
+		if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
+		{
+			// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
+
+			if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
+			{
+				m_MagneticPointList.m_MagneticPoints.remove( iTempIndex );
+
+			}
+		}    			
+			}
+		}
+	}
+
+	private void ValidateLootingBeaconList()
+	{
+		// periodically check the looting beacon list for dead points
+
+		int iTimeFactor = (int)getWorldTime();
+
+		if ( ( iTimeFactor & 15 ) == 0 )
+		{
+			int iListLength = m_LootingBeaconLocationList.m_EffectLocations.size();
+
+			if ( iListLength > 0 )
+			{
+				iTimeFactor = iTimeFactor >> 4;
+
+			int iTempIndex = (int)( iTimeFactor % iListLength );
+
+			FCBeaconEffectLocation tempPoint = (FCBeaconEffectLocation)m_LootingBeaconLocationList.m_EffectLocations.get( iTempIndex );
+
+			if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
+			{
+				// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
+
+				if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
+				{
+					m_LootingBeaconLocationList.m_EffectLocations.remove( iTempIndex );
+
+				}
+			}    			
+			}
+		}
+	}
+
+	private void ValidateSpawnLocationList()
+	{
+		// periodically check the list for dead points
+
+		long lWorldTime = getWorldTime();
+
+		if ( ( lWorldTime & 15 ) == 0 )
+		{
+			Iterator tempIterator = m_SpawnLocationList.m_SpawnLocations.iterator();
+
+			while ( tempIterator.hasNext() )
+			{
+				FCSpawnLocation tempPoint = (FCSpawnLocation)tempIterator.next();
+
+				if ( lWorldTime < tempPoint.m_lSpawnTime || lWorldTime - tempPoint.m_lSpawnTime > FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
+				{        			
+					tempIterator.remove();
+				}        		
+			}
+		}
+	}
+
+	protected void AdjustLightningPosForSurroundings( FCUtilsBlockPos strikePos )
+	{
+		int iHighJ = strikePos.j;
+
+		// store bounds variables since strikePos changes during search
+
+		int iMinI = strikePos.i - 16;
+		int iMinK = strikePos.k - 16;
+
+		int iMaxI = strikePos.i + 16;
+		int iMaxK = strikePos.k + 16;
+
+		for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
+		{
+			for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
+			{
+				int iTempJ = getPrecipitationHeight( iTempI, iTempK );
+
+				if ( iTempJ > iHighJ )
+				{
+					if ( CanLightningStrikeAtPos( iTempI, iTempJ, iTempK ) )
+					{
+						strikePos.i = iTempI;
+						iHighJ = strikePos.j = iTempJ;
+						strikePos.k = iTempK;
+					}
+				}
+			}
+		}    	
+
+		// check entities
+
+		List<Entity> entityList = getEntitiesWithinAABB( Entity.class, AxisAlignedBB.getAABBPool().getAABB( 
+				iMinI, iHighJ, iMinK, iMaxI + 1D, 256D, iMaxK + 1D ) );
+
+		Iterator<Entity> entityIterator = entityList.iterator();
+
+		while ( entityIterator.hasNext() )
+		{
+			Entity tempEntity = entityIterator.next();
+
+			if ( tempEntity.isEntityAlive() && tempEntity.AttractsLightning() )
+			{
+				int iEntityMaxJ = (int)tempEntity.boundingBox.maxY + 1;
+
+				if ( iEntityMaxJ > iHighJ )
+				{            	
+					int iEntityI = MathHelper.floor_double( tempEntity.posX );
+					int iEntityK = MathHelper.floor_double( tempEntity.posZ );
+
+					int iPrecipitationJ = getPrecipitationHeight( iEntityI, iEntityK );
+
+					if ( iPrecipitationJ <= iEntityMaxJ &&
+							CanLightningStrikeAtPos( iEntityI, iPrecipitationJ, iEntityK ) )
+					{
+						strikePos.i = iEntityI;
+						iHighJ = strikePos.j = iPrecipitationJ;
+						strikePos.k = iEntityK;
+					}	                
+				}                
+			}
+		}
+
+		// secondary search for lightning rods in a larger area around new strike pos
+
+		if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
+		{
+			iMinI = strikePos.i - 16;
+			iMinK = strikePos.k - 16;
+
+			iMaxI = strikePos.i + 16;
+			iMaxK = strikePos.k + 16;
+
+			for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
+			{
+				for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
+				{
+					int iTempJ = getPrecipitationHeight( iTempI, iTempK );
+
+					if ( iTempJ > iHighJ && getBlockId( iTempI, iTempJ - 1, iTempK ) == 
+							FCBetterThanWolves.fcBlockLightningRod.blockID )
+					{
+						// intentionally don't test CanLightningStrikeAtPos() so that
+						// rods in non-lightning biomes can still attract lightning to them
+
+						strikePos.i = iTempI;
+						iHighJ = strikePos.j = iTempJ;
+						strikePos.k = iTempK;
+					}
+				}
+			}        	
+		}
+	}
+
+	@Override
+	public int GetClampedViewDistanceInChunks()
+	{
+		int iRange = getMinecraftServer().getConfigurationManager().getViewDistance();
+
+		return MathHelper.clamp_int( iRange, 3, 15 );
+	}
+
+	@Override
+	protected void UpdateActiveChunkMap()
+	{
+		super.UpdateActiveChunkMap();
+
+		UpdateServerIdleState();    	
+
+		// FCCHUNK: Decide on updates around original spawn
+
+		if ( provider.dimensionId == 0 && !IsServerIdle() )
+		{
+			ChunkCoordinates originalSpawn = getSpawnPoint();
+
+			AddAreaAroundChunkToActiveChunkMap( originalSpawn.posX >> 4, 
+					originalSpawn.posZ >> 4 );
+		}
+	}
+
+	public FCChunkTracker GetChunkTracker()
+	{
+		return m_chunkTracker;
+	}    
+
+	protected void UpdateServerIdleState()
+	{
+		if ( !AreAnyPlayersOnServer() )
+		{
+			m_lNoPlayersOnServerTickCount++;
+		}
+		else
+		{
+			m_lNoPlayersOnServerTickCount = 0;
+		}
+	}
+
+	protected boolean IsServerIdle()
+	{
+		return m_lNoPlayersOnServerTickCount >= 1200L;
+	}
+
+	protected boolean AreAnyPlayersOnServer()
+	{
+		return mcServer.getCurrentPlayerCount() > 0;
+	}
+
+	//------------ Addon Data Handling -----------//
+
+	private Map<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> addonWorldDataMap = new HashMap();
+
+	public void saveWorldDataToNBT(File dimensionDirectory) {
+		for (Map.Entry<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> entry : addonWorldDataMap.entrySet()) {
+			NBTTagCompound modData = new NBTTagCompound();
+	        
+			entry.getValue().saveWorldDataToNBT(this, modData);
+	        
+	        NBTTagCompound fileData = new NBTTagCompound();
+	        
+	        fileData.setTag( "Data", modData );
+
+	        try {
+	            File modSaveFile = new File(dimensionDirectory, entry.getValue().getFilename() + ".dat");
+	            
+	            if (modSaveFile.exists()) {
+	            	modSaveFile.delete();
+	            }
+	            
+	            CompressedStreamTools.writeCompressed( fileData, new FileOutputStream(modSaveFile) );
+
+	        }
+	        catch (Exception e) {
+	            e.printStackTrace();
+	        }
+		}
+	}
+
+	public void loadWorldDataFromNBT(File dimensionDirectory) {
+		addonWorldDataMap = FCAddOnHandler.initWorldDataForAddon();
+		
+		for (Map.Entry<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> entry : addonWorldDataMap.entrySet()) {
+			File modSaveFile = null;
+			
+			try {
+				modSaveFile = new File(dimensionDirectory, entry.getValue().getFilename() + ".dat");
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+
+			if (modSaveFile != null && modSaveFile.exists()) {
+				try {
+					NBTTagCompound fileTag = CompressedStreamTools.readCompressed( new FileInputStream(modSaveFile));
+					NBTTagCompound dataTag = fileTag.getCompoundTag("Data");
+
+					entry.getValue().loadWorldDataFromNBT(this, dataTag);
+				}
+				catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	public FCAddOnUtilsWorldData getWorldDataForMod(Class<? extends FCAddOn> mod) {
+		if (addonWorldDataMap.containsKey(mod))
+			return addonWorldDataMap.get(mod);
+		else
+			return null;
+	}
+
+	public void setWorldDataForMod(Class<? extends FCAddOn> mod, FCAddOnUtilsWorldData data) {
+		addonWorldDataMap.put(mod, data);
+	}
+	// END FCMOD
+}
