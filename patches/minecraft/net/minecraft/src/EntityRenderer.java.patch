--- a/minecraft/net/minecraft/src/EntityRenderer.java
+++ b/minecraft/net/minecraft/src/EntityRenderer.java
@@ -1,5 +1,10 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.cc.Colorizer;
+import com.prupe.mcpatcher.cc.Lightmap;
+import com.prupe.mcpatcher.renderpass.RenderPass;
+
 import java.awt.image.BufferedImage;
 import java.nio.FloatBuffer;
 import java.util.List;
@@ -88,8 +93,15 @@
 
     /** FOV multiplier temp */
     private float fovMultiplierTemp;
+    
+    // FCMOD: Changed (client only) the name of this variable for clarity
+    /*
     private float field_82831_U;
     private float field_82832_V;
+    */
+    private float fWitherEffectIntensity;
+    private float fPreviousWithEffectIntensity;
+    // END FCMOD
 
     /** Cloud fog mode */
     private boolean cloudFog = false;
@@ -109,7 +121,7 @@
     private boolean lightmapUpdateNeeded = false;
 
     /** Torch flicker X */
-    float torchFlickerX = 0.0F;
+    public float torchFlickerX = 0.0F;
 
     /** Torch flicker DX */
     float torchFlickerDX = 0.0F;
@@ -202,22 +214,23 @@
         ++this.rendererUpdateCount;
         this.itemRenderer.updateEquippedItem();
         this.addRainParticles();
-        this.field_82832_V = this.field_82831_U;
+        this.fPreviousWithEffectIntensity = this.fWitherEffectIntensity;
 
+        // FCNOTE: The follwing test is basically "if the wither is present"
         if (BossStatus.field_82825_d)
         {
-            this.field_82831_U += 0.05F;
+            this.fWitherEffectIntensity += 0.05F;
 
-            if (this.field_82831_U > 1.0F)
+            if (this.fWitherEffectIntensity > 1.0F)
             {
-                this.field_82831_U = 1.0F;
+                this.fWitherEffectIntensity = 1.0F;
             }
 
             BossStatus.field_82825_d = false;
         }
-        else if (this.field_82831_U > 0.0F)
+        else if (this.fWitherEffectIntensity > 0.0F)
         {
-            this.field_82831_U -= 0.0125F;
+            this.fWitherEffectIntensity -= 0.0125F;
         }
     }
 
@@ -232,15 +245,31 @@
             {
                 this.mc.pointedEntityLiving = null;
                 double var2 = (double)this.mc.playerController.getBlockReachDistance();
+                // FCMOD: Changed (client only) to limit snow ray-trace tests to this call
+                /*
                 this.mc.objectMouseOver = this.mc.renderViewEntity.rayTrace(var2, par1);
+                */
+                this.mc.objectMouseOver = this.mc.renderViewEntity.MouseOverCustomRayTrace(var2, par1);
+                // END FCMOD
+                
                 double var4 = var2;
                 Vec3 var6 = this.mc.renderViewEntity.getPosition(par1);
 
                 if (this.mc.playerController.extendedReach())
                 {
+                	// FCMOD: Changed (client only) to fix weird reach problems in 
+                	//creative mode between blocks and entities
+        			/*
                     var2 = 6.0D;
                     var4 = 6.0D;
+					*/
+		        	if ( var4 > 6D )
+		        	{
+		        		var4 = 6D;
                 }
+		        	var2 = var4;
+		        	// END FCMOD
+                }
                 else
                 {
                     if (var2 > 3.0D)
@@ -735,8 +764,12 @@
     {
         WorldClient var2 = this.mc.theWorld;
 
-        if (var2 != null)
+        if (Lightmap.computeLightmap(this, var2, this.lightmapColors, par1))
         {
+            this.mc.renderEngine.createTextureFromBytes(this.lightmapColors, 16, 16, this.lightmapTexture);
+        }
+        else if (var2 != null)
+        {
             for (int var3 = 0; var3 < 256; ++var3)
             {
                 float var4 = var2.getSunBrightness(1.0F) * 0.95F + 0.05F;
@@ -760,9 +793,9 @@
                 var15 = var15 * 0.96F + 0.03F;
                 float var16;
 
-                if (this.field_82831_U > 0.0F)
+                if (this.fWitherEffectIntensity > 0.0F)
                 {
-                    var16 = this.field_82832_V + (this.field_82831_U - this.field_82832_V) * par1;
+                    var16 = this.fPreviousWithEffectIntensity + (this.fWitherEffectIntensity - this.fPreviousWithEffectIntensity) * par1;
                     var13 = var13 * (1.0F - var16) + var13 * 0.7F * var16;
                     var14 = var14 * (1.0F - var16) + var14 * 0.6F * var16;
                     var15 = var15 * (1.0F - var16) + var15 * 0.6F * var16;
@@ -793,8 +826,12 @@
                     }
 
                     var13 = var13 * (1.0F - var16) + var13 * var17 * var16;
+                    // FCMOD: Removed (client only) to only modify red with night vision
+                    /*
                     var14 = var14 * (1.0F - var16) + var14 * var17 * var16;
                     var15 = var15 * (1.0F - var16) + var15 * var17 * var16;
+                    */
+                    // END FCMOD
                 }
 
                 if (var13 > 1.0F)
@@ -873,6 +910,12 @@
     private float getNightVisionBrightness(EntityPlayer par1EntityPlayer, float par2)
     {
         int var3 = par1EntityPlayer.getActivePotionEffect(Potion.nightVision).getDuration();
+        // FCMOD: Added (client only) to prevent constant flashing with beacon version 
+        if ( par1EntityPlayer.getActivePotionEffect(Potion.nightVision).getIsAmbient() )
+        {
+        	var3 = 400;
+        }
+        // END FCMOD
         return var3 > 200 ? 1.0F : 0.7F + MathHelper.sin(((float)var3 - par2) * (float)Math.PI * 0.2F) * 0.3F;
     }
 
@@ -885,7 +928,12 @@
 
         if (this.lightmapUpdateNeeded)
         {
+        	// FCMOD: Changed (client only)
+        	/*
             this.updateLightmap(par1);
+            */
+        	ModUpdateLightmap(par1);
+        	// END FCMOD
         }
 
         this.mc.mcProfiler.endSection();
@@ -967,6 +1015,13 @@
                 {
                     this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var16, var17);
                 }
+                // FCMOD: Added (client only) to display stuff like ender spectacle effects 
+                // even if the GUI is turned off
+                else
+                {
+                	mc.ingameGUI.RenderGameOverlayWithGuiDisabled(par1, this.mc.currentScreen != null, var16, var17);
+                }
+                // END FCMOD
 
                 this.mc.mcProfiler.endSection();
             }
@@ -1013,7 +1068,12 @@
 
         if (this.lightmapUpdateNeeded)
         {
+        	// FCMOD: Changed (client only)
+        	/*
             this.updateLightmap(par1);
+            */
+        	ModUpdateLightmap(par1);
+        	// END FCMOD
         }
 
         GL11.glEnable(GL11.GL_CULL_FACE);
@@ -1071,7 +1131,7 @@
             GL11.glEnable(GL11.GL_FOG);
             this.setupFog(1, par1);
 
-            if (this.mc.gameSettings.ambientOcclusion != 0)
+            if (RenderPass.setAmbientOcclusion(this.mc.gameSettings.ambientOcclusion != 0))
             {
                 GL11.glShadeModel(GL11.GL_SMOOTH);
             }
@@ -1108,6 +1168,7 @@
             RenderHelper.disableStandardItemLighting();
             this.mc.mcProfiler.endStartSection("terrain");
             var5.sortAndRender(var4, 0, (double)par1);
+            var5.sortAndRender(var4, 4, (double)par1);
             GL11.glShadeModel(GL11.GL_FLAT);
             EntityPlayer var17;
 
@@ -1149,7 +1210,7 @@
             {
                 this.mc.mcProfiler.endStartSection("water");
 
-                if (this.mc.gameSettings.ambientOcclusion != 0)
+                if (RenderPass.setAmbientOcclusion(this.mc.gameSettings.ambientOcclusion != 0))
                 {
                     GL11.glShadeModel(GL11.GL_SMOOTH);
                 }
@@ -1186,6 +1247,8 @@
                 var5.sortAndRender(var4, 1, (double)par1);
             }
 
+            var5.sortAndRender(var4, 5, (double)par1);
+            this.renderRainSnow(par1);
             GL11.glDepthMask(true);
             GL11.glEnable(GL11.GL_CULL_FACE);
             GL11.glDisable(GL11.GL_BLEND);
@@ -1255,6 +1318,11 @@
     {
         float var1 = this.mc.theWorld.getRainStrength(1.0F);
 
+        // FCMOD: Added (client only) to reduce rain particles when it's not stormy
+        var1 *= 0.1F;
+        var1 += mc.theWorld.thunderingStrength * 0.9F;
+        // END FCMOD
+
         if (!this.mc.gameSettings.fancyGraphics)
         {
             var1 /= 2.0F;
@@ -1292,7 +1360,7 @@
                 int var20 = var3.getBlockId(var17, var19 - 1, var18);
                 BiomeGenBase var21 = var3.getBiomeGenForCoords(var17, var18);
 
-                if (var19 <= var5 + var7 && var19 >= var5 - var7 && var21.canSpawnLightningBolt() && var21.getFloatTemperature() >= 0.2F)
+                if ( var19 <= var5 + var7 && var19 >= var5 - var7 && var21.CanRainInBiome() && !var21.canSnowAt(var3, var17, var19, var18))
                 {
                     float var22 = this.random.nextFloat();
                     float var23 = this.random.nextFloat();
@@ -1301,7 +1369,7 @@
                     {
                         if (Block.blocksList[var20].blockMaterial == Material.lava)
                         {
-                            this.mc.effectRenderer.addEffect(new EntitySmokeFX(var3, (double)((float)var17 + var22), (double)((float)var19 + 0.1F) - Block.blocksList[var20].getBlockBoundsMinY(), (double)((float)var18 + var23), 0.0D, 0.0D, 0.0D));
+                            this.mc.effectRenderer.addEffect((EntityFX) EntityList.createEntityOfType(EntitySmokeFX.class, var3, (double)((float)var17 + var22), (double)((float)var19 + 0.1F) - Block.blocksList[var20].getBlockBoundsMinY(), (double)((float)var18 + var23), 0.0D, 0.0D, 0.0D));
                         }
                         else
                         {
@@ -1314,7 +1382,7 @@
                                 var12 = (double)((float)var18 + var23);
                             }
 
-                            this.mc.effectRenderer.addEffect(new EntityRainFX(var3, (double)((float)var17 + var22), (double)((float)var19 + 0.1F) - Block.blocksList[var20].getBlockBoundsMinY(), (double)((float)var18 + var23)));
+                            this.mc.effectRenderer.addEffect((EntityFX) EntityList.createEntityOfType(EntityRainFX.class, var3, (double)((float)var17 + var22), (double)((float)var19 + 0.1F) - Block.blocksList[var20].getBlockBoundsMinY(), (double)((float)var18 + var23)));
                         }
                     }
                 }
@@ -1326,11 +1394,21 @@
 
                 if (var10 > var2.posY + 1.0D && var3.getPrecipitationHeight(MathHelper.floor_double(var2.posX), MathHelper.floor_double(var2.posZ)) > MathHelper.floor_double(var2.posY))
                 {
+                	// FCMOD: Changed (client only) to make intensity of sound dependent on storm strength
+                	/*
                     this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.1F, 0.5F, false);
+                    */
+                    this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.1F * var1, 0.5F, false);
+                    // END FCMOD
                 }
                 else
                 {
+                	// FCMOD: Changed (client only) to make intensity of sound dependent on storm strength
+                	/*
                     this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.2F, 1.0F, false);
+                    */
+                    this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.2F * var1, 1.0F, false);
+                    // END FCMOD
                 }
             }
         }
@@ -1341,9 +1419,13 @@
      */
     protected void renderRainSnow(float par1)
     {
-        float var2 = this.mc.theWorld.getRainStrength(par1);
+        float rainStrength = this.mc.theWorld.getRainStrength(par1);
+        // FCMOD: Added (client only) to reduce rain particles when it's not stormy
+        rainStrength *= 0.5F;
+        rainStrength += mc.theWorld.thunderingStrength * 0.5F;
+        // END FCMOD
 
-        if (var2 > 0.0F)
+        if (rainStrength > 0.0F)
         {
             this.enableLightmap((double)par1);
 
@@ -1352,121 +1434,120 @@
                 this.rainXCoords = new float[1024];
                 this.rainYCoords = new float[1024];
 
-                for (int var3 = 0; var3 < 32; ++var3)
+                for (int i = 0; i < 32; ++i)
                 {
-                    for (int var4 = 0; var4 < 32; ++var4)
+                    for (int k = 0; k < 32; ++k)
                     {
-                        float var5 = (float)(var4 - 16);
-                        float var6 = (float)(var3 - 16);
-                        float var7 = MathHelper.sqrt_float(var5 * var5 + var6 * var6);
-                        this.rainXCoords[var3 << 5 | var4] = -var6 / var7;
-                        this.rainYCoords[var3 << 5 | var4] = var5 / var7;
+                        float iFloat = (float) (i - 16);
+                        float kFloat = (float) (k - 16);
+                        float dist = MathHelper.sqrt_float(kFloat * kFloat + iFloat * iFloat);
+                        
+                        this.rainXCoords[i << 5 | k] = -iFloat / dist;
+                        this.rainYCoords[i << 5 | k] = kFloat / dist;
                     }
                 }
             }
 
-            EntityLiving var41 = this.mc.renderViewEntity;
-            WorldClient var42 = this.mc.theWorld;
-            int var43 = MathHelper.floor_double(var41.posX);
-            int var44 = MathHelper.floor_double(var41.posY);
-            int var45 = MathHelper.floor_double(var41.posZ);
-            Tessellator var8 = Tessellator.instance;
+            EntityLiving viewEntity = this.mc.renderViewEntity;
+            WorldClient worldClient = this.mc.theWorld;
+            int entityX = MathHelper.floor_double(viewEntity.posX);
+            int entityY = MathHelper.floor_double(viewEntity.posY);
+            int entityZ = MathHelper.floor_double(viewEntity.posZ);
+            Tessellator tesselator = Tessellator.instance;
             GL11.glDisable(GL11.GL_CULL_FACE);
             GL11.glNormal3f(0.0F, 1.0F, 0.0F);
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
             GL11.glAlphaFunc(GL11.GL_GREATER, 0.01F);
             this.mc.renderEngine.bindTexture("/environment/snow.png");
-            double var9 = var41.lastTickPosX + (var41.posX - var41.lastTickPosX) * (double)par1;
-            double var11 = var41.lastTickPosY + (var41.posY - var41.lastTickPosY) * (double)par1;
-            double var13 = var41.lastTickPosZ + (var41.posZ - var41.lastTickPosZ) * (double)par1;
+            double var9 = viewEntity.lastTickPosX + (viewEntity.posX - viewEntity.lastTickPosX) * (double)par1;
+            double var11 = viewEntity.lastTickPosY + (viewEntity.posY - viewEntity.lastTickPosY) * (double)par1;
+            double var13 = viewEntity.lastTickPosZ + (viewEntity.posZ - viewEntity.lastTickPosZ) * (double)par1;
             int var15 = MathHelper.floor_double(var11);
-            byte var16 = 5;
+            byte rainDist = 5;
 
             if (this.mc.gameSettings.fancyGraphics)
             {
-                var16 = 10;
+                rainDist = 10;
             }
 
             boolean var17 = false;
             byte var18 = -1;
             float var19 = (float)this.rendererUpdateCount + par1;
 
-            if (this.mc.gameSettings.fancyGraphics)
-            {
-                var16 = 10;
-            }
-
             GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
             var17 = false;
 
-            for (int var20 = var45 - var16; var20 <= var45 + var16; ++var20)
+            for (int k = entityZ - rainDist; k <= entityZ + rainDist; ++k)
             {
-                for (int var21 = var43 - var16; var21 <= var43 + var16; ++var21)
+                for (int i = entityX - rainDist; i <= entityX + rainDist; ++i)
                 {
-                    int var22 = (var20 - var45 + 16) * 32 + var21 - var43 + 16;
-                    float var23 = this.rainXCoords[var22] * 0.5F;
-                    float var24 = this.rainYCoords[var22] * 0.5F;
-                    BiomeGenBase var25 = var42.getBiomeGenForCoords(var21, var20);
+                    int rainCoordIndex = (k - entityZ + 16) * 32 + i - entityX + 16;
+                    float var23 = this.rainXCoords[rainCoordIndex] * 0.5F;
+                    float var24 = this.rainYCoords[rainCoordIndex] * 0.5F;
+                    BiomeGenBase biome = worldClient.getBiomeGenForCoords(i, k);
 
-                    if (var25.canSpawnLightningBolt() || var25.getEnableSnow())
+                    // FCMOD: Changed (client only) for clarity
+                    //if (var25.canSpawnLightningBolt() || var25.getEnableSnow())
+                    if ( biome.CanRainInBiome() || biome.getEnableSnow() )
+                	// END FCMOD
                     {
-                        int var26 = var42.getPrecipitationHeight(var21, var20);
-                        int var27 = var44 - var16;
-                        int var28 = var44 + var16;
+                        int precipitationHeight = worldClient.getPrecipitationHeight(i, k);
+                        int minRainHeight = entityY - rainDist;
+                        int maxRainHeight = entityY + rainDist;
 
-                        if (var27 < var26)
+                        if (minRainHeight < precipitationHeight)
                         {
-                            var27 = var26;
+                            minRainHeight = precipitationHeight;
                         }
 
-                        if (var28 < var26)
+                        if (maxRainHeight < precipitationHeight)
                         {
-                            var28 = var26;
+                            maxRainHeight = precipitationHeight;
                         }
 
                         float var29 = 1.0F;
-                        int var30 = var26;
+                        int var30 = precipitationHeight;
 
-                        if (var26 < var15)
+                        if (precipitationHeight < var15)
                         {
                             var30 = var15;
                         }
 
-                        if (var27 != var28)
+                        if (minRainHeight != maxRainHeight)
                         {
-                            this.random.setSeed((long)(var21 * var21 * 3121 + var21 * 45238971 ^ var20 * var20 * 418711 + var20 * 13761));
-                            float var31 = var25.getFloatTemperature();
-                            float var32;
+                            this.random.setSeed((long)(i * i * 3121 + i * 45238971 ^ k * k * 418711 + k * 13761));
+                            float temperature = biome.getFloatTemperature();
                             double var35;
+                            float var32;
 
-                            if (var42.getWorldChunkManager().getTemperatureAtHeight(var31, var26) >= 0.15F)
+                            if (!biome.canSnowAt(worldClient, i, precipitationHeight, k))
                             {
                                 if (var18 != 0)
                                 {
                                     if (var18 >= 0)
                                     {
-                                        var8.draw();
+                                        tesselator.draw();
                                     }
 
                                     var18 = 0;
                                     this.mc.renderEngine.bindTexture("/environment/rain.png");
-                                    var8.startDrawingQuads();
+                                    tesselator.startDrawingQuads();
                                 }
 
-                                var32 = ((float)(this.rendererUpdateCount + var21 * var21 * 3121 + var21 * 45238971 + var20 * var20 * 418711 + var20 * 13761 & 31) + par1) / 32.0F * (3.0F + this.random.nextFloat());
-                                double var33 = (double)((float)var21 + 0.5F) - var41.posX;
-                                var35 = (double)((float)var20 + 0.5F) - var41.posZ;
-                                float var37 = MathHelper.sqrt_double(var33 * var33 + var35 * var35) / (float)var16;
+                                var32 = ((float)(this.rendererUpdateCount + i * i * 3121 + i * 45238971 + k * k * 418711 + k * 13761 & 31) + par1) / 32.0F * (3.0F + this.random.nextFloat());
+                                double var33 = (double)((float)i + 0.5F) - viewEntity.posX;
+                                var35 = (double)((float)k + 0.5F) - viewEntity.posZ;
+                                float var37 = MathHelper.sqrt_double(var33 * var33 + var35 * var35) / (float)rainDist;
                                 float var38 = 1.0F;
-                                var8.setBrightness(var42.getLightBrightnessForSkyBlocks(var21, var30, var20, 0));
-                                var8.setColorRGBA_F(var38, var38, var38, ((1.0F - var37 * var37) * 0.5F + 0.5F) * var2);
-                                var8.setTranslation(-var9 * 1.0D, -var11 * 1.0D, -var13 * 1.0D);
-                                var8.addVertexWithUV((double)((float)var21 - var23) + 0.5D, (double)var27, (double)((float)var20 - var24) + 0.5D, (double)(0.0F * var29), (double)((float)var27 * var29 / 4.0F + var32 * var29));
-                                var8.addVertexWithUV((double)((float)var21 + var23) + 0.5D, (double)var27, (double)((float)var20 + var24) + 0.5D, (double)(1.0F * var29), (double)((float)var27 * var29 / 4.0F + var32 * var29));
-                                var8.addVertexWithUV((double)((float)var21 + var23) + 0.5D, (double)var28, (double)((float)var20 + var24) + 0.5D, (double)(1.0F * var29), (double)((float)var28 * var29 / 4.0F + var32 * var29));
-                                var8.addVertexWithUV((double)((float)var21 - var23) + 0.5D, (double)var28, (double)((float)var20 - var24) + 0.5D, (double)(0.0F * var29), (double)((float)var28 * var29 / 4.0F + var32 * var29));
-                                var8.setTranslation(0.0D, 0.0D, 0.0D);
+                                tesselator.setBrightness(worldClient.getLightBrightnessForSkyBlocks(i, var30, k, 0));
+                                tesselator.setColorRGBA_F(var38, var38, var38, ((1.0F - var37 * var37) * 0.5F + 0.5F) * rainStrength);
+                                tesselator.setTranslation(-var9 * 1.0D, -var11 * 1.0D, -var13 * 1.0D);
+                                tesselator.addVertexWithUV((double)((float)i - var23) + 0.5D, (double)minRainHeight, (double)((float)k - var24) + 0.5D, (double)(0.0F * var29), (double)((float)minRainHeight * var29 / 4.0F + var32 * var29));
+                                tesselator.addVertexWithUV((double)((float)i + var23) + 0.5D, (double)minRainHeight, (double)((float)k + var24) + 0.5D, (double)(1.0F * var29), (double)((float)minRainHeight * var29 / 4.0F + var32 * var29));
+                                tesselator.addVertexWithUV((double)((float)i + var23) + 0.5D, (double)maxRainHeight, (double)((float)k + var24) + 0.5D, (double)(1.0F * var29), (double)((float)maxRainHeight * var29 / 4.0F + var32 * var29));
+                                tesselator.addVertexWithUV((double)((float)i - var23) + 0.5D, (double)maxRainHeight, (double)((float)k - var24) + 0.5D, (double)(0.0F * var29), (double)((float)maxRainHeight * var29 / 4.0F + var32 * var29));
+                                tesselator.setTranslation(0.0D, 0.0D, 0.0D);
                             }
                             else
                             {
@@ -1474,29 +1555,29 @@
                                 {
                                     if (var18 >= 0)
                                     {
-                                        var8.draw();
+                                        tesselator.draw();
                                     }
 
                                     var18 = 1;
                                     this.mc.renderEngine.bindTexture("/environment/snow.png");
-                                    var8.startDrawingQuads();
+                                    tesselator.startDrawingQuads();
                                 }
 
                                 var32 = ((float)(this.rendererUpdateCount & 511) + par1) / 512.0F;
                                 float var46 = this.random.nextFloat() + var19 * 0.01F * (float)this.random.nextGaussian();
                                 float var34 = this.random.nextFloat() + var19 * (float)this.random.nextGaussian() * 0.001F;
-                                var35 = (double)((float)var21 + 0.5F) - var41.posX;
-                                double var47 = (double)((float)var20 + 0.5F) - var41.posZ;
-                                float var39 = MathHelper.sqrt_double(var35 * var35 + var47 * var47) / (float)var16;
+                                var35 = (double)((float)i + 0.5F) - viewEntity.posX;
+                                double var47 = (double)((float)k + 0.5F) - viewEntity.posZ;
+                                float var39 = MathHelper.sqrt_double(var35 * var35 + var47 * var47) / (float)rainDist;
                                 float var40 = 1.0F;
-                                var8.setBrightness((var42.getLightBrightnessForSkyBlocks(var21, var30, var20, 0) * 3 + 15728880) / 4);
-                                var8.setColorRGBA_F(var40, var40, var40, ((1.0F - var39 * var39) * 0.3F + 0.5F) * var2);
-                                var8.setTranslation(-var9 * 1.0D, -var11 * 1.0D, -var13 * 1.0D);
-                                var8.addVertexWithUV((double)((float)var21 - var23) + 0.5D, (double)var27, (double)((float)var20 - var24) + 0.5D, (double)(0.0F * var29 + var46), (double)((float)var27 * var29 / 4.0F + var32 * var29 + var34));
-                                var8.addVertexWithUV((double)((float)var21 + var23) + 0.5D, (double)var27, (double)((float)var20 + var24) + 0.5D, (double)(1.0F * var29 + var46), (double)((float)var27 * var29 / 4.0F + var32 * var29 + var34));
-                                var8.addVertexWithUV((double)((float)var21 + var23) + 0.5D, (double)var28, (double)((float)var20 + var24) + 0.5D, (double)(1.0F * var29 + var46), (double)((float)var28 * var29 / 4.0F + var32 * var29 + var34));
-                                var8.addVertexWithUV((double)((float)var21 - var23) + 0.5D, (double)var28, (double)((float)var20 - var24) + 0.5D, (double)(0.0F * var29 + var46), (double)((float)var28 * var29 / 4.0F + var32 * var29 + var34));
-                                var8.setTranslation(0.0D, 0.0D, 0.0D);
+                                tesselator.setBrightness((worldClient.getLightBrightnessForSkyBlocks(i, var30, k, 0) * 3 + 15728880) / 4);
+                                tesselator.setColorRGBA_F(var40, var40, var40, ((1.0F - var39 * var39) * 0.3F + 0.5F) * rainStrength);
+                                tesselator.setTranslation(-var9 * 1.0D, -var11 * 1.0D, -var13 * 1.0D);
+                                tesselator.addVertexWithUV((double)((float)i - var23) + 0.5D, (double)minRainHeight, (double)((float)k - var24) + 0.5D, (double)(0.0F * var29 + var46), (double)((float)minRainHeight * var29 / 4.0F + var32 * var29 + var34));
+                                tesselator.addVertexWithUV((double)((float)i + var23) + 0.5D, (double)minRainHeight, (double)((float)k + var24) + 0.5D, (double)(1.0F * var29 + var46), (double)((float)minRainHeight * var29 / 4.0F + var32 * var29 + var34));
+                                tesselator.addVertexWithUV((double)((float)i + var23) + 0.5D, (double)maxRainHeight, (double)((float)k + var24) + 0.5D, (double)(1.0F * var29 + var46), (double)((float)maxRainHeight * var29 / 4.0F + var32 * var29 + var34));
+                                tesselator.addVertexWithUV((double)((float)i - var23) + 0.5D, (double)maxRainHeight, (double)((float)k - var24) + 0.5D, (double)(0.0F * var29 + var46), (double)((float)maxRainHeight * var29 / 4.0F + var32 * var29 + var34));
+                                tesselator.setTranslation(0.0D, 0.0D, 0.0D);
                             }
                         }
                     }
@@ -1505,7 +1586,7 @@
 
             if (var18 >= 0)
             {
-                var8.draw();
+                tesselator.draw();
             }
 
             GL11.glEnable(GL11.GL_CULL_FACE);
@@ -1612,13 +1693,27 @@
             this.fogColorRed = 0.02F;
             this.fogColorGreen = 0.02F;
             this.fogColorBlue = 0.2F;
+            
+            if (ColorizeWorld.computeUnderwaterColor())
+            {
+                this.fogColorRed = Colorizer.setColor[0];
+                this.fogColorGreen = Colorizer.setColor[1];
+                this.fogColorBlue = Colorizer.setColor[2];
         }
+        }
         else if (var21 != 0 && Block.blocksList[var21].blockMaterial == Material.lava)
         {
             this.fogColorRed = 0.6F;
             this.fogColorGreen = 0.1F;
             this.fogColorBlue = 0.0F;
+            
+            if (ColorizeWorld.computeUnderlavaColor())
+            {
+                this.fogColorRed = Colorizer.setColor[0];
+                this.fogColorGreen = Colorizer.setColor[1];
+                this.fogColorBlue = Colorizer.setColor[2];
         }
+        }
 
         float var22 = this.fogColor2 + (this.fogColor1 - this.fogColor2) * par1;
         this.fogColorRed *= var22;
@@ -1639,6 +1734,12 @@
                 var14 = 0.0D;
             }
         }
+        // FCMOD: Added (client only)
+        else if ( mc.gameSettings.thirdPersonView == 0 && var3.HasHeadCrabbedSquid() )
+        {
+        	var14 = 0.2D;
+        }
+        // END FCMOD
 
         if (var14 < 1.0D)
         {
@@ -1655,9 +1756,9 @@
 
         float var23;
 
-        if (this.field_82831_U > 0.0F)
+        if (this.fWitherEffectIntensity > 0.0F)
         {
-            var23 = this.field_82832_V + (this.field_82831_U - this.field_82832_V) * par1;
+            var23 = this.fPreviousWithEffectIntensity + (this.fWitherEffectIntensity - this.fPreviousWithEffectIntensity) * par1;
             this.fogColorRed = this.fogColorRed * (1.0F - var23) + this.fogColorRed * 0.7F * var23;
             this.fogColorGreen = this.fogColorGreen * (1.0F - var23) + this.fogColorGreen * 0.6F * var23;
             this.fogColorBlue = this.fogColorBlue * (1.0F - var23) + this.fogColorBlue * 0.6F * var23;
@@ -1681,8 +1782,12 @@
             }
 
             this.fogColorRed = this.fogColorRed * (1.0F - var23) + this.fogColorRed * var17 * var23;
+            // FCMOD: Removed (client only) to only affect red with night vision
+            /*
             this.fogColorGreen = this.fogColorGreen * (1.0F - var23) + this.fogColorGreen * var17 * var23;
             this.fogColorBlue = this.fogColorBlue * (1.0F - var23) + this.fogColorBlue * var17 * var23;
+            */
+            // END FCMOD
         }
 
         if (this.mc.gameSettings.anaglyph)
@@ -1762,8 +1867,32 @@
                     GL11.glFogi(34138, 34139);
                 }
             }
+            // FCMOD: Added (client only)
+            else if ( mc.gameSettings.thirdPersonView == 0 && var3.HasHeadCrabbedSquid() )
+            {
+                var6 = 0.45F;
+
+                GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
+
+                if (par1 < 0)
+                {
+                    GL11.glFogf(GL11.GL_FOG_START, 0.0F);
+                    GL11.glFogf(GL11.GL_FOG_END, var6 * 0.8F);
+                }
             else
             {
+                    GL11.glFogf(GL11.GL_FOG_START, 0.0F);
+                    GL11.glFogf(GL11.GL_FOG_END, var6);
+                }
+
+                if (GLContext.getCapabilities().GL_NV_fog_distance)
+                {
+                    GL11.glFogi(34138, 34139);
+                }
+            }
+            // END FCMOD            
+            else
+            {
                 float var8;
                 float var9;
                 float var10;
@@ -1923,4 +2052,223 @@
     {
         return par0EntityRenderer.mc;
     }
+    
+    // FCMOD: Added (client only)
+    private static final float m_fMaximumSunBrightnessDelta = 0.001F;
+    
+    private float m_fPreviousSunBrightness = -1F;
+    
+    private void ModUpdateLightmap( float fPartialTicks )
+    {
+        WorldClient world = mc.theWorld;
+        
+        if ( world != null )
+        {
+            if ( world.provider.dimensionId == 0 )
+            {
+            	// isolating the overworld for gloom effects
+            	
+            	ModUpdateLightmapOverworld( world, fPartialTicks );
+            	
+            	return;
 }
+            else
+            {
+                m_fPreviousSunBrightness = -1F;
+                
+            	updateLightmap( fPartialTicks );
+            }
+        }
+    }
+    
+	private void ModUpdateLightmapOverworld( WorldClient world, float fPartialTicks )
+	{
+    	// copy of updateLightmap() to modify for moon phases and to refactor it to make it easier to understand and work with.
+
+    	float fCurrentSunBrightness = world.ComputeOverworldSunBrightnessWithMoonPhases();
+    	
+    	if ( m_fPreviousSunBrightness > -0.01F )
+    	{
+    		if ( Math.abs( fCurrentSunBrightness - m_fPreviousSunBrightness ) > m_fMaximumSunBrightnessDelta )
+    		{
+    			if ( fCurrentSunBrightness > m_fPreviousSunBrightness )
+    			{
+    				fCurrentSunBrightness = m_fPreviousSunBrightness + m_fMaximumSunBrightnessDelta;
+    			}
+    			else
+    			{
+    				fCurrentSunBrightness = m_fPreviousSunBrightness - m_fMaximumSunBrightnessDelta;
+    			}	
+    		}
+    	}
+    	
+    	m_fPreviousSunBrightness = fCurrentSunBrightness;
+    	
+        float fModifiedSunBrightness = fCurrentSunBrightness;
+        
+        boolean bPlayerHasNightVision = mc.thePlayer.isPotionActive( Potion.nightVision );
+    	
+        for ( int iTempMapIndex = 0; iTempMapIndex < 256; ++iTempMapIndex )
+        {
+            float fRedIntensity;
+            float fGreenIntensity;
+            float fBlueIntensity;
+
+            float fTorchBrightnessForIndex = world.provider.lightBrightnessTable[iTempMapIndex % 16] * ( torchFlickerX * 0.1F + 1.5F );
+            
+            float fGreenTorchBrightness = fTorchBrightnessForIndex * ( ( fTorchBrightnessForIndex * 0.6F + 0.4F ) * 0.6F + 0.4F );
+            float fBlueTorchBrightness = fTorchBrightnessForIndex * ( fTorchBrightnessForIndex * fTorchBrightnessForIndex * 0.6F + 0.4F );
+
+            float fSunBrightnessForIndex = world.provider.lightBrightnessTable[iTempMapIndex / 16] * fModifiedSunBrightness;
+            
+            if ( world.lastLightningBolt > 0 )
+            {
+                fSunBrightnessForIndex = world.provider.lightBrightnessTable[iTempMapIndex / 16];
+            }
+
+            float fRedSunBrightness = fSunBrightnessForIndex * ( fCurrentSunBrightness * 0.65F + 0.35F );
+            float fGreenSunBrightness = fRedSunBrightness;                
+            
+            fRedIntensity = fRedSunBrightness + fTorchBrightnessForIndex;
+            fGreenIntensity = fGreenSunBrightness + fGreenTorchBrightness;
+            fBlueIntensity = fSunBrightnessForIndex + fBlueTorchBrightness;
+            
+            if ( fWitherEffectIntensity > 0.0F )
+            {
+            	// this all seems to be related to darkening the sky around the wither.  The above test is true if the player is near, or has recently been near, 
+            	// the wither, with what appears to be a fade-in/out transition on the effect
+
+                float fCurrentWitherEffectIntensity = fPreviousWithEffectIntensity + ( fWitherEffectIntensity - fPreviousWithEffectIntensity ) * fPartialTicks;
+                
+                fRedIntensity = fRedIntensity * (1.0F - fCurrentWitherEffectIntensity) + fRedIntensity * 0.7F * fCurrentWitherEffectIntensity;
+                fGreenIntensity = fGreenIntensity * (1.0F - fCurrentWitherEffectIntensity) + fGreenIntensity * 0.6F * fCurrentWitherEffectIntensity;
+                fBlueIntensity = fBlueIntensity * (1.0F - fCurrentWitherEffectIntensity) + fBlueIntensity * 0.6F * fCurrentWitherEffectIntensity;
+            }
+            
+            float fMinimumBrightness = fSunBrightnessForIndex + fTorchBrightnessForIndex;
+            
+            fMinimumBrightness *= fMinimumBrightness;
+            
+            if ( fMinimumBrightness > 0.03F )
+            {
+            	fMinimumBrightness = 0.03F;
+            }
+
+            if ( bPlayerHasNightVision )
+            {
+            	fRedIntensity = fRedIntensity * 0.96F + 0.03F;
+            	
+            	// Note: this portion has been modified from stock to only modify red with night vision
+                float fNightVisionBrightness = getNightVisionBrightness( mc.thePlayer, fPartialTicks );
+                
+                float var17 = 1.0F / fRedIntensity;
+
+                if (var17 > 1.0F / fGreenIntensity)
+                {
+                    var17 = 1.0F / fGreenIntensity;
+                }
+
+                if (var17 > 1.0F / fBlueIntensity)
+                {
+                    var17 = 1.0F / fBlueIntensity;
+                }
+
+                fRedIntensity = fRedIntensity * (1.0F - fNightVisionBrightness) + fRedIntensity * var17 * fNightVisionBrightness;
+            }
+
+            float fMinimumBrightnessMultiplier = 1F - fMinimumBrightness;
+            
+        	fRedIntensity = fRedIntensity * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fGreenIntensity = fGreenIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fBlueIntensity = fBlueIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;            
+
+            if (fRedIntensity > 1.0F)
+            {
+                fRedIntensity = 1.0F;
+            }
+
+            if (fGreenIntensity > 1.0F)
+            {
+                fGreenIntensity = 1.0F;
+            }
+
+            if (fBlueIntensity > 1.0F)
+            {
+                fBlueIntensity = 1.0F;
+            }
+
+            float fGammaSetting = mc.gameSettings.gammaSetting;
+            
+            float fRedModifier = 1.0F - fRedIntensity;
+            float fGreenModifier = 1.0F - fGreenIntensity;
+            float fBlueModifier = 1.0F - fBlueIntensity;
+            
+            fRedModifier = 1.0F - fRedModifier * fRedModifier * fRedModifier * fRedModifier;
+            fGreenModifier = 1.0F - fGreenModifier * fGreenModifier * fGreenModifier * fGreenModifier;
+            fBlueModifier = 1.0F - fBlueModifier * fBlueModifier * fBlueModifier * fBlueModifier;
+            
+            fRedIntensity = fRedIntensity * (1.0F - fGammaSetting) + fRedModifier * fGammaSetting;
+            fGreenIntensity = fGreenIntensity * (1.0F - fGammaSetting) + fGreenModifier * fGammaSetting;
+            fBlueIntensity = fBlueIntensity * (1.0F - fGammaSetting) + fBlueModifier * fGammaSetting;
+            
+        	//fRedIntensity = fRedIntensity * 0.96F + 0.03F;
+        	//fGreenIntensity = fGreenIntensity * 0.96F + 0.03F;
+        	//fBlueIntensity = fBlueIntensity * 0.96F + 0.03F;
+
+        	fRedIntensity = fRedIntensity * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fGreenIntensity = fGreenIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fBlueIntensity = fBlueIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;            
+        	
+            if (fRedIntensity > 1.0F)
+            {
+                fRedIntensity = 1.0F;
+            }
+
+            if (fGreenIntensity > 1.0F)
+            {
+                fGreenIntensity = 1.0F;
+            }
+
+            if (fBlueIntensity > 1.0F)
+            {
+                fBlueIntensity = 1.0F;
+            }
+
+            if (fRedIntensity < 0.0F)
+            {
+                fRedIntensity = 0.0F;
+            }
+
+            if (fGreenIntensity < 0.0F)
+            {
+                fGreenIntensity = 0.0F;
+            }
+
+            if (fBlueIntensity < 0.0F)
+            {
+                fBlueIntensity = 0.0F;
+            }
+            
+            short sFinalAlpha = 255;
+            
+            int iFinalRed = (int)(fRedIntensity * 255.0F);
+            int iFinalGreen = (int)(fGreenIntensity * 255.0F);
+            int iFinalBlue = (int)(fBlueIntensity * 255.0F);
+            
+            lightmapColors[iTempMapIndex] = sFinalAlpha << 24 | iFinalRed << 16 | iFinalGreen << 8 | iFinalBlue;
+        }
+
+        mc.renderEngine.createTextureFromBytes( lightmapColors, 16, 16, lightmapTexture );
+	}
+	
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }    
+    // END FCMOD
+    
+    public float getNightVisionStrength(float var1)
+    {
+        return this.mc.thePlayer.isPotionActive(Potion.nightVision) ? this.getNightVisionBrightness(this.mc.thePlayer, var1) : 0.0F;
+    }
+}
