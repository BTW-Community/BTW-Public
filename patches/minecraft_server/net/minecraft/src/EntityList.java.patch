--- a/minecraft_server/net/minecraft/src/EntityList.java
+++ b/minecraft_server/net/minecraft/src/EntityList.java
@@ -1,7 +1,10 @@
 package net.minecraft.src;
 
+import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 
 public class EntityList
@@ -27,7 +30,12 @@
     /**
      * adds a mapping between Entity classes and both a string representation and an ID
      */
+    // FCMOD: Code change
+    /*
     private static void addMapping(Class par0Class, String par1Str, int par2)
+    */
+    public static void addMapping(Class par0Class, String par1Str, int par2)
+    // END FCMOD
     {
         stringToClassMapping.put(par1Str, par0Class);
         classToStringMapping.put(par0Class, par1Str);
@@ -39,7 +47,7 @@
     /**
      * Adds a entity mapping with egg info.
      */
-    private static void addMapping(Class par0Class, String par1Str, int par2, int par3, int par4)
+    public static void addMapping(Class par0Class, String par1Str, int par2, int par3, int par4)
     {
         addMapping(par0Class, par1Str, par2);
         entityEggs.put(Integer.valueOf(par2), new EntityEggInfo(par2, par3, par4));
@@ -58,9 +66,14 @@
 
             if (var3 != null)
             {
+            	if (FCEntityVillager.class.equals(var3)) {
+            		var2 = FCEntityVillager.createVillager(par1World);
+            	}
+            	else {
                 var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
             }
         }
+        }
         catch (Exception var4)
         {
             var4.printStackTrace();
@@ -101,9 +114,16 @@
 
             if (var3 != null)
             {
+            	if (FCEntityVillager.class.equals(var3)) {
+            		int profession = par0NBTTagCompound.getInteger("Profession");
+
+            		var2 = FCEntityVillager.createVillagerFromProfession(par1World, profession);
+            	}
+            	else {
                 var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
             }
         }
+        }
         catch (Exception var4)
         {
             var4.printStackTrace();
@@ -115,6 +135,9 @@
         }
         else
         {
+        	//Client
+            //par1World.getWorldLogAgent().logWarning("Skipping Entity with id " + par0NBTTagCompound.getString("id"));
+            //Server
             par1World.getWorldLogAgent().func_98236_b("Skipping Entity with id " + par0NBTTagCompound.getString("id"));
         }
 
@@ -134,9 +157,14 @@
 
             if (var3 != null)
             {
+            	if (FCEntityVillager.class.equals(var3)) {
+            		var2 = FCEntityVillager.createVillager(par1World);
+            	}
+            	else {
                 var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
             }
         }
+        }
         catch (Exception var4)
         {
             var4.printStackTrace();
@@ -144,6 +172,9 @@
 
         if (var2 == null)
         {
+        	//Client
+            //par1World.getWorldLogAgent().logWarning("Skipping Entity with id " + par0);
+            //Server
             par1World.getWorldLogAgent().func_98236_b("Skipping Entity with id " + par0);
         }
 
@@ -241,4 +272,205 @@
         addMapping(EntityVillager.class, "Villager", 120, 5651507, 12422002);
         addMapping(EntityEnderCrystal.class, "EnderCrystal", 200);
     }
+
+    public static void AddMapping( Class entityClass, String sName, int iID )
+    {
+    	addMapping( entityClass, sName, iID );
 }
+
+    public static boolean RemoveMapping( String sName, boolean bRemoveEgg )
+    {
+    	Integer iID = (Integer)stringToIDMapping.get( sName );
+
+    	if ( iID != null )
+    	{
+	    	Class mappedClass = (Class)IDtoClassMapping.get( Integer.valueOf( iID ) );
+
+	    	if ( mappedClass != null )
+	    	{
+	    		stringToClassMapping.remove( sName );
+	    		classToStringMapping.remove( mappedClass );
+	    		IDtoClassMapping.remove( iID );
+	    		classToIDMapping.remove( mappedClass );
+	    		stringToIDMapping.remove( sName );
+
+	    		if ( bRemoveEgg )
+	    		{
+		    		// may or may not have an egg, but this is a safe operation
+
+	    			entityEggs.remove( iID );
+	    		}
+
+	    		return true;
+	    	}
+    	}
+
+    	return false;
+    }
+
+    public static boolean ReplaceExistingMapping( Class newClass, String sName )
+    {    	
+    	Integer iID = (Integer)stringToIDMapping.get( sName );
+
+    	if ( iID != null )
+    	{
+    		if ( RemoveMapping( sName, false ) ) // egg mapping intentionally left in place
+    		{    		
+    			addMapping( newClass, sName, iID );
+    		}
+    	}
+
+    	return false;
+    }
+
+    /**
+     * Replaces entity mapping but leaves the mapping from class to id so the game won't crash if it tries to spawn something of a class which has been replaced
+     * Does not handle spawnable mobs
+     * @param newClass The new class to be added to the mapping
+     * @param entityName The internal name of the entity
+     * @return
+     */
+    public static boolean replaceExistingMappingSafe(Class newClass, String entityName) {
+        int id = (Integer) stringToIDMapping.get(entityName);
+
+        if (removeMappingSafe(entityName, false)) {
+            addMapping(newClass, entityName, id);
+        }
+
+        return false;
+    }
+    
+    /**
+     * Same behavior as replaceExistingMappingSafe except with a wrapper to handle replacing mob spawn lists
+     * @param newEntity
+     * @param entityName
+     * @return
+     */
+    public static boolean replaceSpawnableMappingSafe(Class newEntity, String entityName) {
+    	Class oldEntity = (Class) stringToClassMapping.get(entityName);
+    	
+    	//Super janky implementation
+    	//Code ripped from old version of deco
+    	//Reflection should not be necessary here, but for now I am using code that works, it can be cleaned up later
+    	
+    	//TODO: Clean up
+    	try {
+			for (BiomeGenBase b : BiomeGenBase.biomeList) {
+				if (b == null)
+					continue;
+
+				Field creatureList;
+				Field monsterList;
+				Field waterCreatureList;
+				Field caveCreatureList;
+
+				if (FCUtilsReflection.isObfuscated()) {
+					if (b.getClass().getSuperclass().equals(BiomeGenBase.class)) {
+						creatureList = b.getClass().getSuperclass().getDeclaredField("K");
+						monsterList = b.getClass().getSuperclass().getDeclaredField("J");
+						waterCreatureList = b.getClass().getSuperclass().getDeclaredField("L");
+						caveCreatureList = b.getClass().getSuperclass().getDeclaredField("M");
+					}
+					else {
+						creatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("K");
+						monsterList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("J");
+						waterCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("L");
+						caveCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("M");
+					}
+				}
+				else {
+					if (b.getClass().getSuperclass().equals(BiomeGenBase.class)) {
+						creatureList = b.getClass().getSuperclass().getDeclaredField("spawnableCreatureList");
+						monsterList = b.getClass().getSuperclass().getDeclaredField("spawnableMonsterList");
+						waterCreatureList = b.getClass().getSuperclass().getDeclaredField("spawnableWaterCreatureList");
+						caveCreatureList = b.getClass().getSuperclass().getDeclaredField("spawnableCaveCreatureList");
+					}
+					else {
+						creatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableCreatureList");
+						monsterList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableMonsterList");
+						waterCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableWaterCreatureList");
+						caveCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableCaveCreatureList");
+					}
+				}
+
+				creatureList.setAccessible(true);
+				monsterList.setAccessible(true);
+				waterCreatureList.setAccessible(true);
+				caveCreatureList.setAccessible(true);
+
+				ArrayList<SpawnListEntry> creature = (ArrayList<SpawnListEntry>)creatureList.get(b);
+				ArrayList<SpawnListEntry> monster = (ArrayList<SpawnListEntry>)monsterList.get(b);
+				ArrayList<SpawnListEntry> water = (ArrayList<SpawnListEntry>)waterCreatureList.get(b);
+				ArrayList<SpawnListEntry> cave = (ArrayList<SpawnListEntry>)caveCreatureList.get(b);
+
+				for (SpawnListEntry s : creature) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : monster) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : water) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : cave) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				return replaceExistingMappingSafe(newEntity, entityName);
+			}
+		} catch (NoSuchFieldException e) {
+			if (FCUtilsReflection.isObfuscated()) {
+				e.printStackTrace();
+			}
+			else {
+				FCUtilsReflection.setObfuscated(true);
+				replaceSpawnableMappingSafe(newEntity, entityName);
+			}
+			e.printStackTrace();
+		} catch (SecurityException e) {
+			e.printStackTrace();
+		} catch (IllegalArgumentException e) {
+			e.printStackTrace();
+		} catch (IllegalAccessException e) {
+			e.printStackTrace();
+		}
+    	
+    	return false;
+    }
+
+    public static boolean removeMappingSafe(String var0, boolean var1)
+    {
+        Integer var2 = (Integer)stringToIDMapping.get(var0);
+
+        if (var2 != null)
+        {
+            Class var3 = (Class)IDtoClassMapping.get(Integer.valueOf(var2.intValue()));
+
+            if (var3 != null)
+            {
+                stringToClassMapping.remove(var0);
+                IDtoClassMapping.remove(var2);
+
+                if (var1)
+                {
+                    entityEggs.remove(var2);
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
