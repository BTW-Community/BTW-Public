--- a/minecraft_server/net/minecraft/src/Block.java
+++ b/minecraft_server/net/minecraft/src/Block.java
@@ -1,8 +1,13 @@
 package net.minecraft.src;
 
+import java.lang.reflect.Constructor;
 import java.util.List;
 import java.util.Random;
 
+//FCMOD: Added
+//import net.minecraft.client.Minecraft; //client only
+// END FCMOD
+
 public class Block
 {
     /**
@@ -33,7 +38,11 @@
     /** How much light is subtracted for going through this block */
     public static final int[] lightOpacity = new int[4096];
 
-    /** Array of booleans that tells if a block can grass */
+	public static final boolean[] hasKilnRecipe = new boolean[4096];
+
+	/** Array of booleans that tells if a block can grass
+	 * FCNOTE: Misleading name.  This is actually wether grass can grow under the block
+	 */
     public static final boolean[] canBlockGrass = new boolean[4096];
 
     /** Amount of light emitted */
@@ -41,178 +50,173 @@
 
     /**
      * Flag if block ID should use the brightest neighbor light value as its own
+	 * FCNOTE: Misleading name in that this does not apply to the neighbor below the block,
+	 * only to sides and top
      */
     public static boolean[] useNeighborBrightness = new boolean[4096];
-    public static final Block stone = (new BlockStone(1)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stone");
-    public static final BlockGrass grass = (BlockGrass)(new BlockGrass(2)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("grass");
-    public static final Block dirt = (new BlockDirt(3)).setHardness(0.5F).setStepSound(soundGravelFootstep).setUnlocalizedName("dirt");
-    public static final Block cobblestone = (new Block(4, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block planks = (new BlockWood(5)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("wood");
-    public static final Block sapling = (new BlockSapling(6)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
-    public static final Block bedrock = (new Block(7, Material.rock)).setBlockUnbreakable().setResistance(6000000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("bedrock").disableStats().setCreativeTab(CreativeTabs.tabBlock);
-    public static final BlockFluid waterMoving = (BlockFluid)(new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final Block waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final BlockFluid lavaMoving = (BlockFluid)(new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
 
-    /** Stationary lava source block */
-    public static final Block lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-    public static final Block sand = (new BlockSand(12)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("sand");
-    public static final Block gravel = (new BlockGravel(13)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("gravel");
-    public static final Block oreGold = (new BlockOre(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
-    public static final Block oreIron = (new BlockOre(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
-    public static final Block oreCoal = (new BlockOre(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
-    public static final Block wood = (new BlockLog(17)).setHardness(2.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("log");
-    public static final BlockLeaves leaves = (BlockLeaves)(new BlockLeaves(18)).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep).setUnlocalizedName("leaves");
-    public static final Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
-    public static final Block glass = (new BlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
-    public static final Block oreLapis = (new BlockOre(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
-    public static final Block blockLapis = (new Block(22, Material.rock)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dispenser = (new BlockDispenser(23)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dispenser");
-    public static final Block sandStone = (new BlockSandStone(24)).setStepSound(soundStoneFootstep).setHardness(0.8F).setUnlocalizedName("sandStone");
-    public static final Block music = (new BlockNote(25)).setHardness(0.8F).setUnlocalizedName("musicBlock");
-    public static final Block bed = (new BlockBed(26)).setHardness(0.2F).setUnlocalizedName("bed").disableStats();
-    public static final Block railPowered = (new BlockRailPowered(27)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
-    public static final Block railDetector = (new BlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
-    public static final BlockPistonBase pistonStickyBase = (BlockPistonBase)(new BlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
-    public static final Block web = (new BlockWeb(30)).setLightOpacity(1).setHardness(4.0F).setUnlocalizedName("web");
-    public static final BlockTallGrass tallGrass = (BlockTallGrass)(new BlockTallGrass(31)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tallgrass");
-    public static final BlockDeadBush deadBush = (BlockDeadBush)(new BlockDeadBush(32)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("deadbush");
-    public static final BlockPistonBase pistonBase = (BlockPistonBase)(new BlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
-    public static final BlockPistonExtension pistonExtension = new BlockPistonExtension(34);
-    public static final Block cloth = (new BlockCloth()).setHardness(0.8F).setStepSound(soundClothFootstep).setUnlocalizedName("cloth");
-    public static final BlockPistonMoving pistonMoving = new BlockPistonMoving(36);
-    public static final BlockFlower plantYellow = (BlockFlower)(new BlockFlower(37)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("flower");
-    public static final BlockFlower plantRed = (BlockFlower)(new BlockFlower(38)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("rose");
-    public static final BlockFlower mushroomBrown = (BlockFlower)(new BlockMushroom(39, "mushroom_brown")).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(0.125F).setUnlocalizedName("mushroom");
-    public static final BlockFlower mushroomRed = (BlockFlower)(new BlockMushroom(40, "mushroom_red")).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
-    public static final Block blockGold = (new BlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
-    public static final Block blockIron = (new BlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
+	public static Block stone = new FCBlockStone( 1 );
+	public static BlockGrass grass = new FCBlockGrass( 2 );
+	public static Block dirt = new FCBlockDirt( 3 );
+	public static Block cobblestone = (new FCBlockCobblestone(4)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
+	public static Block planks = new FCBlockPlanks( 5 );
+	public static Block sapling = (new FCBlockSaplingLegacy(6)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
+	public static Block bedrock = new FCBlockBedrock( 7 );
+	public static BlockFluid waterMoving = (BlockFluid)(new FCBlockWaterFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").setCreativeTab(CreativeTabs.tabBlock).disableStats();
+	public static Block waterStill = (new FCBlockWaterStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
+	public static BlockFluid lavaMoving = (BlockFluid)(new FCBlockLavaFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").setCreativeTab(CreativeTabs.tabBlock).disableStats();
+	public static Block lavaStill = (new FCBlockLavaStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
+	public static Block sand = new FCBlockSand( 12 );
+	public static Block gravel = new FCBlockGravel( 13 );
+	public static Block oreGold = (new FCBlockOreGold(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
+	public static Block oreIron = (new FCBlockOreIron(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
+	public static Block oreCoal = (new FCBlockOreCoal(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
+	public static Block wood = new FCBlockLog( 17 );
+	public static BlockLeaves leaves = new FCBlockLeaves( 18 );
+	public static Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
+	public static Block glass = (new FCBlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
+	public static Block oreLapis = (new FCBlockOreLapis(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
+	public static Block blockLapis = (new Block(22, Material.rock)).SetPicksEffectiveOn().setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
+	public static Block dispenser = new FCBlockDispenserVanilla( 23 );
+	public static Block sandStone = new FCBlockSandStone( 24 );
+	public static Block music = new FCBlockNote( 25 );
+	public static Block bed = (new FCBlockBed(26)).setHardness(0.2F).SetBuoyant().setUnlocalizedName("bed").disableStats();
+	public static Block railPowered = (new BlockRailPowered(27)).SetPicksEffectiveOn().setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
+	public static Block railDetector = (new FCBlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
+	public static BlockPistonBase pistonStickyBase = (BlockPistonBase)(new FCBlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
+	public static Block web = new FCBlockWeb( 30 );
+	public static BlockTallGrass tallGrass = new FCBlockTallGrass( 31 );
+	public static BlockDeadBush deadBush = new FCBlockDeadBush( 32 );
+	public static BlockPistonBase pistonBase = (BlockPistonBase)(new FCBlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
+	public static BlockPistonExtension pistonExtension = new FCBlockPistonExtension(34);
+	public static Block cloth = new FCBlockCloth(); // sets own blockID of 35
+	public static BlockPistonMoving pistonMoving = new FCBlockPistonMoving( 36 );
+	public static BlockFlower plantYellow = (BlockFlower)(new FCBlockFlowerBlossom( 37 )).setUnlocalizedName("flower");
+	public static BlockFlower plantRed = (BlockFlower)(new FCBlockFlowerBlossom( 38 )).setUnlocalizedName("rose");
+	public static BlockFlower mushroomBrown = (BlockFlower)(new FCBlockMushroomBrown(39, "mushroom_brown")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
+	public static BlockFlower mushroomRed = (BlockFlower)(new FCBlockMushroom(40, "mushroom_red")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
+	public static Block blockGold = (new FCBlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
+	public static Block blockIron = (new FCBlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
+	public static BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new FCBlockStep(43, true)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+	public static BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new FCBlockStep(44, false)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+	public static Block brick = (new FCBlockBrick(45)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
+	public static Block tnt = new FCBlockPowderKeg( 46 );
+	public static Block bookShelf = new FCBlockBookshelf( 47 );
+	public static Block cobblestoneMossy = new FCBlockCobblestoneMossy( 48 ); 
+	public static Block obsidian = new FCBlockObsidian( 49 );
+	public static Block torchWood = new FCBlockTorchLegacy( 50 );
+	public static BlockFire fire = (BlockFire)(new FCBlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
+	public static Block mobSpawner = new FCBlockMobSpawner( 52 );
+	public static Block stairsWoodOak = (new FCBlockStairsWood( 53, planks, 0 ) ).setUnlocalizedName( "stairsWood" );
+	public static BlockChest chest = (BlockChest)( new FCBlockChest( 54 ) ).setCreativeTab( null );
+	public static BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new FCBlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
+	public static Block oreDiamond = (new FCBlockOreDiamond(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
+	public static Block blockDiamond = (new FCBlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
+	public static Block workbench = new FCBlockWorkbench( 58 );
+	public static Block crops = (new FCBlockWheatLegacy(59)).SetBuoyant().setUnlocalizedName("crops");
+	public static Block tilledField = new FCBlockFarmlandLegacyUnfertilized( 60 );
+	public static Block furnaceIdle = new FCBlockFurnace( 61, false );
+	public static Block furnaceBurning = new FCBlockFurnace( 62, true );
+	public static Block signPost = new FCBlockSign( 63, true );
+	public static Block doorWood = new FCBlockDoorWood( 64 );
+	public static Block ladder = new FCBlockLegacyLadder( 65 );
+	public static Block rail = new FCBlockRailRegular( 66 );
+	public static Block stairsCobblestone = new FCBlockStairsCobblestone( 67 );
+	public static Block signWall = new FCBlockSignWall( 68 );
+	public static Block lever = (new FCBlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
+	public static Block pressurePlateStone = new FCBlockPressurePlateStone( 70 );
+	public static Block doorIron = (new FCBlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
+	public static Block pressurePlatePlanks = new FCBlockPressurePlatePlanks( 72 );
+	public static Block oreRedstone = (new FCBlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
+	public static Block oreRedstoneGlowing = (new FCBlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(null);
+	public static Block torchRedstoneIdle = (new BlockRedstoneTorch( 75, false )).setUnlocalizedName("notGate");
+	public static Block torchRedstoneActive = (new BlockRedstoneTorch( 76, true )).setLightValue(0.5F).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
+	public static Block stoneButton = (new FCBlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
+	public static Block snow = new FCBlockSnowCover( 78 );
+	public static Block ice = (new FCBlockIce(79)).setHardness(0.5F).SetBuoyant().setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
+	public static Block blockSnow = new FCBlockSnowLegacy( 80 );
+	public static Block cactus = new FCBlockCactus( 81 );
+	public static Block blockClay = (new FCBlockClay(82)).setHardness(0.6F).setUnlocalizedName("fcBlockClay");
+	public static Block reed = (new FCBlockReedLegacy(83)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
+	public static Block jukebox = new FCBlockJukebox( 84 );
+	public static Block fence = new FCBlockFenceWood( 85 );
+	public static Block pumpkin = new FCBlockPumpkinCarved( 86 );
+	public static Block netherrack = new FCBlockNetherrack( 87 );
+	public static Block slowSand = (new FCBlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
+	public static Block glowStone = new FCBlockGlowStone( 89 );
+	public static BlockPortal portal = new FCBlockPortal( 90 );
+	public static Block pumpkinLantern = new FCBlockJackOLantern( 91 );
+	public static Block cake = (new FCBlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
+	public static BlockRedstoneRepeater redstoneRepeaterIdle = new FCBlockRedstoneRepeater( 93, false );
+	public static BlockRedstoneRepeater redstoneRepeaterActive = new FCBlockRedstoneRepeater( 94, true );
 
-    /** stoneDoubleSlab */
-    public static final BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-
-    /** stoneSingleSlab */
-    public static final BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-    public static final Block brick = (new Block(45, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block tnt = (new BlockTNT(46)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tnt");
-    public static final Block bookShelf = (new BlockBookshelf(47)).setHardness(1.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("bookshelf");
-    public static final Block cobblestoneMossy = (new Block(48, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneMoss").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block obsidian = (new BlockObsidian(49)).setHardness(50.0F).setResistance(2000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("obsidian");
-    public static final Block torchWood = (new BlockTorch(50)).setHardness(0.0F).setLightValue(0.9375F).setStepSound(soundWoodFootstep).setUnlocalizedName("torch");
-    public static final BlockFire fire = (BlockFire)(new BlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
-    public static final Block mobSpawner = (new BlockMobSpawner(52)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("mobSpawner").disableStats();
-    public static final Block stairsWoodOak = (new BlockStairs(53, planks, 0)).setUnlocalizedName("stairsWood");
-    public static final BlockChest chest = (BlockChest)(new BlockChest(54, 0)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("chest");
-    public static final BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new BlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
-    public static final Block oreDiamond = (new BlockOre(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
-    public static final Block blockDiamond = (new BlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
-    public static final Block workbench = (new BlockWorkbench(58)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("workbench");
-    public static final Block crops = (new BlockCrops(59)).setUnlocalizedName("crops");
-    public static final Block tilledField = (new BlockFarmland(60)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("farmland");
-    public static final Block furnaceIdle = (new BlockFurnace(61, false)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("furnace").setCreativeTab(CreativeTabs.tabDecorations);
-    public static final Block furnaceBurning = (new BlockFurnace(62, true)).setHardness(3.5F).setStepSound(soundStoneFootstep).setLightValue(0.875F).setUnlocalizedName("furnace");
-    public static final Block signPost = (new BlockSign(63, TileEntitySign.class, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("sign").disableStats();
-    public static final Block doorWood = (new BlockDoor(64, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("doorWood").disableStats();
-    public static final Block ladder = (new BlockLadder(65)).setHardness(0.4F).setStepSound(soundLadderFootstep).setUnlocalizedName("ladder");
-    public static final Block rail = (new BlockRail(66)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("rail");
-    public static final Block stairsCobblestone = (new BlockStairs(67, cobblestone, 0)).setUnlocalizedName("stairsStone");
-    public static final Block signWall = (new BlockSign(68, TileEntitySign.class, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("sign").disableStats();
-    public static final Block lever = (new BlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
-    public static final Block pressurePlateStone = (new BlockPressurePlate(70, "stone", Material.rock, EnumMobType.mobs)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("pressurePlate");
-    public static final Block doorIron = (new BlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
-    public static final Block pressurePlatePlanks = (new BlockPressurePlate(72, "wood", Material.wood, EnumMobType.everything)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("pressurePlate");
-    public static final Block oreRedstone = (new BlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block oreRedstoneGlowing = (new BlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone");
-    public static final Block torchRedstoneIdle = (new BlockRedstoneTorch(75, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("notGate");
-    public static final Block torchRedstoneActive = (new BlockRedstoneTorch(76, true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block stoneButton = (new BlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
-    public static final Block snow = (new BlockSnow(78)).setHardness(0.1F).setStepSound(soundSnowFootstep).setUnlocalizedName("snow").setLightOpacity(0);
-    public static final Block ice = (new BlockIce(79)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
-    public static final Block blockSnow = (new BlockSnowBlock(80)).setHardness(0.2F).setStepSound(soundSnowFootstep).setUnlocalizedName("snow");
-    public static final Block cactus = (new BlockCactus(81)).setHardness(0.4F).setStepSound(soundClothFootstep).setUnlocalizedName("cactus");
-    public static final Block blockClay = (new BlockClay(82)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("clay");
-    public static final Block reed = (new BlockReed(83)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
-    public static final Block jukebox = (new BlockJukeBox(84)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("jukebox");
-    public static final Block fence = (new BlockFence(85, "wood", Material.wood)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fence");
-    public static final Block pumpkin = (new BlockPumpkin(86, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkin");
-    public static final Block netherrack = (new BlockNetherrack(87)).setHardness(0.4F).setStepSound(soundStoneFootstep).setUnlocalizedName("hellrock");
-    public static final Block slowSand = (new BlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
-    public static final Block glowStone = (new BlockGlowStone(89, Material.glass)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F).setUnlocalizedName("lightgem");
-
-    /** The purple teleport blocks inside the obsidian circle */
-    public static final BlockPortal portal = (BlockPortal)(new BlockPortal(90)).setHardness(-1.0F).setStepSound(soundGlassFootstep).setLightValue(0.75F).setUnlocalizedName("portal");
-    public static final Block pumpkinLantern = (new BlockPumpkin(91, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setLightValue(1.0F).setUnlocalizedName("litpumpkin");
-    public static final Block cake = (new BlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterIdle = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(93, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterActive = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(94, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
-
     /**
      * April fools secret locked chest, only spawns on new chunks on 1st April.
      */
-    public static final Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
-    public static final Block trapdoor = (new BlockTrapDoor(96, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("trapdoor").disableStats();
-    public static final Block silverfish = (new BlockSilverfish(97)).setHardness(0.75F).setUnlocalizedName("monsterStoneEgg");
-    public static final Block stoneBrick = (new BlockStoneBrick(98)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebricksmooth");
-    public static final Block mushroomCapBrown = (new BlockMushroomCap(99, Material.wood, 0)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("mushroom");
-    public static final Block mushroomCapRed = (new BlockMushroomCap(100, Material.wood, 1)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("mushroom");
-    public static final Block fenceIron = (new BlockPane(101, "fenceIron", "fenceIron", Material.iron, true)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("fenceIron");
-    public static final Block thinGlass = (new BlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
-    public static final Block melon = (new BlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
-    public static final Block pumpkinStem = (new BlockStem(104, pumpkin)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkinStem");
-    public static final Block melonStem = (new BlockStem(105, melon)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkinStem");
-    public static final Block vine = (new BlockVine(106)).setHardness(0.2F).setStepSound(soundGrassFootstep).setUnlocalizedName("vine");
-    public static final Block fenceGate = (new BlockFenceGate(107)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fenceGate");
-    public static final Block stairsBrick = (new BlockStairs(108, brick, 0)).setUnlocalizedName("stairsBrick");
-    public static final Block stairsStoneBrick = (new BlockStairs(109, stoneBrick, 0)).setUnlocalizedName("stairsStoneBrickSmooth");
-    public static final BlockMycelium mycelium = (BlockMycelium)(new BlockMycelium(110)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("mycel");
-    public static final Block waterlily = (new BlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
-    public static final Block netherBrick = (new Block(112, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherBrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block netherFence = (new BlockFence(113, "netherBrick", Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
-    public static final Block stairsNetherBrick = (new BlockStairs(114, netherBrick, 0)).setUnlocalizedName("stairsNetherBrick");
-    public static final Block netherStalk = (new BlockNetherStalk(115)).setUnlocalizedName("netherStalk");
-    public static final Block enchantmentTable = (new BlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
-    public static final Block brewingStand = (new BlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
-    public static final BlockCauldron cauldron = (BlockCauldron)(new BlockCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
-    public static final Block endPortal = (new BlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
-    public static final Block endPortalFrame = (new BlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
-    public static final Block whiteStone = (new Block(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dragonEgg = (new BlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
-    public static final Block redstoneLampIdle = (new BlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block redstoneLampActive = (new BlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
-    public static final BlockHalfSlab woodDoubleSlab = (BlockHalfSlab)(new BlockWoodSlab(125, true)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("woodSlab");
-    public static final BlockHalfSlab woodSingleSlab = (BlockHalfSlab)(new BlockWoodSlab(126, false)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("woodSlab");
-    public static final Block cocoaPlant = (new BlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
-    public static final Block stairsSandStone = (new BlockStairs(128, sandStone, 0)).setUnlocalizedName("stairsSandStone");
-    public static final Block oreEmerald = (new BlockOre(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
-    public static final Block enderChest = (new BlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
-    public static final BlockTripWireSource tripWireSource = (BlockTripWireSource)(new BlockTripWireSource(131)).setUnlocalizedName("tripWireSource");
-    public static final Block tripWire = (new BlockTripWire(132)).setUnlocalizedName("tripWire");
-    public static final Block blockEmerald = (new BlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
-    public static final Block stairsWoodSpruce = (new BlockStairs(134, planks, 1)).setUnlocalizedName("stairsWoodSpruce");
-    public static final Block stairsWoodBirch = (new BlockStairs(135, planks, 2)).setUnlocalizedName("stairsWoodBirch");
-    public static final Block stairsWoodJungle = (new BlockStairs(136, planks, 3)).setUnlocalizedName("stairsWoodJungle");
-    public static final Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
-    public static final BlockBeacon beacon = (BlockBeacon)(new BlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
-    public static final Block cobblestoneWall = (new BlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
-    public static final Block flowerPot = (new BlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
-    public static final Block carrot = (new BlockCarrot(141)).setUnlocalizedName("carrots");
-    public static final Block potato = (new BlockPotato(142)).setUnlocalizedName("potatoes");
-    public static final Block woodenButton = (new BlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
-    public static final Block skull = (new BlockSkull(144)).setHardness(1.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("skull");
-    public static final Block anvil = (new BlockAnvil(145)).setHardness(5.0F).setStepSound(soundAnvilFootstep).setResistance(2000.0F).setUnlocalizedName("anvil");
-    public static final Block chestTrapped = (new BlockChest(146, 1)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("chestTrap");
-    public static final Block pressurePlateGold = (new BlockPressurePlateWeighted(147, "blockGold", Material.iron, 64)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("weightedPlate_light");
-    public static final Block pressurePlateIron = (new BlockPressurePlateWeighted(148, "blockIron", Material.iron, 640)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("weightedPlate_heavy");
-    public static final BlockComparator redstoneComparatorIdle = (BlockComparator)(new BlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockComparator redstoneComparatorActive = (BlockComparator)(new BlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new BlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
-    public static final Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone");
-    public static final Block oreNetherQuartz = (new BlockOre(153)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherquartz");
-    public static final BlockHopper hopperBlock = (BlockHopper)(new BlockHopper(154)).setHardness(3.0F).setResistance(8.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("hopper");
-    public static final Block blockNetherQuartz = (new BlockQuartz(155)).setStepSound(soundStoneFootstep).setHardness(0.8F).setUnlocalizedName("quartzBlock");
-    public static final Block stairsNetherQuartz = (new BlockStairs(156, blockNetherQuartz, 0)).setUnlocalizedName("stairsQuartz");
-    public static final Block railActivator = (new BlockRailPowered(157)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("activatorRail");
-    public static final Block dropper = (new BlockDropper(158)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dropper");
+	public static Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
+	public static Block trapdoor = new FCBlockTrapDoor( 96 );
+	public static Block silverfish = new FCBlockSilverfishLegacy( 97 );
+	public static Block stoneBrick = new FCBlockStoneBrick( 98 );
+	public static Block mushroomCapBrown = new FCBlockMushroomCapLegacy( 99, 0 );
+	public static Block mushroomCapRed = new FCBlockMushroomCapLegacy( 100, 1 );
+	public static Block fenceIron = new FCBlockIronBars( 101 );
+	public static Block thinGlass = (new FCBlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).SetPicksEffectiveOn().setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
+	public static Block melon = (new FCBlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
+	public static Block pumpkinStem = new FCBlockStem( 104, pumpkin );
+	public static Block melonStem = new FCBlockStem( 105, melon );
+	public static Block vine = new FCBlockVine( 106 );
+	public static Block fenceGate = new FCBlockFenceGate( 107 );
+	public static Block stairsBrick = (new FCBlockStairsBrick(108)).setUnlocalizedName("stairsBrick");
+	public static Block stairsStoneBrick = new FCBlockStairsStoneBrick( 109 );
+	public static BlockMycelium mycelium = new FCBlockMycelium( 110 );
+	public static Block waterlily = (new FCBlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
+	public static Block netherBrick = new FCBlockNetherBrick( 112 );
+	public static Block netherFence = (new FCBlockFence( 113, "netherBrick", FCBetterThanWolves.fcMaterialNetherRock )).setHardness(2F).setResistance(10F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
+	public static Block stairsNetherBrick = new FCBlockStairsNetherBrick( 114 );
+	public static Block netherStalk = (new FCBlockNetherStalk(115)).setUnlocalizedName("netherStalk");
+	public static Block enchantmentTable = (new FCBlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
+	public static Block brewingStand = (new FCBlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
+	public static BlockCauldron cauldron = (BlockCauldron)(new FCBlockVanillaCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
+	public static Block endPortal = (new FCBlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
+	public static Block endPortalFrame = (new FCBlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
+	public static Block whiteStone = (new FCBlockEndStone(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
+	public static Block dragonEgg = (new FCBlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
+	public static Block redstoneLampIdle = (new FCBlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
+	public static Block redstoneLampActive = (new FCBlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
+	public static BlockHalfSlab woodDoubleSlab = new FCBlockWoodSlab( 125, true );
+	public static BlockHalfSlab woodSingleSlab = new FCBlockWoodSlab( 126, false );
+	public static Block cocoaPlant = (new FCBlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).SetBuoyant().setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
+	public static Block stairsSandStone = (new FCBlockStairsSandStone(128)).setUnlocalizedName("stairsSandStone");
+	public static Block oreEmerald = (new FCBlockOreEmerald(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
+	public static Block enderChest = (new FCBlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
+	public static BlockTripWireSource tripWireSource = new FCBlockTripWireSource( 131 );
+	public static Block tripWire = (new FCBlockTripWire(132)).setUnlocalizedName("tripWire");
+	public static Block blockEmerald = (new FCBlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
+	public static Block stairsWoodSpruce = ( new FCBlockStairsWood( 134, planks, 1 ) ).setUnlocalizedName( "stairsWoodSpruce" );
+	public static Block stairsWoodBirch = ( new FCBlockStairsWood( 135, planks, 2 ) ).setUnlocalizedName( "stairsWoodBirch" );
+	public static Block stairsWoodJungle = ( new FCBlockStairsWood( 136, planks, 3 ) ).setUnlocalizedName( "stairsWoodJungle" );
+	public static Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
+	public static BlockBeacon beacon = (BlockBeacon)(new FCBlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
+	public static Block cobblestoneWall = (new FCBlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
+	public static Block flowerPot = (new FCBlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
+	public static Block carrot = (new FCBlockCarrotLegacy(141)).setUnlocalizedName("carrots");
+	public static Block potato = (new FCBlockPotatoLegacy(142)).setUnlocalizedName("potatoes");
+	public static Block woodenButton = (new FCBlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
+	public static Block skull = new FCBlockSkull( 144 );
+	public static Block anvil = new FCBlockAnvil( 145 );
+	public static Block chestTrapped = new FCBlockStub( 146 ).setUnlocalizedName( "chestTrap" );
+	public static Block pressurePlateGold = new FCBlockStub( 147 ).setUnlocalizedName( "weightedPlate_light" );
+	public static Block pressurePlateIron = new FCBlockStub( 148 ).setUnlocalizedName( "weightedPlate_heavy" );
+	public static BlockComparator redstoneComparatorIdle = (BlockComparator)(new FCBlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
+	public static BlockComparator redstoneComparatorActive = (BlockComparator)(new FCBlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
+	public static BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new FCBlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
+	public static Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone").setLightValue(0.75F);
+	public static Block oreNetherQuartz = new FCBlockNetherQuartzOre( 153 );
+	public static BlockHopper hopperBlock = new FCBlockVanillaHopper( 154 );
+	public static Block blockNetherQuartz = new FCBlockBlackStone( 155 );
+	public static Block stairsNetherQuartz = new FCBlockBlackStoneStairs( 156 );
+	public static Block railActivator = new FCBlockStub( 157 ).setUnlocalizedName( "activatorRail" );
+	public static Block dropper = new FCBlockStub( 158 ).setUnlocalizedName( "dropper" );
 
     /** ID of the block. */
     public final int blockID;
@@ -242,30 +246,25 @@
     /** true if the Block contains a Tile Entity */
     protected boolean isBlockContainer;
 
-    /** minimum X for the block bounds (local coordinates) */
-    protected double minX;
+	/** FCNOTE: DEPRECATED */
+	protected double minX = 0D;
+	/** FCNOTE: DEPRECATED */
+	protected double minY = 0D;
+	/** FCNOTE: DEPRECATED */
+	protected double minZ = 0D;
+	/** FCNOTE: DEPRECATED */
+	protected double maxX = 1D;
+	/** FCNOTE: DEPRECATED */
+	protected double maxY = 1D;
+	/** FCNOTE: DEPRECATED */
+	protected double maxZ = 1D;
 
-    /** minimum Y for the block bounds (local coordinates) */
-    protected double minY;
-
-    /** minimum Z for the block bounds (local coordinates) */
-    protected double minZ;
-
-    /** maximum X for the block bounds (local coordinates) */
-    protected double maxX;
-
-    /** maximum Y for the block bounds (local coordinates) */
-    protected double maxY;
-
-    /** maximum Z for the block bounds (local coordinates) */
-    protected double maxZ;
-
     /** Sound of stepping on the block */
     public StepSound stepSound;
     public float blockParticleGravity;
 
     /** Block material definition. */
-    public final Material blockMaterial;
+	public Material blockMaterial;
 
     /**
      * Determines how much velocity is maintained while moving on top of this block
@@ -274,7 +273,16 @@
 
     /** The unlocalized name of this block. */
     private String unlocalizedName;
+	protected Icon blockIcon;
 
+	public static final boolean[] blockReplaced = new boolean[4096];
+	public static final String[] blockReplacedBy = new String[4096];
+
+	private int idDroppedOnStonecut = -1;
+	private int countDroppedOnStonecut = 0;
+	private int metaDroppedOnStonecut = 0;
+	private MapColor[] mapColorsForMetadata;
+
     protected Block(int par1, Material par2Material)
     {
         this.stepSound = soundPowderFootstep;
@@ -294,6 +302,10 @@
             opaqueCubeLookup[par1] = this.isOpaqueCube();
             lightOpacity[par1] = this.isOpaqueCube() ? 255 : 0;
             canBlockGrass[par1] = !par2Material.getCanBlockGrass();
+			// FCMOD: Added
+			useNeighborBrightness[par1] = false;
+			SetFilterableProperties( Item.m_iFilterable_SolidBlock );
+			// END FCMOD
         }
     }
 
@@ -343,7 +355,12 @@
     public static boolean isNormalCube(int par0)
     {
         Block var1 = blocksList[par0];
+		// FCMOD: Changed this to not care about providing power (this is the way it used to work)
+		/*
         return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock() && !var1.canProvidePower();
+		 */
+		return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock();
+		// END FCMOD
     }
 
     /**
@@ -354,6 +371,9 @@
         return true;
     }
 
+	/**
+	 * FCNOTE: This is misnamed and returns true if the block *doesn't* block movement
+	 */	
     public boolean getBlocksMovement(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         return !this.blockMaterial.blocksMovement();
@@ -423,16 +443,20 @@
     }
 
     /**
-     * Sets the bounds of the block.  minX, minY, minZ, maxX, maxY, maxZ
+	 * FCNOTE: DEPRECATED 
      */
     protected final void setBlockBounds(float par1, float par2, float par3, float par4, float par5, float par6)
     {
+		// FCMOD: Removed due to deprecating these variables to eliminate client/server race conditions
+		/*
         this.minX = (double)par1;
         this.minY = (double)par2;
         this.minZ = (double)par3;
         this.maxX = (double)par4;
         this.maxY = (double)par5;
         this.maxZ = (double)par6;
+		 */
+		// END FCMOD
     }
 
     /**
@@ -447,6 +471,7 @@
     /**
      * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
      * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
+	 * FCNOTE: The "mask" referred to above is just the bounding box to check for intersection with
      */
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
@@ -462,10 +487,14 @@
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
      * cleared to be reused)
      */
+	// FCMOD: Removed and replaced
+	/*
     public AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
     {
         return AxisAlignedBB.getAABBPool().getAABB((double)par2 + this.minX, (double)par3 + this.minY, (double)par4 + this.minZ, (double)par2 + this.maxX, (double)par3 + this.maxY, (double)par4 + this.maxZ);
     }
+	 */
+	// END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -494,17 +523,20 @@
 
     /**
      * Ticks the block if it's been scheduled
+	 * FCNOTE: Called on server only
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random) {}
 
     /**
      * Called right before the block is destroyed by a player.  Args: world, x, y, z, metaData
+	 * FCNOTE: Called AFTER block is set to air, not before
      */
     public void onBlockDestroyedByPlayer(World par1World, int par2, int par3, int par4, int par5) {}
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
+	 * FCNOTE: Only called on server
      */
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5) {}
 
@@ -518,11 +550,13 @@
 
     /**
      * Called whenever the block is added into the world. Args: world, x, y, z
+	 * FCNOTE: Called on server only
      */
     public void onBlockAdded(World par1World, int par2, int par3, int par4) {}
 
     /**
      * ejects contained items into the world, and notifies neighbours of an update, as appropriate
+	 * FCNOTE: Called on server only.  Called AFTER block is set, so it is no longer valid at pos.
      */
     public void breakBlock(World par1World, int par2, int par3, int par4, int par5, int par6) {}
 
@@ -546,11 +580,15 @@
      * Gets the hardness of block at the given coordinates in the given world, relative to the ability of the given
      * EntityPlayer.
      */
+	// FCMOD: Removed and replaced later
+	/*
     public float getPlayerRelativeBlockHardness(EntityPlayer par1EntityPlayer, World par2World, int par3, int par4, int par5)
     {
         float var6 = this.getBlockHardness(par2World, par3, par4, par5);
         return var6 < 0.0F ? 0.0F : (!par1EntityPlayer.canHarvestBlock(this) ? par1EntityPlayer.getCurrentPlayerStrVsBlock(this, false) / var6 / 100.0F : par1EntityPlayer.getCurrentPlayerStrVsBlock(this, true) / var6 / 30.0F);
     }
+	 */
+	// END FCMOD
 
     /**
      * Drops the specified block items
@@ -595,7 +633,7 @@
             double var7 = (double)(par1World.rand.nextFloat() * var6) + (double)(1.0F - var6) * 0.5D;
             double var9 = (double)(par1World.rand.nextFloat() * var6) + (double)(1.0F - var6) * 0.5D;
             double var11 = (double)(par1World.rand.nextFloat() * var6) + (double)(1.0F - var6) * 0.5D;
-            EntityItem var13 = new EntityItem(par1World, (double)par2 + var7, (double)par3 + var9, (double)par4 + var11, par5ItemStack);
+			EntityItem var13 = (EntityItem) EntityList.createEntityOfType(EntityItem.class, par1World, (double)par2 + var7, (double)par3 + var9, (double)par4 + var11, par5ItemStack);
             var13.delayBeforeCanPickup = 10;
             par1World.spawnEntityInWorld(var13);
         }
@@ -606,6 +644,8 @@
      */
     protected void dropXpOnBlockBreak(World par1World, int par2, int par3, int par4, int par5)
     {
+		// FCMOD: Code removed
+		/*
         if (!par1World.isRemote)
         {
             while (par5 > 0)
@@ -615,6 +655,8 @@
                 par1World.spawnEntityInWorld(new EntityXPOrb(par1World, (double)par2 + 0.5D, (double)par3 + 0.5D, (double)par4 + 0.5D, var6));
             }
         }
+		 */
+		// END FCMOD
     }
 
     /**
@@ -637,6 +679,8 @@
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
+	// FCMOD: Removed and replaced
+	/*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
@@ -753,35 +797,32 @@
         }
     }
 
-    /**
-     * Checks if a vector is within the Y and Z bounds of the block.
-     */
     private boolean isVecInsideYZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
-    /**
-     * Checks if a vector is within the X and Z bounds of the block.
-     */
     private boolean isVecInsideXZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
-    /**
-     * Checks if a vector is within the X and Y bounds of the block.
-     */
     private boolean isVecInsideXYBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY;
     }
+	 */
+	// END FCMOD 
 
     /**
      * Called upon the block being destroyed by an explosion
      */
     public void onBlockDestroyedByExplosion(World par1World, int par2, int par3, int par4, Explosion par5Explosion) {}
 
+	public void onBlockDestroyedByMiningCharge(World world, int x, int y, int z) {
+		this.onBlockDestroyedByExplosion(world, x, y, z, null);
+	}
+
     public boolean canPlaceBlockOnSide(World par1World, int par2, int par3, int par4, int par5, ItemStack par6ItemStack)
     {
         return this.canPlaceBlockOnSide(par1World, par2, par3, par4, par5);
@@ -835,9 +876,7 @@
      */
     public void velocityToAddToEntity(World par1World, int par2, int par3, int par4, Entity par5Entity, Vec3 par6Vec3) {}
 
-    /**
-     * Updates the blocks bounds based on its current state. Args: world, x, y, z
-     */
+	/** FCNOTE: DEPRECATED */
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4) {}
 
     /**
@@ -928,13 +967,22 @@
     /**
      * Called when the player destroys a block with an item that can harvest it. (i, j, k) are the coordinates of the
      * block and l is the block's subtype/damage.
+	 * FCNOTE: Only called on server
      */
     public void harvestBlock(World par1World, EntityPlayer par2EntityPlayer, int par3, int par4, int par5, int par6)
     {
         par2EntityPlayer.addStat(StatList.mineBlockStatArray[this.blockID], 1);
+
+		// FCMOD: Changed
+		/*
         par2EntityPlayer.addExhaustion(0.025F);
 
         if (this.canSilkHarvest() && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
+		 */
+		par2EntityPlayer.AddHarvestBlockExhaustion( blockID, par3, par4, par5, par6 );        
+
+		if ( this.canSilkHarvest( par6 ) && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
+			// END FCMOD
         {
             ItemStack var8 = this.createStackedBlock(par6);
 
@@ -961,6 +1009,7 @@
     /**
      * Returns an item stack containing a single instance of the current block type. 'i' is the block's subtype/damage
      * and is ignored for blocks which do not support subtypes. Blocks which cannot be harvested should return null.
+	 * FCNOTE: This is the function used to create the silk-touch drop
      */
     protected ItemStack createStackedBlock(int par1)
     {
@@ -992,6 +1041,7 @@
 
     /**
      * Called when the block is placed in the world.
+	 * FCNOTE: Called AFTER the block is placed, unlike onBlockPlaced()
      */
     public void onBlockPlacedBy(World par1World, int par2, int par3, int par4, EntityLiving par5EntityLiving, ItemStack par6ItemStack) {}
 
@@ -1051,6 +1101,7 @@
     /**
      * Returns the mobility information of the block, 0 = free, 1 = can't push but can move over, 2 = total immobility
      * and stop pistons
+	 * FCMOD: 3 = can be piston shoveled, but free otherwise 
      */
     public int getMobilityFlag()
     {
@@ -1070,6 +1121,13 @@
         return this.damageDropped(par1World.getBlockMetadata(par2, par3, par4));
     }
 
+	// FCMOD: Added from client to avoid nuisance
+	public CreativeTabs getCreativeTabToDisplayOn()
+	{
+		return this.displayOnCreativeTab;
+	}
+	// END FCMOD    
+
     /**
      * Sets the CreativeTab to display this block on.
      */
@@ -1176,8 +1234,12 @@
                     blocksList[var0].initializeBlock();
                 }
 
+				// FCMOD: Changed to not overwrite settings in block classes and to instead set
+				// useNeighborBrightness[] in block classes for most cases instead.
+				/*
                 boolean var1 = false;
 
+                // FCNOTE: renderType 10 is used by vanilla stairs
                 if (var0 > 0 && blocksList[var0].getRenderType() == 10)
                 {
                     var1 = true;
@@ -1204,10 +1266,2108 @@
                 }
 
                 useNeighborBrightness[var0] = var1;
+				 */
+				if ( canBlockGrass[var0] || lightOpacity[var0] == 0 )
+				{
+					useNeighborBrightness[var0] = true;
             }
+				// END FCMOD
         }
+		}
 
         canBlockGrass[0] = true;
         StatList.initBreakableStats();
     }
+
+	// FCMOD: Added New
+	private static final int[] m_iRotatedFacingsAroundJClockwise = 
+			new int[] { 0, 1, 4, 5, 3, 2 };
+
+	private static final int[] m_iRotatedFacingsAroundJCounterclockwise = 
+			new int[] { 0, 1, 5, 4, 2, 3 };
+
+	private static final int[] m_iCycledFacings = 
+			new int[] { 4, 0, 1, 5, 3, 2 };
+
+	private static final int[] m_iCycledFacingsReversed = 
+			new int[] { 1, 2, 5, 4, 0, 3 };
+
+	public boolean IsNormalCube( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockMaterial.isOpaque() && renderAsNormalBlock();
 }
+
+	/**
+	 * Similar to onBlockPlacedBy() but called before the block is placed rather than after
+	 */
+	public int PreBlockPlacedBy( World world, int i, int j, int k, int iMetadata, EntityLiving entityBy ) 
+	{
+		return iMetadata;    	
+	}
+
+	public void SetBlockMaterial( Material material )
+	{
+		blockMaterial = material;
+
+		canBlockGrass[blockID] = !material.getCanBlockGrass();    	
+	}
+
+	/**
+	 * Called on server only
+	 */
+	public void RandomUpdateTick( World world, int i, int j, int k, Random rand )
+	{
+		updateTick( world, i, j, k, rand );
+	}
+
+	public void ClientNotificationOfMetadataChange( World world, int i, int j, int k, int iOldMetadata, int iNewMetadata )
+	{
+	}
+
+	public void OnArrowImpact( World world, int i, int j, int k, EntityArrow arrow )
+	{
+	}
+
+	public void OnArrowCollide( World world, int i, int j, int k, EntityArrow arrow )
+	{
+	}
+
+	public float GetMovementModifier( World world, int i, int j, int k )
+	{
+		float fModifier = 1.0F;
+
+		if ( blockMaterial != Material.ground && blockMaterial != Material.grass )
+		{
+			fModifier *= 1.2F;
+		}
+
+		return fModifier;
+	}
+
+	public void OnPlayerWalksOnBlock( World world, int i, int j, int k, EntityPlayer player )
+	{    	
+		// Disabled Hardcore sinkholes
+		/*
+     	if ( IsFallingBlock( world, i, j, k ) )
+     	{
+     		CheckForUnstableGround( world, i, j, k );
+     	}
+		 */
+	}
+
+	/**
+	 * Applies to Hopper ejecting items into the world, not inserting into the block itself
+	 */
+	public boolean DoesBlockHopperEject( World world, int i, int j, int k )
+	{
+		return blockMaterial.isSolid();
+	}
+
+	/**
+	 * Applies to Hopper inserting items directly into the block's inventory.  This
+	 * does not ensure the block has a valid inventory, it's just a first-pass chance
+	 * to block such behavior.
+	 */
+	public boolean DoesBlockHopperInsert( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * Returns true if the block is warm enough to melt nearby snow or ice
+	 */
+	public boolean GetIsBlockWarm( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public StepSound GetStepSound( World world, int i, int j, int k )
+	{
+		return stepSound;
+	}
+
+	public void ClientBreakBlock( World world, int i, int j, int k, int iBlockID, int iMetadata )
+	{
+	}
+
+	public void ClientBlockAdded( World world, int i, int j, int k )
+	{
+	}
+
+	public boolean HasStrata()
+	{
+		return false;
+	}
+
+	public int GetMetadataConversionForStrataLevel( int iLevel, int iMetadata )
+	{
+		return iMetadata;
+	}
+
+	public float getExplosionResistance( Entity entity, World world, int i, int j, int k )
+	{
+		return getExplosionResistance( entity );
+	}
+
+	public boolean CanBlockStayDuringGenerate( World world, int i, int j, int k )
+	{
+		// breaking this off into a separate function so that we can prevent certain blocks (like mushrooms) spawning under certain conditions without messing up worldgen or
+		// its usual growth conditions
+
+		// NOTE: This function isn't called for all types of WorldGen to avoid excessive base class changes where not needed.  If you want to override it, make sure it is called
+		// appropriately for the block in question first.
+
+		return canBlockStay( world, i, j, k );
+	}
+
+	/**
+	 * Used to determine if this is a stair block for purposes of connecting visually to others
+	 */
+	public boolean IsStairBlock()
+	{
+		return false;
+	}
+
+	public boolean ShouldDeleteTileEntityOnBlockChange( int iNewBlockID )
+	{
+		return true;
+	}
+
+	/** 
+	 * Determines whether other stone will "connect" to this block for purposes of determing whether
+	 * a stone block can be individually harvested without breaking apart
+	 */
+	public boolean IsNaturalStone( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	static public AxisAlignedBB GetFulBlockBoundingBoxFromPool( World world, int i, int j, int k )
+	{
+		return AxisAlignedBB.getAABBPool().getAABB(
+				(float)i, (float)j, (float)k, 
+				(float)i + 1.0F, (float)j + 1.0F, (float)k + 1.0F );	    	
+	}
+
+	public boolean CanSpitWebReplaceBlock( World world, int i, int j, int k )
+	{
+		return IsGroundCover( ) || IsAirBlock();
+	}
+
+	public boolean IsAirBlock()
+	{
+		return false;
+	}
+
+	public boolean IsReplaceableVegetation( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean HasWaterToSidesOrTop( World world, int i, int j, int k )
+	{
+		for ( int iFacing = 1; iFacing <= 5; iFacing++ )
+		{		
+			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iFacing );
+
+			int iTempBlockID = world.getBlockId( tempPos.i, tempPos.j, tempPos.k );
+			Block tempBlock = Block.blocksList[iTempBlockID];
+
+			if ( tempBlock != null && tempBlock.blockMaterial == Material.water )
+			{
+				return true;
+			}			
+		}
+
+		return false;
+	}
+
+	public boolean GetPreventsFluidFlow( World world, int i, int j, int k, Block fluidBlock )
+	{
+		return blockMaterial == Material.portal ? true : blockMaterial.blocksMovement();
+	}
+
+	public void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid fluidBlock )
+	{
+		dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+	}
+
+	public boolean IsBlockClimbable( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/** 
+	 * Whether or not the block sets off Buddy Blocks.  Set to false for stuff like redstone blocks
+	 * that can cause feedback loops.
+	 */
+	public boolean TriggersBuddy()
+	{
+		return true;
+	}
+
+	//------------ Addon interfacing related functionality ----------//
+
+	/**
+	 * Replaces a reference to an existing block (vanilla or btw)
+	 * @param id The block id to be replaced
+	 * @param newClass The class of the new block
+	 * @param parameters Optional additional parameters to pass to the block, not including the id.
+	 */
+	public static Block replaceBlock(int id, Class newClass, FCAddOn addonPerformingReplacement, Object ... parameters) {
+		return replaceBlock(id, newClass, new String[] {}, addonPerformingReplacement, parameters);
+	}
+
+	/**
+	 * Replaces a reference to an existing block (vanilla or btw), with a list of valid addons for which to be able to overwrite their replacement
+	 * @param id The block id to be replaced
+	 * @param newClass The class of the new block
+	 * @param validAddonNamesForOverwrite An array of addon names which should be ignored when handling conflicts
+	 * @param parameters Optional additional parameters to pass to the block, not including the id.
+	 */
+	public static Block replaceBlock(int id, Class newClass, String[] validAddonNamesForOverwrite, FCAddOn addonPerformingReplacement, Object ... parameters) {
+		if (blockReplaced[id]) {
+			String replacedBy = blockReplacedBy[id];
+			boolean isValidOverwrite = false;
+			
+			for (String addonName : validAddonNamesForOverwrite) {
+				if (replacedBy.equals(addonName)) {
+					isValidOverwrite = true;
+				}
+			}
+			
+			if (!isValidOverwrite) {
+				throw new RuntimeException("Multiple addons attempting to replace block " + blocksList[id]);
+			}
+		}
+
+		Block newBlock = null;
+
+		Class[] parameterTypes = new Class[parameters.length + 1];
+		Object[] parameterValues = new Object[parameters.length + 1];
+
+		parameterTypes[0] = Integer.TYPE;
+		parameterValues[0] = id;
+
+		Block original = blocksList[id];
+		blocksList[id] = null;
+
+		for (int i = 0; i < parameters.length; i++) {
+			Class<?> type = parameters[i].getClass();
+
+			Class<?> primitiveType = FCUtilsReflection.getPrimitiveFromBoxedClass(type);
+
+			if (primitiveType != null) {
+				type = primitiveType;
+			}
+
+			parameterTypes[i + 1] = type;
+			parameterValues[i + 1] = parameters[i];
+		}
+
+		Constructor constructorToUse = FCUtilsReflection.findMatchingConstructor(newClass, parameterTypes);
+
+		if (constructorToUse == null) {
+			String message = "No appropriate constructor found for " + blocksList[id] + ": ";
+
+			for (Class<?> paramType : parameterTypes) {
+				message += paramType.getSimpleName() + ", ";
+			}
+
+			throw new RuntimeException(message);
+		}
+
+		try {
+			constructorToUse.setAccessible(true);
+			newBlock = (Block) constructorToUse.newInstance(parameterValues);
+		} catch (InstantiationException e) {
+			throw new RuntimeException("A problem has occured attempting to instantiate replacement for " + blocksList[id]);
+		} catch (IllegalArgumentException e) {
+			throw new RuntimeException("Incompatible types passed to specified constructor for " + blocksList[id]);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+		blockReplaced[id] = true;
+		
+		if (addonPerformingReplacement != null) {
+			blockReplacedBy[id] = addonPerformingReplacement.getName();
+		}
+		else {
+			FCAddOnHandler.LogWarning("Deprecated block replacement call for block " + blocksList[id] + ". Please attach addon when handling replacement for mutual replacement handling.");
+			blockReplacedBy[id] = "";
+		}
+
+		newBlock.setHardness(original.blockHardness).setResistance(original.blockResistance).setStepSound(original.stepSound).setUnlocalizedName(original.unlocalizedName).setCreativeTab(original.getCreativeTabToDisplayOn());
+		if (!original.enableStats)
+			newBlock.disableStats();
+
+		blocksList[id] = newBlock;
+
+		return newBlock;
+	}
+
+	//------------ Harvesting related functionality ----------//
+
+	protected boolean canSilkHarvest( int iMetadata )
+	{
+		return canSilkHarvest();
+	}
+
+	/**
+	 * Called on server only, after the block is removed from the world
+	 */
+	public void OnBlockDestroyedWithImproperTool( World world, EntityPlayer player, int i, int j, int k, int iMetadata )
+	{
+		world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyedWithImproperToolAuxFXID, i, j, k, blockID + ( iMetadata << 12 ) );
+
+		DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, 1F );
+	}
+
+	protected void DropItemsIndividualy( World world, int i, int j, int k, int iIDDropped, int iPileCount, int iDamageDropped, float fChanceOfPileDrop )
+	{
+		for ( int iTempCount = 0; iTempCount < iPileCount; iTempCount++ )
+		{
+			if ( world.rand.nextFloat() <= fChanceOfPileDrop )
+			{
+				ItemStack stack = new ItemStack( iIDDropped, 1, iDamageDropped );
+
+				dropBlockAsItem_do( world, i, j, k, stack );
+			}
+		}
+	}
+
+	/**
+	 * Called by explosions and improper tool use.  
+	 * Should return true if the block processes its own drops through this method, false otherwise
+	 * Note that the block may no longer be at the specified position when this is called
+	 */
+	public boolean DropComponentItemsOnBadBreak( World world, int i, int j, int k, int iMetadata, float fChanceOfDrop )
+	{
+		return false;
+	}
+
+	/**
+	 * Explosion may be null if this is called by a mining charge
+	 */
+	public void DropItemsOnDestroyedByExplosion( World world, int i, int j, int k, Explosion explosion )
+	{
+		if ( !world.isRemote && canDropFromExplosion( explosion ) )
+		{
+			float fChance = 1F;
+
+			if ( explosion != null )
+			{
+				fChance /= explosion.explosionSize;
+			}
+
+			int iMetadata = world.getBlockMetadata( i, j, k );
+
+			if ( !DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, fChance ) )
+			{
+				dropBlockAsItemWithChance( world, i, j, k, iMetadata, fChance, 0 );
+			}
+		}
+	}
+
+	public void dropItemsOnDestroyedByMiningCharge(World world, int x, int y, int z, int metadata) {
+		if (!world.isRemote) {
+			dropBlockAsItem(world, x, y, z, metadata, 0);
+		}
+	}
+
+	/**
+	 * Notifies neighbors of dirt blocks that they should be loosened
+	 */
+	protected void OnDirtDugWithImproperTool( World world, int i, int j, int k )
+	{
+		for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+		{
+			NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );    		    		
+		}
+	}
+
+	protected void OnDirtSlabDugWithImproperTool( World world, int i, int j, int k, 
+			boolean bUpsideDown )
+	{
+		for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+		{
+			if ( !( bUpsideDown && iTempFacing == 0 ) && !( !bUpsideDown && iTempFacing == 1 ) )
+			{
+				NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );
+			}
+		}
+	}
+
+	protected void NotifyNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
+			int iToFacing )
+	{
+		FCUtilsBlockPos neighborPos = new FCUtilsBlockPos( i, j, k, iToFacing );
+
+		int iTargetBlockID = world.getBlockId( neighborPos.i, neighborPos.j, neighborPos.k );
+
+		Block targetBlock = blocksList[iTargetBlockID];
+
+		if ( targetBlock != null )
+		{    	
+			targetBlock.OnNeighborDirtDugWithImproperTool( world, 
+					neighborPos.i, neighborPos.j, neighborPos.k, GetOppositeFacing( iToFacing ) );
+		}    		
+	}
+
+	protected void OnNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
+			int iToFacing )
+	{
+	}
+
+	//------------ Hard Point related functionality ----------//
+
+	/**
+	 * small attachment surfaces, like those required for the bottom of a torch (approx 1/8 block width)
+	 */
+	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+	}
+
+	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasSmallCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+	}
+
+	/**
+	 * medium sized attachment points like the top of fence posts (approx 1/4 block width)
+	 */
+	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+	}
+
+	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+	}
+
+	/**
+	 * large attachment points that can support a full block width
+	 */	
+	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+
+	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+	}
+
+	/**
+	 * returns true if the block is sitting on the one below, like a torch resting on the ground
+	 */
+	public boolean IsBlockRestingOnThatBelow( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * returns true if block is attached to a block in a particular direction.  Example: pumpkins attached to stems
+	 */
+	public boolean IsBlockAttachedToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return false;
+	}
+
+	public void AttachToFacing( World world, int i, int j, int k, int iFacing )
+	{
+	}
+
+	public boolean HasContactPointToFullFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+
+	public boolean HasContactPointToSlabSideFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIsSlabUpsideDown )
+	{
+		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+	}
+
+	/**
+	 * This method refers to the 'L' shaped sides of stair blocks.  Other stair facings will refernce either the full face, stair top,
+	 * or slab methods, depending on their shape
+	 */
+	public boolean HasContactPointToStairShapedFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+	}
+
+	/**
+	 * This method refers to the half-block shaped top or bottom of stair blocks.
+	 */
+	public boolean HasContactPointToStairNarrowVerticalFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, int iStairFacing )
+	{
+		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+	}
+
+	/**
+	 * Should return true if mortar has been successfully applied to block.
+	 */
+	public boolean OnMortarApplied( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean HasMortar( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean HasNeighborWithMortarInContact( World world, int i, int j, int k )
+	{
+		for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+		{
+			if ( FCUtilsWorld.HasNeighborWithMortarInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	public boolean IsStickyToSnow( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean HasStickySnowNeighborInContact( World world, int i, int j, int k )
+	{
+		for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+		{
+			if ( FCUtilsWorld.HasStickySnowNeighborInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	//--------------- Fire related functionality -------------//
+
+	private int m_iDefaultFurnaceBurnTime = 0;    
+
+	public int GetFurnaceBurnTime( int iItemDamage )
+	{
+		return m_iDefaultFurnaceBurnTime;
+	}
+
+	public void SetFurnaceBurnTime( int iBurnTime )
+	{
+		m_iDefaultFurnaceBurnTime = iBurnTime;
+	}
+
+	public void SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
+	{
+		SetFurnaceBurnTime( burnTime.m_iBurnTime );
+	}
+
+	public boolean DoesInfiniteBurnToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return false;
+	}
+
+	public boolean DoesExtinguishFireAbove( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public void OnDestroyedByFire( World world, int i, int j, int k, int iFireAge, boolean bForcedFireSpread )
+	{
+		if ( bForcedFireSpread || ( world.rand.nextInt( iFireAge + 10 ) < 5 && 
+				!world.IsRainingAtPos( i, j, k ) ) )
+		{
+			int iNewFireMetadata = iFireAge + world.rand.nextInt( 5 ) / 4;
+
+			if ( iNewFireMetadata > 15 )
+			{
+				iNewFireMetadata = 15;
+			}
+
+			world.setBlockAndMetadataWithNotify( i, j, k, Block.fire.blockID, iNewFireMetadata );
+		}
+		else
+		{
+			world.setBlockWithNotify( i, j, k, 0 );
+		}
+	}    
+
+	public Block SetFireProperties( int iChanceToEncourageFire, int iAbilityToCatchFire )
+	{
+		BlockFire.chanceToEncourageFire[blockID] = iChanceToEncourageFire;
+		BlockFire.abilityToCatchFire[blockID] = iAbilityToCatchFire;
+
+		return this;
+	}
+
+	public Block SetFireProperties( FCEnumFlammability flammability )
+	{
+		return SetFireProperties( flammability.m_iChanceToEncourageFire, 
+				flammability.m_iAbilityToCatchFire );
+	}
+
+	/**
+	 * Whether the block itself can be set on fire, rather than a neighboring block being set to a fire block
+	 */
+	public boolean GetCanBeSetOnFireDirectly( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean GetCanBeSetOnFireDirectlyByItem( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return GetCanBeSetOnFireDirectly( blockAccess, i, j, k );
+	}
+
+	public boolean SetOnFireDirectly( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public int GetChanceOfFireSpreadingDirectlyTo( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+
+	public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k, Entity entity )
+	{
+		return GetDoesFireDamageToEntities( world, i, j, k );
+	}
+
+	public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * Used by Hibachi to determine if it can remove the block above it when lit
+	 */
+	public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
+	{
+		return Block.fire.canBlockCatchFire( world, i, j, k ) || !blockMaterial.blocksMovement();
+	}
+
+	/** 
+	 * Whether a fire block can be directly placed over this one, without first burning or catching fire, as if it were air.
+	 */
+	public boolean GetCanBlockBeReplacedByFire( World world, int i, int j, int k )
+	{
+		return IsAirBlock();
+	}
+
+	public boolean IsIncineratedInCrucible()
+	{
+		return FCBlockFire.CanBlockBeDestroyedByFire( blockID );
+	}
+
+	//------------- Pathing related functionality ------------//
+
+	public boolean CanPathThroughBlock( IBlockAccess blockAccess, int i, int j, int k, 
+			Entity entity, PathFinder pathFinder )
+	{
+		// note: getBlocksMovement() is misnamed and returns if the block *doesn't* block movement
+
+		return getBlocksMovement( blockAccess, i, j, k );
+	}
+
+	/**
+	 * Used to determine if entities who start their pathing from within this block
+	 * should instead start pathing from a neighbor block instead, to prevent getting stuck
+	 * in this one.  Mostly applies to stuff like chickens getting stuck in fences.
+	 */
+	public boolean ShouldOffsetPositionIfPathingOutOf( IBlockAccess blockAccess, 
+			int i, int j, int k, Entity entity, PathFinder pathFinder )
+	{
+		return !CanPathThroughBlock( blockAccess, i, j, k, entity, pathFinder );
+	}
+
+	public int GetWeightOnPathBlocked( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}    
+
+	public int AdjustPathWeightOnNotBlocked( int iPreviousWeight )
+	{
+		return iPreviousWeight;
+	}
+
+	public boolean IsBreakableBarricade( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean IsBreakableBarricadeOpen( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	//------------- Kiln related functionality ------------//
+
+	public final boolean GetCanBeCookedByKiln(IBlockAccess blockAccess, int i, int j, int k)
+	{
+		int metadata = blockAccess.getBlockMetadata(i, j, k);
+
+		return FCCraftingManagerKiln.instance.getRecipeResult(this, metadata) != null;
+	}    
+
+	public final int GetCookTimeMultiplierInKiln(IBlockAccess blockAccess, int i, int j, int k)
+	{
+		int metadata = blockAccess.getBlockMetadata(i, j, k);
+
+		FCCraftingManagerKilnRecipe recipe = FCCraftingManagerKiln.instance.getRecipe(this, metadata);
+
+		return recipe != null ? recipe.getCookTimeMultiplier() : 1;
+	}
+
+	public final ItemStack[] getOutputsWhenCookedByKiln(IBlockAccess blockAccess, int i, int j, int k)
+	{
+		int metadata = blockAccess.getBlockMetadata(i, j, k);
+
+		return FCCraftingManagerKiln.instance.getRecipeResult(this, metadata);
+	}
+
+	public void OnCookedByKiln( World world, int i, int j, int k )
+	{
+		ItemStack[] outputs = getOutputsWhenCookedByKiln(world, i, j, k);
+
+		if ( outputs != null )
+		{
+			world.setBlockToAir( i, j, k );
+
+			for (ItemStack stack : outputs) {
+				FCUtilsItem.EjectStackWithRandomOffset(world, i, j, k, stack.copy());
+			}
+		}
+	}
+
+	//------------- Saw related functionality ------------//
+
+	public boolean DoesBlockBreakSaw(World world, int x, int y, int z) {
+		if (blockMaterial.isSolid() && !blockMaterial.breaksSaw()) {
+			return true;
+		}
+
+		return false;
+	}
+
+	/*
+	 * returns true if the block has been sawed, false otherwise
+	 */
+	public boolean OnBlockSawed( World world, int i, int j, int k, int iSawPosI, int iSawPosJ, int iSawPosK )
+	{
+		return OnBlockSawed( world, i, j, k );
+	}
+
+	/*
+	 * returns true if the block has been sawed, false otherwise
+	 */
+	public boolean OnBlockSawed( World world, int i, int j, int k )
+	{
+		int metadata = world.getBlockMetadata(i, j, k);
+		FCCraftingManagerSawRecipe recipe = FCCraftingManagerSaw.instance.getRecipe(this, metadata);
+
+		if (recipe != null)
+		{
+			for (ItemStack stack : recipe.getOutput()) {
+				FCUtilsItem.EjectStackWithRandomOffset(world, i, j, k, stack.copy());
+			}
+		}
+		else
+		{
+			if ( !DoesBlockDropAsItemOnSaw( world, i, j, k ) )
+			{
+				return false;
+			}
+
+			dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+		}
+
+		world.setBlockToAir( i, j, k );
+
+		return true;
+	}
+
+	public boolean DoesBlockDropAsItemOnSaw( World world, int i, int j, int k )
+	{
+		return blockMaterial.isSolid();
+	}
+	
+	//------------- silverfish related functionality ------------//
+
+	public int getBlockIDOnInfest(EntityLiving entity, int metadata)
+	{
+		return FCBetterThanWolves.fcBlockSilverfishStone.blockID;
+	}
+
+	/**
+	 * handles all things that happen on infestation, including what should happen to the infector
+	 */
+	public void onInfested(World world, EntityLiving entity, int x, int y, int z, int metadata)
+	{
+		infestBlock(world, entity, x, y, z, metadata);
+		entity.spawnExplosionParticle();
+		entity.setDead();
+	}
+
+	/**
+	 * Basically set block but uses entity and metadata to pick blockID
+	 */
+	public void infestBlock(World world, EntityLiving entity, int x, int y, int z, int metadata)
+	{
+		world.setBlock(x, y, z, getBlockIDOnInfest(entity, metadata), 0, 3);
+	}
+
+	/**
+	 * If this block is infested by linked entity, used by silverfish
+	 */
+	public boolean isBlockInfestedBy(EntityLiving entity)
+	{
+		return false;
+	}
+
+	/**
+	 *
+	 * @param entity for having hook for other infesting mobs
+	 * @param metadata for having single blockID be infestable depending on metadata
+	 * @return
+	 */
+	public boolean isBlockInfestable(EntityLiving entity, int metadata)
+	{
+		return false;
+	}
+	
+	//------------- Mechanical power related functionality ------------//
+
+	public int GetMechanicalPowerLevelProvidedToAxleAtFacing( World world, int i, int j, int k, int iFacing )
+	{
+		return 0;
+	}
+
+	//------------- Tool effectiveness functionality ------------//
+
+	private boolean m_bShovelsEffectiveOn = false;
+	private boolean m_bPicksEffectiveOn = false;
+	private boolean m_bAxesEffectiveOn = false;
+	private boolean m_bHoesEffectiveOn = false;
+
+	private boolean m_bChiselsEffectiveOn = false;
+	private boolean m_bChiselsCanHarvest = false;
+
+	public boolean AreShovelsEffectiveOn()
+	{
+		return m_bShovelsEffectiveOn;
+	}
+
+	public boolean ArePicksEffectiveOn()
+	{
+		return m_bPicksEffectiveOn;
+	}
+
+	public boolean AreAxesEffectiveOn()
+	{
+		return m_bAxesEffectiveOn;
+	}
+
+	public boolean AreHoesEffectiveOn()
+	{
+		return m_bHoesEffectiveOn;
+	}
+
+	public boolean AreChiselsEffectiveOn()
+	{
+		return m_bChiselsEffectiveOn;
+	}
+
+	public boolean AreChiselsEffectiveOn( World world, int i, int j, int k )
+	{
+		return AreChiselsEffectiveOn();
+	}
+
+	public boolean CanChiselsHarvest()
+	{
+		return m_bChiselsCanHarvest;
+	}
+
+	public Block SetShovelsEffectiveOn() { return SetShovelsEffectiveOn( true ); }
+	public Block SetShovelsEffectiveOn( boolean bEffective )
+	{
+		m_bShovelsEffectiveOn = bEffective;
+
+		return this;
+	}
+
+	public Block SetPicksEffectiveOn() { return SetPicksEffectiveOn( true ); }
+	public Block SetPicksEffectiveOn( boolean bEffective )
+	{
+		m_bPicksEffectiveOn = bEffective;
+
+		return this;
+	}
+
+	public Block SetAxesEffectiveOn() { return SetAxesEffectiveOn( true ); }
+	public Block SetAxesEffectiveOn( boolean bEffective )
+	{
+		m_bAxesEffectiveOn = bEffective;
+
+		return this;
+	}
+
+	public Block SetHoesEffectiveOn() { return SetHoesEffectiveOn( true ); }
+	public Block SetHoesEffectiveOn( boolean bEffective )
+	{
+		m_bHoesEffectiveOn = bEffective;
+
+		return this;
+	}
+
+	public Block SetChiselsEffectiveOn() { return SetChiselsEffectiveOn( true ); }
+	public Block SetChiselsEffectiveOn( boolean bEffective )
+	{
+		m_bChiselsEffectiveOn = bEffective;
+
+		return this;
+	}
+
+	public Block SetChiselsCanHarvest() { return SetChiselsCanHarvest( true ); }
+	public Block SetChiselsCanHarvest( boolean bCanHarvest )
+	{
+		m_bChiselsCanHarvest = bCanHarvest;
+
+		return this;
+	}
+
+	public float getPlayerRelativeBlockHardness( EntityPlayer player, World world, int i, int j, int k )
+	{
+		float fBlockHardness = getBlockHardness( world, i, j, k );
+
+		if ( fBlockHardness >= 0F )
+		{
+			float fRelativeHardness = player.getCurrentPlayerStrVsBlock( this, i, j, k ) / fBlockHardness;
+
+			if ( player.IsCurrentToolEffectiveOnBlock( this, i, j, k ) )
+			{
+				return fRelativeHardness / 30F;
+			}
+			else
+			{
+				return fRelativeHardness / 200F;
+			}
+		}
+		else
+		{
+			return 0F; 
+		}
+	}
+
+	public boolean CanConvertBlock( ItemStack stack, World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * Returns false if the block has not been replaced with another, and should be removed
+	 */
+	public boolean ConvertBlock( ItemStack stack, World world, int i, int j, int k, int iFromSide )
+	{
+		return false;
+	}
+
+	public int GetEfficientToolLevel( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+
+	public int GetHarvestToolLevel( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return GetEfficientToolLevel( blockAccess, i, j, k );
+	}
+
+	/**
+	 * The following is for stumps and such, which are a pain to remove regardless of whether their overall block has
+	 * relevant tool effeciencies
+	 */
+	public boolean GetIsProblemToRemove( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean GetDoesStumpRemoverWorkOnBlock( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean CanToolsStickInBlock( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return true;
+	}
+
+	//------------- Buoyancy related functionality ------------//
+
+	private float m_fBuoyancy = -1.0F;
+
+	public Block SetBuoyancy( float fBuoyancy )
+	{
+		m_fBuoyancy = fBuoyancy;
+
+		return this;
+	}
+
+	public Block SetBuoyant() { return SetBuoyancy( 1F ); }
+	public Block SetNonBuoyant() { return SetBuoyancy( -1F ); }
+	public Block SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
+
+	public float GetBuoyancy( int iMetadata )
+	{
+		return m_fBuoyancy;
+	}
+
+	//------------- Ground cover related functionality ------------//
+
+	public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
+	{
+		if ( world.doesBlockHaveSolidTopSurface( i, j, k ) )
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0F;
+	}
+
+	public boolean IsGroundCover()
+	{
+		return false;
+	}
+
+	public boolean GetCanGrassSpreadToBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean SpreadGrassToBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean GetCanGrassGrowUnderBlock( World world, int i, int j, int k, boolean bGrassOnHalfSlab )
+	{
+		if ( !bGrassOnHalfSlab )
+		{
+			return !HasLargeCenterHardPointToFacing( world, i, j, k, 0 );
+		}
+
+		return true;
+	}
+
+	public boolean GetCanMyceliumSpreadToBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean SpreadMyceliumToBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean GetCanBlightSpreadToBlock( World world, int i, int j, int k, int iBlightLevel )
+	{
+		return false;
+	}
+
+	/**
+	 * Used by blocks like grass and mycellium to determine if they should use a snow side
+	 * texture.  Note that this refers to the top visible surface, not just the top facing,
+	 * which means that stuff like half-slabs should only return true if they have ground cover
+	 * actually on the top surface halfway up the block vertically.
+	 */ 
+	public boolean IsSnowCoveringTopSurface( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		int iBlockAboveID = blockAccess.getBlockId( i, j + 1, k );
+
+		if ( iBlockAboveID != 0 )
+		{
+			Block blockAbove = blocksList[iBlockAboveID];
+
+			Material aboveMaterial = blockAbove.blockMaterial;
+
+			if ( aboveMaterial == Material.snow || aboveMaterial == Material.craftedSnow && 
+					blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 ) )
+			{
+				return true;
+			}
+			else if ( 
+					blockAbove.GroundCoverRestingOnVisualOffset( blockAccess, i, j + 1, k ) < -0.99F && 
+					blockAccess.getBlockId( i, j + 2, k ) == snow.blockID )
+			{
+				// consider snow resting on tall grass and such
+
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	//---------- Piston Related Functionality ---------//
+
+	/**
+	 * Returns the metadata that will be placed
+	 */
+	public int OnPreBlockPlacedByPiston( World world, int i, int j, int k, int iMetadata, int iDirectionMoved )
+	{
+		return iMetadata;
+	}
+
+	public boolean CanBlockBePulledByPiston( World world, int i, int j, int k, int iToFacing )
+	{
+		if ( getMobilityFlag() != 1 ) // blocks destroyed on push can not be pulled
+		{
+			return CanBlockBePushedByPiston( world, i, j, k, iToFacing );
+		}
+
+		return false;    	                         
+	}
+
+	public boolean CanBlockBePushedByPiston( World world, int i, int j, int k, int iToFacing )
+	{
+		int iMobility = getMobilityFlag();
+
+		return iMobility == 1 || ( iMobility != 2 && !( this instanceof ITileEntityProvider ) );
+	}
+
+	public boolean CanBePistonShoveled( World world, int i, int j, int k )
+	{
+		return AreShovelsEffectiveOn();
+	}
+
+	/**
+	 * returns the direction the shoveled block will go in if this block is moving towards iToFacing.  
+	 * return -1 if it's no shoveling is taking place.
+	 */
+	public int GetPistonShovelEjectDirection( World world, int i, int j, int k, int iToFacing )
+	{
+		return -1;
+	}
+
+	public AxisAlignedBB GetAsPistonMovingBoundingBox( World world, int i, int j, int k )
+	{
+		return getCollisionBoundingBoxFromPool( world, i, j, k );
+	}
+
+	public int AdjustMetadataForPistonMove( int iMetadata )
+	{
+		return iMetadata;
+	}
+
+	public boolean CanContainPistonPackingToFacing( World world, int i, int j, int k, int iFacing )
+	{
+		return HasLargeCenterHardPointToFacing( world, i, j, k, iFacing, true );
+	}
+
+	public void OnBrokenByPistonPush( World world, int i, int j, int k, int iMetadata )
+	{
+		dropBlockAsItem( world, i, j, k, iMetadata, 0 );
+	}
+
+	//------------- Hopper Filtering Functionality -----------//
+
+	protected int m_iFilterablePropertiesBitfield = 0;
+
+	public boolean CanItemPassIfFilter( ItemStack filteredItem )
+	{
+		return true;
+	}
+
+	public int GetFilterableProperties( ItemStack stack )
+	{
+		return m_iFilterablePropertiesBitfield;
+	}
+
+	public void SetFilterableProperties( int iProperties )
+	{
+		m_iFilterablePropertiesBitfield = iProperties;
+	}
+
+	//---------- Falling Block Functionality ----------//
+
+	private static final int m_iLoadedRangeToCheckFalling = 32;
+
+	public boolean IsFallingBlock()
+	{
+		return false;
+	}
+
+	protected boolean CheckForFall( World world, int i, int j, int k)
+	{
+		if ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j >= 0 )
+		{
+			if ( !BlockSand.fallInstantly && world.checkChunksExist( 
+					i - m_iLoadedRangeToCheckFalling, j - m_iLoadedRangeToCheckFalling, k - m_iLoadedRangeToCheckFalling, 
+					i + m_iLoadedRangeToCheckFalling, j + m_iLoadedRangeToCheckFalling, k + m_iLoadedRangeToCheckFalling ) )
+			{
+				if ( !world.isRemote )
+				{
+					FCEntityFallingBlock fallingEntity = (FCEntityFallingBlock) EntityList.createEntityOfType(FCEntityFallingBlock.class, world, (double)i + 0.5D, (double)j + 0.5D, (double)k + 0.5D,
+							blockID, world.getBlockMetadata( i, j, k ) );
+
+					onStartFalling( fallingEntity );
+
+					world.spawnEntityInWorld( fallingEntity );
+				}
+
+				return true;
+			}
+			else
+			{
+				world.setBlockToAir( i, j, k );
+
+				while ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j > 0 )
+				{
+					j--;
+				}
+
+				if ( j > 0 )
+				{
+					world.setBlock( i, j, k, blockID );
+				}
+
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	/**
+	 * Only called on server
+	 */
+	protected void onStartFalling( EntityFallingSand entity ) {}
+
+	/**
+	 * This is actually called when a block lands safely.  Do not rename as BlockSand has a child method off of this
+	 */
+	public void onFinishFalling( World world, int i, int j, int k, int iMetadata )
+	{
+		NotifyNearbyAnimalsFinishedFalling( world, i, j, k );
+	}
+
+	protected void OnFallingUpdate( FCEntityFallingBlock entity ) {}
+
+	public void NotifyNearbyAnimalsFinishedFalling( World world, int i, int j, int k )
+	{
+		if ( !world.isRemote )
+		{
+			EntityPlayer entityPlayer = world.getClosestPlayer((float)i + 0.5F, (float)j + 0.5F, (float)k + 0.5F, 64D );
+
+			if ( entityPlayer != null )
+			{
+				world.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( entityPlayer, this, i, j, k );
+			}
+		}
+	}
+
+	/** 
+	 * returns true if the block still exists
+	 */
+	public boolean OnFinishedFalling( EntityFallingSand entity, float fFallDistance )
+	{
+		return true;
+	}
+
+	/**
+	 * returns true if the block has combined with the entity
+	 */
+	public boolean AttemptToCombineWithFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+	{
+		return false;
+	}
+
+	public boolean CanBeCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+	{
+		return false;
+	}
+
+	public void OnCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+	{
+	}
+
+	protected boolean CanFallIntoBlockAtPos( World world, int i, int j, int k )
+	{
+		Block targetBlock = Block.blocksList[world.getBlockId( i, j, k )];
+
+		return targetBlock == null || !targetBlock.CanSupportFallingBlocks( world, i, j, k );
+	}
+
+	public boolean CanSupportFallingBlocks( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return HasCenterHardPointToFacing( blockAccess, i, j, k, 1, true );    	
+	}
+
+	protected void CheckForUnstableGround( World world, int i, int j, int k )
+	{
+		for ( int iJOffset = 1; iJOffset <= 16; iJOffset++ )
+		{
+			int iTempJ = j - iJOffset;
+
+			if ( iTempJ <= 0 )
+			{
+				break;
+			}
+			else
+			{
+				if( world.isAirBlock( i, iTempJ, k ) )
+				{
+					world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+
+					break;
+				}
+				else
+				{    	        	
+					int iTempBlockID = world.getBlockId( i, iTempJ, k );
+
+					if ( iTempBlockID == Block.fire.blockID )
+					{
+						world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+
+						break;
+					}
+					else
+					{
+						Block tempBlock = Block.blocksList[iTempBlockID];
+
+						if ( tempBlock.blockMaterial == Material.water || tempBlock.blockMaterial == Material.lava )
+						{
+							world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+
+							break;
+						}
+						else if ( !tempBlock.IsFallingBlock() )
+						{
+							break;
+						}
+					}
+				}    			
+			}
+		}
+	}
+
+	protected void ScheduleCheckForFall( World world, int i, int j, int k )
+	{
+		world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+	}
+
+	/**
+	 * Called on server only
+	 */
+	public void OnBlockDestroyedLandingFromFall( World world, int i, int j, int k, int iMetadata )
+	{
+		OnBlockDestroyedWithImproperTool( world, null, i, j, k, iMetadata );
+	}
+
+	public boolean HasFallingBlockRestingOn( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		Block blockAbove = Block.blocksList[blockAccess.getBlockId( i, j + 1, k )];
+
+		return blockAbove != null && blockAbove.IsFallingBlock() && 
+				blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 );
+	}
+
+	//----------- Block Facing Functionality ----------//
+
+	public int GetFacing( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return GetFacing( blockAccess.getBlockMetadata( i, j, k ) );
+	}
+
+	public int GetFacing( int iMetadata )
+	{
+		return 0;
+	}
+
+	public void SetFacing( World world, int i, int j, int k, int iFacing )
+	{
+		int iMetadata = world.getBlockMetadata( i, j, k );
+
+		int iNewMetadata = SetFacing( iMetadata, iFacing );
+
+		if ( iNewMetadata != iMetadata )
+		{
+			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
+		}
+	}
+
+	public int SetFacing( int iMetadata, int iFacing )
+	{
+		return iMetadata;
+	}
+
+	/**
+	 * Cycle through all the possible facings for a block 
+	 * returns true if the facing has actually changed as a result of this call
+	 */
+	public boolean ToggleFacing( World world, int i, int j, int k, boolean bReverse )
+	{
+		return RotateAroundJAxis( world, i, j, k, bReverse );
+	}
+
+	public int ConvertFacingToTopTextureRotation( int iFacing )
+	{
+		if ( iFacing >= 2 )
+		{
+			if ( iFacing <= 3 )
+			{
+				if ( iFacing == 3 )
+				{
+					return 3;
+				}
+			}
+			else
+			{
+				if ( iFacing == 4 )
+				{
+					return 2;
+				}
+				else // iFacing == 5
+				{
+					return 1;
+				}
+			}
+		}
+
+		return 0;
+	}
+
+	public int ConvertFacingToBottomTextureRotation( int iFacing )
+	{
+		if ( iFacing >= 2 )
+		{
+			if ( iFacing <= 3 )
+			{
+				if ( iFacing == 3 )
+				{
+					return 3;
+				}
+			}
+			else
+			{
+				if ( iFacing == 4 )
+				{
+					return 1;
+				}
+				else // iFacing == 5
+				{
+					return 2;
+				}
+			}
+		}
+
+		return 0;
+	}
+
+	static public int GetOppositeFacing( int iFacing )
+	{
+		return iFacing ^ 1;
+	}
+
+	static public int RotateFacingAroundJ( int iFacing, boolean bReverse )
+	{
+		if ( bReverse )
+		{
+			return m_iRotatedFacingsAroundJCounterclockwise[iFacing];
+		}
+
+		return m_iRotatedFacingsAroundJClockwise[iFacing];
+	}
+
+	static public int CycleFacing( int iFacing, boolean bReverse )
+	{
+		if ( bReverse )
+		{
+			return m_iCycledFacingsReversed[iFacing];
+		}
+
+		return m_iCycledFacings[iFacing];
+	}
+
+	//-------- Turntable Related Functionality --------//
+
+	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}	
+
+	public boolean CanTransmitRotationHorizontallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+
+	public boolean CanTransmitRotationVerticallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+
+	/**
+	 * Returns the new crafting counter after rotation.  It is unmodified if no crafting has taken place, 
+	 * incremented or reset on completion if it has.
+	 */
+	public int RotateOnTurntable(World world, int x, int y, int z, boolean reverse, int craftingCounter) {
+		OnRotatedOnTurntable(world, x, y, z);
+
+		if (!RotateAroundJAxis(world, x, y, z, reverse)) {
+			// notify the surrounding blocks of a change if no facing change actually takes place, so that buddy can pick up on it
+			// this is because solid blocks still "rotate" even if their facing doesn't change
+			world.notifyBlocksOfNeighborChange( x, y, z, blockID );
+		}
+		
+		int metadata = world.getBlockMetadata(x, y, z);
+		
+		FCCraftingManagerTurntableRecipe recipe = FCCraftingManagerTurntable.instance.getRecipe(this, metadata);
+		
+		if (recipe != null) {
+			craftingCounter = this.TurntableCraftingRotation(world, x, y, z, reverse, craftingCounter);
+		}
+
+		return craftingCounter;
+	}
+
+	/*
+	 * Intended to play block specific FX and such
+	 */
+	protected void OnRotatedOnTurntable(World world, int x, int y, int z) {}
+
+	protected int TurntableCraftingRotation(World world, int x, int y, int z, boolean reverse, int craftingCounter) {
+		craftingCounter++;
+		
+		int metadata = world.getBlockMetadata(x, y, z);
+		
+		FCCraftingManagerTurntableRecipe recipe = FCCraftingManagerTurntable.instance.getRecipe(this, metadata);
+
+		if (recipe != null) {
+			if (craftingCounter >= recipe.getRotationsToCraft()) {
+				this.onCraftedOnTurntable(world, x, y, z);
+	
+				Block output = recipe.getOutputBlock();
+				int outputBlockID;
+				
+				if (output != null) {
+					outputBlockID = output.blockID;
+				}
+				else {
+					outputBlockID = 0;
+				}
+				
+				world.setBlockAndMetadataWithNotify(x, y, z, outputBlockID, recipe.getOutputMetadata());
+				
+				recipe.playCompletionEffect(world, x, y, z);
+				
+				if (recipe.getItemsEjected() != null) {
+					for (ItemStack stack : recipe.getItemsEjected()) {
+						for (int i = 0; i < stack.stackSize; i++) {
+							FCUtilsItem.EjectSingleItemWithRandomOffset(world, x, y, z, stack.itemID, stack.getItemDamage());
+						}
+					}
+				}
+				
+				craftingCounter = 0;
+			}
+			else {
+				recipe.playEffect(world, x, y, z);
+			}
+		}
+
+		return craftingCounter;
+	}
+
+	public void onCraftedOnTurntable(World world, int x, int y, int z) {
+		world.playAuxSFX(FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
+				x, y, z, world.getBlockId(x, y, z) + (world.getBlockMetadata(x, y, z) << 12));
+	}
+
+	/**
+	 * Returns true if the facing has actually changed as a result of this call
+	 */
+	public boolean RotateAroundJAxis( World world, int i, int j, int k, boolean bReverse )
+	{
+		int iMetadata = world.getBlockMetadata( i, j, k );
+
+		int iNewMetadata = RotateMetadataAroundJAxis( iMetadata, bReverse );
+
+		if ( iNewMetadata != iMetadata )
+		{
+			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
+
+			return true;
+		}
+
+		return false;
+	}
+
+	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
+	{
+		int iFacing = GetFacing( iMetadata );
+
+		int iNewFacing = RotateFacingAroundJ( iFacing, bReverse );
+
+		return SetFacing( iMetadata, iNewFacing );
+	}
+
+	public boolean CanRotateAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
+	{
+		return false;
+	}
+
+	/**
+	 * Returns false if the block was destroyed and should not be rotated
+	 */
+	public boolean OnRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
+	{
+		return true;
+	}
+
+	public int GetNewMetadataRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iInitialFacing, int iRotatedFacing )
+	{
+		return 0;
+	}
+
+	//----- Block Dispenser Related Functionality -----//
+
+	/**
+	 * If the stack returned is null, the block will not be retrieved
+	 */
+	public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
+	{
+		int iMetadata = world.getBlockMetadata( i, j, k );
+
+		if ( canSilkHarvest( iMetadata ) )
+		{
+			return createStackedBlock( iMetadata );
+		}
+
+		int iIdDropped = idDropped( iMetadata, world.rand, 0 );
+
+		if ( iIdDropped > 0 )
+		{
+			return new ItemStack( iIdDropped, 1, damageDropped( iMetadata ) );
+		}
+
+		return null;
+	}
+
+	/**
+	 * Whether a block is destroyed by the dispenser, even if no item is collected
+	 */
+	public boolean IsBlockDestroyedByBlockDispenser( int iMetadata )
+	{
+		return false;
+	}
+
+	public void OnRemovedByBlockDispenser( World world, int i, int j, int k )
+	{
+		world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
+				i, j, k, blockID + ( world.getBlockMetadata( i, j, k ) << 12 ) );
+
+		world.setBlockWithNotify( i, j, k, 0 );
+	}
+
+	//---------- Weather Related Functionality --------//
+
+	/**
+	 * Called on server only
+	 */
+	public void OnStruckByLightning( World world, int i, int j, int k )
+	{
+	}
+
+	//------- Mob Spawning Related Functionality ------//
+
+	/**
+	 * This is only a first-pass indicator as to whether ANY mobs can spawn on top of the block,
+	 * so stuff like leaves where only Jungle Spiders can spawn on them, should still return true.
+	 */
+	public boolean CanMobsSpawnOn( World world, int i, int j, int k )
+	{
+		return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId ) &&
+				getCollisionBoundingBoxFromPool( world, i, j, k ) != null;
+	}
+
+	public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
+	{
+		return 0F;
+	}
+
+	//-------- Collision Handling Functionality -------//
+
+	/**
+	 * This should never be modified after a block is initialized to avoid multithreading issues
+	 * that occurred with the old min/max bounds variables.
+	 */
+	private AxisAlignedBB m_fixedBlockBounds = new AxisAlignedBB( 0D, 0D, 0D, 1D, 1D, 1D );
+	private boolean m_bFixedBlockBoundsSet = false;
+
+	/**
+	 * Should only ever be called once for a block.  Repeated calls will silently fail without
+	 * changing the bounds.
+	 */
+	protected void InitBlockBounds( double dMinX, double dMinY, double dMinZ, 
+			double dMaxX, double dMaxY, double dMaxZ )
+	{
+		if ( !m_bFixedBlockBoundsSet )
+		{
+			// only allow the bounds to be set before they're ever accessed to 
+			// discourage the kind of errors that necessitated it in the first 
+			// place: client and server threads modifying the min/max values 
+			// resulting in race conditions.
+
+			m_fixedBlockBounds.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );    		
+		}
+	}
+
+	protected void InitBlockBounds( AxisAlignedBB bounds )
+	{
+		if ( !m_bFixedBlockBoundsSet )
+		{
+			m_fixedBlockBounds.setBB( bounds );
+		}
+	}
+
+	protected AxisAlignedBB GetFixedBlockBoundsFromPool()
+	{
+		m_bFixedBlockBoundsSet = true;
+
+		return m_fixedBlockBounds.MakeTemporaryCopy();
+	}
+
+	public AxisAlignedBB getCollisionBoundingBoxFromPool( World world, int i, int j, int k )
+	{
+		return GetBlockBoundsFromPoolBasedOnState( world, i, j, k ).offset( i, j, k );
+	}
+
+	public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+			IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return GetFixedBlockBoundsFromPool();
+	}
+
+	public MovingObjectPosition collisionRayTrace( World world, int i, int j, int k, 
+			Vec3 startRay, Vec3 endRay )
+	{
+		return CollisionRayTraceVsBlockBounds( world, i, j, k, startRay, endRay );
+	}
+
+	public MovingObjectPosition MouseOverRayTrace( World world, int i, int j, int k, 
+			Vec3 startRay, Vec3 endRay )
+	{
+		return collisionRayTrace( world, i, j, k, startRay, endRay );
+	}
+
+	public MovingObjectPosition CollisionRayTraceVsBlockBounds( World world, int i, int j, int k, 
+			Vec3 startRay, Vec3 endRay )
+	{
+		AxisAlignedBB collisionBox = GetBlockBoundsFromPoolBasedOnState( 
+				world, i, j, k ).offset( i, j, k );
+
+		MovingObjectPosition collisionPoint = collisionBox.calculateIntercept( startRay, endRay );
+
+		if ( collisionPoint != null )
+		{
+			collisionPoint.blockX = i;
+			collisionPoint.blockY = j;
+			collisionPoint.blockZ = k;
+		}
+
+		return collisionPoint;
+	}
+
+	//------------- Grazing Functionality -------------//
+
+	private int m_iHerbivoreItemFoodValue = 0;
+	private int m_iBirdItemFoodValue = 0;
+	private int m_iPigItemFoodValue = 0;
+
+	public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+			EntityAnimal byAnimal )
+	{
+		return false;
+	}
+
+	public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
+	{
+		world.setBlockToAir( i, j, k );
+
+		Block blockBelow = blocksList[world.getBlockId( i, j - 1, k )];
+
+		if ( blockBelow != null )
+		{
+			blockBelow.OnVegetationAboveGrazed( world, i, j - 1, k, animal );
+		}
+	}
+
+	public void OnVegetationAboveGrazed( World world, int i, int j, int k, EntityAnimal animal )
+	{
+	}
+
+	/** 
+	 * Used when pigs dig up dirt to let any attached neighbors know that they should break loose
+	 */
+	public void NotifyNeighborsBlockDisrupted( World world, int i, int j, int k )
+	{
+		FCUtilsBlockPos pos = new FCUtilsBlockPos( i, j, k );
+		FCUtilsBlockPos tempPos = new FCUtilsBlockPos();
+
+		for ( int iTempFacing = 0; iTempFacing <= 5; iTempFacing++ )
+		{
+			tempPos.Set( pos );			
+			tempPos.AddFacingAsOffset( iTempFacing );
+
+			Block tempBlock = Block.blocksList[world.getBlockId( tempPos.i, tempPos.j, tempPos.k )];
+
+			if ( tempBlock != null )
+			{
+				tempBlock.OnNeighborDisrupted( world, tempPos.i, tempPos.j, tempPos.k, 
+						GetOppositeFacing( iTempFacing ) );
+			}
+		}
+	}
+
+	public void OnNeighborDisrupted( World world, int i, int j, int k, int iToFacing )
+	{
+	}
+
+	public int GetHerbivoreItemFoodValue( int iItemDamage )
+	{
+		return m_iHerbivoreItemFoodValue;
+	}
+
+	public void SetHerbivoreItemFoodValue( int iFoodValue )
+	{
+		m_iHerbivoreItemFoodValue = iFoodValue;
+	}
+
+	public int GetChickenItemFoodValue( int iItemDamage )
+	{
+		return m_iBirdItemFoodValue;
+	}
+
+	public void SetChickenItemFoodValue( int iFoodValue )
+	{
+		m_iBirdItemFoodValue = iFoodValue;
+	}
+
+	public int GetPigItemFoodValue( int iItemDamage )
+	{
+		return m_iPigItemFoodValue;
+	}
+
+	public void SetPigItemFoodValue( int iFoodValue )
+	{
+		m_iPigItemFoodValue = iFoodValue;
+	}
+
+	//------ Misc Animal Functionality ------//
+
+	private boolean alwaysStartlesAnimals;
+
+	public Block setAlwaysStartlesAnimals() {
+		this.alwaysStartlesAnimals = true;
+		return this;
+	}
+
+	public boolean startlesAnimalsWhenPlaced(World world, int x, int y, int z) {
+		return this.alwaysStartlesAnimals || this.blockMaterial.blocksMovement();
+	}
+
+	//----------- Plant Growth Functionality ----------//
+
+	public boolean CanDomesticatedCropsGrowOnBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean CanReedsGrowOnBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean CanSaplingsGrowOnBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * Covers stuff like flowers and tall grass
+	 */
+	public boolean CanWildVegetationGrowOnBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean CanNetherWartGrowOnBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean CanCactusGrowOnBlock( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean IsBlockHydratedForPlantGrowthOn( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean IsConsideredNeighbouringWaterForReedGrowthOn( World world, int i, int j, int k )
+	{
+		for ( int iTempI = i - 1; iTempI <= i + 1; iTempI++ )
+		{		
+			for ( int iTempK = k - 1; iTempK <= k + 1; iTempK++ )
+			{				
+				if ( world.getBlockMaterial( iTempI, j, iTempK ) == Material.water )
+				{
+					return true;
+				}
+			}
+		}
+
+		return false;
+	}
+
+	/** 
+	 * This is used by old style non-daily plant growth
+	 */
+	public float GetPlantGrowthOnMultiplier( World world, int i, int j, int k, Block plantBlock )
+	{
+		return 1F;
+	}
+
+	public boolean GetIsFertilizedForPlantGrowth( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/** 
+	 * Called when a plant hits a full growth stage, like wheat fully grown, 
+	 * or each full block of Hemp.  Used to clear fertilizer.
+	 */
+	public void NotifyOfFullStagePlantGrowthOn( World world, int i, int j, int k, Block plantBlock )
+	{
+	}
+
+	/**
+	 * Called server only.  Called AFTER the plant is removed, so it's no longer valid.  
+	 */
+	public void NotifyOfPlantAboveRemoved( World world, int i, int j, int k, Block plantBlock )
+	{
+	}
+
+	/**
+	 * This determines whether weeds can share space with crop blocks, or grow
+	 * within their own independent weed blocks
+	 */
+	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * The growth level of weeds growing out of this block.  Range of 0 to 7 
+	 */
+	public int GetWeedsGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+
+	public void RemoveWeeds( World world, int i, int j, int k )
+	{
+	}
+
+	public boolean AttemptToApplyFertilizerTo( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean GetConvertsLegacySoil( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;		
+	}
+
+	//----------------- Map related functionality ----------------//
+
+	/**
+	 * Gets the color used in map rendering for this block with the specified metadata
+	 * @param meta
+	 * @return
+	 */
+	public MapColor getMapColor(int meta) {
+		if (mapColorsForMetadata == null) {
+			return this.blockMaterial.materialMapColor;
+		}
+		else {
+			try {
+				return mapColorsForMetadata[meta];
+			}
+			catch (Exception e) {
+				FCAddOnHandler.LogMessage("Map color not found for metadata " + meta + " of block " + this);
+				return this.blockMaterial.materialMapColor;
+			}
+		}
+	}
+
+	/**
+	 * Set the array of map colors to use per metadata for this block. Make sure you include ALL possible metadata when using this method!
+	 * @param mapColors Array of mapcolor objects which is referenced when rendering maps
+	 * @return
+	 */
+	public Block setMapColorsForMetadata(MapColor[] mapColors) {
+		this.mapColorsForMetadata = mapColors;
+		return this;
+	}
+
+	//------ Light functionality ------//
+
+	public static int getLightValueForBlock(IBlockAccess blockAccess, int x, int y, int z, Block block) {
+		if (block != null) {
+			return block.getLightValue(blockAccess, x, y, z);
+		}
+		else {
+			return 0;
+		}
+	}
+
+	public int getLightValue(IBlockAccess blockAccess, int x, int y, int z) {
+		return lightValue[this.blockID];
+	}
+	
+	//------ Mob spawner conversion functionality ------//
+
+    public boolean canBeCovertedByMobSpawner(World world, int x, int y, int z) {
+    	return false;
+    }
+
+    public void convertBlockFromMobSpawner(World world, int x, int y, int z) {}
+
+	//----------------- Integrity Test ----------------//
+
+	static public boolean InstallationIntegrityTest()
+	{
+		return true;
+	}
+}
