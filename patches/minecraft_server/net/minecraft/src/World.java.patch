--- a/minecraft_server/net/minecraft/src/World.java
+++ b/minecraft_server/net/minecraft/src/World.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
@@ -9,6 +10,10 @@
 import java.util.Random;
 import java.util.Set;
 
+//FCMOD: Added
+import java.util.LinkedList;
+// END FCMOD
+
 public abstract class World implements IBlockAccess
 {
     /**
@@ -85,7 +90,9 @@
     public boolean findingSpawnPoint;
     public MapStorage mapStorage;
     public final VillageCollection villageCollectionObj;
-    protected final VillageSiege villageSiegeObj = new VillageSiege(this);
+    // FCMOD: Removed
+    //protected final VillageSiege villageSiegeObj = new VillageSiege(this);
+    // END FCMOD
     public final Profiler theProfiler;
 
     /** The world-local pool of vectors */
@@ -105,8 +112,23 @@
     protected boolean spawnPeacefulMobs = true;
 
     /** populated by chunks that are within 9 chunks of any player */
-    protected Set activeChunkSet = new HashSet();
+    // FCMOD: Changed to use same type as ChunkProviderServer.loadedChunkHashMap, to avoid
+    // duplicate hash values.  Renamed as new type requires existing references to be adapated
+    // appropriately.
+    //protected Set activeChunkSet = new HashSet();
+    /** 
+     * populated by chunks that are within the view distance (default 8 chunks) of any player,
+     * the original spawn, or any other chunk loader
+     */
+    protected LongHashMap m_activeChunksCoordsMap = new LongHashMap();
 
+    /** 
+     * list of same coords in m_activeChunksCoordsMap
+     */
+    protected LinkedList<ChunkCoordIntPair> m_activeChunksCoordsList = 
+    	new LinkedList<ChunkCoordIntPair>(); 
+    // END FCMOD
+
     /** number of ticks until the next random ambients play */
     private int ambientTickCountdown;
 
@@ -293,7 +315,14 @@
      */
     public boolean isAirBlock(int par1, int par2, int par3)
     {
+    	// FCMOD: Change
+		/*
         return this.getBlockId(par1, par2, par3) == 0;
+		*/
+    	int iBlockID = getBlockId(par1, par2, par3);
+    	
+        return iBlockID == 0 || Block.blocksList[iBlockID].IsAirBlock(); 
+        // END FCMOD
     }
 
     /**
@@ -390,6 +419,10 @@
      * cause a block update. Flag 2 will send the change to clients (you almost always want this). Flag 4 prevents the
      * block from being re-rendered, if this is a client world. Flags can be added together.
      */
+    /**
+     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
     public boolean setBlock(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -487,6 +520,10 @@
      * Sets the blocks metadata and if set will then notify blocks that this block changed, depending on the flag. Args:
      * x, y, z, metadata, flag. See setBlock for flag description
      */
+    /**
+     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
     public boolean setBlockMetadata(int par1, int par2, int par3, int par4, int par5)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -987,6 +1024,8 @@
         return this.rayTraceBlocks_do_do(par1Vec3, par2Vec3, par3, false);
     }
 
+    // FCMOD: Code removed and replaced later
+    /*
     public MovingObjectPosition rayTraceBlocks_do_do(Vec3 par1Vec3, Vec3 par2Vec3, boolean par3, boolean par4)
     {
         if (!Double.isNaN(par1Vec3.xCoord) && !Double.isNaN(par1Vec3.yCoord) && !Double.isNaN(par1Vec3.zCoord))
@@ -1196,6 +1235,8 @@
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Plays a sound at the entity's position. Args: entity, sound, volume (relative to 1.0), and frequency (or pitch,
@@ -1279,15 +1320,14 @@
     }
 
     /**
-     * Called when an entity is spawned in the world. This includes players.
+     * Called to place all entities as part of a world
      */
-    public boolean spawnEntityInWorld(Entity par1Entity)
-    {
-        int var2 = MathHelper.floor_double(par1Entity.posX / 16.0D);
-        int var3 = MathHelper.floor_double(par1Entity.posZ / 16.0D);
-        boolean var4 = par1Entity.field_98038_p;
+    public boolean spawnEntityInWorld(Entity entity) {
+        int var2 = MathHelper.floor_double(entity.posX / 16.0D);
+        int var3 = MathHelper.floor_double(entity.posZ / 16.0D);
+        boolean var4 = entity.field_98038_p;
 
-        if (par1Entity instanceof EntityPlayer)
+        if (entity instanceof EntityPlayer)
         {
             var4 = true;
         }
@@ -1298,16 +1338,16 @@
         }
         else
         {
-            if (par1Entity instanceof EntityPlayer)
+            if (entity instanceof EntityPlayer)
             {
-                EntityPlayer var5 = (EntityPlayer)par1Entity;
+                EntityPlayer var5 = (EntityPlayer)entity;
                 this.playerEntities.add(var5);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            this.getChunkFromChunkCoords(var2, var3).addEntity(par1Entity);
-            this.loadedEntityList.add(par1Entity);
-            this.obtainEntitySkin(par1Entity);
+            this.getChunkFromChunkCoords(var2, var3).addEntity(entity);
+            this.loadedEntityList.add(entity);
+            this.obtainEntitySkin(entity);
             return true;
         }
     }
@@ -1425,18 +1465,29 @@
         }
 
         double var14 = 0.25D;
-        List var15 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
+        // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
+		/*
+        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
+		*/
+        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, 2.0, var14));
+        // END FCMOD
 
-        for (int var16 = 0; var16 < var15.size(); ++var16)
+        for (int var15 = 0; var15 < var16.size(); ++var15)
         {
-            AxisAlignedBB var13 = ((Entity)var15.get(var16)).getBoundingBox();
+        	// FCMOD: Code added
+        	if ( !par1Entity.CanCollideWithEntity( (Entity)var16.get( var15 ) ) )
+        	{
+        		continue;
+        	}
+        	// END FCMOD
+            AxisAlignedBB var13 = ((Entity)var16.get(var15)).getBoundingBox();
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
             {
                 this.collidingBoundingBoxes.add(var13);
             }
 
-            var13 = par1Entity.getCollisionBox((Entity)var15.get(var16));
+            var13 = par1Entity.getCollisionBox((Entity)var16.get(var15));
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
             {
@@ -1539,6 +1590,7 @@
 
     /**
      * Finds the highest block on the x, z coordinate that is solid and returns its y coord. Args x, z
+     * FCNOTE: Despite name, actually returns the block ABOVE the top one, and does not count liquids
      */
     public int getTopSolidOrLiquidBlock(int par1, int par2)
     {
@@ -1638,6 +1690,21 @@
         }
 
         this.unloadedEntityList.clear();
+        // FCMOD: Code added to prevent jerkiness when one entity pushes another (like on Platforms)
+        for (int l = 0; l < loadedEntityList.size(); l++)
+        {
+            Entity tempEntity = (Entity)loadedEntityList.get(l);
+            
+            if (!tempEntity.isDead)
+            {
+            	tempEntity.lastTickPosX = tempEntity.posX;
+            	tempEntity.lastTickPosY = tempEntity.posY;
+            	tempEntity.lastTickPosZ = tempEntity.posZ;        
+            	tempEntity.prevRotationYaw = tempEntity.rotationYaw;
+            	tempEntity.prevRotationPitch = tempEntity.rotationPitch;
+            }
+        }        
+        // END FCMOD
         this.theProfiler.endStartSection("regular");
 
         for (var1 = 0; var1 < this.loadedEntityList.size(); ++var1)
@@ -1700,7 +1767,12 @@
         {
             TileEntity var9 = (TileEntity)var14.next();
 
-            if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
+        	// FCCHUNK: Decide on updates around original spawn
+            // FCMOD: Changed
+            //if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
+            if ( !var9.isInvalid() && var9.func_70309_m() && 
+            	IsBlockPosActive( var9.xCoord, var9.yCoord, var9.zCoord ) )            	            	
+        	// END FCMOD
             {
                 try
                 {
@@ -1798,20 +1870,33 @@
     /**
      * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
      * Args: entity, forceUpdate
+     * FCNOTE: 2nd parameter is more "bOnlyUpdateInLoadedChunks" rather than what is said above
+     * The "OptionalForce" in the function name refers to forcing the update, not a physical force
      */
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
         int var3 = MathHelper.floor_double(par1Entity.posX);
         int var4 = MathHelper.floor_double(par1Entity.posZ);
-        byte var5 = 32;
+        // FCMOD: Changed
+        //byte var5 = 32;
+        int var5 = m_iLoadedChunksUpdateRange;
+        // END FCMOD
 
-        if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
+    	// FCCHUNK: Decide on updates around original spawn
+        // FCMOD: Changed
+        //if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
+        if ( !par2 || IsBlockPosActive( var3, 0, var4 ) )
+        	// END FCMOD
         {
+            // FCMOD: Removed and moved to a pre-update loop elsewhere in this file
+            /*
             par1Entity.lastTickPosX = par1Entity.posX;
             par1Entity.lastTickPosY = par1Entity.posY;
             par1Entity.lastTickPosZ = par1Entity.posZ;
             par1Entity.prevRotationYaw = par1Entity.rotationYaw;
             par1Entity.prevRotationPitch = par1Entity.rotationPitch;
+		    */
+		    // END FCMOD
 
             if (par2 && par1Entity.addedToChunk)
             {
@@ -2015,8 +2100,15 @@
     /**
      * Returns whether or not the given bounding box is on fire or not
      */
-    public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    // FCMOD: Changed
+    //public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    public boolean isBoundingBoxBurning( Entity entity )
+    // END FCMOD
     {
+    	// FCMOD: Added
+    	AxisAlignedBB par1AxisAlignedBB = entity.boundingBox.contract(0.001D, 0.001D, 0.001D);
+    	// END FCMOD
+    	
         int var2 = MathHelper.floor_double(par1AxisAlignedBB.minX);
         int var3 = MathHelper.floor_double(par1AxisAlignedBB.maxX + 1.0D);
         int var4 = MathHelper.floor_double(par1AxisAlignedBB.minY);
@@ -2032,9 +2124,16 @@
                 {
                     for (int var10 = var6; var10 < var7; ++var10)
                     {
+                        // FCMOD: Changed
+						/*
                         int var11 = this.getBlockId(var8, var9, var10);
 
                         if (var11 == Block.fire.blockID || var11 == Block.lavaMoving.blockID || var11 == Block.lavaStill.blockID)
+                        */
+                        Block block = Block.blocksList[getBlockId(var8, var9, var10)];
+                        
+                        if ( block != null && block.GetDoesFireDamageToEntities( this, var8, var9, var10, entity ) )
+                    	// END FCMOD
                         {
                             return true;
                         }
@@ -2268,7 +2367,12 @@
 
         if (this.getBlockId(par2, par3, par4) == Block.fire.blockID)
         {
+        	// FCMOD: Code change to fix fizz effect
+        	/*
             this.playAuxSFXAtEntity(par1EntityPlayer, 1004, par2, par3, par4, 0);
+            */
+            playAuxSFX( 1004, par2, par3, par4, 0);
+            // END FCMOD
             this.setBlockToAir(par2, par3, par4);
             return true;
         }
@@ -2426,9 +2530,21 @@
      */
     public boolean isBlockNormalCube(int par1, int par2, int par3)
     {
-        return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+    	// FCMOD: Changed
+        //return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+    	int iBlockID = getBlockId( par1, par2, par3 );
+
+        Block block = Block.blocksList[iBlockID];
+
+        if( block != null)
+        {
+			return block.IsNormalCube( this, par1, par2, par3 );
     }
 
+        return false;
+        // END FCMOD
+    }
+
     public boolean func_85174_u(int par1, int par2, int par3)
     {
         int var4 = this.getBlockId(par1, par2, par3);
@@ -2447,20 +2563,28 @@
     /**
      * Returns true if the block at the given coordinate has a solid (buildable) top surface.
      */
+    // FCMOD: Removed (replaced later)
+    /*
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
         Block var4 = Block.blocksList[this.getBlockId(par1, par2, par3)];
         return this.isBlockTopFacingSurfaceSolid(var4, this.getBlockMetadata(par1, par2, par3));
     }
+    */
+    // END FCMOD
 
     /**
      * Performs check to see if the block is a normal, solid block, or if the metadata of the block indicates that its
      * facing puts its solid side upwards. (inverted stairs, for example)
      */
+    // FCMOD: Removed (deprecated)
+    /*
     public boolean isBlockTopFacingSurfaceSolid(Block par1Block, int par2)
     {
         return par1Block == null ? false : (par1Block.blockMaterial.isOpaque() && par1Block.renderAsNormalBlock() ? true : (par1Block instanceof BlockStairs ? (par2 & 4) == 4 : (par1Block instanceof BlockHalfSlab ? (par2 & 8) == 8 : (par1Block instanceof BlockHopper ? true : (par1Block instanceof BlockSnow ? (par2 & 7) == 7 : false)))));
     }
+    */
+    // END FCMOD
 
     /**
      * Checks if the block is a solid, normal cube. If the chunk does not exist, or is not loaded, it returns the
@@ -2475,7 +2599,12 @@
             if (var5 != null && !var5.isEmpty())
             {
                 Block var6 = Block.blocksList[this.getBlockId(par1, par2, par3)];
+                // FCMOD: Change so that torches will stick to the appropriate blocks
+                /*
                 return var6 == null ? false : var6.blockMaterial.isOpaque() && var6.renderAsNormalBlock();
+                */
+                return ( var6 != null && isBlockNormalCube( par1, par2, par3 ) );
+                // END FCMOD                
             }
             else
             {
@@ -2506,7 +2635,12 @@
      */
     public void setAllowedSpawnTypes(boolean par1, boolean par2)
     {
+    	// FCMOD: Code change to remove peaceful difficulty.  If animals can spawn, then so can mobs
+    	/*
         this.spawnHostileMobs = par1;
+        */
+        this.spawnHostileMobs = par2;
+    	// END FCMOD
         this.spawnPeacefulMobs = par2;
     }
 
@@ -2515,7 +2649,15 @@
      */
     public void tick()
     {
+    	// FCMOD: Added
+    	UpdateActiveChunkMap();
+    	// END FCMOD
+    	
         this.updateWeather();
+        
+        // FCMOD: Added
+        ModSpecificTick();
+        // END FCMOD
     }
 
     /**
@@ -2537,6 +2679,8 @@
     /**
      * Updates all weather states.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     protected void updateWeather()
     {
         if (!this.provider.hasNoSky)
@@ -2632,6 +2776,8 @@
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * start precipitation in this world (2 ticks after command posted)
@@ -2643,6 +2789,8 @@
 
     protected void setActivePlayerChunksAndCheckLight()
     {
+    	// FCMOD: Changed with active chunk functionality replaced elsewhere
+    	/*
         this.activeChunkSet.clear();
         this.theProfiler.startSection("buildList");
         int var1;
@@ -2667,6 +2815,12 @@
         }
 
         this.theProfiler.endSection();
+        */
+        int var1;
+        EntityPlayer var2;
+        int var3;
+        int var4;    	
+    	// END FCMOD
 
         if (this.ambientTickCountdown > 0)
         {
@@ -2819,10 +2973,16 @@
         {
             if (par2 >= 0 && par2 < 256 && this.getSavedLightValue(EnumSkyBlock.Block, par1, par2, par3) < 10)
             {
+                // FCMOD: Code change
+                /*
                 int var6 = this.getBlockId(par1, par2 - 1, par3);
                 int var7 = this.getBlockId(par1, par2, par3);
 
                 if (var7 == 0 && Block.snow.canPlaceBlockAt(this, par1, par2, par3) && var6 != 0 && var6 != Block.ice.blockID && Block.blocksList[var6].blockMaterial.blocksMovement())
+                */
+                if ( FCBlockSnowCover.CanSnowCoverReplaceBlock( this, par1, par2, par3 ) && 
+                	Block.snow.canPlaceBlockAt( this, par1, par2, par3 ) )
+            	// END FCMOD
                 {
                     return true;
                 }
@@ -2851,10 +3011,10 @@
         else
         {
             int var5 = this.getBlockId(par1, par2, par3);
-            int var6 = par4EnumSkyBlock == EnumSkyBlock.Sky ? 0 : Block.lightValue[var5];
+            int var6 = par4EnumSkyBlock == EnumSkyBlock.Sky || var5 == 0 ? 0 : Block.getLightValueForBlock(this, par1, par2, par3, Block.blocksList[var5]);
             int var7 = Block.lightOpacity[var5];
 
-            if (var7 >= 15 && Block.lightValue[var5] > 0)
+            if (var7 >= 15 && Block.getLightValueForBlock(this, par1, par2, par3, Block.blocksList[var5]) > 0)
             {
                 var7 = 1;
             }
@@ -2913,8 +3073,8 @@
             int var13;
             int var14;
             int var15;
-            int var16;
             int var17;
+            int var16;
 
             if (var8 > var7)
             {
@@ -3053,10 +3213,18 @@
     public List getEntitiesWithinAABBExcludingEntity(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
         ArrayList var4 = new ArrayList();
+        // FCMOD: Change to increased size of box to be able to handle wind mills extending accross chunk boundaries
+        /*
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        */
+        int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
+        int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
+        int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
+        int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
+        // END FCMOD
 
         for (int var9 = var5; var9 <= var6; ++var9)
         {
@@ -3082,10 +3250,18 @@
 
     public List selectEntitiesWithinAABB(Class par1Class, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
+        // FCMOD: Increased size of box to be able to handle wind mills extending accross chunk boundaries
+    	/*
         int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        */
+        int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
+        int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
+        int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
+        int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
+    	// END FCMOD
         ArrayList var8 = new ArrayList();
 
         for (int var9 = var4; var9 <= var5; ++var9)
@@ -3146,6 +3322,8 @@
     /**
      * Counts how many entities of an entity class exist in the world. Args: entityClass
      */
+    // FCMOD: Code removed and replaced by custom function later
+    /*
     public int countEntities(Class par1Class)
     {
         int var2 = 0;
@@ -3162,6 +3340,8 @@
 
         return var2;
     }
+    */
+    // END FCMOD
 
     /**
      * adds entities to the loaded entities list, and loads thier skins.
@@ -3205,7 +3385,14 @@
         }
         else
         {
+            // FCMOD: Change
+    		/*
             if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable()))
+            */
+            if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable() ||
+            	var10 == FCBetterThanWolves.fcBlockDetectorLogic || var10 == FCBetterThanWolves.fcBlockDetectorGlowingLogic || 
+            	var10 == FCBetterThanWolves.fcBlockFireStoked ) )
+        	// END FCMOD        	
             {
                 var10 = null;
             }
@@ -3332,6 +3519,22 @@
     {
         if (this.isBlockNormalCube(par1, par2, par3))
         {
+        	// FCMOD: Code added so solid blocks can act as power sources
+            int iBlockID = getBlockId( par1, par2, par3 );
+            
+        	if ( Block.blocksList[iBlockID].canProvidePower() )
+        	{
+        		int iPowerInput = getBlockPowerInput(par1, par2, par3);
+        		int iPowerProvided = Block.blocksList[iBlockID].isProvidingWeakPower(this, par1, par2, par3, par4);
+        		
+        		if ( iPowerInput > iPowerProvided )
+        		{
+        			return iPowerInput;
+        		}
+        		
+        		return iPowerProvided;
+        	}
+        	// END FCMOD
             return this.getBlockPowerInput(par1, par2, par3);
         }
         else
@@ -3607,8 +3810,15 @@
         return (double)this.getRainStrength(1.0F) > 0.2D;
     }
 
+    /** 
+     * FCNOTE: Terribly named.  Was actually whether a specific block is currently being rained on
+     * Deprecated through sending message to avoid modifying vanilla classes that use it
+     * while still ensuring that it isn't actually called.
+     */
     public boolean canLightningStrikeAt(int par1, int par2, int par3)
     {
+    	// FCMOD: Changed
+    	/*    	 
         if (!this.isRaining())
         {
             return false;
@@ -3626,8 +3836,20 @@
             BiomeGenBase var4 = this.getBiomeGenForCoords(par1, par3);
             return var4.getEnableSnow() ? false : var4.canSpawnLightningBolt();
         }
+        */
+    	if ( !m_bCanLightningStrikeAtMessageSent )
+    	{
+	    	FCBetterThanWolves.DebugWarning( (new StringBuilder()).
+	    		append( "Deprecated method World.canLightningStrikeAt() called.  " ).
+	    		append( "Use IsRainingAtPos() or CanLightingStrikeAtPos() instead." ).toString() );
+	    	
+	    	m_bCanLightningStrikeAtMessageSent = true;
     }
 
+    	return IsRainingAtPos( par1, par2, par3 );
+    	// END FCMOD
+    }
+
     /**
      * Checks to see if the biome rainfall values for a given x,y,z coordinate set are extremely high
      */
@@ -3664,6 +3886,10 @@
         return this.mapStorage.getUniqueDataId(par1Str);
     }
 
+    /**
+     * FCNOTE: Sends an auxSFX to all players, regardless of distance to the effect.
+     * Good for stuff like long range wolf howls and thunder claps.  
+     */
     public void func_82739_e(int par1, int par2, int par3, int par4, int par5)
     {
         for (int var6 = 0; var6 < this.worldAccesses.size(); ++var6)
@@ -3841,4 +4067,1200 @@
     {
         return this.worldLogAgent;
     }
+
+    // FCMOD: Added New
+    private boolean m_bCanLightningStrikeAtMessageSent = false;
+    
+    private long m_lTimeOfLastSquidPossessionCapCount = -1;
+    private int m_iLastSquidPossessionCapCount = 0;
+    
+    public static final int m_iLoadedChunksUpdateRange = 32;
+
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
 }
+
+    public void ModSpecificTick()
+    {
+    }
+    
+    public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
+    {   
+        return false;
+    }
+    
+    /** 
+     * Wrapper function for clarity: while ticks are being processed they are not still scheduled,
+     * but are in a separate list for this tick.
+     */
+    public boolean IsUpdatePendingThisTickForBlock( int i, int j, int k, int iBlockID )
+    {   
+        return isBlockTickScheduled( i, j, k, iBlockID );
+    }
+    
+    public boolean setBlockAndMetadataWithNotify( int i, int j, int k, int iBlockID, int iMetadata )
+    {
+        return this.setBlock( i, j, k, iBlockID, iMetadata, 3 );
+    }
+
+    public boolean setBlockWithNotify( int i, int j, int k, int iBlockID )
+    {
+        return this.setBlock( i, j, k, iBlockID, 0, 3 );
+    }
+    
+    /**
+	 * Alias to avoid inconsistent naming between client and server
+     * Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
+    public boolean SetBlockMetadataWithNotify( int i, int j, int k, int iMetadata, int iNotifyBitField )
+    {
+    	// client
+        //return setBlockMetadataWithNotify( i, j, k, iMetadata, iNotifyBitField );
+    	// server
+        return setBlockMetadata( i, j, k, iMetadata, iNotifyBitField );
+    }
+    
+    public boolean setBlockMetadata( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 0 );
+    }
+
+    public boolean setBlockMetadataWithNotify( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 3 );
+    }
+    
+    public boolean setBlockMetadataWithClient( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 2 );
+    }
+    
+    public boolean setBlockMetadataWithNotifyNoClient( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 1 );
+    }
+    
+    public boolean setBlockAndMetadata( int i, int j, int k, int iBlockID, int iMetadata )
+    {
+        return this.setBlock( i, j, k, iBlockID, iMetadata, 2 );
+    }
+    
+    public boolean isBlockGettingPowered( int i, int j, int k )
+    {
+    	return getBlockPowerInput( i, j, k ) > 0;
+    }
+
+    
+    public MovingObjectPosition rayTraceBlocks_do_do( Vec3 startVec, Vec3 endVec, boolean bHitFluidSources, boolean bIgnoreNonMovementBlockingBlocks )
+    {
+    	// refactored version of vanilla function to try to optimize and correct errors
+    	
+        if ( !Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord) &&
+        	!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord) )
+        {
+        	Vec3 currentVec = getWorldVec3Pool().getVecFromPool( startVec.xCoord, startVec.yCoord, startVec.zCoord );
+        	
+        	double dTotalDeltaX = endVec.xCoord - startVec.xCoord;
+        	double dTotalDeltaY = endVec.yCoord - startVec.yCoord;
+        	double dTotalDeltaZ = endVec.zCoord - startVec.zCoord;
+        	
+            int iEndPosI = MathHelper.floor_double(endVec.xCoord);
+            int iEndPosJ = MathHelper.floor_double(endVec.yCoord);
+            int iEndPosK = MathHelper.floor_double(endVec.zCoord);
+            
+            int iCurrentPosI = MathHelper.floor_double(currentVec.xCoord);
+            int iCurrentPosJ = MathHelper.floor_double(currentVec.yCoord);
+            int iCurrentPosK = MathHelper.floor_double(currentVec.zCoord);
+            
+            double dProportionOfLengthToNextBlockBoundaryX;
+            double dProportionOfLengthToNextBlockBoundaryY;
+            double dProportionOfLengthToNextBlockBoundaryZ;
+            
+        	int iAxisFinishedCount = 0;
+        	
+        	int iIncrementI = -1;
+        	
+        	double dNextBlockBoundaryX = (double)iCurrentPosI;
+        	double dBlockBoundaryIncrementX = -1D; 
+        	
+        	if ( iEndPosI > iCurrentPosI )
+        	{
+        		iIncrementI = 1;
+        		
+            	dNextBlockBoundaryX += 1D;
+            	dBlockBoundaryIncrementX = 1D;                	
+        	}
+        	else if ( iEndPosI == iCurrentPosI )
+        	{
+        		iIncrementI = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+        	int iIncrementJ = -1;
+        	
+        	double dNextBlockBoundaryY = (double)iCurrentPosJ;
+        	double dBlockBoundaryIncrementY = -1D;
+        	
+        	if ( iEndPosJ > iCurrentPosJ )
+        	{
+        		iIncrementJ = 1;
+        		
+            	dNextBlockBoundaryY += 1D;
+            	dBlockBoundaryIncrementY = 1D; 
+        	}
+        	else if ( iEndPosJ == iCurrentPosJ )
+        	{
+        		iIncrementJ = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+        	int iIncrementK = -1;
+        	
+        	double dNextBlockBoundaryZ = (double)iCurrentPosK;
+        	double dBlockBoundaryIncrementZ = -1D;
+        	
+        	if ( iEndPosK > iCurrentPosK )
+        	{
+        		iIncrementK = 1;
+        		
+            	dNextBlockBoundaryZ += 1D;
+            	dBlockBoundaryIncrementZ = 1D; 
+        	}
+        	else if ( iEndPosK == iCurrentPosK )
+        	{
+        		iIncrementK = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+            int iTempCount = 200;
+
+            while ( iTempCount-- >= 0 )
+            {                    
+                int iCurrentBlockID = getBlockId( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
+                
+                if ( iCurrentBlockID > 0 )
+                {
+                    Block currentBlock = Block.blocksList[iCurrentBlockID];
+
+	                if ( !bIgnoreNonMovementBlockingBlocks || currentBlock.getCollisionBoundingBoxFromPool(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK ) != null )
+	                {
+	                    int iFirstBlockMetadata = getBlockMetadata( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
+	                    
+	                	if (  currentBlock.canCollideCheck( iFirstBlockMetadata, bHitFluidSources ) )
+	                	{
+		                    MovingObjectPosition collisionPosition = currentBlock.collisionRayTrace(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK, currentVec, endVec);
+		
+		                    if ( collisionPosition != null )
+		                    {
+		                        return collisionPosition;
+		                    }
+	                	}
+	                }
+                }
+
+                if ( iAxisFinishedCount >= 3 )
+                {
+                    return null;
+                }
+                
+                if ( iIncrementI != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryX = ( dNextBlockBoundaryX - currentVec.xCoord ) / dTotalDeltaX;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryX = 999.0D;
+                }
+                
+                
+                if ( iIncrementJ != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryY = ( dNextBlockBoundaryY - currentVec.yCoord ) / dTotalDeltaY;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryY = 999.0D;
+                }
+                
+                
+                if ( iIncrementK != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryZ = ( dNextBlockBoundaryZ - currentVec.zCoord ) / dTotalDeltaZ;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryZ = 999.0D;
+                }
+                
+                if ( dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryY && 
+                	dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryZ )
+                {
+                    currentVec.xCoord = dNextBlockBoundaryX;
+                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryX;
+                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryX;
+                    
+                    iCurrentPosI += iIncrementI;
+                	dNextBlockBoundaryX += dBlockBoundaryIncrementX;
+                    
+                    if ( iCurrentPosI == iEndPosI )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementI = 0;
+                    }
+                    
+                }
+                else if (dProportionOfLengthToNextBlockBoundaryY < dProportionOfLengthToNextBlockBoundaryZ)
+                {
+                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryY;
+                    currentVec.yCoord = dNextBlockBoundaryY;
+                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryY;
+                    
+                    iCurrentPosJ += iIncrementJ;
+                	dNextBlockBoundaryY += dBlockBoundaryIncrementY;
+                    
+                    if ( iCurrentPosJ == iEndPosJ )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementJ = 0;
+                    }                        
+                }
+                else
+                {
+                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryZ;
+                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryZ;
+                    currentVec.zCoord = dNextBlockBoundaryZ;
+                    
+                    iCurrentPosK += iIncrementK;
+                	dNextBlockBoundaryZ += dBlockBoundaryIncrementZ;
+                	
+                    if ( iCurrentPosK == iEndPosK )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementK = 0;
+                    }                        
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    public MovingObjectPosition MouseOverRayTrace( Vec3 startVec, Vec3 endVec )
+    {
+        if (!Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord))
+        {
+            if (!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord))
+            {
+                int iEndI = MathHelper.floor_double(endVec.xCoord);
+                int iEndJ = MathHelper.floor_double(endVec.yCoord);
+                int iEndK = MathHelper.floor_double(endVec.zCoord);
+                int iTempI = MathHelper.floor_double(startVec.xCoord);
+                int iTempJ = MathHelper.floor_double(startVec.yCoord);
+                int iTempK = MathHelper.floor_double(startVec.zCoord);
+                
+                MovingObjectPosition tempCollisionPos = 
+                	CheckLocationForMouseOverRayTrace( iTempI, iTempJ, iTempK,
+            		startVec, endVec );
+                
+                if ( tempCollisionPos != null )
+                {
+                	return tempCollisionPos;
+                }                    
+
+                int iTempCount = 200;
+
+                while (iTempCount-- >= 0)
+                {
+                    if (Double.isNaN(startVec.xCoord) || Double.isNaN(startVec.yCoord) || Double.isNaN(startVec.zCoord))
+                    {
+                        return null;
+                    }
+
+                    if (iTempI == iEndI && iTempJ == iEndJ && iTempK == iEndK)
+                    {
+                        return null;
+                    }
+
+                    boolean var39 = true;
+                    boolean var40 = true;
+                    boolean var41 = true;
+                    double var15 = 999.0D;
+                    double var17 = 999.0D;
+                    double var19 = 999.0D;
+
+                    if (iEndI > iTempI)
+                    {
+                        var15 = (double)iTempI + 1.0D;
+                    }
+                    else if (iEndI < iTempI)
+                    {
+                        var15 = (double)iTempI + 0.0D;
+                    }
+                    else
+                    {
+                        var39 = false;
+                    }
+
+                    if (iEndJ > iTempJ)
+                    {
+                        var17 = (double)iTempJ + 1.0D;
+                    }
+                    else if (iEndJ < iTempJ)
+                    {
+                        var17 = (double)iTempJ + 0.0D;
+                    }
+                    else
+                    {
+                        var40 = false;
+                    }
+
+                    if (iEndK > iTempK)
+                    {
+                        var19 = (double)iTempK + 1.0D;
+                    }
+                    else if (iEndK < iTempK)
+                    {
+                        var19 = (double)iTempK + 0.0D;
+                    }
+                    else
+                    {
+                        var41 = false;
+                    }
+
+                    double var21 = 999.0D;
+                    double var23 = 999.0D;
+                    double var25 = 999.0D;
+                    double var27 = endVec.xCoord - startVec.xCoord;
+                    double var29 = endVec.yCoord - startVec.yCoord;
+                    double var31 = endVec.zCoord - startVec.zCoord;
+
+                    if (var39)
+                    {
+                        var21 = (var15 - startVec.xCoord) / var27;
+                    }
+
+                    if (var40)
+                    {
+                        var23 = (var17 - startVec.yCoord) / var29;
+                    }
+
+                    if (var41)
+                    {
+                        var25 = (var19 - startVec.zCoord) / var31;
+                    }
+
+                    boolean var33 = false;
+                    byte var42;
+
+                    if (var21 < var23 && var21 < var25)
+                    {
+                        if (iEndI > iTempI)
+                        {
+                            var42 = 4;
+                        }
+                        else
+                        {
+                            var42 = 5;
+                        }
+
+                        startVec.xCoord = var15;
+                        startVec.yCoord += var29 * var21;
+                        startVec.zCoord += var31 * var21;
+                    }
+                    else if (var23 < var25)
+                    {
+                        if (iEndJ > iTempJ)
+                        {
+                            var42 = 0;
+                        }
+                        else
+                        {
+                            var42 = 1;
+                        }
+
+                        startVec.xCoord += var27 * var23;
+                        startVec.yCoord = var17;
+                        startVec.zCoord += var31 * var23;
+                    }
+                    else
+                    {
+                        if (iEndK > iTempK)
+                        {
+                            var42 = 2;
+                        }
+                        else
+                        {
+                            var42 = 3;
+                        }
+
+                        startVec.xCoord += var27 * var25;
+                        startVec.yCoord += var29 * var25;
+                        startVec.zCoord = var19;
+                    }
+
+                    Vec3 var34 = this.getWorldVec3Pool().getVecFromPool(startVec.xCoord, startVec.yCoord, startVec.zCoord);
+                    iTempI = (int)(var34.xCoord = (double)MathHelper.floor_double(startVec.xCoord));
+
+                    if (var42 == 5)
+                    {
+                        --iTempI;
+                        ++var34.xCoord;
+                    }
+
+                    iTempJ = (int)(var34.yCoord = (double)MathHelper.floor_double(startVec.yCoord));
+
+                    if (var42 == 1)
+                    {
+                        --iTempJ;
+                        ++var34.yCoord;
+                    }
+
+                    iTempK = (int)(var34.zCoord = (double)MathHelper.floor_double(startVec.zCoord));
+
+                    if (var42 == 3)
+                    {
+                        --iTempK;
+                        ++var34.zCoord;
+                    }
+
+                    tempCollisionPos = CheckLocationForMouseOverRayTrace( 
+                    	iTempI, iTempJ, iTempK, startVec, endVec );
+                    
+                    if ( tempCollisionPos != null )
+                    {
+                    	return tempCollisionPos;
+                    }                    
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    public MovingObjectPosition CheckLocationForMouseOverRayTrace( int i, 
+    	int j, int k, Vec3 startVec, Vec3 endVec )
+    {
+    	MovingObjectPosition closestPos = null;
+    	double dClosestDistSq = 0D;
+    	
+    	for ( int iTempJ = j - 1; iTempJ <= j + 1; iTempJ++ )
+    	{
+            int iTempBlockID = getBlockId( i, iTempJ, k );
+
+            if ( iTempBlockID > 0 )
+            {
+                int iTempMetadata = getBlockMetadata( i, iTempJ, k );                    
+                Block tempBlock = Block.blocksList[iTempBlockID];
+
+                if ( tempBlock.canCollideCheck( iTempMetadata, false ) )
+                {
+                    MovingObjectPosition tempCollisionPos = tempBlock.MouseOverRayTrace( 
+                    	this, i, iTempJ, k, startVec, endVec);
+                    
+                    if ( tempCollisionPos != null )
+                    {
+                    	double tempDistSq = tempCollisionPos.hitVec.squareDistanceTo( startVec );
+                    	
+                    	if ( closestPos == null || tempDistSq < dClosestDistSq )
+                    	{
+                    		dClosestDistSq = tempDistSq;
+                    		
+                    		closestPos = tempCollisionPos;
+                    	} 
+                    }
+                }
+            }
+    	}
+    	
+    	return closestPos;
+    }
+    
+    public void playSound(double par1, double par3, double par5, String par7Str, float par8, float par9 ) 
+    {
+        playSound( par1, par3, par5, par7Str, par8, par9, false );    	
+    }
+    
+    public Entity GetClosestEntityMatchingCriteriaWithinRange( double dSourcePosX, double dSourcePosY, double dSourcePosZ, double dRange, FCClosestEntitySelectionCriteria criteria )
+    {
+		int iChunkEntityListMinVerticalIndex = MathHelper.floor_double( ( dSourcePosY - dRange ) / 16.0D );
+		int iChunkEntityListMaxVerticalIndex = MathHelper.floor_double( ( dSourcePosY + dRange ) / 16.0D ) + 1;
+		
+		if ( iChunkEntityListMinVerticalIndex < 0 )
+		{
+			iChunkEntityListMinVerticalIndex = 0;
+			iChunkEntityListMaxVerticalIndex = Math.max( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
+		}
+		
+		if ( iChunkEntityListMaxVerticalIndex > 15 )
+		{
+			iChunkEntityListMaxVerticalIndex = 15;
+			iChunkEntityListMinVerticalIndex = Math.min( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
+		}
+		
+    	FCClosestEntityInfo closestEntityInfo = 
+    		new FCClosestEntityInfo( dSourcePosX, dSourcePosY, dSourcePosZ, dRange * dRange, null, criteria, iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );
+    	
+        int iMinChunkX = MathHelper.floor_double( ( dSourcePosX - dRange ) / 16D  );
+        int iMaxChunkX = MathHelper.floor_double( ( dSourcePosX + dRange ) / 16D  ) + 1;
+        int iMinChunkZ = MathHelper.floor_double( ( dSourcePosZ - dRange ) / 16D  );
+        int iMaxChunkZ = MathHelper.floor_double( ( dSourcePosZ + dRange ) / 16D  ) + 1;
+        
+        for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
+        {
+            for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
+            {
+                if ( chunkExists( iTempChunkX, iTempChunkZ ) )
+                {
+                    getChunkFromChunkCoords( iTempChunkX, iTempChunkZ ).GetClosestEntityMatchingCriteriaWithinRangeSq( closestEntityInfo );
+                }
+            }
+        }
+
+        return closestEntityInfo.m_closestEntity;
+    }
+    
+    public int CountEntitiesThatApplyToSpawnCap( Class classToCount )
+    {
+    	// replacement for CountEntities that is slightly optimized
+    	
+        int iEntityCount = 0;
+
+        for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
+        {
+            Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
+
+            if ( tempEntity.DoesEntityApplyToSpawnCap() && classToCount.isAssignableFrom( tempEntity.getClass() ) )
+            {
+            	// verify that the entity is actually active
+            	
+            	++iEntityCount;
+            }
+        }
+
+        return iEntityCount;
+    }
+    
+    public int GetNumEntitiesThatApplyToSquidPossessionCap()
+    {
+    	long lCurrentTime = getWorldTime();
+    	
+    	if ( lCurrentTime != m_lTimeOfLastSquidPossessionCapCount )
+    	{
+    		m_iLastSquidPossessionCapCount = 0;
+    		m_lTimeOfLastSquidPossessionCapCount = lCurrentTime;
+    		
+            for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
+            {
+                Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
+
+                if ( tempEntity.DoesEntityApplyToSquidPossessionCap() )
+                {
+                	m_iLastSquidPossessionCapCount++;
+                }
+            }            
+    	}
+    	
+		return m_iLastSquidPossessionCapCount;
+    }
+
+	public void NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( EntityPlayer player, Block block, int i, int j, int k )
+	{
+		if ( !isRemote && block.startlesAnimalsWhenPlaced(this, i, j, k) && !player.capabilities.isCreativeMode )
+		{
+			double dXBlock = (double)i + 0.5D;
+			double dYBlock = (double)j + 0.5D;
+			double dZBlock = (double)k + 0.5D;
+			
+			AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB( dXBlock - 8D, dYBlock - 4D, dZBlock - 8D, dXBlock + 8D, dYBlock + 4D, dZBlock + 8D );
+			
+	        List animalList = this.getEntitiesWithinAABB( EntityAnimal.class, targetBox );
+	        
+	        Iterator animalIterator = animalList.iterator();
+	
+	        while ( animalIterator.hasNext())
+	        {
+	    		EntityAnimal tempAnimal = (EntityAnimal)animalIterator.next();
+	    		
+		        if ( !tempAnimal.isLivingDead )
+		        {
+		        	tempAnimal.OnNearbyPlayerBlockAddOrRemove( player ); 
+		        }		        
+	        }
+		}
+	}
+	
+    public int GetBlockNaturalLightValue( int i, int j, int k )
+    {
+        return GetBlockNaturalLightValue_do( i, j, k, true, skylightSubtracted );
+    }
+
+    public int GetBlockNaturalLightValueMaximum( int i, int j, int k )
+    {
+        return GetBlockNaturalLightValue_do( i, j, k, true, 0 );
+    }
+
+    public float GetNaturalLightBrightness( int i, int j, int k )
+    {
+        return provider.lightBrightnessTable[GetBlockNaturalLightValue(i, j, k)];
+    }
+
+    private int GetBlockNaturalLightValue_do( int i, int j, int k, boolean bConsiderNeighbors, int iSkylightToSubtract )
+    {
+    	// Version of getBlockLightValue_do modified to only consider natural light    	
+        if ( i >= -30000000 && k >= -30000000 && i < 30000000 && k < 30000000 )
+        {
+            if ( bConsiderNeighbors )
+            {
+                int iBlockID = getBlockId( i, j, k );
+
+                if ( Block.useNeighborBrightness[iBlockID] )
+                {
+                    int iNeighbor1 = GetBlockNaturalLightValue_do( i, j + 1, k, false, iSkylightToSubtract );
+                    int iNeighbor2 = GetBlockNaturalLightValue_do( i + 1, j, k, false, iSkylightToSubtract );
+                    int iNeighbor3 = GetBlockNaturalLightValue_do( i - 1, j, k, false, iSkylightToSubtract );
+                    int iNeighbor4 = GetBlockNaturalLightValue_do( i, j, k + 1, false, iSkylightToSubtract );
+                    int iNeighbor5 = GetBlockNaturalLightValue_do( i, j, k - 1, false, iSkylightToSubtract );
+
+                    if (iNeighbor2 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor2;
+                    }
+
+                    if (iNeighbor3 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor3;
+                    }
+
+                    if (iNeighbor4 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor4;
+                    }
+
+                    if (iNeighbor5 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor5;
+                    }
+
+                    return iNeighbor1;
+                }
+            }
+
+            if (j < 0)
+            {
+                return 0;
+            }
+            else
+            {
+                if (j >= 256)
+                {
+                    j = 255;
+                }
+
+                Chunk chunk = this.getChunkFromChunkCoords(i >> 4, k >> 4);
+                
+                i &= 15;
+                k &= 15;
+                
+                return chunk.GetBlockNaturalLightValue( i, j, k, iSkylightToSubtract );
+            }
+        }
+        else
+        {
+            return 15;
+        }
+    }
+    
+    public int getBlockLightValueNoSky(int x, int y, int z) {
+    	return getBlockLightValueNoSky_do(x, y, z, true);
+    }
+
+    private int getBlockLightValueNoSky_do(int x, int y, int z, boolean considerNeighbors) {
+        if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000) {
+            if (considerNeighbors) {
+                int blockID = this.getBlockId(x, y, z);
+
+                if (Block.useNeighborBrightness[blockID]) {
+                    int neighbor1 = this.getBlockLightValueNoSky_do(x, y + 1, z, false);
+                    int neighbor2 = this.getBlockLightValueNoSky_do(x + 1, y, z, false);
+                    int neighbor3 = this.getBlockLightValueNoSky_do(x - 1, y, z, false);
+                    int neighbor4 = this.getBlockLightValueNoSky_do(x, y, z + 1, false);
+                    int neighbor5 = this.getBlockLightValueNoSky_do(x, y, z - 1, false);
+
+                    if (neighbor2 > neighbor1) {
+                        neighbor1 = neighbor2;
+                    }
+
+                    if (neighbor3 > neighbor1) {
+                        neighbor1 = neighbor3;
+                    }
+
+                    if (neighbor4 > neighbor1) {
+                        neighbor1 = neighbor4;
+                    }
+
+                    if (neighbor5 > neighbor1) {
+                        neighbor1 = neighbor5;
+                    }
+
+                    return neighbor1;
+                }
+            }
+
+            if (y < 0) {
+                return 0;
+            }
+            else {
+                if (y >= 256) {
+                    y = 255;
+                }
+
+                Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+
+                x &= 15;
+                z &= 15;
+
+                return chunk.getBlockLightValueNoSky(x, y, z);
+            }
+        }
+        else {
+            return 15;
+        }
+    }
+    
+    // @Override // client only override
+    public boolean doesBlockHaveSolidTopSurface( int i, int j, int k )
+    {
+        Block block = Block.blocksList[this.getBlockId(i, j, k)];
+        
+        return block != null && block.HasLargeCenterHardPointToFacing( this, i, j, k, 1 );
+    }
+    
+    //------------- Hardcore of Darkness Handling ------------//    
+    
+    static private double[] m_dMoonBrightnessByPhase = new double[] { 1.25D, 0.875, 0.75D, 0.5D, 0D, 0.5D, 0.75D, 1.25D }; 
+	
+    public float ComputeOverworldSunBrightnessWithMoonPhases()
+    {
+		// slight modified version of regular moon phase equation so that phase switches over at noon to avoid sudden jump in lighting at dawn
+		long lOffsetWorldTime = worldInfo.getWorldTime() - 12000L;
+		
+		if ( lOffsetWorldTime < 0L )
+		{
+			lOffsetWorldTime = 0L;
+		}
+		
+		int iMoonPhase = (int)( ( lOffsetWorldTime / 24000L ) % 8L );		
+		double dMoonBrightness = m_dMoonBrightnessByPhase[iMoonPhase];
+		
+        float fCelestialAngle = getCelestialAngle( 1F );
+        
+        // slight modifcation from vanilla calc so that gloom starts to set in on moonless nights the moment the sun drops beneath the horizon, and is removed at the moment of rise
+        //float fSunInvertedBrightness = 1.0F - (MathHelper.cos(fCelestialAngle * (float)Math.PI * 2.0F) * 2.0F + 0.2F);
+        float fSunInvertedBrightness = 1.0F - ( ( MathHelper.cos( fCelestialAngle * (float)Math.PI * 2.0F ) * 2.0F ) + 0.25F );
+
+        if ( fSunInvertedBrightness < 0.0F)
+        {
+        	fSunInvertedBrightness = 0.0F;
+        }
+        else if ( fSunInvertedBrightness > 1.0F)
+        {
+        	fSunInvertedBrightness = 1.0F;
+        }
+
+        double dSunBrightness = 1.0D - fSunInvertedBrightness;
+        
+        double dRainBrightnessModifier = ( 1.0D - (double)( getRainStrength( 1F ) * 5.0F ) / 16.0D );
+        double dStormBrightnessModifier = ( 1.0D - (double)( getWeightedThunderStrength( 1F ) * 5.0F ) / 16.0D );
+        
+        dSunBrightness = dSunBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
+
+        double dMinBrightness = 0.2D;
+        
+        dMinBrightness *= dMoonBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
+        
+        // clamp at a value that causes the world to descend into gloom on a new moon during a storm
+        if ( dMinBrightness < 0.05D )
+        {
+        	dMinBrightness = 0D;
+        }            
+    	
+        return (float)( dSunBrightness * ( 1D - dMinBrightness ) + dMinBrightness );
+    }
+    
+    public boolean IsTheEndNigh()
+    {
+    	return false;
+    }
+    
+    //------------- Magnetic Point Handling ------------//
+    
+    protected FCMagneticPointList m_MagneticPointList = new FCMagneticPointList();
+    
+    public FCMagneticPointList GetMagneticPointList()
+    {
+    	return m_MagneticPointList;
+    }
+    
+    //------------- Ender Chest Handling ------------//
+    
+    protected InventoryEnderChest m_localEnderChestInventory = new InventoryEnderChest();
+    protected InventoryEnderChest m_localLowPowerEnderChestInventory = new InventoryEnderChest();
+    
+    public InventoryEnderChest GetLocalEnderChestInventory()
+    {
+    	return m_localEnderChestInventory;
+    }
+    
+    public InventoryEnderChest GetLocalLowPowerEnderChestInventory()
+    {
+    	return m_localLowPowerEnderChestInventory;
+    }
+    
+    //------------- Looting Beacon Handling ------------//
+    
+    protected FCBeaconEffectLocationList m_LootingBeaconLocationList = new FCBeaconEffectLocationList();
+    
+    public FCBeaconEffectLocationList GetLootingBeaconLocationList()
+    {
+    	return m_LootingBeaconLocationList;
+    }
+    
+    public int GetAmbientLootingEffectAtLocation( int iLocI, int iLocJ, int iLocK )
+    {
+    	return m_LootingBeaconLocationList.GetMostPowerfulBeaconEffectForLocation( iLocI, iLocK );
+    }
+    
+    //------------- Spawn Location Handling ------------//
+    
+    protected FCSpawnLocationList m_SpawnLocationList = new FCSpawnLocationList();
+    
+    public FCSpawnLocationList GetSpawnLocationList()
+    {
+    	return m_SpawnLocationList;
+    }    
+    
+    //------------- Explosion Handling ------------//
+    
+    /**
+     * Copy of newExplosion() that suppresses the audio/visual effects
+     */
+    public Explosion NewExplosionNoFX( Entity par1Entity, double dPosX, double dPosY, double dPosZ, 
+    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
+    {
+        Explosion explosion = new Explosion( this, par1Entity, dPosX, dPosY, dPosZ, fExplosionSize );
+        
+        explosion.isFlaming = bCreatesFlames;
+        explosion.isSmoking = bDestroysBlocks;
+        explosion.m_bSuppressFX = true;
+        
+        explosion.doExplosionA();
+        explosion.doExplosionB( false ); // false tells individual block destruction effects not to play
+        
+        return explosion;
+    }
+    
+    //------------- "View Distance" / Chunk Update Handling ------------//
+    
+    /** 
+     * The "view distance" is actually the range at which chunks are loaded, specified as 
+     * a vanilla server parameter (default is 10 chunks). 
+     */
+    public int GetClampedViewDistanceInChunks()
+    {
+    	return 10;
+    }
+    
+    public int GetMobSpawnRangeInChunks()
+    {
+    	return GetClampedViewDistanceInChunks() - 2;
+    }
+    
+    /** 
+     * "Active" chunks handle stuff like random block updates (grass growing, etc.)
+     * and precipitation
+     */
+    public int GetActiveChunkRangeInChunks()
+    {
+    	int iRange = GetClampedViewDistanceInChunks() - 3;
+    	
+    	if ( iRange < 1 )
+    	{
+    		iRange = 1;
+    	}
+    	
+    	return iRange;
+    }
+    
+    protected void UpdateActiveChunkMap()
+    {
+    	ClearActiveChunkMap();
+    	
+        for ( int iTempIndex = 0; iTempIndex < playerEntities.size(); ++iTempIndex )
+        {
+            EntityPlayer tempPlayer = (EntityPlayer)playerEntities.get( iTempIndex );
+            
+            AddEntityToActiveChunkMap( tempPlayer );
+        }
+    }
+    
+    protected void AddEntityToActiveChunkMap( Entity entity )
+    {
+        int iChunkX = MathHelper.floor_double( entity.posX / 16D );
+        int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
+        
+        AddAreaAroundChunkToActiveChunkMap( iChunkX, iChunkZ );
+    }
+    
+    protected void AddAreaAroundChunkToActiveChunkMap( int iChunkX, int iChunkZ )
+    {
+        int iActiveRange = GetActiveChunkRangeInChunks();
+        
+        for ( int iTempChunkX = iChunkX - iActiveRange; 
+        	iTempChunkX <= iChunkX + iActiveRange; iTempChunkX++ )
+        {
+            for ( int iTempChunkZ = iChunkZ - iActiveRange; 
+            	iTempChunkZ <= iChunkZ + iActiveRange; iTempChunkZ++ )
+            {
+            	AddToActiveChunkMap( iTempChunkX, iTempChunkZ );
+            }
+        }
+    }
+    
+    protected void ClearActiveChunkMap()
+    {
+        Iterator<ChunkCoordIntPair> tempIterator = m_activeChunksCoordsList.iterator();
+
+        while ( tempIterator.hasNext() )
+        {
+        	ChunkCoordIntPair coords = tempIterator.next();
+            Long lTempKey = ChunkCoordIntPair.chunkXZ2Int( coords.chunkXPos, coords.chunkZPos );
+            
+            tempIterator.remove();
+            m_activeChunksCoordsMap.remove( lTempKey ); 
+        }
+    }
+    
+    protected void AddToActiveChunkMap( int iChunkX, int iChunkZ )
+    {
+        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
+        
+        if ( !m_activeChunksCoordsMap.containsItem( lCoordKey ) )
+        {
+	    	ChunkCoordIntPair coords = new ChunkCoordIntPair( iChunkX, iChunkZ );
+	    	
+	        m_activeChunksCoordsList.add( coords );
+	        
+	        m_activeChunksCoordsMap.add( lCoordKey, coords );
+        }
+    }
+    
+    public boolean IsChunkActive( int iChunkX, int iChunkZ )
+    {
+        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
+        
+        return m_activeChunksCoordsMap.containsItem( lCoordKey );
+    }
+    
+    public boolean IsBlockPosActive( int i, int j, int k )
+    {    	
+        if ( j >= 0 && j < 256 )
+        {
+        	return IsChunkActive( i >> 4, k >> 4 );
+        }
+        
+        return false;
+    }
+    
+    public LinkedList<ChunkCoordIntPair> GetActiveChunksCoordsList()
+    {
+    	return m_activeChunksCoordsList;
+    }
+    
+    //------------- Weather Handling ------------//
+    
+    protected void updateWeather()
+    {
+    	// replacement for vanilla code to clean up and ensure that storms only start after it's been raining awhile
+    	
+        if ( !provider.hasNoSky )
+        {
+            int iRainTime = worldInfo.getRainTime();
+
+            if ( iRainTime <= 0 )
+            {
+                if ( worldInfo.isRaining() )
+                {
+                    worldInfo.setRainTime( rand.nextInt( 12000 ) + 12000 );
+                }
+                else
+                {
+                    worldInfo.setRainTime( rand.nextInt( 168000 ) + 12000 );
+                }
+            }
+            else
+            {
+                --iRainTime;
+                
+                worldInfo.setRainTime( iRainTime );
+
+                if ( iRainTime <= 0 )
+                {
+                    worldInfo.setRaining( !worldInfo.isRaining() );
+                    
+                    if ( worldInfo.isRaining() && !worldInfo.isThundering() )
+                    {
+                    	// min of a minute when rain starts before storm.  About a 1/5 chance of rain turning into a storm at some point in its duration
+                    	
+                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
+                    }
+                }
+            }
+
+            if ( worldInfo.isRaining() )
+            {
+	            int iThunderTime = worldInfo.getThunderTime();
+	
+	            if ( iThunderTime <= 0 )
+	            {
+	                if ( worldInfo.isThundering() )
+	                {
+	                    worldInfo.setThunderTime( rand.nextInt( 12000 ) + 3600 );
+	                }
+	                else
+	                {
+                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
+	                }
+	            }
+	            else
+	            {
+	                --iThunderTime;
+	                
+	                worldInfo.setThunderTime( iThunderTime );
+	
+	                if ( iThunderTime <= 0 )
+	                {
+	                    worldInfo.setThundering( !worldInfo.isThundering() );
+	                }
+	            }
+            }
+            else if ( worldInfo.isThundering() )
+        	{
+        		worldInfo.setThundering( false );
+        	}
+
+            // update the rain and thunder strength counters
+            
+            prevRainingStrength = rainingStrength;
+
+            if ( worldInfo.isRaining() )
+            {
+                rainingStrength = rainingStrength + 0.01F;
+                
+                if ( rainingStrength > 1F )
+                {
+                    rainingStrength = 1F;
+                }
+            }
+            else
+            {
+                rainingStrength = rainingStrength - 0.01F;
+                
+                if ( rainingStrength < 0F )
+                {
+                    rainingStrength = 0F;
+                }
+            }
+
+            prevThunderingStrength = thunderingStrength;
+
+            if ( worldInfo.isThundering() )
+            {
+                thunderingStrength = thunderingStrength + 0.01F;
+                
+                if ( thunderingStrength > 1F )
+                {
+                    thunderingStrength = 1F;
+                }
+            }
+            else
+            {
+                thunderingStrength = thunderingStrength - 0.01F;
+                
+                if ( thunderingStrength < 0F )
+                {
+                    thunderingStrength = 0F;
+                }
+            }
+        }
+    }
+    
+    public boolean IsRainingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsSnowingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsPrecipitatingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow() || biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsPrecipitatingAtPos( int i, int k )
+    {
+        if ( isRaining() )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow() || biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean CanLightningStrikeAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.CanLightningStrikeInBiome();
+        }
+        
+        return false;
+    }
+    // END FCMOD
+}
