--- /dev/null
+++ b/minecraft_server/net/minecraft/src/FCAddOnFinder.java
@@ -0,0 +1,157 @@
+package net.minecraft.src;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
+
+public class FCAddOnFinder {
+	private static boolean debug = false;
+	private static List<String> blacklist = Arrays.asList(new String[] { "net.minecraft.src.", "net.minecraft.client.",
+			"net.minecraft.server.", "com.prupe.mcpatcher.", "argo.", "org.bouncycastle." });
+
+	public static String[] getClasses(final ClassLoader classLoader) throws IOException {
+		return getClasses(classLoader, "");
+	}
+
+	public static String[] getClasses(final ClassLoader classLoader, String packageName) throws IOException {
+		assert classLoader != null;
+		if (debug) {
+			FCAddOnHandler.LogMessage("Class Loader class is " + classLoader.getClass().getName() + "\n"
+					+ "Package name is " + classLoader.getClass().getName());
+		}
+		Enumeration<URL> resources;
+		final String packagePath = packageName.replace('.', '/');
+		final List<String> classes = new ArrayList<String>();
+		if (classLoader instanceof URLClassLoader) {
+			URLClassLoader urlClassLoader = (URLClassLoader) classLoader;
+			resources = Collections.enumeration(Arrays.asList(urlClassLoader.getURLs()));
+		} else {
+			resources = classLoader.getResources(packagePath);
+		}
+		while (resources.hasMoreElements()) {
+			final URL resource = resources.nextElement();
+			final String proto = resource.getProtocol();
+			if (debug) {
+				FCAddOnHandler.LogMessage("RESOURCE: " + resource.getPath() + "\n" + "PROTO: " + proto);
+			}
+			if ("file".equals(proto)) {
+				classes.addAll(findFileClasses(new File(resource.getFile()), packageName));
+			} else if ("jar".equals(proto)) {
+				classes.addAll(findJarClasses(resource));
+			} else {
+				FCAddOnHandler.LogWarning("Protocol " + proto + " not supported");
+				continue;
+			}
+		}
+		return classes.toArray(new String[classes.size()]);
+	}
+
+	private static List<String> findJarClasses(URL packageResource) {
+		final List<String> classes = new ArrayList<String>();
+		try {
+			if (debug) {
+				FCAddOnHandler.LogMessage("Jar URL Path is " + packageResource.getPath());
+			}
+			final URL fileUrl = new URL(packageResource.getPath());
+			final String proto = fileUrl.getProtocol();
+			if ("file".equals(proto)) {
+				final String filePath = fileUrl.getPath().substring(1); // skip leading /
+				int jarTagPos = filePath.indexOf(".jar!/");
+				if (jarTagPos < 0)
+					jarTagPos = filePath.indexOf(".zip!/");
+				if (jarTagPos < 0) {
+					FCAddOnHandler.LogWarning("Non-conformant jar file reference " + filePath + " !");
+				} else {
+					final String packagePath = filePath.substring(jarTagPos + 6);
+					final String jarFilename = filePath.substring(0, jarTagPos + 4);
+					if (debug) {
+						FCAddOnHandler.LogMessage("Package " + packagePath);
+						FCAddOnHandler.LogMessage("Jar file " + jarFilename);
+					}
+					final String packagePrefix = packagePath.length() == 0 ? "" : packagePath + '/';
+					try {
+						final JarInputStream jarFile = new JarInputStream(new FileInputStream(jarFilename));
+						JarEntry jarEntry;
+
+						jarLoop: while (true) {
+							jarEntry = jarFile.getNextJarEntry();
+							if (jarEntry == null) {
+								break;
+							}
+							final String classPath = jarEntry.getName();
+
+							if (classPath.startsWith(packagePrefix) && classPath.endsWith(".class")) {
+								final String className = classPath.substring(0, classPath.length() - 6).replace('/',
+										'.');
+
+								if (className.indexOf(".") < 0)
+									continue jarLoop;
+
+								for (String prefix : blacklist) {
+									if (className.startsWith(prefix))
+										continue jarLoop;
+								}
+
+								if (debug) {
+									FCAddOnHandler.LogMessage("Found entry " + jarEntry.getName());
+								}
+
+								classes.add(className);
+							}
+						}
+						jarFile.close();
+					} catch (final Exception e) {
+						e.printStackTrace();
+					}
+				}
+			} else {
+				FCAddOnHandler.LogWarning("Nested protocol " + proto + " not supprted!");
+			}
+		} catch (final MalformedURLException e) {
+			e.printStackTrace();
+		}
+		return classes;
+	}
+
+	private static List<String> findFileClasses(File directory, String packageName) {
+		final List<String> classes = new ArrayList<String>();
+		if (!directory.exists()) {
+			FCAddOnHandler.LogWarning("Directory " + directory.getAbsolutePath() + " does not exist.");
+			return classes;
+		}
+		final File[] files = directory.listFiles();
+		if (debug) {
+			FCAddOnHandler
+					.LogMessage("Directory " + directory.getAbsolutePath() + " has " + files.length + " elements.");
+		}
+		if (packageName.length() > 0 && !packageName.endsWith("."))
+			packageName = packageName + ".";
+
+		if (blacklist.indexOf(packageName) >= 0)
+			return classes;
+
+		for (final File file : files) {
+			if (file.isDirectory()) {
+				assert !file.getName().contains(".");
+				classes.addAll(findFileClasses(file, packageName + file.getName()));
+			} else if (file.getName().endsWith(".class")) {
+				if (packageName.length() == 0)
+					continue;
+				final String className = packageName + file.getName().substring(0, file.getName().length() - 6);
+				classes.add(className);
+			}
+		}
+		return classes;
+	}
+}
