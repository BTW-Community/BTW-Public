diff --git a/minecraft/net/minecraft/client/Minecraft.java b/minecraft/net/minecraft/client/Minecraft.java
index 9d8b0af..6a17b5b 100644
--- a/minecraft/net/minecraft/client/Minecraft.java
+++ b/minecraft/net/minecraft/client/Minecraft.java
@@ -1,5 +1,8 @@
 package net.minecraft.client;
 
+import com.prupe.mcpatcher.MCPatcherUtils;
+import com.prupe.mcpatcher.hd.AAHelper;
+import com.prupe.mcpatcher.mal.resource.TexturePackChangeHandler;
 import java.awt.BorderLayout;
 import java.awt.Canvas;
 import java.awt.Color;
@@ -287,6 +290,7 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
 
     public Minecraft(Canvas par1Canvas, MinecraftApplet par2MinecraftApplet, int par3, int par4, boolean par5)
     {
+    	MCPatcherUtils.setMinecraft((File)null, (File)null, "1.5.2", "5.0.3");
         StatList.nopInit();
         this.tempDisplayHeight = par4;
         this.fullscreen = par5;
@@ -300,6 +304,9 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
         theMinecraft = this;
         TextureManager.init();
         this.guiAchievement = new GuiAchievement(this);
+        // FCMOD: Code added to handle initialization of mods on client
+        net.minecraft.src.FCAddOnHandler.InitializeMods();
+        // END FCMOD
     }
 
     private void startTimerHackThread()
@@ -376,7 +383,7 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
 
         try
         {
-            Display.create((new PixelFormat()).withDepthBits(24));
+            Display.create(AAHelper.setupPixelFormat((new PixelFormat()).withDepthBits(24)));
         }
         catch (LWJGLException var5)
         {
@@ -404,7 +411,12 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
         this.fontRenderer = new FontRenderer(this.gameSettings, "/font/default.png", this.renderEngine, false);
         this.standardGalacticFontRenderer = new FontRenderer(this.gameSettings, "/font/alternate.png", this.renderEngine, false);
 
+    	// FCMOD: Change to prevent crash loading options files from newer versions of MC
+    	/*
         if (this.gameSettings.language != null)
+        */
+        if ( gameSettings.language != null && Minecraft.class.getResource( "/lang/" + gameSettings.language + ".lang" ) != null )
+        // END FCMOD
         {
             StringTranslate.getInstance().setLanguage(this.gameSettings.language, false);
             this.fontRenderer.setUnicodeFlag(StringTranslate.getInstance().isUnicode());
@@ -435,7 +447,15 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
         this.checkGLError("Startup");
         this.sndManager.loadSoundSettings(this.gameSettings);
         this.renderGlobal = new RenderGlobal(this, this.renderEngine);
+        TexturePackChangeHandler.earlyInitialize("com.prupe.mcpatcher.mal.tile.TileLoader", "init");
+        TexturePackChangeHandler.earlyInitialize("com.prupe.mcpatcher.ctm.CTMUtils", "reset");
+        TexturePackChangeHandler.earlyInitialize("com.prupe.mcpatcher.cit.CITUtils", "init");
+        TexturePackChangeHandler.earlyInitialize("com.prupe.mcpatcher.hd.FontUtils", "init");
+        TexturePackChangeHandler.earlyInitialize("com.prupe.mcpatcher.mob.MobRandomizer", "init");
+        TexturePackChangeHandler.earlyInitialize("com.prupe.mcpatcher.cc.Colorizer", "init");
+        TexturePackChangeHandler.beforeChange1();
         this.renderEngine.refreshTextureMaps();
+        TexturePackChangeHandler.afterChange1();
         GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
         this.effectRenderer = new EffectRenderer(this.theWorld, this.renderEngine);
 
@@ -789,6 +809,8 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
      */
     private void runGameLoop()
     {
+    	TexturePackChangeHandler.checkForTexturePackChange();
+    	
         if (this.mcApplet != null && !this.mcApplet.isActive())
         {
             this.running = false;
@@ -1092,8 +1114,8 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
                 var5.addVertex((double)var7, (double)var8, 0.0D);
                 int var14;
                 float var15;
-                float var16;
                 float var17;
+                float var16;
 
                 for (var14 = var13; var14 >= 0; --var14)
                 {
@@ -1120,27 +1142,27 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
                 var9 += var12.field_76332_a;
             }
 
-            DecimalFormat var18 = new DecimalFormat("##0.00");
+            DecimalFormat var19 = new DecimalFormat("##0.00");
             GL11.glEnable(GL11.GL_TEXTURE_2D);
-            String var19 = "";
+            String var18 = "";
 
             if (!var4.field_76331_c.equals("unspecified"))
             {
-                var19 = var19 + "[0] ";
+                var18 = var18 + "[0] ";
             }
 
             if (var4.field_76331_c.length() == 0)
             {
-                var19 = var19 + "ROOT ";
+                var18 = var18 + "ROOT ";
             }
             else
             {
-                var19 = var19 + var4.field_76331_c + " ";
+                var18 = var18 + var4.field_76331_c + " ";
             }
 
             var13 = 16777215;
-            this.fontRenderer.drawStringWithShadow(var19, var7 - var6, var8 - var6 / 2 - 16, var13);
-            this.fontRenderer.drawStringWithShadow(var19 = var18.format(var4.field_76330_b) + "%", var7 + var6 - this.fontRenderer.getStringWidth(var19), var8 - var6 / 2 - 16, var13);
+            this.fontRenderer.drawStringWithShadow(var18, var7 - var6, var8 - var6 / 2 - 16, var13);
+            this.fontRenderer.drawStringWithShadow(var18 = var19.format(var4.field_76330_b) + "%", var7 + var6 - this.fontRenderer.getStringWidth(var18), var8 - var6 / 2 - 16, var13);
 
             for (int var21 = 0; var21 < var3.size(); ++var21)
             {
@@ -1158,8 +1180,8 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
 
                 var22 = var22 + var20.field_76331_c;
                 this.fontRenderer.drawStringWithShadow(var22, var7 - var6, var8 + var6 / 2 + var21 * 8 + 20, var20.func_76329_a());
-                this.fontRenderer.drawStringWithShadow(var22 = var18.format(var20.field_76332_a) + "%", var7 + var6 - 50 - this.fontRenderer.getStringWidth(var22), var8 + var6 / 2 + var21 * 8 + 20, var20.func_76329_a());
-                this.fontRenderer.drawStringWithShadow(var22 = var18.format(var20.field_76330_b) + "%", var7 + var6 - this.fontRenderer.getStringWidth(var22), var8 + var6 / 2 + var21 * 8 + 20, var20.func_76329_a());
+                this.fontRenderer.drawStringWithShadow(var22 = var19.format(var20.field_76332_a) + "%", var7 + var6 - 50 - this.fontRenderer.getStringWidth(var22), var8 + var6 / 2 + var21 * 8 + 20, var20.func_76329_a());
+                this.fontRenderer.drawStringWithShadow(var22 = var19.format(var20.field_76330_b) + "%", var7 + var6 - this.fontRenderer.getStringWidth(var22), var8 + var6 / 2 + var21 * 8 + 20, var20.func_76329_a());
             }
         }
     }
@@ -1228,7 +1250,11 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
 
         if (par1 != 0 || this.leftClickCounter <= 0)
         {
-            if (par2 && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == EnumMovingObjectType.TILE && par1 == 0)
+        	// FCMOD: Changed (client only)
+            //if (par2 && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == EnumMovingObjectType.TILE && par1 == 0)
+            if ( par2 && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == EnumMovingObjectType.TILE && par1 == 0 &&
+            	!thePlayer.isUsingItem() )
+        	// END FCMOD
             {
                 int var3 = this.objectMouseOver.blockX;
                 int var4 = this.objectMouseOver.blockY;
@@ -1793,6 +1819,11 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
 
             if (this.gameSettings.keyBindUseItem.pressed && this.rightClickDelayTimer == 0 && !this.thePlayer.isUsingItem())
             {
+            	// FCMOD: Code added (Client Only)
+            	ItemStack currentStack = thePlayer.inventory.getCurrentItem();
+            	
+            	if ( currentStack != null && currentStack.getItem().IsMultiUsePerClick() )
+        		// END FCMOD
                 this.clickMouse(1);
             }
 
@@ -2253,27 +2284,27 @@ public abstract class Minecraft implements Runnable, IPlayerUsage
         var1.put("username", var6);
         var1.put("fullscreen", "" + var4);
         var1.put("sessionid", var7);
-        Frame var15 = new Frame();
-        var15.setTitle("Minecraft");
-        var15.setBackground(Color.BLACK);
+        Frame var17 = new Frame();
+        var17.setTitle("Minecraft");
+        var17.setBackground(Color.BLACK);
         JPanel var16 = new JPanel();
-        var15.setLayout(new BorderLayout());
+        var17.setLayout(new BorderLayout());
         var16.setPreferredSize(new Dimension(854, 480));
-        var15.add(var16, "Center");
-        var15.pack();
-        var15.setLocationRelativeTo((Component)null);
-        var15.setVisible(true);
-        var15.addWindowListener(new GameWindowListener());
-        MinecraftFakeLauncher var17 = new MinecraftFakeLauncher(var1);
+        var17.add(var16, "Center");
+        var17.pack();
+        var17.setLocationRelativeTo((Component)null);
+        var17.setVisible(true);
+        var17.addWindowListener(new GameWindowListener());
+        MinecraftFakeLauncher var15 = new MinecraftFakeLauncher(var1);
         MinecraftApplet var18 = new MinecraftApplet();
-        var18.setStub(var17);
-        var17.setLayout(new BorderLayout());
-        var17.add(var18, "Center");
-        var17.validate();
-        var15.removeAll();
+        var18.setStub(var15);
         var15.setLayout(new BorderLayout());
-        var15.add(var17, "Center");
+        var15.add(var18, "Center");
         var15.validate();
+        var17.removeAll();
+        var17.setLayout(new BorderLayout());
+        var17.add(var15, "Center");
+        var17.validate();
         var18.init();
         Iterator var19 = var8.iterator();
 
diff --git a/minecraft/net/minecraft/src/AxisAlignedBB.java b/minecraft/net/minecraft/src/AxisAlignedBB.java
index f3d92e4..80db858 100644
--- a/minecraft/net/minecraft/src/AxisAlignedBB.java
+++ b/minecraft/net/minecraft/src/AxisAlignedBB.java
@@ -1,6 +1,11 @@
 package net.minecraft.src;
 
-public class AxisAlignedBB
+import java.util.List;
+
+// FCMOD: Changed
+//public class AxisAlignedBB
+public class AxisAlignedBB extends FCUtilsPrimitiveGeometric
+// END FCMOD
 {
     /** ThreadLocal AABBPool */
     private static final ThreadLocal theAABBLocalPool = new AABBLocalPool();
@@ -475,4 +480,163 @@ public class AxisAlignedBB
     {
         return "box[" + this.minX + ", " + this.minY + ", " + this.minZ + " -> " + this.maxX + ", " + this.maxY + ", " + this.maxZ + "]";
     }
+    
+    // FCMOD: Added New
+	/**
+	 * Yaws the box around the J axis. Assumes that the box's initial facing is along the negative K axis (facing 2)
+	 */
+    @Override
+	public void RotateAroundJToFacing( int iFacing )
+    {
+		if ( iFacing > 2 )
+		{
+	    	if ( iFacing == 5 ) // i + 1
+	    	{
+	        	setBounds( 1.0D - maxZ, minY, 1.0D - maxX, 1.0D - minZ, maxY, 1.0D - minX );
+	    	}
+	    	else if ( iFacing == 4 ) // i - 1
+	    	{
+	        	setBounds( minZ, minY, minX, maxZ, maxY, maxX );
+	    	}
+	    	else // if ( iFacing == 3 ) // k + 1
+	    	{
+	        	setBounds( 1.0D - maxX, minY, 1.0D - maxZ, 1.0D - minX, maxY, 1.0D - minZ );
+	    	}
+		}    	
+    }
+	
+	/**
+	 * "Tilts" the box towards the desired facing.  Takes the up vector and either yaws or rolls it towards the specified axis.
+	 */	
+    @Override
+	public void TiltToFacingAlongJ( int iFacing )
+    {
+    	double newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ;
+    	
+		if ( iFacing == 0 ) // j - 1
+		{
+			// rotating around k axis here to point downwards
+			
+	    	setBounds( 1D - maxX, 1D - maxY, minZ, 1D - minX, 1D - minY, maxZ );
+		}
+		else if ( iFacing == 2 ) // k - 1
+		{
+			setBounds( minX, minZ, 1D - maxY, maxX, maxZ, 1D - minY );
+		}			
+		else if ( iFacing == 3 ) // k + 1
+		{
+			setBounds( minX, 1D - maxZ, minY, maxX, 1D - minZ, maxY );
+		}
+		else if ( iFacing == 4 ) // i - 1
+		{
+			setBounds( 1D - maxY, minX, minZ, 1D - minY, maxX, maxZ );
+		}			
+		else if ( iFacing == 5 ) // i + 1
+		{
+			setBounds( minY, 1D - maxX, minZ, maxY, 1D - minX, maxZ );
+		}			
+    }
+
+    @Override
+	public void Translate( double dDeltaX, double dDeltaY, double dDeltaZ )
+    {
+    	offset( dDeltaX, dDeltaY, dDeltaZ );
+    }
+    
+    @Override
+	public void AddToRayTrace( FCUtilsRayTraceVsComplexBlock rayTrace )
+    {
+    	rayTrace.AddBoxWithLocalCoordsToIntersectionList( minX, minY, minZ, maxX, maxY, maxZ );
+    }
+	
+    @Override
+	public AxisAlignedBB MakeTemporaryCopy()
+	{
+		return getAABBPool().getAABB( minX, minY, minZ, maxX, maxY, maxZ );
+	}
+	
+    @Override
+    public void AddIntersectingBoxesToCollisionList( World world, int i, int j, int k, AxisAlignedBB boxToIntersect, List collisionList )
+    {
+    	AxisAlignedBB offsetBox = MakeTemporaryCopy().offset( i, j, k );
+    	
+    	offsetBox.AddToListIfIntersects( boxToIntersect, collisionList );
+    }
+	
+    //------------- Class Specific Methods ------------//	
+    
+    public void ExpandToInclude( AxisAlignedBB box )
+    {
+    	minX = Math.min( minX, box.minX );
+    	maxX = Math.max( maxX, box.maxX );
+    	
+    	minY = Math.min( minY, box.minY );
+    	maxY = Math.max( maxY, box.maxY );
+    	
+    	minZ = Math.min( minZ, box.minZ );
+    	maxZ = Math.max( maxZ, box.maxZ );
+    }
+    
+    public void AddToListIfIntersects( AxisAlignedBB intersectingBox, List list )
+    {
+    	if ( intersectsWith( intersectingBox ) )
+    	{
+    		list.add( this );
+    	}
+    }
+    
+	//----------- Client Side Functionality -----------//
+
+    @Override
+	public boolean RenderAsBlock( RenderBlocks renderBlocks, Block block, int i, int j, int k )
+	{	
+        renderBlocks.setRenderBounds( this );
+        
+        return renderBlocks.renderStandardBlock( block, i, j, k );
+    }
+    
+    @Override
+	public boolean RenderAsBlockWithColorMultiplier( RenderBlocks renderBlocks, Block block, int i, int j, int k, float fRed, float fGreen, float fBlue )
+    {
+        renderBlocks.setRenderBounds( this );
+        
+        return renderBlocks.renderStandardBlockWithColorMultiplier( block, i, j, k, fRed, fGreen, fBlue );
+    }
+    
+    @Override
+	public boolean RenderAsBlockWithTexture( RenderBlocks renderBlocks, Block block, int i, int j, int k, Icon icon )
+    {
+        renderBlocks.setRenderBounds( this );
+        
+        FCClientUtilsRender.RenderStandardBlockWithTexture( renderBlocks, block, i, j, k, icon );
+        
+        return true;
+    }
+    
+    @Override
+	public boolean RenderAsBlockFullBrightWithTexture( RenderBlocks renderBlocks, Block block, int i, int j, int k, Icon icon )
+    {
+        renderBlocks.setRenderBounds( this );
+        
+        FCClientUtilsRender.RenderBlockFullBrightWithTexture( renderBlocks, renderBlocks.blockAccess, i, j, k, icon );
+        
+        return true;
+    }
+    
+    @Override
+	public void RenderAsItemBlock( RenderBlocks renderBlocks, Block block, int iItemDamage )
+	{
+        renderBlocks.setRenderBounds( this );
+        
+        FCClientUtilsRender.RenderInvBlockWithMetadata( renderBlocks, block, -0.5F, -0.5F, -0.5F, iItemDamage );    
+	}
+    
+    @Override
+	public void RenderAsFallingBlock( RenderBlocks renderBlocks, Block block, int i, int j, int k, int iMetadata )
+	{
+        renderBlocks.setRenderBounds( this );
+        
+        renderBlocks.RenderStandardFallingBlock( block, i, j, k, iMetadata );
+	}
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BehaviorDispenseArmor.java b/minecraft/net/minecraft/src/BehaviorDispenseArmor.java
index 3e9d104..205bf16 100644
--- a/minecraft/net/minecraft/src/BehaviorDispenseArmor.java
+++ b/minecraft/net/minecraft/src/BehaviorDispenseArmor.java
@@ -7,6 +7,8 @@ final class BehaviorDispenseArmor extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -33,4 +35,6 @@ final class BehaviorDispenseArmor extends BehaviorDefaultDispenseItem
             return super.dispenseStack(par1IBlockSource, par2ItemStack);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BehaviorDispenseMinecart.java b/minecraft/net/minecraft/src/BehaviorDispenseMinecart.java
index 0698a00..235c70d 100644
--- a/minecraft/net/minecraft/src/BehaviorDispenseMinecart.java
+++ b/minecraft/net/minecraft/src/BehaviorDispenseMinecart.java
@@ -7,6 +7,8 @@ final class BehaviorDispenseMinecart extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -39,12 +41,18 @@ final class BehaviorDispenseMinecart extends BehaviorDefaultDispenseItem
         par2ItemStack.splitStack(1);
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+	// FCMOD: Code removed
+    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         par1IBlockSource.getWorld().playAuxSFX(1000, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BiomeGenBase.java b/minecraft/net/minecraft/src/BiomeGenBase.java
index 2109dc9..b47b2d1 100644
--- a/minecraft/net/minecraft/src/BiomeGenBase.java
+++ b/minecraft/net/minecraft/src/BiomeGenBase.java
@@ -11,41 +11,57 @@ public abstract class BiomeGenBase
     public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];
     public static final BiomeGenBase ocean = (new BiomeGenOcean(0)).setColor(112).setBiomeName("Ocean").setMinMaxHeight(-1.0F, 0.4F);
     public static final BiomeGenBase plains = (new BiomeGenPlains(1)).setColor(9286496).setBiomeName("Plains").setTemperatureRainfall(0.8F, 0.4F);
-    public static final BiomeGenBase desert = (new BiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
-    public static final BiomeGenBase extremeHills = (new BiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
-    public static final BiomeGenBase forest = (new BiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
-    public static final BiomeGenBase taiga = (new BiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase desert = (new BiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
+    //public static final BiomeGenBase extremeHills = (new BiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
+    //public static final BiomeGenBase forest = (new BiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
+    //public static final BiomeGenBase taiga = (new BiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
+    public static final BiomeGenBase desert = (new FCBiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
+    public static final BiomeGenBase extremeHills = (new FCBiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
+    public static final BiomeGenBase forest = (new FCBiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
+    public static final BiomeGenBase taiga = (new FCBiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
+    // END FCMOD
     public static final BiomeGenBase swampland = (new BiomeGenSwamp(6)).setColor(522674).setBiomeName("Swampland").func_76733_a(9154376).setMinMaxHeight(-0.2F, 0.1F).setTemperatureRainfall(0.8F, 0.9F);
     public static final BiomeGenBase river = (new BiomeGenRiver(7)).setColor(255).setBiomeName("River").setMinMaxHeight(-0.5F, 0.0F);
-    public static final BiomeGenBase hell = (new BiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase hell = (new BiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
+    public static final BiomeGenBase hell = (new FCBiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
+    // END FCMOD
 
     /** Is the biome used for sky world. */
-    public static final BiomeGenBase sky = (new BiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
+    // FCMOD: Changed
+    //public static final BiomeGenBase sky = (new BiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
+    public static final BiomeGenBase sky = (new FCBiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
+    // END FCMOD
     public static final BiomeGenBase frozenOcean = (new BiomeGenOcean(10)).setColor(9474208).setBiomeName("FrozenOcean").setEnableSnow().setMinMaxHeight(-1.0F, 0.5F).setTemperatureRainfall(0.0F, 0.5F);
     public static final BiomeGenBase frozenRiver = (new BiomeGenRiver(11)).setColor(10526975).setBiomeName("FrozenRiver").setEnableSnow().setMinMaxHeight(-0.5F, 0.0F).setTemperatureRainfall(0.0F, 0.5F);
-    public static final BiomeGenBase icePlains = (new BiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
-    public static final BiomeGenBase iceMountains = (new BiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase icePlains = (new BiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
+    //public static final BiomeGenBase iceMountains = (new BiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
+    public static final BiomeGenBase icePlains = (new FCBiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
+    public static final BiomeGenBase iceMountains = (new FCBiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
+    // END FCMOD
     public static final BiomeGenBase mushroomIsland = (new BiomeGenMushroomIsland(14)).setColor(16711935).setBiomeName("MushroomIsland").setTemperatureRainfall(0.9F, 1.0F).setMinMaxHeight(0.2F, 1.0F);
     public static final BiomeGenBase mushroomIslandShore = (new BiomeGenMushroomIsland(15)).setColor(10486015).setBiomeName("MushroomIslandShore").setTemperatureRainfall(0.9F, 1.0F).setMinMaxHeight(-1.0F, 0.1F);
 
     /** Beach biome. */
     public static final BiomeGenBase beach = (new BiomeGenBeach(16)).setColor(16440917).setBiomeName("Beach").setTemperatureRainfall(0.8F, 0.4F).setMinMaxHeight(0.0F, 0.1F);
 
-    /** Desert Hills biome. */
-    public static final BiomeGenBase desertHills = (new BiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
-
-    /** Forest Hills biome. */
-    public static final BiomeGenBase forestHills = (new BiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
-
-    /** Taiga Hills biome. */
-    public static final BiomeGenBase taigaHills = (new BiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
-
-    /** Extreme Hills Edge biome. */
-    public static final BiomeGenBase extremeHillsEdge = (new BiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
-
-    /** Jungle biome identifier */
-    public static final BiomeGenBase jungle = (new BiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
-    public static final BiomeGenBase jungleHills = (new BiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase desertHills = (new BiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
+    //public static final BiomeGenBase forestHills = (new BiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
+    //public static final BiomeGenBase taigaHills = (new BiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
+    //public static final BiomeGenBase extremeHillsEdge = (new BiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
+    //public static final BiomeGenBase jungle = (new BiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
+    //public static final BiomeGenBase jungleHills = (new BiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
+    public static final BiomeGenBase desertHills = (new FCBiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
+    public static final BiomeGenBase forestHills = (new FCBiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
+    public static final BiomeGenBase taigaHills = (new FCBiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
+    public static final BiomeGenBase extremeHillsEdge = (new FCBiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
+    public static final BiomeGenBase jungle = (new FCBiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
+    public static final BiomeGenBase jungleHills = (new FCBiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
+    // END FCMOD
+    
     public String biomeName;
     public int color;
 
@@ -135,18 +151,35 @@ public abstract class BiomeGenBase
         this.biomeID = par1;
         biomeList[par1] = this;
         this.theBiomeDecorator = this.createBiomeDecorator();
-        this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
-        this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
-        this.spawnableCaveCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
+        // FCMOD: Changed 
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
+        //this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
+        //this.spawnableCaveCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
+        spawnableCreatureList.add( new SpawnListEntry( FCEntitySheep.class, 12, 4, 4 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityPig.class, 10, 4, 4 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityChicken.class, 10, 4, 4 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityCow.class, 8, 4, 4 ) );
+        
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySpider.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityZombie.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySkeleton.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityCreeper.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySlime.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityEnderman.class, 1, 1, 4 ) );
+        
+        spawnableWaterCreatureList.add( new SpawnListEntry( FCEntitySquid.class, 10, 4, 4 ) );
+        
+        spawnableCaveCreatureList.add( new SpawnListEntry( FCEntityBat.class, 10, 8, 8 ) );
+        // END FCMOD
     }
 
     /**
@@ -275,10 +308,15 @@ public abstract class BiomeGenBase
     /**
      * Return true if the biome supports lightning bolt spawn, either by have the bolts enabled and have rain enabled.
      */
+    // FCMOD: Removed and replaced due to ambiguous naming and use.  It was used in vanilla
+    // both for determining whether lightning could strike in a biome, and whether it could rain there.
+    /*
     public boolean canSpawnLightningBolt()
     {
         return this.enableSnow ? false : this.enableRain;
     }
+    */
+    // END FCMOD
 
     /**
      * Checks to see if the rainfall level of the biome is extremely high
@@ -352,4 +390,16 @@ public abstract class BiomeGenBase
         double var3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
         return ColorizerFoliage.getFoliageColor(var1, var3);
     }
+    
+    // FCMOD: Added
+    public boolean CanRainInBiome()
+    {
+        return enableSnow ? false : enableRain;
+    }
+    
+    public boolean CanLightningStrikeInBiome()
+    {
+    	return CanRainInBiome();
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BiomeGenHell.java b/minecraft/net/minecraft/src/BiomeGenHell.java
index 3970cf1..832411e 100644
--- a/minecraft/net/minecraft/src/BiomeGenHell.java
+++ b/minecraft/net/minecraft/src/BiomeGenHell.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/28/2018
+
 package net.minecraft.src;
 
 public class BiomeGenHell extends BiomeGenBase
diff --git a/minecraft/net/minecraft/src/BiomeGenMushroomIsland.java b/minecraft/net/minecraft/src/BiomeGenMushroomIsland.java
index a62759e..313f3c5 100644
--- a/minecraft/net/minecraft/src/BiomeGenMushroomIsland.java
+++ b/minecraft/net/minecraft/src/BiomeGenMushroomIsland.java
@@ -11,7 +11,11 @@ public class BiomeGenMushroomIsland extends BiomeGenBase
         this.theBiomeDecorator.mushroomsPerChunk = 1;
         this.theBiomeDecorator.bigMushroomsPerChunk = 1;
         this.topBlock = (byte)Block.mycelium.blockID;
+        // FCMOD: Code removed so mobs can spawn in mushroom biomes
+        /*
         this.spawnableMonsterList.clear();
+        */
+        // END FCMOD
         this.spawnableCreatureList.clear();
         this.spawnableWaterCreatureList.clear();
         this.spawnableCreatureList.add(new SpawnListEntry(EntityMooshroom.class, 8, 4, 8));
diff --git a/minecraft/net/minecraft/src/BiomeGenSwamp.java b/minecraft/net/minecraft/src/BiomeGenSwamp.java
index 31e7846..26676de 100644
--- a/minecraft/net/minecraft/src/BiomeGenSwamp.java
+++ b/minecraft/net/minecraft/src/BiomeGenSwamp.java
@@ -15,7 +15,21 @@ public class BiomeGenSwamp extends BiomeGenBase
         this.theBiomeDecorator.clayPerChunk = 1;
         this.theBiomeDecorator.waterlilyPerChunk = 4;
         this.waterColorMultiplier = 14745518;
+        
+        // FCMOD: Changed
+        /*
         this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 1, 1, 1));
+        */
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySlime.class, 1, 1, 1 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityWitch.class, 1, 1, 1 ) );
+        
+        // get rid of cows and sheep and cause other animals to spawn in lower numbers
+        
+        spawnableCreatureList.clear();
+        
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityChicken.class, 10, 2, 2 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityPig.class, 10, 2, 2 ) );
+        // END FCMOD        
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/Block.java b/minecraft/net/minecraft/src/Block.java
index a6a03a3..84e56d2 100644
--- a/minecraft/net/minecraft/src/Block.java
+++ b/minecraft/net/minecraft/src/Block.java
@@ -1,8 +1,15 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.List;
 import java.util.Random;
 
+import org.lwjgl.opengl.GL11;
+
+// FCMOD: Added
+import net.minecraft.client.Minecraft; //client only
+// END FCMOD
+
 public class Block
 {
     /**
@@ -33,7 +40,9 @@ public class Block
     /** How much light is subtracted for going through this block */
     public static final int[] lightOpacity = new int[4096];
 
-    /** Array of booleans that tells if a block can grass */
+    /** Array of booleans that tells if a block can grass
+     * FCNOTE: Misleading name.  This is actually wether grass can grow under the block
+     */
     public static final boolean[] canBlockGrass = new boolean[4096];
 
     /** Amount of light emitted */
@@ -41,180 +50,173 @@ public class Block
 
     /**
      * Flag if block ID should use the brightest neighbor light value as its own
-     */
+     * FCNOTE: Misleading name in that this does not apply to the neighbor below the block,
+     * only to sides and top
+     */ 
     public static boolean[] useNeighborBrightness = new boolean[4096];
-    public static final Block stone = (new BlockStone(1)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stone");
-    public static final BlockGrass grass = (BlockGrass)(new BlockGrass(2)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("grass");
-    public static final Block dirt = (new BlockDirt(3)).setHardness(0.5F).setStepSound(soundGravelFootstep).setUnlocalizedName("dirt");
-    public static final Block cobblestone = (new Block(4, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block planks = (new BlockWood(5)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("wood");
-    public static final Block sapling = (new BlockSapling(6)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
-    public static final Block bedrock = (new Block(7, Material.rock)).setBlockUnbreakable().setResistance(6000000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("bedrock").disableStats().setCreativeTab(CreativeTabs.tabBlock);
-    public static final BlockFluid waterMoving = (BlockFluid)(new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final Block waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final BlockFluid lavaMoving = (BlockFluid)(new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-
-    /** Stationary lava source block */
-    public static final Block lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-    public static final Block sand = (new BlockSand(12)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("sand");
-    public static final Block gravel = (new BlockGravel(13)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("gravel");
-    public static final Block oreGold = (new BlockOre(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
-    public static final Block oreIron = (new BlockOre(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
-    public static final Block oreCoal = (new BlockOre(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
-    public static final Block wood = (new BlockLog(17)).setHardness(2.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("log");
-    public static final BlockLeaves leaves = (BlockLeaves)(new BlockLeaves(18)).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep).setUnlocalizedName("leaves");
-    public static final Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
-    public static final Block glass = (new BlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
-    public static final Block oreLapis = (new BlockOre(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
-    public static final Block blockLapis = (new Block(22, Material.rock)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dispenser = (new BlockDispenser(23)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dispenser");
-    public static final Block sandStone = (new BlockSandStone(24)).setStepSound(soundStoneFootstep).setHardness(0.8F).setUnlocalizedName("sandStone");
-    public static final Block music = (new BlockNote(25)).setHardness(0.8F).setUnlocalizedName("musicBlock");
-    public static final Block bed = (new BlockBed(26)).setHardness(0.2F).setUnlocalizedName("bed").disableStats();
-    public static final Block railPowered = (new BlockRailPowered(27)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
-    public static final Block railDetector = (new BlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
-    public static final BlockPistonBase pistonStickyBase = (BlockPistonBase)(new BlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
-    public static final Block web = (new BlockWeb(30)).setLightOpacity(1).setHardness(4.0F).setUnlocalizedName("web");
-    public static final BlockTallGrass tallGrass = (BlockTallGrass)(new BlockTallGrass(31)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tallgrass");
-    public static final BlockDeadBush deadBush = (BlockDeadBush)(new BlockDeadBush(32)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("deadbush");
-    public static final BlockPistonBase pistonBase = (BlockPistonBase)(new BlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
-    public static final BlockPistonExtension pistonExtension = new BlockPistonExtension(34);
-    public static final Block cloth = (new BlockCloth()).setHardness(0.8F).setStepSound(soundClothFootstep).setUnlocalizedName("cloth");
-    public static final BlockPistonMoving pistonMoving = new BlockPistonMoving(36);
-    public static final BlockFlower plantYellow = (BlockFlower)(new BlockFlower(37)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("flower");
-    public static final BlockFlower plantRed = (BlockFlower)(new BlockFlower(38)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("rose");
-    public static final BlockFlower mushroomBrown = (BlockFlower)(new BlockMushroom(39, "mushroom_brown")).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(0.125F).setUnlocalizedName("mushroom");
-    public static final BlockFlower mushroomRed = (BlockFlower)(new BlockMushroom(40, "mushroom_red")).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
-    public static final Block blockGold = (new BlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
-    public static final Block blockIron = (new BlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
-
-    /** stoneDoubleSlab */
-    public static final BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-
-    /** stoneSingleSlab */
-    public static final BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-    public static final Block brick = (new Block(45, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block tnt = (new BlockTNT(46)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tnt");
-    public static final Block bookShelf = (new BlockBookshelf(47)).setHardness(1.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("bookshelf");
-    public static final Block cobblestoneMossy = (new Block(48, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneMoss").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block obsidian = (new BlockObsidian(49)).setHardness(50.0F).setResistance(2000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("obsidian");
-    public static final Block torchWood = (new BlockTorch(50)).setHardness(0.0F).setLightValue(0.9375F).setStepSound(soundWoodFootstep).setUnlocalizedName("torch");
-    public static final BlockFire fire = (BlockFire)(new BlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
-    public static final Block mobSpawner = (new BlockMobSpawner(52)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("mobSpawner").disableStats();
-    public static final Block stairsWoodOak = (new BlockStairs(53, planks, 0)).setUnlocalizedName("stairsWood");
-    public static final BlockChest chest = (BlockChest)(new BlockChest(54, 0)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("chest");
-    public static final BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new BlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
-    public static final Block oreDiamond = (new BlockOre(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
-    public static final Block blockDiamond = (new BlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
-    public static final Block workbench = (new BlockWorkbench(58)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("workbench");
-    public static final Block crops = (new BlockCrops(59)).setUnlocalizedName("crops");
-    public static final Block tilledField = (new BlockFarmland(60)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("farmland");
-    public static final Block furnaceIdle = (new BlockFurnace(61, false)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("furnace").setCreativeTab(CreativeTabs.tabDecorations);
-    public static final Block furnaceBurning = (new BlockFurnace(62, true)).setHardness(3.5F).setStepSound(soundStoneFootstep).setLightValue(0.875F).setUnlocalizedName("furnace");
-    public static final Block signPost = (new BlockSign(63, TileEntitySign.class, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("sign").disableStats();
-    public static final Block doorWood = (new BlockDoor(64, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("doorWood").disableStats();
-    public static final Block ladder = (new BlockLadder(65)).setHardness(0.4F).setStepSound(soundLadderFootstep).setUnlocalizedName("ladder");
-    public static final Block rail = (new BlockRail(66)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("rail");
-    public static final Block stairsCobblestone = (new BlockStairs(67, cobblestone, 0)).setUnlocalizedName("stairsStone");
-    public static final Block signWall = (new BlockSign(68, TileEntitySign.class, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("sign").disableStats();
-    public static final Block lever = (new BlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
-    public static final Block pressurePlateStone = (new BlockPressurePlate(70, "stone", Material.rock, EnumMobType.mobs)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("pressurePlate");
-    public static final Block doorIron = (new BlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
-    public static final Block pressurePlatePlanks = (new BlockPressurePlate(72, "wood", Material.wood, EnumMobType.everything)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("pressurePlate");
-    public static final Block oreRedstone = (new BlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block oreRedstoneGlowing = (new BlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone");
-    public static final Block torchRedstoneIdle = (new BlockRedstoneTorch(75, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("notGate");
-    public static final Block torchRedstoneActive = (new BlockRedstoneTorch(76, true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block stoneButton = (new BlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
-    public static final Block snow = (new BlockSnow(78)).setHardness(0.1F).setStepSound(soundSnowFootstep).setUnlocalizedName("snow").setLightOpacity(0);
-    public static final Block ice = (new BlockIce(79)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
-    public static final Block blockSnow = (new BlockSnowBlock(80)).setHardness(0.2F).setStepSound(soundSnowFootstep).setUnlocalizedName("snow");
-    public static final Block cactus = (new BlockCactus(81)).setHardness(0.4F).setStepSound(soundClothFootstep).setUnlocalizedName("cactus");
-    public static final Block blockClay = (new BlockClay(82)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("clay");
-    public static final Block reed = (new BlockReed(83)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
-    public static final Block jukebox = (new BlockJukeBox(84)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("jukebox");
-    public static final Block fence = (new BlockFence(85, "wood", Material.wood)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fence");
-    public static final Block pumpkin = (new BlockPumpkin(86, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkin");
-    public static final Block netherrack = (new BlockNetherrack(87)).setHardness(0.4F).setStepSound(soundStoneFootstep).setUnlocalizedName("hellrock");
-    public static final Block slowSand = (new BlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
-    public static final Block glowStone = (new BlockGlowStone(89, Material.glass)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F).setUnlocalizedName("lightgem");
-
-    /** The purple teleport blocks inside the obsidian circle */
-    public static final BlockPortal portal = (BlockPortal)(new BlockPortal(90)).setHardness(-1.0F).setStepSound(soundGlassFootstep).setLightValue(0.75F).setUnlocalizedName("portal");
-    public static final Block pumpkinLantern = (new BlockPumpkin(91, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setLightValue(1.0F).setUnlocalizedName("litpumpkin");
-    public static final Block cake = (new BlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterIdle = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(93, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterActive = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(94, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
+    
+    public static Block stone = new FCBlockStone( 1 );
+    public static BlockGrass grass = new FCBlockGrass( 2 );
+    public static Block dirt = new FCBlockDirt( 3 );
+    public static Block cobblestone = (new FCBlockCobblestone(4)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block planks = new FCBlockPlanks( 5 );
+    public static Block sapling = (new FCBlockSapling(6)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
+    public static Block bedrock = new FCBlockBedrock( 7 );
+    public static BlockFluid waterMoving = (BlockFluid)(new FCBlockWaterFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
+    public static Block waterStill = (new FCBlockWaterStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
+    public static BlockFluid lavaMoving = (BlockFluid)(new FCBlockLavaFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
+    public static Block lavaStill = (new FCBlockLavaStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
+    public static Block sand = new FCBlockSand( 12 );
+    public static Block gravel = new FCBlockGravel( 13 );
+    public static Block oreGold = (new FCBlockOreGold(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
+    public static Block oreIron = (new FCBlockOreIron(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
+    public static Block oreCoal = (new FCBlockOreCoal(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
+    public static Block wood = new FCBlockLog( 17 );
+    public static BlockLeaves leaves = new FCBlockLeaves( 18 );
+    public static Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
+    public static Block glass = (new FCBlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
+    public static Block oreLapis = (new FCBlockOreLapis(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
+    public static Block blockLapis = (new Block(22, Material.rock)).SetPicksEffectiveOn().setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block dispenser = new FCBlockDispenserVanilla( 23 );
+    public static Block sandStone = new FCBlockSandStone( 24 );
+    public static Block music = new FCBlockNote( 25 );
+    public static Block bed = (new FCBlockBed(26)).setHardness(0.2F).SetBuoyant().setUnlocalizedName("bed").disableStats();
+    public static Block railPowered = (new BlockRailPowered(27)).SetPicksEffectiveOn().setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
+    public static Block railDetector = (new FCBlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
+    public static BlockPistonBase pistonStickyBase = (BlockPistonBase)(new FCBlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
+    public static Block web = new FCBlockWeb( 30 );
+    public static BlockTallGrass tallGrass = new FCBlockTallGrass( 31 );
+    public static BlockDeadBush deadBush = new FCBlockDeadBush( 32 );
+    public static BlockPistonBase pistonBase = (BlockPistonBase)(new FCBlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
+    public static BlockPistonExtension pistonExtension = new FCBlockPistonExtension(34);
+    public static Block cloth = new FCBlockCloth(); // sets own blockID of 35
+    public static BlockPistonMoving pistonMoving = new FCBlockPistonMoving( 36 );
+    public static BlockFlower plantYellow = (BlockFlower)(new FCBlockFlowerBlossom( 37 )).setUnlocalizedName("flower");
+    public static BlockFlower plantRed = (BlockFlower)(new FCBlockFlowerBlossom( 38 )).setUnlocalizedName("rose");
+    public static BlockFlower mushroomBrown = (BlockFlower)(new FCBlockMushroomBrown(39, "mushroom_brown")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
+    public static BlockFlower mushroomRed = (BlockFlower)(new FCBlockMushroom(40, "mushroom_red")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
+    public static Block blockGold = (new FCBlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
+    public static Block blockIron = (new FCBlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
+    public static BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new FCBlockStep(43, true)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+    public static BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new FCBlockStep(44, false)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+    public static Block brick = (new FCBlockBrick(45)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block tnt = new FCBlockPowderKeg( 46 );
+    public static Block bookShelf = new FCBlockBookshelf( 47 );
+    public static Block cobblestoneMossy = new FCBlockCobblestoneMossy( 48 ); 
+    public static Block obsidian = new FCBlockObsidian( 49 );
+    public static Block torchWood = new FCBlockTorchLegacy( 50 );
+    public static BlockFire fire = (BlockFire)(new FCBlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
+    public static Block mobSpawner = new FCBlockMobSpawner( 52 );
+    public static Block stairsWoodOak = (new FCBlockStairsWood( 53, planks, 0 ) ).setUnlocalizedName( "stairsWood" );
+    public static BlockChest chest = (BlockChest)( new FCBlockChest( 54 ) ).setCreativeTab( null );
+    public static BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new FCBlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
+    public static Block oreDiamond = (new FCBlockOreDiamond(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
+    public static Block blockDiamond = (new FCBlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
+    public static Block workbench = new FCBlockWorkbench( 58 );
+    public static Block crops = (new FCBlockWheatLegacy(59)).SetBuoyant().setUnlocalizedName("crops");
+    public static Block tilledField = new FCBlockFarmlandLegacyUnfertilized( 60 );
+    public static Block furnaceIdle = new FCBlockFurnace( 61, false );
+    public static Block furnaceBurning = new FCBlockFurnace( 62, true );
+    public static Block signPost = new FCBlockSign( 63, true );
+    public static Block doorWood = new FCBlockDoorWood( 64 );
+    public static Block ladder = new FCBlockLegacyLadder( 65 );
+    public static Block rail = new FCBlockRailRegular( 66 );
+    public static Block stairsCobblestone = new FCBlockStairsCobblestone( 67 );
+    public static Block signWall = new FCBlockSignWall( 68 );
+    public static Block lever = (new FCBlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
+    public static Block pressurePlateStone = new FCBlockPressurePlateStone( 70 );
+    public static Block doorIron = (new FCBlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
+    public static Block pressurePlatePlanks = new FCBlockPressurePlatePlanks( 72 );
+    public static Block oreRedstone = (new FCBlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block oreRedstoneGlowing = (new FCBlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(null);
+    public static Block torchRedstoneIdle = (new BlockRedstoneTorch( 75, false )).setUnlocalizedName("notGate");
+    public static Block torchRedstoneActive = (new BlockRedstoneTorch( 76, true )).setLightValue(0.5F).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
+    public static Block stoneButton = (new FCBlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
+    public static Block snow = new FCBlockSnowCover( 78 );
+    public static Block ice = (new FCBlockIce(79)).setHardness(0.5F).SetBuoyant().setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
+    public static Block blockSnow = new FCBlockSnowLegacy( 80 );
+    public static Block cactus = new FCBlockCactus( 81 );
+    public static Block blockClay = (new FCBlockClay(82)).setHardness(0.6F).setUnlocalizedName("clay");
+    public static Block reed = (new FCBlockReed(83)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
+    public static Block jukebox = new FCBlockJukebox( 84 );
+    public static Block fence = new FCBlockFenceWood( 85 );
+    public static Block pumpkin = new FCBlockPumpkinCarved( 86 );
+    public static Block netherrack = new FCBlockNetherrack( 87 );
+    public static Block slowSand = (new FCBlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
+    public static Block glowStone = new FCBlockGlowStone( 89 );
+    public static BlockPortal portal = new FCBlockPortal( 90 );
+    public static Block pumpkinLantern = new FCBlockJackOLantern( 91 );
+    public static Block cake = (new FCBlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
+    public static BlockRedstoneRepeater redstoneRepeaterIdle = new FCBlockRedstoneRepeater( 93, false );
+    public static BlockRedstoneRepeater redstoneRepeaterActive = new FCBlockRedstoneRepeater( 94, true );
 
     /**
      * April fools secret locked chest, only spawns on new chunks on 1st April.
      */
-    public static final Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
-    public static final Block trapdoor = (new BlockTrapDoor(96, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("trapdoor").disableStats();
-    public static final Block silverfish = (new BlockSilverfish(97)).setHardness(0.75F).setUnlocalizedName("monsterStoneEgg");
-    public static final Block stoneBrick = (new BlockStoneBrick(98)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebricksmooth");
-    public static final Block mushroomCapBrown = (new BlockMushroomCap(99, Material.wood, 0)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("mushroom");
-    public static final Block mushroomCapRed = (new BlockMushroomCap(100, Material.wood, 1)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("mushroom");
-    public static final Block fenceIron = (new BlockPane(101, "fenceIron", "fenceIron", Material.iron, true)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("fenceIron");
-    public static final Block thinGlass = (new BlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
-    public static final Block melon = (new BlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
-    public static final Block pumpkinStem = (new BlockStem(104, pumpkin)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkinStem");
-    public static final Block melonStem = (new BlockStem(105, melon)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkinStem");
-    public static final Block vine = (new BlockVine(106)).setHardness(0.2F).setStepSound(soundGrassFootstep).setUnlocalizedName("vine");
-    public static final Block fenceGate = (new BlockFenceGate(107)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fenceGate");
-    public static final Block stairsBrick = (new BlockStairs(108, brick, 0)).setUnlocalizedName("stairsBrick");
-    public static final Block stairsStoneBrick = (new BlockStairs(109, stoneBrick, 0)).setUnlocalizedName("stairsStoneBrickSmooth");
-    public static final BlockMycelium mycelium = (BlockMycelium)(new BlockMycelium(110)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("mycel");
-    public static final Block waterlily = (new BlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
-    public static final Block netherBrick = (new Block(112, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherBrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block netherFence = (new BlockFence(113, "netherBrick", Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
-    public static final Block stairsNetherBrick = (new BlockStairs(114, netherBrick, 0)).setUnlocalizedName("stairsNetherBrick");
-    public static final Block netherStalk = (new BlockNetherStalk(115)).setUnlocalizedName("netherStalk");
-    public static final Block enchantmentTable = (new BlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
-    public static final Block brewingStand = (new BlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
-    public static final BlockCauldron cauldron = (BlockCauldron)(new BlockCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
-    public static final Block endPortal = (new BlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
-    public static final Block endPortalFrame = (new BlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
-
-    /** The rock found in The End. */
-    public static final Block whiteStone = (new Block(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dragonEgg = (new BlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
-    public static final Block redstoneLampIdle = (new BlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block redstoneLampActive = (new BlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
-    public static final BlockHalfSlab woodDoubleSlab = (BlockHalfSlab)(new BlockWoodSlab(125, true)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("woodSlab");
-    public static final BlockHalfSlab woodSingleSlab = (BlockHalfSlab)(new BlockWoodSlab(126, false)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("woodSlab");
-    public static final Block cocoaPlant = (new BlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
-    public static final Block stairsSandStone = (new BlockStairs(128, sandStone, 0)).setUnlocalizedName("stairsSandStone");
-    public static final Block oreEmerald = (new BlockOre(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
-    public static final Block enderChest = (new BlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
-    public static final BlockTripWireSource tripWireSource = (BlockTripWireSource)(new BlockTripWireSource(131)).setUnlocalizedName("tripWireSource");
-    public static final Block tripWire = (new BlockTripWire(132)).setUnlocalizedName("tripWire");
-    public static final Block blockEmerald = (new BlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
-    public static final Block stairsWoodSpruce = (new BlockStairs(134, planks, 1)).setUnlocalizedName("stairsWoodSpruce");
-    public static final Block stairsWoodBirch = (new BlockStairs(135, planks, 2)).setUnlocalizedName("stairsWoodBirch");
-    public static final Block stairsWoodJungle = (new BlockStairs(136, planks, 3)).setUnlocalizedName("stairsWoodJungle");
-    public static final Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
-    public static final BlockBeacon beacon = (BlockBeacon)(new BlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
-    public static final Block cobblestoneWall = (new BlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
-    public static final Block flowerPot = (new BlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
-    public static final Block carrot = (new BlockCarrot(141)).setUnlocalizedName("carrots");
-    public static final Block potato = (new BlockPotato(142)).setUnlocalizedName("potatoes");
-    public static final Block woodenButton = (new BlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
-    public static final Block skull = (new BlockSkull(144)).setHardness(1.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("skull");
-    public static final Block anvil = (new BlockAnvil(145)).setHardness(5.0F).setStepSound(soundAnvilFootstep).setResistance(2000.0F).setUnlocalizedName("anvil");
-    public static final Block chestTrapped = (new BlockChest(146, 1)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("chestTrap");
-    public static final Block pressurePlateGold = (new BlockPressurePlateWeighted(147, "blockGold", Material.iron, 64)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("weightedPlate_light");
-    public static final Block pressurePlateIron = (new BlockPressurePlateWeighted(148, "blockIron", Material.iron, 640)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("weightedPlate_heavy");
-    public static final BlockComparator redstoneComparatorIdle = (BlockComparator)(new BlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockComparator redstoneComparatorActive = (BlockComparator)(new BlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new BlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
-    public static final Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone");
-    public static final Block oreNetherQuartz = (new BlockOre(153)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherquartz");
-    public static final BlockHopper hopperBlock = (BlockHopper)(new BlockHopper(154)).setHardness(3.0F).setResistance(8.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("hopper");
-    public static final Block blockNetherQuartz = (new BlockQuartz(155)).setStepSound(soundStoneFootstep).setHardness(0.8F).setUnlocalizedName("quartzBlock");
-    public static final Block stairsNetherQuartz = (new BlockStairs(156, blockNetherQuartz, 0)).setUnlocalizedName("stairsQuartz");
-    public static final Block railActivator = (new BlockRailPowered(157)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("activatorRail");
-    public static final Block dropper = (new BlockDropper(158)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dropper");
+    public static Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
+    public static Block trapdoor = new FCBlockTrapDoor( 96 );
+    public static Block silverfish = new FCBlockSilverfish( 97 );
+    public static Block stoneBrick = new FCBlockStoneBrick( 98 );
+    public static Block mushroomCapBrown = new FCBlockMushroomCapLegacy( 99, 0 );
+    public static Block mushroomCapRed = new FCBlockMushroomCapLegacy( 100, 1 );
+    public static Block fenceIron = new FCBlockIronBars( 101 );
+    public static Block thinGlass = (new FCBlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).SetPicksEffectiveOn().setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
+    public static Block melon = (new FCBlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
+    public static Block pumpkinStem = new FCBlockStem( 104, pumpkin );
+    public static Block melonStem = new FCBlockStem( 105, melon );
+    public static Block vine = new FCBlockVine( 106 );
+    public static Block fenceGate = new FCBlockFenceGate( 107 );
+    public static Block stairsBrick = (new FCBlockStairsBrick(108)).setUnlocalizedName("stairsBrick");
+    public static Block stairsStoneBrick = new FCBlockStairsStoneBrick( 109 );
+    public static BlockMycelium mycelium = new FCBlockMycelium( 110 );
+    public static Block waterlily = (new FCBlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
+    public static Block netherBrick = new FCBlockNetherBrick( 112 );
+    public static Block netherFence = (new FCBlockFence( 113, "netherBrick", FCBetterThanWolves.fcMaterialNetherRock )).setHardness(2F).setResistance(10F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
+    public static Block stairsNetherBrick = new FCBlockStairsNetherBrick( 114 );
+    public static Block netherStalk = (new FCBlockNetherStalk(115)).setUnlocalizedName("netherStalk");
+    public static Block enchantmentTable = (new FCBlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
+    public static Block brewingStand = (new FCBlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
+    public static BlockCauldron cauldron = (BlockCauldron)(new FCBlockVanillaCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
+    public static Block endPortal = (new FCBlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
+    public static Block endPortalFrame = (new FCBlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
+    public static Block whiteStone = (new FCBlockEndStone(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block dragonEgg = (new FCBlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
+    public static Block redstoneLampIdle = (new FCBlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
+    public static Block redstoneLampActive = (new FCBlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
+    public static BlockHalfSlab woodDoubleSlab = new FCBlockWoodSlab( 125, true );
+    public static BlockHalfSlab woodSingleSlab = new FCBlockWoodSlab( 126, false );
+    public static Block cocoaPlant = (new FCBlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).SetBuoyant().setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
+    public static Block stairsSandStone = (new FCBlockStairsSandStone(128)).setUnlocalizedName("stairsSandStone");
+    public static Block oreEmerald = (new FCBlockOreEmerald(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
+    public static Block enderChest = (new FCBlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
+    public static BlockTripWireSource tripWireSource = new FCBlockTripWireSource( 131 );
+    public static Block tripWire = (new FCBlockTripWire(132)).setUnlocalizedName("tripWire");
+    public static Block blockEmerald = (new FCBlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
+    public static Block stairsWoodSpruce = ( new FCBlockStairsWood( 134, planks, 1 ) ).setUnlocalizedName( "stairsWoodSpruce" );
+    public static Block stairsWoodBirch = ( new FCBlockStairsWood( 135, planks, 2 ) ).setUnlocalizedName( "stairsWoodBirch" );
+    public static Block stairsWoodJungle = ( new FCBlockStairsWood( 136, planks, 3 ) ).setUnlocalizedName( "stairsWoodJungle" );
+    public static Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
+    public static BlockBeacon beacon = (BlockBeacon)(new FCBlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
+    public static Block cobblestoneWall = (new FCBlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
+    public static Block flowerPot = (new FCBlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
+    public static Block carrot = (new FCBlockCarrot(141)).setUnlocalizedName("carrots");
+    public static Block potato = (new FCBlockPotato(142)).setUnlocalizedName("potatoes");
+    public static Block woodenButton = (new FCBlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
+    public static Block skull = new FCBlockSkull( 144 );
+    public static Block anvil = new FCBlockAnvil( 145 );
+    public static Block chestTrapped = new FCBlockStub( 146 ).setUnlocalizedName( "chestTrap" );
+    public static Block pressurePlateGold = new FCBlockStub( 147 ).setUnlocalizedName( "weightedPlate_light" );
+    public static Block pressurePlateIron = new FCBlockStub( 148 ).setUnlocalizedName( "weightedPlate_heavy" );
+    public static BlockComparator redstoneComparatorIdle = (BlockComparator)(new FCBlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
+    public static BlockComparator redstoneComparatorActive = (BlockComparator)(new FCBlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
+    public static BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new FCBlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
+    public static Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone").setLightValue(0.75F);
+    public static Block oreNetherQuartz = new FCBlockNetherQuartzOre( 153 );
+    public static BlockHopper hopperBlock = new FCBlockVanillaHopper( 154 );
+    public static Block blockNetherQuartz = new FCBlockBlackStone( 155 );
+    public static Block stairsNetherQuartz = new FCBlockBlackStoneStairs( 156 );
+    public static Block railActivator = new FCBlockStub( 157 ).setUnlocalizedName( "activatorRail" );
+    public static Block dropper = new FCBlockStub( 158 ).setUnlocalizedName( "dropper" );
 
     /** ID of the block. */
     public final int blockID;
@@ -244,31 +246,26 @@ public class Block
     /** true if the Block contains a Tile Entity */
     protected boolean isBlockContainer;
 
-    /** minimum X for the block bounds (local coordinates) */
-    protected double minX;
-
-    /** minimum Y for the block bounds (local coordinates) */
-    protected double minY;
-
-    /** minimum Z for the block bounds (local coordinates) */
-    protected double minZ;
-
-    /** maximum X for the block bounds (local coordinates) */
-    protected double maxX;
-
-    /** maximum Y for the block bounds (local coordinates) */
-    protected double maxY;
-
-    /** maximum Z for the block bounds (local coordinates) */
-    protected double maxZ;
+    /** FCNOTE: DEPRECATED */
+    protected double minX = 0D;
+    /** FCNOTE: DEPRECATED */
+    protected double minY = 0D;
+    /** FCNOTE: DEPRECATED */
+    protected double minZ = 0D;
+    /** FCNOTE: DEPRECATED */
+    protected double maxX = 1D;
+    /** FCNOTE: DEPRECATED */
+    protected double maxY = 1D;
+    /** FCNOTE: DEPRECATED */
+    protected double maxZ = 1D;
 
     /** Sound of stepping on the block */
     public StepSound stepSound;
     public float blockParticleGravity;
 
     /** Block material definition. */
-    public final Material blockMaterial;
-
+    public Material blockMaterial;
+    
     /**
      * Determines how much velocity is maintained while moving on top of this block
      */
@@ -277,6 +274,13 @@ public class Block
     /** The unlocalized name of this block. */
     private String unlocalizedName;
     protected Icon blockIcon;
+    
+    public static final boolean[] blockReplaced = new boolean[4096];
+    
+    private int idDroppedOnStonecut = -1;
+    private int countDroppedOnStonecut = 0;
+    private int metaDroppedOnStonecut = 0;
+    private MapColor[] mapColorsForMetadata;
 
     protected Block(int par1, Material par2Material)
     {
@@ -297,6 +301,10 @@ public class Block
             opaqueCubeLookup[par1] = this.isOpaqueCube();
             lightOpacity[par1] = this.isOpaqueCube() ? 255 : 0;
             canBlockGrass[par1] = !par2Material.getCanBlockGrass();
+            // FCMOD: Added
+            useNeighborBrightness[par1] = false;
+            SetFilterableProperties( Item.m_iFilterable_SolidBlock );
+            // END FCMOD
         }
     }
 
@@ -346,7 +354,12 @@ public class Block
     public static boolean isNormalCube(int par0)
     {
         Block var1 = blocksList[par0];
+        // FCMOD: Changed this to not care about providing power (this is the way it used to work)
+        /*
         return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock() && !var1.canProvidePower();
+        */
+        return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock();
+        // END FCMOD
     }
 
     /**
@@ -357,6 +370,9 @@ public class Block
         return true;
     }
 
+	/**
+	 * FCNOTE: This is misnamed and returns true if the block *doesn't* block movement
+	 */	
     public boolean getBlocksMovement(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         return !this.blockMaterial.blocksMovement();
@@ -426,16 +442,20 @@ public class Block
     }
 
     /**
-     * Sets the bounds of the block.  minX, minY, minZ, maxX, maxY, maxZ
+     * FCNOTE: DEPRECATED 
      */
     protected final void setBlockBounds(float par1, float par2, float par3, float par4, float par5, float par6)
     {
+    	// FCMOD: Removed due to deprecating these variables to eliminate client/server race conditions
+    	/*
         this.minX = (double)par1;
         this.minY = (double)par2;
         this.minZ = (double)par3;
         this.maxX = (double)par4;
         this.maxY = (double)par5;
         this.maxZ = (double)par6;
+        */
+    	// END FCMOD
     }
 
     /**
@@ -458,10 +478,14 @@ public class Block
      * Returns true if the given side of this block type should be rendered, if the adjacent block is at the given
      * coordinates.  Args: blockAccess, x, y, z, side
      */
+    // FCMOD: Code removed and replaced later.  Client only.
+    /*
     public boolean shouldSideBeRendered(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)
     {
         return par5 == 0 && this.minY > 0.0D ? true : (par5 == 1 && this.maxY < 1.0D ? true : (par5 == 2 && this.minZ > 0.0D ? true : (par5 == 3 && this.maxZ < 1.0D ? true : (par5 == 4 && this.minX > 0.0D ? true : (par5 == 5 && this.maxX < 1.0D ? true : !par1IBlockAccess.isBlockOpaqueCube(par2, par3, par4))))));
     }
+    */
+    // END FCMOD
 
     /**
      * Returns Returns true if the given side of this block type should be rendered (if it's solid or not), if the
@@ -499,14 +523,19 @@ public class Block
     /**
      * Returns the bounding box of the wired rectangular prism to render.
      */
+    // FCMOD: Removed and replaced
+    /*
     public AxisAlignedBB getSelectedBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
     {
         return AxisAlignedBB.getAABBPool().getAABB((double)par2 + this.minX, (double)par3 + this.minY, (double)par4 + this.minZ, (double)par2 + this.maxX, (double)par3 + this.maxY, (double)par4 + this.maxZ);
     }
+    */
+    // END FCMOD
 
     /**
      * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
      * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
+     * FCNOTE: The "mask" referred to above is just the bounding box to check for intersection with
      */
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
@@ -522,10 +551,14 @@ public class Block
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
      * cleared to be reused)
      */
+    // FCMOD: Removed and replaced
+    /*
     public AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
     {
         return AxisAlignedBB.getAABBPool().getAABB((double)par2 + this.minX, (double)par3 + this.minY, (double)par4 + this.minZ, (double)par2 + this.maxX, (double)par3 + this.maxY, (double)par4 + this.maxZ);
     }
+    */
+    // END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -554,6 +587,7 @@ public class Block
 
     /**
      * Ticks the block if it's been scheduled
+     * FCNOTE: Called on server only
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random) {}
 
@@ -564,12 +598,14 @@ public class Block
 
     /**
      * Called right before the block is destroyed by a player.  Args: world, x, y, z, metaData
+     * FCNOTE: Called AFTER block is set to air, not before
      */
     public void onBlockDestroyedByPlayer(World par1World, int par2, int par3, int par4, int par5) {}
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
+     * FCNOTE: Only called on server
      */
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5) {}
 
@@ -583,11 +619,13 @@ public class Block
 
     /**
      * Called whenever the block is added into the world. Args: world, x, y, z
+     * FCNOTE: Called on server only
      */
     public void onBlockAdded(World par1World, int par2, int par3, int par4) {}
 
     /**
      * ejects contained items into the world, and notifies neighbours of an update, as appropriate
+     * FCNOTE: Called on server only.  Called AFTER block is set, so it is no longer valid at pos.
      */
     public void breakBlock(World par1World, int par2, int par3, int par4, int par5, int par6) {}
 
@@ -611,11 +649,15 @@ public class Block
      * Gets the hardness of block at the given coordinates in the given world, relative to the ability of the given
      * EntityPlayer.
      */
+    // FCMOD: Removed and replaced later
+    /*
     public float getPlayerRelativeBlockHardness(EntityPlayer par1EntityPlayer, World par2World, int par3, int par4, int par5)
     {
         float var6 = this.getBlockHardness(par2World, par3, par4, par5);
         return var6 < 0.0F ? 0.0F : (!par1EntityPlayer.canHarvestBlock(this) ? par1EntityPlayer.getCurrentPlayerStrVsBlock(this, false) / var6 / 100.0F : par1EntityPlayer.getCurrentPlayerStrVsBlock(this, true) / var6 / 30.0F);
     }
+    */
+    // END FCMOD
 
     /**
      * Drops the specified block items
@@ -671,6 +713,8 @@ public class Block
      */
     protected void dropXpOnBlockBreak(World par1World, int par2, int par3, int par4, int par5)
     {
+    	// FCMOD: Code removed
+    	/*
         if (!par1World.isRemote)
         {
             while (par5 > 0)
@@ -680,6 +724,8 @@ public class Block
                 par1World.spawnEntityInWorld(new EntityXPOrb(par1World, (double)par2 + 0.5D, (double)par3 + 0.5D, (double)par4 + 0.5D, var6));
             }
         }
+        */
+    	// END FCMOD
     }
 
     /**
@@ -702,6 +748,8 @@ public class Block
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
+    // FCMOD: Removed and replaced
+    /*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
@@ -818,29 +866,22 @@ public class Block
         }
     }
 
-    /**
-     * Checks if a vector is within the Y and Z bounds of the block.
-     */
     private boolean isVecInsideYZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
-    /**
-     * Checks if a vector is within the X and Z bounds of the block.
-     */
     private boolean isVecInsideXZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
-    /**
-     * Checks if a vector is within the X and Y bounds of the block.
-     */
     private boolean isVecInsideXYBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY;
     }
+    */
+    // END FCMOD
 
     /**
      * Called upon the block being destroyed by an explosion
@@ -908,9 +949,7 @@ public class Block
      */
     public void velocityToAddToEntity(World par1World, int par2, int par3, int par4, Entity par5Entity, Vec3 par6Vec3) {}
 
-    /**
-     * Updates the blocks bounds based on its current state. Args: world, x, y, z
-     */
+    /** FCNOTE: DEPRECATED */
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4) {}
 
     /**
@@ -963,7 +1002,7 @@ public class Block
 
     public int getBlockColor()
     {
-        return 16777215;
+        return ColorizeBlock.colorizeBlock(this) ? ColorizeBlock.blockColor : 16777215;
     }
 
     /**
@@ -971,7 +1010,7 @@ public class Block
      */
     public int getRenderColor(int par1)
     {
-        return 16777215;
+        return ColorizeBlock.colorizeBlock(this, par1) ? ColorizeBlock.blockColor : 16777215;
     }
 
     /**
@@ -980,7 +1019,7 @@ public class Block
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        return 16777215;
+        return ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4) ? ColorizeBlock.blockColor : 16777215;
     }
 
     /**
@@ -1023,13 +1062,22 @@ public class Block
     /**
      * Called when the player destroys a block with an item that can harvest it. (i, j, k) are the coordinates of the
      * block and l is the block's subtype/damage.
+     * FCNOTE: Only called on server
      */
     public void harvestBlock(World par1World, EntityPlayer par2EntityPlayer, int par3, int par4, int par5, int par6)
     {
         par2EntityPlayer.addStat(StatList.mineBlockStatArray[this.blockID], 1);
-        par2EntityPlayer.addExhaustion(0.025F);
 
+        // FCMOD: Changed
+        /*
+        par2EntityPlayer.addExhaustion(0.025F);
+        
         if (this.canSilkHarvest() && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
+        */        
+        par2EntityPlayer.AddHarvestBlockExhaustion( blockID, par3, par4, par5, par6 );        
+        
+        if ( this.canSilkHarvest( par6 ) && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
+    	// END FCMOD
         {
             ItemStack var8 = this.createStackedBlock(par6);
 
@@ -1056,6 +1104,7 @@ public class Block
     /**
      * Returns an item stack containing a single instance of the current block type. 'i' is the block's subtype/damage
      * and is ignored for blocks which do not support subtypes. Blocks which cannot be harvested should return null.
+     * FCNOTE: This is the function used to create the silk-touch drop
      */
     protected ItemStack createStackedBlock(int par1)
     {
@@ -1087,6 +1136,7 @@ public class Block
 
     /**
      * Called when the block is placed in the world.
+     * FCNOTE: Called AFTER the block is placed, unlike onBlockPlaced()
      */
     public void onBlockPlacedBy(World par1World, int par2, int par3, int par4, EntityLiving par5EntityLiving, ItemStack par6ItemStack) {}
 
@@ -1154,6 +1204,7 @@ public class Block
     /**
      * Returns the mobility information of the block, 0 = free, 1 = can't push but can move over, 2 = total immobility
      * and stop pistons
+     * FCMOD: 3 = can be piston shoveled, but free otherwise 
      */
     public int getMobilityFlag()
     {
@@ -1175,6 +1226,7 @@ public class Block
 
     /**
      * only called by clickMiddleMouseButton , and passed to inventory.setCurrentItem (along with isCreative)
+     * FCNOTE: Client only
      */
     public int idPicked(World par1World, int par2, int par3, int par4)
     {
@@ -1336,8 +1388,12 @@ public class Block
                     blocksList[var0].initializeBlock();
                 }
 
+                // FCMOD: Changed to not overwrite settings in block classes and to instead set
+                // useNeighborBrightness[] in block classes for most cases instead.
+                /*
                 boolean var1 = false;
 
+                // FCNOTE: renderType 10 is used by vanilla stairs
                 if (var0 > 0 && blocksList[var0].getRenderType() == 10)
                 {
                     var1 = true;
@@ -1364,10 +1420,2431 @@ public class Block
                 }
 
                 useNeighborBrightness[var0] = var1;
+                */
+                if ( canBlockGrass[var0] || lightOpacity[var0] == 0 )
+                {
+                	useNeighborBrightness[var0] = true;
+                }
+                // END FCMOD
             }
         }
 
         canBlockGrass[0] = true;
         StatList.initBreakableStats();
     }
+    
+    // FCMOD: Added New
+	private static final int[] m_iRotatedFacingsAroundJClockwise = 
+		new int[] { 0, 1, 4, 5, 3, 2 };
+	
+	private static final int[] m_iRotatedFacingsAroundJCounterclockwise = 
+		new int[] { 0, 1, 5, 4, 2, 3 };
+	
+	private static final int[] m_iCycledFacings = 
+		new int[] { 4, 0, 1, 5, 3, 2 };
+	
+	private static final int[] m_iCycledFacingsReversed = 
+		new int[] { 1, 2, 5, 4, 0, 3 };
+	
+    public boolean IsNormalCube( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return blockMaterial.isOpaque() && renderAsNormalBlock();
+    }
+    
+    /**
+     * Similar to onBlockPlacedBy() but called before the block is placed rather than after
+     */
+    public int PreBlockPlacedBy( World world, int i, int j, int k, int iMetadata, EntityLiving entityBy ) 
+    {
+    	return iMetadata;    	
+    }
+
+    public void SetBlockMaterial( Material material )
+    {
+    	blockMaterial = material;
+    	
+        canBlockGrass[blockID] = !material.getCanBlockGrass();    	
+    }
+    
+    /**
+     * Called on server only
+     */
+    public void RandomUpdateTick( World world, int i, int j, int k, Random rand )
+    {
+    	updateTick( world, i, j, k, rand );
+    }
+    
+	public void ClientNotificationOfMetadataChange( World world, int i, int j, int k, int iOldMetadata, int iNewMetadata )
+	{
+	}
+	
+    public void OnArrowImpact( World world, int i, int j, int k, EntityArrow arrow )
+    {
+    }
+    
+    public void OnArrowCollide( World world, int i, int j, int k, EntityArrow arrow )
+    {
+    }
+    
+    public float GetMovementModifier( World world, int i, int j, int k )
+    {
+    	float fModifier = 1.0F;
+    	
+		if ( blockMaterial != Material.ground && blockMaterial != Material.grass )
+		{
+			fModifier *= 1.2F;
+		}
+    	
+    	return fModifier;
+    }
+    
+    public void OnPlayerWalksOnBlock( World world, int i, int j, int k, EntityPlayer player )
+    {    	
+		// Disabled Hardcore sinkholes
+    	/*
+    	if ( IsFallingBlock( world, i, j, k ) )
+    	{
+    		CheckForUnstableGround( world, i, j, k );
+    	}
+    	*/
+    }
+    
+    /**
+     * Applies to Hopper ejecting items into the world, not inserting into the block itself
+     */
+    public boolean DoesBlockHopperEject( World world, int i, int j, int k )
+    {
+    	return blockMaterial.isSolid();
+    }
+
+    /**
+     * Applies to Hopper inserting items directly into the block's inventory.  This
+     * does not ensure the block has a valid inventory, it's just a first-pass chance
+     * to block such behavior.
+     */
+    public boolean DoesBlockHopperInsert( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    /**
+     * Returns true if the block is warm enough to melt nearby snow or ice
+     */
+    public boolean GetIsBlockWarm( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public StepSound GetStepSound( World world, int i, int j, int k )
+    {
+    	return stepSound;
+    }
+    
+    public void ClientBreakBlock( World world, int i, int j, int k, int iBlockID, int iMetadata )
+    {
+    }
+    
+    public void ClientBlockAdded( World world, int i, int j, int k )
+    {
+    }
+    
+    public boolean HasStrata()
+    {
+    	return false;
+    }
+    
+    public int GetMetadataConversionForStrataLevel( int iLevel, int iMetadata )
+    {
+    	return iMetadata;
+    }
+    
+    public float getExplosionResistance( Entity entity, World world, int i, int j, int k )
+    {
+        return getExplosionResistance( entity );
+    }
+    
+    public boolean CanBlockStayDuringGenerate( World world, int i, int j, int k )
+    {
+    	// breaking this off into a separate function so that we can prevent certain blocks (like mushrooms) spawning under certain conditions without messing up worldgen or
+    	// its usual growth conditions
+    	
+    	// NOTE: This function isn't called for all types of WorldGen to avoid excessive base class changes where not needed.  If you want to override it, make sure it is called
+    	// appropriately for the block in question first.
+    	
+    	return canBlockStay( world, i, j, k );
+    }
+    
+    /**
+     * Used to determine if this is a stair block for purposes of connecting visually to others
+     */
+    public boolean IsStairBlock()
+    {
+    	return false;
+    }
+    
+    public boolean ShouldDeleteTileEntityOnBlockChange( int iNewBlockID )
+    {
+    	return true;
+    }
+
+    /** 
+     * Determines whether other stone will "connect" to this block for purposes of determing whether
+     * a stone block can be individually harvested without breaking apart
+     */
+    public boolean IsNaturalStone( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+
+    static public AxisAlignedBB GetFulBlockBoundingBoxFromPool( World world, int i, int j, int k )
+    {
+    	return AxisAlignedBB.getAABBPool().getAABB(
+    		(float)i, (float)j, (float)k, 
+    		(float)i + 1.0F, (float)j + 1.0F, (float)k + 1.0F );	    	
+    }
+    
+    public boolean CanSpitWebReplaceBlock( World world, int i, int j, int k )
+    {
+    	return IsGroundCover( ) || IsAirBlock();
+    }
+    
+    public boolean IsAirBlock()
+    {
+    	return false;
+    }
+    
+    public boolean IsReplaceableVegetation( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+	public boolean HasWaterToSidesOrTop( World world, int i, int j, int k )
+	{
+		for ( int iFacing = 1; iFacing <= 5; iFacing++ )
+		{		
+			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iFacing );
+		
+			int iTempBlockID = world.getBlockId( tempPos.i, tempPos.j, tempPos.k );
+			Block tempBlock = Block.blocksList[iTempBlockID];
+			
+			if ( tempBlock != null && tempBlock.blockMaterial == Material.water )
+			{
+				return true;
+			}			
+		}
+		
+		return false;
+	}
+	
+	public boolean GetPreventsFluidFlow( World world, int i, int j, int k, Block fluidBlock )
+	{
+        return blockMaterial == Material.portal ? true : blockMaterial.blocksMovement();
+	}
+
+	public void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid fluidBlock )
+	{
+        dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+	}
+
+	public boolean IsBlockClimbable( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/** 
+	 * Whether or not the block sets off Buddy Blocks.  Set to false for stuff like redstone blocks
+	 * that can cause feedback loops.
+	 */
+	public boolean TriggersBuddy()
+	{
+		return true;
+	}
+	
+    //------------ Addon interfacing related functionality ----------//
+	
+    /**
+     * Replaces a reference to an existing block (vanilla or btw)
+     * @param id The block id to be replaced
+     * @param newClass The class of the new block
+     * @param parameters Optional additional parameters to pass to the block, not including the id.
+     */
+    public static Block replaceBlock(int id, Class newClass, Object ... parameters) {
+    	if (blockReplaced[id]) {
+    		throw new RuntimeException("Multiple addons attempting to replace block " + blocksList[id]);
+    	}
+    	else {
+    		Block newBlock = null;
+    		
+    		Class[] parameterTypes = new Class[parameters.length + 1];
+    		Object[] parameterValues = new Object[parameters.length + 1];
+    		
+    		parameterTypes[0] = Integer.TYPE;
+    		parameterValues[0] = id;
+
+    		Block original = blocksList[id];
+    		blocksList[id] = null;
+    		
+    		for (int i = 0; i < parameters.length; i++) {
+    			Class<?> type = parameters[i].getClass();
+    			
+    			if (type == Integer.class) {
+    				type = Integer.TYPE;
+    			}
+    			else if (type == Boolean.class) {
+    				type = Boolean.TYPE;
+    			}
+    			else if (type == Float.class) {
+    				type = Float.TYPE;
+    			}
+    			else if (type == Double.class) {
+    				type = Double.TYPE;
+    			}
+    			else if (Block.class.isAssignableFrom(type)) {
+    				type = Block.class;
+    			}
+    			else if (Item.class.isAssignableFrom(type)) {
+    				type = Item.class;
+    			}
+    			else if (Material.class.isAssignableFrom(type)) {
+    				type = Material.class;
+    			}
+    			
+    			parameterTypes[i + 1] = type;
+    			parameterValues[i + 1] = parameters[i];
+    		}
+    		
+    		try {
+    			newBlock = (Block) newClass.getConstructor(parameterTypes).newInstance(parameterValues);
+    		} catch (InstantiationException e) {
+    			throw new RuntimeException("A problem has occured attempting to instantiate replacement for " + blocksList[id]);
+    		} catch (IllegalArgumentException e) {
+    			throw new RuntimeException("Incompatible types passed to specified constructor for " + blocksList[id]);
+    		} catch (NoSuchMethodException e) {
+    			throw new RuntimeException("No appropriate constructor found for " + blocksList[id] + ". Constructors must be public to be used in replacement.");
+    		} catch (Exception e) {
+    			e.printStackTrace();
+    		}
+    		
+    		blockReplaced[id] = true;
+    		
+    		newBlock.setHardness(original.blockHardness).setResistance(original.blockResistance).setStepSound(original.stepSound).setUnlocalizedName(original.unlocalizedName).setCreativeTab(original.getCreativeTabToDisplayOn());
+    		if (!original.enableStats)
+    			newBlock.disableStats();
+    		
+    		blocksList[id] = newBlock;
+    		
+    		return newBlock;
+    	}
+    }
+	
+    //------------ Harvesting related functionality ----------//
+    
+    protected boolean canSilkHarvest( int iMetadata )
+    {
+    	return canSilkHarvest();
+    }
+    
+    /**
+     * Called on server only, after the block is removed from the world
+     */
+    public void OnBlockDestroyedWithImproperTool( World world, EntityPlayer player, int i, int j, int k, int iMetadata )
+    {
+        world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyedWithImproperToolAuxFXID, i, j, k, blockID + ( iMetadata << 12 ) );
+    	
+    	DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, 1F );
+    }
+    
+    protected void DropItemsIndividualy( World world, int i, int j, int k, int iIDDropped, int iPileCount, int iDamageDropped, float fChanceOfPileDrop )
+	{
+    	for ( int iTempCount = 0; iTempCount < iPileCount; iTempCount++ )
+    	{
+    		if ( world.rand.nextFloat() <= fChanceOfPileDrop )
+    		{
+	    		ItemStack stack = new ItemStack( iIDDropped, 1, iDamageDropped );
+	    		
+	            dropBlockAsItem_do( world, i, j, k, stack );
+    		}
+    	}
+	}
+    
+    /**
+     * Called by explosions and improper tool use.  
+     * Should return true if the block processes its own drops through this method, false otherwise
+     * Note that the block may no longer be at the specified position when this is called
+     */
+    public boolean DropComponentItemsOnBadBreak( World world, int i, int j, int k, int iMetadata, float fChanceOfDrop )
+    {
+    	return false;
+    }
+    
+    /**
+     * Explosion may be null if this is called by a mining charge
+     */
+    public void DropItemsOnDestroyedByExplosion( World world, int i, int j, int k, Explosion explosion )
+    {
+        if ( !world.isRemote && canDropFromExplosion( explosion ) )
+        {
+        	float fChance = 1F;
+        	
+        	if ( explosion != null )
+        	{
+        		fChance /= explosion.explosionSize;
+        	}
+        	
+        	int iMetadata = world.getBlockMetadata( i, j, k );
+
+        	if ( !DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, fChance ) )
+        	{
+        		dropBlockAsItemWithChance( world, i, j, k, iMetadata, fChance, 0 );
+        	}
+        }
+    }
+
+    /**
+     * Notifies neighbors of dirt blocks that they should be loosened
+     */
+    protected void OnDirtDugWithImproperTool( World world, int i, int j, int k )
+    {
+    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+    	{
+    		NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );    		    		
+    	}
+    }
+    
+    protected void OnDirtSlabDugWithImproperTool( World world, int i, int j, int k, 
+    	boolean bUpsideDown )
+    {
+    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+    	{
+	        if ( !( bUpsideDown && iTempFacing == 0 ) && !( !bUpsideDown && iTempFacing == 1 ) )
+	        {
+	        	NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );
+	        }
+    	}
+    }
+    
+    protected void NotifyNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
+    	int iToFacing )
+    {
+		FCUtilsBlockPos neighborPos = new FCUtilsBlockPos( i, j, k, iToFacing );
+		
+		int iTargetBlockID = world.getBlockId( neighborPos.i, neighborPos.j, neighborPos.k );
+		
+		Block targetBlock = blocksList[iTargetBlockID];
+		
+		if ( targetBlock != null )
+		{    	
+			targetBlock.OnNeighborDirtDugWithImproperTool( world, 
+				neighborPos.i, neighborPos.j, neighborPos.k, GetOppositeFacing( iToFacing ) );
+		}    		
+    }
+    
+    protected void OnNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
+    	int iToFacing )
+    {
+    }
+    
+    //------------ Hard Point related functionality ----------//
+    
+	/**
+	 * small attachment surfaces, like those required for the bottom of a torch (approx 1/8 block width)
+	 */
+	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+	}
+	
+	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasSmallCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+	}
+
+	/**
+	 * medium sized attachment points like the top of fence posts (approx 1/4 block width)
+	 */
+	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+	}
+
+	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+	}
+
+	/**
+	 * large attachment points that can support a full block width
+	 */	
+	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+
+	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+	}
+	
+	/**
+	 * returns true if the block is sitting on the one below, like a torch resting on the ground
+	 */
+	public boolean IsBlockRestingOnThatBelow( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * returns true if block is attached to a block in a particular direction.  Example: pumpkins attached to stems
+	 */
+	public boolean IsBlockAttachedToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return false;
+	}
+	
+	public void AttachToFacing( World world, int i, int j, int k, int iFacing )
+	{
+	}
+	
+	public boolean HasContactPointToFullFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+	
+	public boolean HasContactPointToSlabSideFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIsSlabUpsideDown )
+	{
+		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+	}
+	
+	/**
+	 * This method refers to the 'L' shaped sides of stair blocks.  Other stair facings will refernce either the full face, stair top,
+	 * or slab methods, depending on their shape
+	 */
+	public boolean HasContactPointToStairShapedFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+	{
+		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+	}
+	
+	/**
+	 * This method refers to the half-block shaped top or bottom of stair blocks.
+	 */
+	public boolean HasContactPointToStairNarrowVerticalFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, int iStairFacing )
+	{
+		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+	}
+	
+	/**
+	 * Should return true if mortar has been successfully applied to block.
+	 */
+	public boolean OnMortarApplied( World world, int i, int j, int k )
+	{
+		return false;
+	}
+	
+	public boolean HasMortar( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+	
+    public boolean HasNeighborWithMortarInContact( World world, int i, int j, int k )
+    {
+    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+    	{
+    		if ( FCUtilsWorld.HasNeighborWithMortarInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
+			{
+				return true;
+			}
+    	}
+    	
+    	return false;
+    }
+    
+	public boolean IsStickyToSnow( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+	
+    public boolean HasStickySnowNeighborInContact( World world, int i, int j, int k )
+    {
+    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+    	{
+    		if ( FCUtilsWorld.HasStickySnowNeighborInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
+			{
+				return true;
+			}
+    	}
+    	
+    	return false;
+    }
+    
+    //--------------- Fire related functionality -------------//
+    
+    private int m_iDefaultFurnaceBurnTime = 0;    
+    
+    public int GetFurnaceBurnTime( int iItemDamage )
+    {
+    	return m_iDefaultFurnaceBurnTime;
+    }
+    
+    public void SetFurnaceBurnTime( int iBurnTime )
+    {
+    	m_iDefaultFurnaceBurnTime = iBurnTime;
+    }
+    
+    public void SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
+    {
+    	SetFurnaceBurnTime( burnTime.m_iBurnTime );
+    }
+    
+    public boolean DoesInfiniteBurnToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+    {
+    	return false;
+    }
+    
+    public boolean DoesExtinguishFireAbove( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public void OnDestroyedByFire( World world, int i, int j, int k, int iFireAge, boolean bForcedFireSpread )
+    {
+        if ( bForcedFireSpread || ( world.rand.nextInt( iFireAge + 10 ) < 5 && 
+        	!world.IsRainingAtPos( i, j, k ) ) )
+        {
+            int iNewFireMetadata = iFireAge + world.rand.nextInt( 5 ) / 4;
+
+            if ( iNewFireMetadata > 15 )
+            {
+                iNewFireMetadata = 15;
+            }
+
+            world.setBlockAndMetadataWithNotify( i, j, k, Block.fire.blockID, iNewFireMetadata );
+        }
+        else
+        {
+            world.setBlockWithNotify( i, j, k, 0 );
+        }
+    }    
+    
+    public Block SetFireProperties( int iChanceToEncourageFire, int iAbilityToCatchFire )
+    {
+    	BlockFire.chanceToEncourageFire[blockID] = iChanceToEncourageFire;
+    	BlockFire.abilityToCatchFire[blockID] = iAbilityToCatchFire;
+    	
+    	return this;
+    }
+    
+    public Block SetFireProperties( FCEnumFlammability flammability )
+    {
+    	return SetFireProperties( flammability.m_iChanceToEncourageFire, 
+    		flammability.m_iAbilityToCatchFire );
+    }
+    
+    /**
+     * Whether the block itself can be set on fire, rather than a neighboring block being set to a fire block
+     */
+    public boolean GetCanBeSetOnFireDirectly( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean GetCanBeSetOnFireDirectlyByItem( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetCanBeSetOnFireDirectly( blockAccess, i, j, k );
+    }
+    
+    public boolean SetOnFireDirectly( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public int GetChanceOfFireSpreadingDirectlyTo( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return 0;
+    }
+    
+    public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k, Entity entity )
+    {
+    	return GetDoesFireDamageToEntities( world, i, j, k );
+    }
+    
+    public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    /**
+     * Used by Hibachi to determine if it can remove the block above it when lit
+     */
+    public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
+    {
+		return Block.fire.canBlockCatchFire( world, i, j, k ) || !blockMaterial.blocksMovement();
+    }
+    
+    /** 
+     * Whether a fire block can be directly placed over this one, without first burning or catching fire, as if it were air.
+     */
+    public boolean GetCanBlockBeReplacedByFire( World world, int i, int j, int k )
+    {
+    	return IsAirBlock();
+    }
+    
+    public boolean IsIncineratedInCrucible()
+    {
+    	return FCBlockFire.CanBlockBeDestroyedByFire( blockID );
+    }
+    
+    //------------- Pathing related functionality ------------//
+    
+    public boolean CanPathThroughBlock( IBlockAccess blockAccess, int i, int j, int k, 
+    	Entity entity, PathFinder pathFinder )
+    {
+		// note: getBlocksMovement() is misnamed and returns if the block *doesn't* block movement
+    	
+    	return getBlocksMovement( blockAccess, i, j, k );
+    }
+
+    /**
+     * Used to determine if entities who start their pathing from within this block
+     * should instead start pathing from a neighbor block instead, to prevent getting stuck
+     * in this one.  Mostly applies to stuff like chickens getting stuck in fences.
+     */
+    public boolean ShouldOffsetPositionIfPathingOutOf( IBlockAccess blockAccess, 
+    	int i, int j, int k, Entity entity, PathFinder pathFinder )
+    {
+    	return !CanPathThroughBlock( blockAccess, i, j, k, entity, pathFinder );
+    }
+    
+    public int GetWeightOnPathBlocked( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return 0;
+    }    
+    
+    public int AdjustPathWeightOnNotBlocked( int iPreviousWeight )
+    {
+    	return iPreviousWeight;
+    }
+    
+    public boolean IsBreakableBarricade( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+
+    public boolean IsBreakableBarricadeOpen( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    //------------- Kiln related functionality ------------//
+    
+    private boolean m_bCanBeCookedByKiln = false;
+    private int m_iItemIndexDroppedWhenCookedByKiln = -1;
+    private int m_iItemDamageDroppedWhenCookedByKiln = 0;
+    
+    public Block SetCanBeCookedByKiln( boolean bCanBeCooked )
+    {
+    	m_bCanBeCookedByKiln = bCanBeCooked;
+    	
+    	return this;
+    }
+    
+    public boolean GetCanBeCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return m_bCanBeCookedByKiln;
+    }    
+    
+    public int GetCookTimeMultiplierInKiln( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return 1;
+    }    
+    
+    public Block SetItemIndexDroppedWhenCookedByKiln( int iItemIndex )
+    {
+    	m_iItemIndexDroppedWhenCookedByKiln = iItemIndex;
+    	
+    	return this;
+    }
+    
+    public int GetItemIndexDroppedWhenCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return m_iItemIndexDroppedWhenCookedByKiln;
+    }
+    
+    public Block SetItemDamageDroppedWhenCookedByKiln( int iItemDamage )
+    {
+    	m_iItemDamageDroppedWhenCookedByKiln = iItemDamage;
+    	
+    	return this;
+    }
+    
+    public int GetItemDamageDroppedWhenCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return m_iItemDamageDroppedWhenCookedByKiln;
+    }
+    
+    public void OnCookedByKiln( World world, int i, int j, int k )
+    {
+    	int iItemDropped = GetItemIndexDroppedWhenCookedByKiln( world, i, j, k );
+    	
+    	if ( iItemDropped >= 0 )
+    	{
+    		int iDamageDropped = GetItemDamageDroppedWhenCookedByKiln( world, i, j, k );
+    		
+        	world.setBlockToAir( i, j, k );
+
+        	if ( iItemDropped > 0 )
+        	{
+        		FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j, k, iItemDropped, iDamageDropped );
+        	}
+    	}
+    }
+    
+    //------------- Saw related functionality ------------//
+    
+    public boolean DoesBlockBreakSaw( World world, int i, int j, int k )
+    {
+    	if ( blockMaterial.isSolid() )
+    	{
+	    	if ( blockMaterial != Material.wood && 
+	    		blockMaterial != Material.cactus && 
+	    		blockMaterial != Material.pumpkin &&
+	    		blockMaterial != Material.leaves &&
+	    		blockMaterial != Material.plants &&
+	    		blockMaterial != Material.vine &&
+	    		blockMaterial != Material.snow &&
+	    		blockMaterial != Material.craftedSnow &&
+	    		blockMaterial != FCBetterThanWolves.fcMaterialLog &&
+	    		blockMaterial != FCBetterThanWolves.fcMaterialPlanks &&
+	    		blockMaterial != FCBetterThanWolves.fcMaterialAsh
+			)
+	    	{
+				return true;
+	    	}
+    	}
+    	
+    	return false;
+    }
+
+    /*
+     * returns true if the block has been sawed, false otherwise
+     */
+    public boolean OnBlockSawed( World world, int i, int j, int k, int iSawPosI, int iSawPosJ, int iSawPosK )
+    {
+    	return OnBlockSawed( world, i, j, k );
+    }
+    
+    /*
+     * returns true if the block has been sawed, false otherwise
+     */
+    public boolean OnBlockSawed( World world, int i, int j, int k )
+    {		
+    	int iItemIDDropped = GetItemIDDroppedOnSaw( world, i, j, k ); 
+    	
+    	if (  iItemIDDropped >= 0 )
+    	{
+    		int iItemCountDropped = GetItemCountDroppedOnSaw( world, i, j, k );
+    		int iItemDamageDropped = GetItemDamageDroppedOnSaw( world, i, j, k );
+    		
+    		for ( int iTempCount = 0; iTempCount < iItemCountDropped; iTempCount++ )
+    		{
+				FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j, k, 
+					iItemIDDropped, iItemDamageDropped );
+    		}
+    	}
+    	else
+    	{
+    		if ( !DoesBlockDropAsItemOnSaw( world, i, j, k ) )
+        	{
+    			return false;
+        	}
+        	
+			dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+    	}
+    	
+    	world.setBlockToAir( i, j, k );
+    	
+    	return true;
+    }
+    
+    public int GetItemIDDroppedOnSaw( World world, int i, int j, int k )
+    {
+    	return -1;
+    }
+    
+    public int GetItemCountDroppedOnSaw( World world, int i, int j, int k )
+    {
+    	return 0;
+    }
+    
+    public int GetItemDamageDroppedOnSaw( World world, int i, int j, int k )
+    {
+    	return 0;
+    }
+    
+    public boolean DoesBlockDropAsItemOnSaw( World world, int i, int j, int k )
+    {
+    	return blockMaterial.isSolid();
+    }
+    
+    //------------- Stonecutter related functionality ------------//
+    // Only called by Automation+ addon
+    // Can be used by other addons to interface
+    
+    public void setItemIDDroppedOnStonecutter(int id) {
+    	this.idDroppedOnStonecut = id;
+    }
+    
+    public void setItemCountDroppedOnStonecutter(int count) {
+    	this.countDroppedOnStonecut = count;
+    }
+
+    public void setItemDamageDroppedOnStonecutter(int meta) {
+    	this.metaDroppedOnStonecut = meta;
+    }
+
+    public int getItemIDDroppedOnStonecutter(World world, int x, int y, int z) {
+        return this.idDroppedOnStonecut;
+    }
+
+    public int getItemCountDroppedOnStonecutter(World world, int x, int y, int z) {
+        return this.countDroppedOnStonecut;
+    }
+
+    public int getItemDamageDroppedOnStonecutter(World world, int x, int y, int z)  {
+        return this.metaDroppedOnStonecut;
+    }
+
+    public boolean doesBlockDropAsItemOnStonecutter(World world, int x, int y, int z)  {
+        return this.blockMaterial.isSolid();
+    }
+
+    public boolean doesBlockBreakStonecutter(World world, int x, int y, int z) {
+        return this.blockMaterial.isSolid() && this.blockMaterial != Material.rock && this.blockMaterial != Material.snow && this.blockMaterial != Material.craftedSnow && this.blockMaterial != FCBetterThanWolves.fcMaterialAsh && this.blockMaterial != FCBetterThanWolves.fcMaterialNetherRock;
+    }
+
+    public boolean onBlockStonecut(World world, int x, int y, int z, int stonecutterX, int stonecutterY, int stonecutterZ) {
+        return this.onBlockStonecut(world, x, y, z);
+    }
+
+    /**
+     * Override this method to provide finer control over stonecutter behavior.
+     * @param world
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    public boolean onBlockStonecut(World world, int x, int y, int z){
+        int id = this.getItemIDDroppedOnStonecutter(world, x, y, z);
+
+        if (id >= 0) {
+            int count = this.getItemCountDroppedOnStonecutter(world, x, y, z);
+            int meta = this.getItemDamageDroppedOnStonecutter(world, x, y, z);
+
+            for (int i = 0; i < count; i++) {
+                FCUtilsItem.EjectSingleItemWithRandomOffset(world, x, y, z, id, meta);
+            }
+        }
+        else {
+            if (!this.doesBlockDropAsItemOnStonecutter(world, x, y, z)) {
+                return false;
+            }
+
+            this.dropBlockAsItem(world, x, y, z, world.getBlockMetadata(x, y, z), 0);
+        }
+
+        world.setBlockToAir(x, y, z);
+        return true;
+    }
+    
+    //------------- Mechanical power related functionality ------------//
+    
+    public int GetMechanicalPowerLevelProvidedToAxleAtFacing( World world, int i, int j, int k, int iFacing )
+    {
+    	return 0;
+    }
+    
+    //------------- Tool effectiveness functionality ------------//
+    
+    private boolean m_bShovelsEffectiveOn = false;
+    private boolean m_bPicksEffectiveOn = false;
+    private boolean m_bAxesEffectiveOn = false;
+    private boolean m_bHoesEffectiveOn = false;
+    
+    private boolean m_bChiselsEffectiveOn = false;
+    private boolean m_bChiselsCanHarvest = false;
+    
+    public boolean AreShovelsEffectiveOn()
+    {
+    	return m_bShovelsEffectiveOn;
+    }
+    
+    public boolean ArePicksEffectiveOn()
+    {
+    	return m_bPicksEffectiveOn;
+    }
+    
+    public boolean AreAxesEffectiveOn()
+    {
+    	return m_bAxesEffectiveOn;
+    }
+    
+    public boolean AreHoesEffectiveOn()
+    {
+    	return m_bHoesEffectiveOn;
+    }
+    
+    public boolean AreChiselsEffectiveOn()
+    {
+    	return m_bChiselsEffectiveOn;
+    }
+    
+    public boolean AreChiselsEffectiveOn( World world, int i, int j, int k )
+    {
+    	return AreChiselsEffectiveOn();
+    }
+    
+    public boolean CanChiselsHarvest()
+    {
+    	return m_bChiselsCanHarvest;
+    }
+    
+    public Block SetShovelsEffectiveOn() { return SetShovelsEffectiveOn( true ); }
+    public Block SetShovelsEffectiveOn( boolean bEffective )
+    {
+    	m_bShovelsEffectiveOn = bEffective;
+    	
+    	return this;
+    }
+    
+    public Block SetPicksEffectiveOn() { return SetPicksEffectiveOn( true ); }
+    public Block SetPicksEffectiveOn( boolean bEffective )
+    {
+    	m_bPicksEffectiveOn = bEffective;
+    	
+    	return this;
+    }
+    
+    public Block SetAxesEffectiveOn() { return SetAxesEffectiveOn( true ); }
+    public Block SetAxesEffectiveOn( boolean bEffective )
+    {
+    	m_bAxesEffectiveOn = bEffective;
+    	
+    	return this;
+    }
+    
+    public Block SetHoesEffectiveOn() { return SetHoesEffectiveOn( true ); }
+    public Block SetHoesEffectiveOn( boolean bEffective )
+    {
+    	m_bHoesEffectiveOn = bEffective;
+    	
+    	return this;
+    }
+    
+    public Block SetChiselsEffectiveOn() { return SetChiselsEffectiveOn( true ); }
+    public Block SetChiselsEffectiveOn( boolean bEffective )
+    {
+    	m_bChiselsEffectiveOn = bEffective;
+    	
+    	return this;
+    }
+    
+    public Block SetChiselsCanHarvest() { return SetChiselsCanHarvest( true ); }
+    public Block SetChiselsCanHarvest( boolean bCanHarvest )
+    {
+    	m_bChiselsCanHarvest = bCanHarvest;
+    	
+    	return this;
+    }
+    
+    public float getPlayerRelativeBlockHardness( EntityPlayer player, World world, int i, int j, int k )
+    {
+        float fBlockHardness = getBlockHardness( world, i, j, k );
+        
+        if ( fBlockHardness >= 0F )
+        {
+            float fRelativeHardness = player.getCurrentPlayerStrVsBlock( this, i, j, k ) / fBlockHardness;
+            
+        	if ( player.IsCurrentToolEffectiveOnBlock( this, i, j, k ) )
+        	{
+        		return fRelativeHardness / 30F;
+        	}
+        	else
+        	{
+        		return fRelativeHardness / 200F;
+        	}
+        }
+        else
+        {
+        	return 0F; 
+        }
+    }
+    
+    public boolean CanConvertBlock( ItemStack stack, World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    /**
+     * Returns false if the block has not been replaced with another, and should be removed
+     */
+    public boolean ConvertBlock( ItemStack stack, World world, int i, int j, int k, int iFromSide )
+    {
+    	return false;
+    }
+    
+    public int GetEfficientToolLevel( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return 0;
+    }
+    
+    public int GetHarvestToolLevel( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetEfficientToolLevel( blockAccess, i, j, k );
+    }
+    
+    /**
+     * The following is for stumps and such, which are a pain to remove regardless of whether their overall block has
+     * relevant tool effeciencies
+     */
+    public boolean GetIsProblemToRemove( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean GetDoesStumpRemoverWorkOnBlock( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean CanToolsStickInBlock( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return true;
+    }
+    
+    //------------- Buoyancy related functionality ------------//
+    
+	private float m_fBuoyancy = -1.0F;
+	
+    public Block SetBuoyancy( float fBuoyancy )
+    {
+    	m_fBuoyancy = fBuoyancy;
+    	
+    	return this;
+    }
+    
+    public Block SetBuoyant() { return SetBuoyancy( 1F ); }
+    public Block SetNonBuoyant() { return SetBuoyancy( -1F ); }
+    public Block SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
+    
+    public float GetBuoyancy( int iMetadata )
+    {
+    	return m_fBuoyancy;
+    }
+    
+    //------------- Ground cover related functionality ------------//
+    
+    public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
+    {
+    	if ( world.doesBlockHaveSolidTopSurface( i, j, k ) )
+    	{
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    
+    public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return 0F;
+    }
+    
+    public boolean IsGroundCover()
+    {
+    	return false;
+    }
+    
+    public boolean AttempToSpreadGrassToBlock( World world, int i, int j, int k )
+    {
+    	if ( GetCanGrassSpreadToBlock( world, i, j, k ) &&
+        	world.GetBlockNaturalLightValueMaximum( i, j + 1, k ) >= 
+    		FCBlockGrass.m_iGrassSpreadToLightLevel && 
+        	Block.lightOpacity[world.getBlockId( i, j + 1, k )] <= 2 &&
+    		!FCBlockGroundCover.IsGroundCoverRestingOnBlock( world, i, j, k ) )    		
+    	{
+    		return SpreadGrassToBlock( world, i, j, k );
+    	}
+    	
+    	return false;
+    }
+    
+    public boolean GetCanGrassSpreadToBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean SpreadGrassToBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean GetCanGrassGrowUnderBlock( World world, int i, int j, int k, boolean bGrassOnHalfSlab )
+    {
+    	if ( !bGrassOnHalfSlab )
+    	{
+    		return !HasLargeCenterHardPointToFacing( world, i, j, k, 0 );
+    	}
+    	
+    	return true;
+    }
+    
+    public boolean AttempToSpreadMyceliumToBlock( World world, int i, int j, int k )
+    {
+    	if ( GetCanMyceliumSpreadToBlock( world, i, j, k ) &&
+    		world.getBlockLightValue( i, j + 1, k ) >= 
+    		FCBlockMycelium.m_iMyceliumSpreadToMinimumLightLevel &&
+    		Block.lightOpacity[world.getBlockId( i, j + 1, k )] <= 2 &&
+    		!FCBlockGroundCover.IsGroundCoverRestingOnBlock( world, i, j, k ) )    		
+    	{
+			return SpreadMyceliumToBlock( world, i, j, k );
+    	}
+    	
+    	return false;
+    }
+    
+    public boolean GetCanMyceliumSpreadToBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean SpreadMyceliumToBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean GetCanBlightSpreadToBlock( World world, int i, int j, int k, int iBlightLevel )
+    {
+    	return false;
+    }
+
+    /**
+     * Used by blocks like grass and mycellium to determine if they should use a snow side
+     * texture.  Note that this refers to the top visible surface, not just the top facing,
+     * which means that stuff like half-slabs should only return true if they have ground cover
+     * actually on the top surface halfway up the block vertically.
+     */ 
+    public boolean IsSnowCoveringTopSurface( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	int iBlockAboveID = blockAccess.getBlockId( i, j + 1, k );
+    	
+    	if ( iBlockAboveID != 0 )
+    	{
+    		Block blockAbove = blocksList[iBlockAboveID];
+    		
+    		Material aboveMaterial = blockAbove.blockMaterial;
+    		
+	        if ( aboveMaterial == Material.snow || aboveMaterial == Material.craftedSnow && 
+	        	blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 ) )
+	        {
+	        	return true;
+	        }
+	        else if ( 
+	        	blockAbove.GroundCoverRestingOnVisualOffset( blockAccess, i, j + 1, k ) < -0.99F && 
+	        	blockAccess.getBlockId( i, j + 2, k ) == snow.blockID )
+	        {
+	        	// consider snow resting on tall grass and such
+	        	
+	        	return true;
+	        }
+    	}
+    	
+    	return false;
+    }
+    
+    //---------- Piston Related Functionality ---------//
+    
+    /**
+     * Returns the metadata that will be placed
+     */
+    public int OnPreBlockPlacedByPiston( World world, int i, int j, int k, int iMetadata, int iDirectionMoved )
+    {
+    	return iMetadata;
+    }
+    
+    public boolean CanBlockBePulledByPiston( World world, int i, int j, int k, int iToFacing )
+    {
+    	if ( getMobilityFlag() != 1 ) // blocks destroyed on push can not be pulled
+    	{
+    		return CanBlockBePushedByPiston( world, i, j, k, iToFacing );
+    	}
+    	
+    	return false;    	                         
+    }
+    
+    public boolean CanBlockBePushedByPiston( World world, int i, int j, int k, int iToFacing )
+    {
+        int iMobility = getMobilityFlag();
+        
+        return iMobility == 1 || ( iMobility != 2 && !( this instanceof ITileEntityProvider ) );
+    }
+    
+    public boolean CanBePistonShoveled( World world, int i, int j, int k )
+    {
+    	return AreShovelsEffectiveOn();
+    }
+    
+    /**
+     * returns the direction the shoveled block will go in if this block is moving towards iToFacing.  
+     * return -1 if it's no shoveling is taking place.
+     */
+    public int GetPistonShovelEjectDirection( World world, int i, int j, int k, int iToFacing )
+    {
+    	return -1;
+    }
+    
+    public AxisAlignedBB GetAsPistonMovingBoundingBox( World world, int i, int j, int k )
+    {
+    	return getCollisionBoundingBoxFromPool( world, i, j, k );
+    }
+    
+    public int AdjustMetadataForPistonMove( int iMetadata )
+    {
+    	return iMetadata;
+    }
+    
+    public boolean CanContainPistonPackingToFacing( World world, int i, int j, int k, int iFacing )
+    {
+    	return HasLargeCenterHardPointToFacing( world, i, j, k, iFacing, true );
+    }    
+    
+    public boolean IsPistonPackable( ItemStack stack )
+    {
+    	return false;
+    }
+    
+    public int GetRequiredItemCountToPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public void OnBrokenByPistonPush( World world, int i, int j, int k, int iMetadata )
+    {
+    	dropBlockAsItem( world, i, j, k, iMetadata, 0 );
+    }
+    
+    //------------- Hopper Filtering Functionality -----------//
+    
+    protected int m_iFilterablePropertiesBitfield = 0;
+    
+    public boolean CanItemPassIfFilter( ItemStack filteredItem )
+    {
+    	return true;
+    }
+    
+    public int GetFilterableProperties( ItemStack stack )
+    {
+    	return m_iFilterablePropertiesBitfield;
+    }
+    
+    public void SetFilterableProperties( int iProperties )
+    {
+    	m_iFilterablePropertiesBitfield = iProperties;
+    }
+    
+    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
+    {
+    	return false;
+    }
+    
+    //---------- Falling Block Functionality ----------//
+    
+    private static final int m_iLoadedRangeToCheckFalling = 32;
+    
+    public boolean IsFallingBlock()
+    {
+    	return false;
+    }
+    
+    protected boolean CheckForFall( World world, int i, int j, int k)
+    {
+        if ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j >= 0 )
+        {
+            if ( !BlockSand.fallInstantly && world.checkChunksExist( 
+            	i - m_iLoadedRangeToCheckFalling, j - m_iLoadedRangeToCheckFalling, k - m_iLoadedRangeToCheckFalling, 
+            	i + m_iLoadedRangeToCheckFalling, j + m_iLoadedRangeToCheckFalling, k + m_iLoadedRangeToCheckFalling ) )
+            {
+                if ( !world.isRemote )
+                {
+                	FCEntityFallingBlock fallingEntity = new FCEntityFallingBlock( world, (double)i + 0.5D, (double)j + 0.5D, (double)k + 0.5D, 
+                    	blockID, world.getBlockMetadata( i, j, k ) );
+                    
+                    onStartFalling( fallingEntity );
+                    
+                    world.spawnEntityInWorld( fallingEntity );
+                }
+                
+                return true;
+            }
+            else
+            {
+                world.setBlockToAir( i, j, k );
+
+                while ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j > 0 )
+                {
+                    j--;
+                }
+
+                if ( j > 0 )
+                {
+                    world.setBlock( i, j, k, blockID );
+                }
+                
+                return true;
+            }
+        }
+        
+        return false;
+    }
+
+    /**
+     * Only called on server
+     */
+    protected void onStartFalling( EntityFallingSand entity ) {}
+    
+    /**
+     * This is actually called when a block lands safely.  Do not rename as BlockSand has a child method off of this
+     */
+    public void onFinishFalling( World world, int i, int j, int k, int iMetadata )
+    {
+    	NotifyNearbyAnimalsFinishedFalling( world, i, j, k );
+    }
+
+    protected void OnFallingUpdate( FCEntityFallingBlock entity ) {}
+    
+    public void NotifyNearbyAnimalsFinishedFalling( World world, int i, int j, int k )
+    {
+    	if ( !world.isRemote )
+    	{
+            EntityPlayer entityPlayer = world.getClosestPlayer((float)i + 0.5F, (float)j + 0.5F, (float)k + 0.5F, 64D );
+            
+            if ( entityPlayer != null )
+            {
+            	world.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( entityPlayer, this, i, j, k );
+            }
+    	}
+    }
+    
+	/** 
+	 * returns true if the block still exists
+	 */
+    public boolean OnFinishedFalling( EntityFallingSand entity, float fFallDistance )
+    {
+    	return true;
+    }
+    
+    /**
+     * returns true if the block has combined with the entity
+     */
+    public boolean AttemptToCombineWithFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+    {
+    	return false;
+    }
+    
+    public boolean CanBeCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+    {
+    	return false;
+    }
+    
+    public void OnCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+    {
+    }
+    
+    protected boolean CanFallIntoBlockAtPos( World world, int i, int j, int k )
+    {
+    	Block targetBlock = Block.blocksList[world.getBlockId( i, j, k )];
+
+    	return targetBlock == null || !targetBlock.CanSupportFallingBlocks( world, i, j, k );
+    }
+    
+    public boolean CanSupportFallingBlocks( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return HasCenterHardPointToFacing( blockAccess, i, j, k, 1, true );    	
+    }
+    
+    protected void CheckForUnstableGround( World world, int i, int j, int k )
+    {
+    	for ( int iJOffset = 1; iJOffset <= 16; iJOffset++ )
+    	{
+    		int iTempJ = j - iJOffset;
+    		
+    		if ( iTempJ <= 0 )
+    		{
+    			break;
+    		}
+    		else
+    		{
+    	        if( world.isAirBlock( i, iTempJ, k ) )
+    	        {
+    	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+    	        	
+    	        	break;
+    	        }
+    	        else
+    	        {    	        	
+    	        	int iTempBlockID = world.getBlockId( i, iTempJ, k );
+    	        	
+    	        	if ( iTempBlockID == Block.fire.blockID )
+    	        	{
+        	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+        	        	
+        	        	break;
+    	        	}
+    	        	else
+    	        	{
+    	        		Block tempBlock = Block.blocksList[iTempBlockID];
+    	        		
+    	        		if ( tempBlock.blockMaterial == Material.water || tempBlock.blockMaterial == Material.lava )
+    	        		{
+            	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+            	        	
+            	        	break;
+    	        		}
+    	        		else if ( !tempBlock.IsFallingBlock() )
+    	        		{
+    	        			break;
+    	        		}
+    	        	}
+    	        }    			
+    		}
+    	}
+    }
+    
+    protected void ScheduleCheckForFall( World world, int i, int j, int k )
+    {
+        world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+    }
+
+    /**
+     * Called on server only
+     */
+    public void OnBlockDestroyedLandingFromFall( World world, int i, int j, int k, int iMetadata )
+    {
+    	OnBlockDestroyedWithImproperTool( world, null, i, j, k, iMetadata );
+    }
+    
+    public boolean HasFallingBlockRestingOn( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	Block blockAbove = Block.blocksList[blockAccess.getBlockId( i, j + 1, k )];
+    	                                    
+        return blockAbove != null && blockAbove.IsFallingBlock() && 
+        	blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 );
+    }
+    
+	//----------- Block Facing Functionality ----------//
+	
+	public int GetFacing( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return GetFacing( blockAccess.getBlockMetadata( i, j, k ) );
+	}
+	
+	public int GetFacing( int iMetadata )
+	{
+		return 0;
+	}
+	
+	public void SetFacing( World world, int i, int j, int k, int iFacing )
+	{
+		int iMetadata = world.getBlockMetadata( i, j, k );
+		
+		int iNewMetadata = SetFacing( iMetadata, iFacing );
+		
+		if ( iNewMetadata != iMetadata )
+		{
+			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
+		}
+	}
+	
+	public int SetFacing( int iMetadata, int iFacing )
+	{
+		return iMetadata;
+	}
+	
+	/**
+	 * Cycle through all the possible facings for a block 
+	 * returns true if the facing has actually changed as a result of this call
+	 */
+	public boolean ToggleFacing( World world, int i, int j, int k, boolean bReverse )
+	{
+		return RotateAroundJAxis( world, i, j, k, bReverse );
+	}
+	
+    public int ConvertFacingToTopTextureRotation( int iFacing )
+    {
+    	if ( iFacing >= 2 )
+    	{
+    		if ( iFacing <= 3 )
+    		{
+    			if ( iFacing == 3 )
+    			{
+    				return 3;
+    			}
+    		}
+    		else
+    		{
+    			if ( iFacing == 4 )
+    			{
+    				return 2;
+    			}
+    			else // iFacing == 5
+    			{
+    				return 1;
+    			}
+    		}
+    	}
+    	
+    	return 0;
+    }
+    
+    public int ConvertFacingToBottomTextureRotation( int iFacing )
+    {
+    	if ( iFacing >= 2 )
+    	{
+    		if ( iFacing <= 3 )
+    		{
+    			if ( iFacing == 3 )
+    			{
+    				return 3;
+    			}
+    		}
+    		else
+    		{
+    			if ( iFacing == 4 )
+    			{
+    				return 1;
+    			}
+    			else // iFacing == 5
+    			{
+    				return 2;
+    			}
+    		}
+    	}
+    	
+    	return 0;
+    }
+    
+	static public int GetOppositeFacing( int iFacing )
+	{
+		return iFacing ^ 1;
+	}
+	
+	static public int RotateFacingAroundJ( int iFacing, boolean bReverse )
+	{
+		if ( bReverse )
+		{
+			return m_iRotatedFacingsAroundJCounterclockwise[iFacing];
+		}
+		
+		return m_iRotatedFacingsAroundJClockwise[iFacing];
+	}
+
+	static public int CycleFacing( int iFacing, boolean bReverse )
+	{
+		if ( bReverse )
+		{
+			return m_iCycledFacingsReversed[iFacing];
+		}
+		
+		return m_iCycledFacings[iFacing];
+	}
+
+    //-------- Turntable Related Functionality --------//
+    
+	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}	
+	
+	public boolean CanTransmitRotationHorizontallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+	
+	public boolean CanTransmitRotationVerticallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return blockAccess.isBlockNormalCube( i, j, k );
+	}
+	
+	/**
+	 * Returns the new crafting counter after rotation.  It is unmodified if no crafting has taken place, 
+	 * incremented or reset on completion if it has.
+	 */
+	public int RotateOnTurntable( World world, int i, int j, int k, boolean bReverse, int iCraftingCounter )
+	{
+		OnRotatedOnTurntable( world, i, j, k );
+		
+		if ( !RotateAroundJAxis( world, i, j, k, bReverse ) )
+		{
+			// notify the surrounding blocks of a change if no facing change actually takes place, so that buddy can pick up on it
+			// this is because solid blocks still "rotate" even if their facing doesn't change
+			
+	    	world.notifyBlocksOfNeighborChange( i, j, k, blockID );	    	
+		}
+		
+		return iCraftingCounter;
+	}
+
+	/*
+	 * Intended to play block specific FX and such
+	 */
+	protected void OnRotatedOnTurntable( World world, int i, int j, int k )
+	{
+	}
+
+	protected int TurntableCraftingRotation( World world, int i, int j, int k, boolean bReverse, int iCraftingCounter )
+	{
+		iCraftingCounter++;
+		
+		if ( iCraftingCounter >= GetRotationsToCraftOnTurntable( world, i, j, k ) )
+		{
+			OnCraftedOnTurntable( world, i, j, k );
+			
+			int iNewBlockID = GetNewBlockIDCraftedOnTurntable( world, i, j, k );
+			int iNewBlockMetadata = GetNewMetadataCraftedOnTurntable( world, i, j, k );
+			int iItemIDDropped = GetItemIDCraftedOnTurntable( world, i, j, k );
+			int iItemCountDropped = GetItemCountCraftedOnTurntable( world, i, j, k );
+			int iItemDamageDropped = GetItemDamageCraftedOnTurntable( world, i, j, k );
+			
+			for ( int tempCount = 0; tempCount < iItemCountDropped; tempCount++ )
+			{
+				FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j + 1, k, iItemIDDropped, iItemDamageDropped );			
+			}
+
+			world.setBlockAndMetadataWithNotify( i, j, k, iNewBlockID, iNewBlockMetadata );			
+			
+			iCraftingCounter = 0;
+		}
+		
+		return iCraftingCounter;
+	}
+	
+	public int GetRotationsToCraftOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 1;
+	}
+	
+	public void OnCraftedOnTurntable( World world, int i, int j, int k )
+	{
+        world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
+        	i, j, k, world.getBlockId( i, j, k ) + ( world.getBlockMetadata( i, j, k ) << 12 ) );        
+	}
+	
+	public int GetNewBlockIDCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+	
+	public int GetNewMetadataCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+	
+	public int GetItemIDCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return Item.clay.itemID;
+	}
+	
+	public int GetItemCountCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 1;
+	}
+	
+	public int GetItemDamageCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+	
+	/**
+	 * Returns true if the facing has actually changed as a result of this call
+	 */
+	public boolean RotateAroundJAxis( World world, int i, int j, int k, boolean bReverse )
+	{
+		int iMetadata = world.getBlockMetadata( i, j, k );
+		
+		int iNewMetadata = RotateMetadataAroundJAxis( iMetadata, bReverse );
+		
+		if ( iNewMetadata != iMetadata )
+		{
+			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
+			
+			return true;
+		}
+		
+		return false;
+	}
+
+	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
+	{
+		int iFacing = GetFacing( iMetadata );
+		
+		int iNewFacing = RotateFacingAroundJ( iFacing, bReverse );
+		
+		return SetFacing( iMetadata, iNewFacing );
+	}
+
+    public boolean CanRotateAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
+    {
+    	return false;
+    }
+    
+    /**
+     * Returns false if the block was destroyed and should not be rotated
+     */
+    public boolean OnRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
+    {
+    	return true;
+    }
+    
+    public int GetNewMetadataRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iInitialFacing, int iRotatedFacing )
+    {
+    	return 0;
+    }
+    
+    //----- Block Dispenser Related Functionality -----//
+    
+    /**
+     * If the stack returned is null, the block will not be retrieved
+     */
+    public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
+    {
+    	int iMetadata = world.getBlockMetadata( i, j, k );
+    	
+    	if ( canSilkHarvest( iMetadata ) )
+    	{
+    		return createStackedBlock( iMetadata );
+    	}
+    	
+    	int iIdDropped = idDropped( iMetadata, world.rand, 0 );
+    	
+    	if ( iIdDropped > 0 )
+    	{
+    		return new ItemStack( iIdDropped, 1, damageDropped( iMetadata ) );
+    	}
+    	
+    	return null;
+    }
+    
+    /**
+     * Whether a block is destroyed by the dispenser, even if no item is collected
+     */
+    public boolean IsBlockDestroyedByBlockDispenser( int iMetadata )
+    {
+    	return false;
+    }
+    
+    public void OnRemovedByBlockDispenser( World world, int i, int j, int k )
+    {
+        world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
+        	i, j, k, blockID + ( world.getBlockMetadata( i, j, k ) << 12 ) );
+        
+    	world.setBlockWithNotify( i, j, k, 0 );
+    }
+    
+	//---------- Weather Related Functionality --------//
+    
+    /**
+     * Called on server only
+     */
+    public void OnStruckByLightning( World world, int i, int j, int k )
+    {
+    }
+    
+	//------- Mob Spawning Related Functionality ------//
+    
+    /**
+     * This is only a first-pass indicator as to whether ANY mobs can spawn on top of the block,
+     * so stuff like leaves where only Jungle Spiders can spawn on them, should still return true.
+     */
+    public boolean CanMobsSpawnOn( World world, int i, int j, int k )
+    {
+        return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId ) &&
+    		getCollisionBoundingBoxFromPool( world, i, j, k ) != null;
+    }
+
+    public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
+    {
+    	return 0F;
+    }
+    
+	//-------- Collision Handling Functionality -------//
+    
+    /**
+     * This should never be modified after a block is initialized to avoid multithreading issues
+     * that occurred with the old min/max bounds variables.
+     */
+    private AxisAlignedBB m_fixedBlockBounds = new AxisAlignedBB( 0D, 0D, 0D, 1D, 1D, 1D );
+    private boolean m_bFixedBlockBoundsSet = false;
+    
+    /**
+     * Should only ever be called once for a block.  Repeated calls will silently fail without
+     * changing the bounds.
+     */
+    protected void InitBlockBounds( double dMinX, double dMinY, double dMinZ, 
+    	double dMaxX, double dMaxY, double dMaxZ )
+    {
+    	if ( !m_bFixedBlockBoundsSet )
+    	{
+    		// only allow the bounds to be set before they're ever accessed to 
+    		// discourage the kind of errors that necessitated it in the first 
+    		// place: client and server threads modifying the min/max values 
+    		// resulting in race conditions.
+    		
+    		m_fixedBlockBounds.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );    		
+    	}
+    }
+
+    protected void InitBlockBounds( AxisAlignedBB bounds )
+    {
+    	if ( !m_bFixedBlockBoundsSet )
+    	{
+    		m_fixedBlockBounds.setBB( bounds );
+    	}
+    }
+    
+    protected AxisAlignedBB GetFixedBlockBoundsFromPool()
+    {
+		m_bFixedBlockBoundsSet = true;
+		
+    	return m_fixedBlockBounds.MakeTemporaryCopy();
+    }
+
+    public AxisAlignedBB getCollisionBoundingBoxFromPool( World world, int i, int j, int k )
+    {
+    	return GetBlockBoundsFromPoolBasedOnState( world, i, j, k ).offset( i, j, k );
+    }
+    
+    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+    	IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetFixedBlockBoundsFromPool();
+    }
+    
+    public MovingObjectPosition collisionRayTrace( World world, int i, int j, int k, 
+    	Vec3 startRay, Vec3 endRay )
+    {
+    	return CollisionRayTraceVsBlockBounds( world, i, j, k, startRay, endRay );
+    }
+
+    public MovingObjectPosition MouseOverRayTrace( World world, int i, int j, int k, 
+    	Vec3 startRay, Vec3 endRay )
+    {
+    	return collisionRayTrace( world, i, j, k, startRay, endRay );
+    }
+
+    public MovingObjectPosition CollisionRayTraceVsBlockBounds( World world, int i, int j, int k, 
+    	Vec3 startRay, Vec3 endRay )
+    {
+    	AxisAlignedBB collisionBox = GetBlockBoundsFromPoolBasedOnState( 
+    		world, i, j, k ).offset( i, j, k );
+    	
+    	MovingObjectPosition collisionPoint = collisionBox.calculateIntercept( startRay, endRay );
+    	
+    	if ( collisionPoint != null )
+    	{
+    		collisionPoint.blockX = i;
+    		collisionPoint.blockY = j;
+    		collisionPoint.blockZ = k;
+    	}
+    	
+    	return collisionPoint;
+    }
+    
+	//------------- Grazing Functionality -------------//
+    
+    private int m_iHerbivoreItemFoodValue = 0;
+    private int m_iBirdItemFoodValue = 0;
+    private int m_iPigItemFoodValue = 0;
+    
+    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+    	EntityAnimal byAnimal )
+    {
+    	return false;
+    }
+    
+    public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
+    {
+        world.setBlockToAir( i, j, k );
+
+        Block blockBelow = blocksList[world.getBlockId( i, j - 1, k )];
+        
+        if ( blockBelow != null )
+        {
+        	blockBelow.OnVegetationAboveGrazed( world, i, j - 1, k, animal );
+        }
+    }
+    
+	public void OnVegetationAboveGrazed( World world, int i, int j, int k, EntityAnimal animal )
+	{
+	}
+	
+	/** 
+	 * Used when pigs dig up dirt to let any attached neighbors know that they should break loose
+	 */
+	public void NotifyNeighborsBlockDisrupted( World world, int i, int j, int k )
+	{
+		FCUtilsBlockPos pos = new FCUtilsBlockPos( i, j, k );
+		FCUtilsBlockPos tempPos = new FCUtilsBlockPos();
+		
+		for ( int iTempFacing = 0; iTempFacing <= 5; iTempFacing++ )
+		{
+			tempPos.Set( pos );			
+			tempPos.AddFacingAsOffset( iTempFacing );
+			
+			Block tempBlock = Block.blocksList[world.getBlockId( tempPos.i, tempPos.j, tempPos.k )];
+			
+			if ( tempBlock != null )
+			{
+				tempBlock.OnNeighborDisrupted( world, tempPos.i, tempPos.j, tempPos.k, 
+					GetOppositeFacing( iTempFacing ) );
+			}
+		}
+	}
+	
+	public void OnNeighborDisrupted( World world, int i, int j, int k, int iToFacing )
+	{
+	}
+	
+    public int GetHerbivoreItemFoodValue( int iItemDamage )
+    {
+    	return m_iHerbivoreItemFoodValue;
+    }
+    
+    public void SetHerbivoreItemFoodValue( int iFoodValue )
+    {
+    	m_iHerbivoreItemFoodValue = iFoodValue;
+    }
+    
+    public int GetChickenItemFoodValue( int iItemDamage )
+    {
+    	return m_iBirdItemFoodValue;
+    }
+    
+    public void SetChickenItemFoodValue( int iFoodValue )
+    {
+    	m_iBirdItemFoodValue = iFoodValue;
+    }
+    
+    public int GetPigItemFoodValue( int iItemDamage )
+    {
+    	return m_iPigItemFoodValue;
+    }
+    
+    public void SetPigItemFoodValue( int iFoodValue )
+    {
+    	m_iPigItemFoodValue = iFoodValue;
+    }
+    
+	//----------- Plant Growth Functionality ----------//
+    
+    public boolean CanDomesticatedCropsGrowOnBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean CanReedsGrowOnBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean CanSaplingsGrowOnBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    /**
+     * Covers stuff like flowers and tall grass
+     */
+    public boolean CanWildVegetationGrowOnBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean CanNetherWartGrowOnBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    public boolean CanCactusGrowOnBlock( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+	public boolean IsBlockHydratedForPlantGrowthOn( World world, int i, int j, int k )
+	{
+		return false;
+	}
+
+	public boolean IsConsideredNeighbouringWaterForReedGrowthOn( World world, int i, int j, int k )
+	{
+		for ( int iTempI = i - 1; iTempI <= i + 1; iTempI++ )
+		{		
+			for ( int iTempK = k - 1; iTempK <= k + 1; iTempK++ )
+			{				
+				if ( world.getBlockMaterial( iTempI, j, iTempK ) == Material.water )
+				{
+					return true;
+				}
+			}
+		}
+
+		return false;
+	}
+	
+	/** 
+	 * This is used by old style non-daily plant growth
+	 */
+	public float GetPlantGrowthOnMultiplier( World world, int i, int j, int k, Block plantBlock )
+	{
+		return 1F;
+	}
+	
+	public boolean GetIsFertilizedForPlantGrowth( World world, int i, int j, int k )
+	{
+		return false;
+	}
+	
+	/** 
+	 * Called when a plant hits a full growth stage, like wheat fully grown, 
+	 * or each full block of Hemp.  Used to clear fertilizer.
+	 */
+	public void NotifyOfFullStagePlantGrowthOn( World world, int i, int j, int k, Block plantBlock )
+	{
+	}
+	
+	/**
+	 * Called server only.  Called AFTER the plant is removed, so it's no longer valid.  
+	 */
+	public void NotifyOfPlantAboveRemoved( World world, int i, int j, int k, Block plantBlock )
+	{
+	}
+	
+	/**
+	 * This determines whether weeds can share space with crop blocks, or grow
+	 * within their own independent weed blocks
+	 */
+	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;
+	}
+
+	/**
+	 * The growth level of weeds growing out of this block.  Range of 0 to 7 
+	 */
+	public int GetWeedsGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return 0;
+	}
+	
+	public void RemoveWeeds( World world, int i, int j, int k )
+	{
+	}
+	
+	public boolean AttemptToApplyFertilizerTo( World world, int i, int j, int k )
+	{
+		return false;
+	}
+	
+	public boolean GetConvertsLegacySoil( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return false;		
+	}
+	
+	//----------------- Map related functionality ----------------//
+    
+    /**
+     * Gets the color used in map rendering for this block with the specified metadata
+     * @param meta
+     * @return
+     */
+    public MapColor getMapColor(int meta) {
+    	if (mapColorsForMetadata == null) {
+    		return this.blockMaterial.materialMapColor;
+    	}
+    	else {
+    		try {
+    			return mapColorsForMetadata[meta];
+    		}
+    		catch (Exception e) {
+    			FCAddOnHandler.LogMessage("Map color not found for metadata " + meta + " of block " + this);
+        		return this.blockMaterial.materialMapColor;
+    		}
+    	}
+    }
+    
+    /**
+     * Set the array of map colors to use per metadata for this block. Make sure you include ALL possible metadata when using this method!
+     * @param mapColors Array of mapcolor objects which is referenced when rendering maps
+     * @return
+     */
+    public Block setMapColorsForMetadata(MapColor[] mapColors) {
+    	this.mapColorsForMetadata = mapColors;
+    	return this;
+    }
+	
+	//----------------- Integrity Test ----------------//
+    
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    /**
+     * Mainly used by shouldSideBeRendered() so that it can access the current render bounds.
+     * NOTE: Does not apply to item rendering unless specifically set within RenderBlockAsItem()
+     */
+    public RenderBlocks m_currentBlockRenderer = null;
+    
+    public boolean shouldSideBeRendered( IBlockAccess blockAccess, 
+    	int iNeighborI, int iNeighborJ, int iNeighborK, int iSide )
+    {
+        Block neighborBlock = Block.blocksList[blockAccess.getBlockId( iNeighborI, iNeighborJ, iNeighborK )];
+        
+        if ( neighborBlock != null )
+        {
+        	return neighborBlock.ShouldRenderNeighborFullFaceSide( blockAccess, iNeighborI, iNeighborJ, iNeighborK, iSide ); 
+        }
+        
+        return true;
+    }
+    
+    public boolean ShouldRenderNeighborHalfSlabSide( IBlockAccess blockAccess, int i, int j, int k, int iNeighborSlabSide, boolean bNeighborUpsideDown )
+    {
+		return !isOpaqueCube();
+    }
+    
+    public boolean ShouldRenderNeighborFullFaceSide( IBlockAccess blockAccess, int i, int j, int k, int iNeighborSide )
+    {
+		return !isOpaqueCube();
+    }
+    
+    public boolean RenderBlock( RenderBlocks renderer, int i, int j, int k )
+    {
+        renderer.setRenderBounds( GetBlockBoundsFromPoolBasedOnState( 
+        	renderer.blockAccess, i, j, k ) );
+        
+    	return renderer.renderStandardBlock( this, i, j, k );
+    }
+
+    /** 
+     * If the block has a second pass, like a kiln cooking overlay texture, it should Override this method.  This method does not call the overlay
+     * by default to cut down on rendering time, since this function is called by every single loaded block.
+     * Note that this function is necessary to prevent potential recursion within RenderBlock, if it were to call its own overlays
+     * directly, and then potentially get called with a texture overlay itself through RenderBlockWithTexture.
+     */
+    public void RenderBlockSecondPass( RenderBlocks renderBlocks, int i, int j, int k, boolean bFirstPassResult )
+    {    
+    }
+    
+    public boolean RenderBlockWithTexture( RenderBlocks renderBlocks, int i, int j, int k, Icon texture )
+    {
+    	boolean bReturnValue;
+    	
+    	renderBlocks.setOverrideBlockTexture( texture );
+    	
+		// this test is necessary due to optimizations in RenderStandardFullBlock() that 
+    	// assumes the texture isn't overriden 
+    	if ( !renderAsNormalBlock() )
+    	{
+	        bReturnValue = RenderBlock( renderBlocks, i, j, k );
+	        
+    	}
+    	else
+    	{
+        	renderBlocks.setRenderBounds( GetBlockBoundsFromPoolBasedOnState( 
+        		renderBlocks.blockAccess, i, j, k ) );
+            
+            bReturnValue = renderBlocks.renderStandardBlock( this, i, j, k );            
+    	}
+    	
+        renderBlocks.clearOverrideBlockTexture();
+        
+        return bReturnValue;
+    }
+
+    public AxisAlignedBB GetBlockBoundsFromPoolForItemRender( int iItemDamage )
+    {
+    	return GetFixedBlockBoundsFromPool();
+    }
+    
+    public void RenderBlockAsItem( RenderBlocks renderBlocks, int iItemDamage, float fBrightness )
+    {
+    	renderBlocks.renderBlockAsItemVanilla( this, iItemDamage, fBrightness );
+    }
+    
+    public boolean DoesItemRenderAsBlock( int iItemDamage )
+    {
+    	return RenderBlocks.DoesRenderIDRenderItemIn3d( getRenderType() );
+    }    
+    
+    public void RenderCookingByKilnOverlay( RenderBlocks renderBlocks, int i, int j, int k, boolean bFirstPassResult )
+    {
+    	if ( bFirstPassResult )
+    	{
+	    	IBlockAccess blockAccess = renderBlocks.blockAccess;
+	    	
+	    	// check texture override to prevent recursion
+			if ( !renderBlocks.hasOverrideBlockTexture() && GetCanBeCookedByKiln( blockAccess, i, j, k ) )
+			{
+	    		int iBlockBelowID = blockAccess.getBlockId( i, j - 1, k );
+	    		
+	    		if ( iBlockBelowID == FCBetterThanWolves.fcKiln.blockID )
+	    		{
+	    			Icon overlayTexture = FCBetterThanWolves.fcKiln.GetCookTextureForCurrentState( blockAccess, i, j - 1, k );
+	    			
+	            	if ( overlayTexture != null )
+	            	{
+	            		RenderBlockWithTexture( renderBlocks, i, j, k, overlayTexture );
+	            	}
+	    		} 
+			}
+    	}
+    }
+    
+    public boolean ShouldRenderWhileFalling( World world, EntityFallingSand entity )
+    {
+        int iCurrentBlockI = MathHelper.floor_double( entity.posX );
+        int iCurrentBlockJ = MathHelper.floor_double( entity.posY );
+        int iCurrentBlockK = MathHelper.floor_double( entity.posZ );
+        
+        int iBlockIDAtLocation = world.getBlockId( iCurrentBlockI, iCurrentBlockJ, iCurrentBlockK );
+        
+    	return iBlockIDAtLocation != entity.blockID;
+    }
+
+    /**
+     * Applies both to falling blocks, and those pushed by pistons
+     */     
+    public void RenderFallingBlock( RenderBlocks renderBlocks, int i, int j, int k, int iMetadata ) 
+    {
+        renderBlocks.setRenderBounds( GetFixedBlockBoundsFromPool() );
+        
+        renderBlocks.RenderStandardFallingBlock( this, i, j, k, iMetadata );
+    }
+    
+    public boolean ShouldSideBeRenderedOnFallingBlock( int iSide, int iMetadata )
+    {
+    	// called within renderBlocks.renderStandardMovingBlock() instead of the usual
+    	// shouldSideBeRendered() since neighboring blocks aren't relevant while moving
+    	
+    	return true;
+    }
+    
+    public void RenderBlockMovedByPiston( RenderBlocks renderBlocks, int i, int j, int k )
+    {
+        renderBlocks.renderBlockAllFaces( this, i, j, k );
+    }
+    
+    public AxisAlignedBB getSelectedBoundingBoxFromPool( World world, int i, int j, int k )
+    {
+    	return GetBlockBoundsFromPoolBasedOnState( world, i, j, k ).offset( i, j, k );
+    }
+    
+    /** 
+     * Replaces vanilla call in RenderGlobal to provide ray trace info so specific portions of the block can be highlighted as selected
+     */
+    public AxisAlignedBB getSelectedBoundingBoxFromPool( World world, MovingObjectPosition rayTraceHit )
+    {
+        return getSelectedBoundingBoxFromPool( world, rayTraceHit.blockX, rayTraceHit.blockY, rayTraceHit.blockZ );
+    }
+
+    /**
+     * Called by geometric primitives that FCModelBlock uses, to reference textures not associated with a specific block
+     * side.
+     */ 
+    public Icon GetIconByIndex( int iIndex )
+    {
+    	return blockIcon;
+    }
+    
+    public Icon GetHopperFilterIcon()
+    {
+    	return null;
+    }
+    
+    protected void RenderCrossHatch( RenderBlocks renderer, int i, int j, int k, Icon icon, 
+    	double dBorderWidth, double dVerticalOffset )
+    {
+    	Tessellator tessellator = Tessellator.instance;
+    	
+    	double dX = i; 
+    	double dY = j + dVerticalOffset;
+    	double dZ = k;
+    	
+        double dMinU = icon.getMinU();
+        double dMinV = icon.getMinV();
+        double dMaxU = icon.getMaxU();
+        double dMaxV = icon.getMaxV();
+        
+        double dX1 = dX + 1D - dBorderWidth;
+        double dX2 = dX + dBorderWidth;
+        
+        double dZ1 = dZ;
+        double dZ2 = dZ + 1D;
+        
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ1, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ1, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ2, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ2, dMaxU, dMinV );
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ2, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ2, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ1, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ1, dMaxU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ2, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ2, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ1, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ1, dMaxU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ1, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ1, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ2, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ2, dMaxU, dMinV );
+        
+        dX1 = dX;
+        dX2 = dX + 1D;
+        
+        dZ1 = dZ + dBorderWidth;
+        dZ2 = dZ + 1D - dBorderWidth;
+        
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ1, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ1, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ1, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ1, dMaxU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ1, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ1, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ1, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ1, dMaxU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ2, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ2, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ2, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ2, dMaxU, dMinV );
+        tessellator.addVertexWithUV( dX1, dY + 1D, dZ2, dMinU, dMinV );
+        tessellator.addVertexWithUV( dX1, dY + 0D, dZ2, dMinU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 0D, dZ2, dMaxU, dMaxV );
+        tessellator.addVertexWithUV( dX2, dY + 1D, dZ2, dMaxU, dMinV );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockCrops.java b/minecraft/net/minecraft/src/BlockCrops.java
index 526cc10..ed1f7c4 100644
--- a/minecraft/net/minecraft/src/BlockCrops.java
+++ b/minecraft/net/minecraft/src/BlockCrops.java
@@ -11,7 +11,10 @@ public class BlockCrops extends BlockFlower
         super(par1);
         this.setTickRandomly(true);
         float var2 = 0.5F;
-        this.setBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
+        InitBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
+        //END FCMOD
         this.setCreativeTab((CreativeTabs)null);
         this.setHardness(0.0F);
         this.setStepSound(soundGrassFootstep);
@@ -22,14 +25,20 @@ public class BlockCrops extends BlockFlower
      * Gets passed in the blockID of the block below and supposed to return true if its allowed to grow on the type of
      * blockID passed in. Args: blockID
      */
+    // FCMOD: Removed as deprecated
+    /*
     protected boolean canThisPlantGrowOnThisBlockID(int par1)
     {
         return par1 == Block.tilledField.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * Ticks the block if it's been scheduled
      */
+    // FCMOD: Removed and replaced
+    /*
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
         super.updateTick(par1World, par2, par3, par4, par5Random);
@@ -50,6 +59,8 @@ public class BlockCrops extends BlockFlower
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Apply bonemeal to the crops.
@@ -71,6 +82,8 @@ public class BlockCrops extends BlockFlower
      * different sides that aren't opposing, and by adding growth for every crop next to this one (and for crop below
      * this one). Args: x, y, z
      */
+    // FCMOD: Removed as deprecated
+    /*
     private float getGrowthRate(World par1World, int par2, int par3, int par4)
     {
         float var5 = 1.0F;
@@ -119,6 +132,8 @@ public class BlockCrops extends BlockFlower
 
         return var5;
     }
+    */
+    // END FCMOD
 
     /**
      * From the specified side and block metadata retrieves the blocks texture. Args: side, metadata
@@ -168,6 +183,8 @@ public class BlockCrops extends BlockFlower
         {
             if (par5 >= 7)
             {
+            	// FCMOD: Change
+            	/*
                 int var8 = 3 + par7;
 
                 for (int var9 = 0; var9 < var8; ++var9)
@@ -177,6 +194,9 @@ public class BlockCrops extends BlockFlower
                         this.dropBlockAsItem_do(par1World, par2, par3, par4, new ItemStack(this.getSeedItem(), 1, 0));
                     }
                 }
+                */
+            	DropSeeds( par1World, par2, par3, par4, par5, par6, par7);
+            	// END FCMOD
             }
         }
     }
@@ -184,10 +204,14 @@ public class BlockCrops extends BlockFlower
     /**
      * Returns the ID of the items to drop on destruction.
      */
+    // FCMOD: Removed and replaced
+    /*
     public int idDropped(int par1, Random par2Random, int par3)
     {
         return par1 == 7 ? this.getCropItem() : this.getSeedItem();
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the quantity of items to drop on block destruction.
@@ -218,4 +242,160 @@ public class BlockCrops extends BlockFlower
             this.iconArray[var2] = par1IconRegister.registerIcon("crops_" + var2);
         }
     }
+
+    // FCMOD: Added New    
+    @Override
+    public int idDropped( int iMetadata, Random random, int iFortuneModifier )
+    {
+    	if ( iMetadata == 7 )
+    	{
+    		return getCropItem();
+    	}
+    	
+        return 0;
+    }
+    
+    @Override
+    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+    	EntityAnimal animal )
+    {
+		return true;
+    }
+    
+    @Override
+    public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
+    {
+    	// drop the block as an item so that animals can get the base graze value + eat
+    	// any tasties that drop
+    	
+        dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+        
+        super.OnGrazed( world, i, j, k, animal );    
+    }
+    
+    @Override
+    public void updateTick( World world, int i, int j, int k, Random rand )
+    {
+        super.updateTick( world, i, j, k, rand );
+
+    	// make sure parent update didn't destroy the block, and prevent crops growing in the end
+    	// note that CanGrowOnBlock() has already been confirmed in parent method    	
+    	
+        if ( world.provider.dimensionId != 1 && 
+        	world.getBlockId( i, j, k ) == blockID )
+        {
+        	AttemptToGrow( world, i, j, k, rand );
+        }
+    }
+
+    @Override
+    protected boolean CanGrowOnBlock( World world, int i, int j, int k )
+    {
+    	Block blockOn = Block.blocksList[world.getBlockId( i, j, k )];
+    	
+    	return blockOn != null && blockOn.CanDomesticatedCropsGrowOnBlock( world, i, j, k );
+    }
+    
+	@Override
+	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return true;
+	}
+	
+    //------------- Class Specific Methods ------------//
+    
+    protected void AttemptToGrow( World world, int i, int j, int k, Random rand )
+    {
+    	if ( GetWeedsGrowthLevel( world, i, j, k ) == 0 && 
+    		GetGrowthLevel( world, i, j, k ) < 7 && 
+	    	world.getBlockLightValue( i, j + 1, k ) >= 9 )
+	    {
+	        Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+	        
+	        if ( blockBelow != null && 
+	        	blockBelow.IsBlockHydratedForPlantGrowthOn( world, i, j - 1, k ) )
+	        {
+	    		float fGrowthChance = GetBaseGrowthChance( world, i, j, k ) *
+	    			blockBelow.GetPlantGrowthOnMultiplier( world, i, j - 1, k, this );
+	    		
+	            if ( rand.nextFloat() <= fGrowthChance )
+	            {
+	            	IncrementGrowthLevel( world, i, j, k );
+	            }
+	        }
+	    }
+    }
+    
+    public void DropSeeds( World world, int i, int j, int k, int iMetadata, 
+    	float fChance, int iFortuneModifier )
+    {
+        dropBlockAsItem_do(world, i, j, k, new ItemStack( getSeedItem(), 1, 0 ) );
+        
+        if ( world.rand.nextInt( 16 ) - iFortuneModifier < 4 )
+        {
+            dropBlockAsItem_do(world, i, j, k, new ItemStack( getSeedItem(), 1, 0 ) );
+        }
+    }
+    
+    public float GetBaseGrowthChance( World world, int i, int j, int k )
+    {
+    	return 0.05F;
+    }
+    
+    protected void IncrementGrowthLevel( World world, int i, int j, int k )
+    {
+    	int iGrowthLevel = GetGrowthLevel( world, i, j, k ) + 1;
+    	
+        SetGrowthLevel( world, i, j, k, iGrowthLevel );
+        
+        if ( iGrowthLevel == 7 )
+        {
+        	Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+        	
+        	if ( blockBelow != null )
+        	{
+        		blockBelow.NotifyOfFullStagePlantGrowthOn( world, i, j - 1, k, this );
+        	}
+        }
+    }
+    
+    protected int GetGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetGrowthLevel( blockAccess.getBlockMetadata( i, j, k ) );
+    }
+    
+    protected int GetGrowthLevel( int iMetadata )
+    {
+    	return iMetadata & 7;
+    }
+    
+    protected void SetGrowthLevel( World world, int i, int j, int k, int iLevel )
+    {
+    	int iMetadata = world.getBlockMetadata( i, j, k ) & (~7); // filter out old level   	
+    	
+    	world.setBlockMetadataWithNotify( i, j, k, iMetadata | iLevel );
+    }
+    
+    protected void SetGrowthLevelNoNotify( World world, int i, int j, int k, int iLevel )
+    {
+    	int iMetadata = world.getBlockMetadata( i, j, k ) & (~7); // filter out old level   	
+    	
+    	world.setBlockMetadata( i, j, k, iMetadata | iLevel );
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public boolean RenderBlock( RenderBlocks renderer, int i, int j, int k )
+    {
+    	renderer.setRenderBounds( GetBlockBoundsFromPoolBasedOnState( 
+    		renderer.blockAccess, i, j, k ) );
+        
+    	renderer.renderBlockCrops( this, i, j, k );
+    	
+    	FCBetterThanWolves.fcBlockWeeds.RenderWeeds( this, renderer, i, j, k );
+
+		return true;
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockDoor.java b/minecraft/net/minecraft/src/BlockDoor.java
index bf654e9..d536989 100644
--- a/minecraft/net/minecraft/src/BlockDoor.java
+++ b/minecraft/net/minecraft/src/BlockDoor.java
@@ -471,4 +471,11 @@ public class BlockDoor extends Block
             par1World.setBlockToAir(par2, par3 - 1, par4);
         }
     }
-}
+    
+    // FCMOD: Code added
+    public void OnAIOpenDoor( World world, int i, int j, int k, boolean bOpen )
+    {
+    	onPoweredBlockChange( world, i, j, k, bOpen );    	
+    }
+    // END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/BlockFire.java b/minecraft/net/minecraft/src/BlockFire.java
index 37053a1..3266b60 100644
--- a/minecraft/net/minecraft/src/BlockFire.java
+++ b/minecraft/net/minecraft/src/BlockFire.java
@@ -5,13 +5,24 @@ import java.util.Random;
 public class BlockFire extends Block
 {
     /** The chance this block will encourage nearby blocks to catch on fire */
+	// FCMOD: Change to static, public, and extended block IDs
+	/*
     private int[] chanceToEncourageFire = new int[256];
+    */
+    static public int[] chanceToEncourageFire = new int[4096];
+    // END FCMOD
 
     /**
      * This is an array indexed by block ID the larger the number in the array the more likely a block type will catch
      * fires
      */
+	// FCMOD: Change to static, public, and extended block IDs
+    // FCNOTE: This is actually the chance of a block being DESTROYED by fire, and potentially converted to a fire block
+	/*
     private int[] abilityToCatchFire = new int[256];
+    */
+    static public int[] abilityToCatchFire = new int[4096];
+    // END FCMOD
     private Icon[] iconArray;
 
     protected BlockFire(int par1)
@@ -24,6 +35,8 @@ public class BlockFire extends Block
      * This method is called on a block after all other blocks gets already created. You can use it to reference and
      * configure something on the block that needs the others ones.
      */
+	// FCMOD: Removed in favor of the block classes themselves setting their own fire properties
+    /*
     public void initializeBlock()
     {
         this.setBurnRate(Block.planks.blockID, 5, 20);
@@ -42,6 +55,8 @@ public class BlockFire extends Block
         this.setBurnRate(Block.cloth.blockID, 30, 60);
         this.setBurnRate(Block.vine.blockID, 15, 100);
     }
+    */
+    // END FCMOD
 
     /**
      * Sets the burn rate for a block. The larger abilityToCatchFire the more easily it will catch. The larger
@@ -107,6 +122,8 @@ public class BlockFire extends Block
     /**
      * Ticks the block if it's been scheduled
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
         if (par1World.getGameRules().getGameRuleBooleanValue("doFireTick"))
@@ -212,6 +229,8 @@ public class BlockFire extends Block
             }
         }
     }
+    */
+    // END FCMOD
 
     public boolean func_82506_l()
     {
@@ -226,7 +245,10 @@ public class BlockFire extends Block
         {
             boolean var9 = par1World.getBlockId(par2, par3, par4) == Block.tnt.blockID;
 
-            if (par6Random.nextInt(par7 + 10) < 5 && !par1World.canLightningStrikeAt(par2, par3, par4))
+            // FCMOD: Changed
+            //if (par6Random.nextInt(par7 + 10) < 5 && !par1World.canLightningStrikeAt(par2, par3, par4))
+            if ( par6Random.nextInt( par7 + 10 ) < 5 && !par1World.IsRainingAtPos( par2, par3, par4 ) )
+        	// END FCMOD
             {
                 int var10 = par7 + par6Random.nextInt(5) / 4;
 
@@ -252,7 +274,12 @@ public class BlockFire extends Block
     /**
      * Returns true if at least one block next to this one can burn.
      */
+	// FCMOD: Changed to protected
+	/*
     private boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
+    */
+    protected boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
+    // END FCMOD
     {
         return this.canBlockCatchFire(par1World, par2 + 1, par3, par4) ? true : (this.canBlockCatchFire(par1World, par2 - 1, par3, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3 - 1, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3 + 1, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3, par4 - 1) ? true : this.canBlockCatchFire(par1World, par2, par3, par4 + 1)))));
     }
@@ -260,6 +287,8 @@ public class BlockFire extends Block
     /**
      * Gets the highest chance of a neighbor block encouraging this block to catch fire
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     private int getChanceOfNeighborsEncouragingFire(World par1World, int par2, int par3, int par4)
     {
         byte var5 = 0;
@@ -279,6 +308,8 @@ public class BlockFire extends Block
             return var6;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns if this block is collidable (only used by Fire). Args: x, y, z
@@ -301,11 +332,15 @@ public class BlockFire extends Block
      * current number passed in it will return its number instead of the passed in one.  Args: world, x, y, z,
      * curChanceToEncourageFire
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public int getChanceToEncourageFire(World par1World, int par2, int par3, int par4, int par5)
     {
         int var6 = this.chanceToEncourageFire[par1World.getBlockId(par2, par3, par4)];
         return var6 > par5 ? var6 : par5;
     }
+    */
+    // END FCMOD
 
     /**
      * Checks to see if its valid to put this block at the specified coordinates. Args: world, x, y, z
@@ -450,4 +485,27 @@ public class BlockFire extends Block
     {
         return this.iconArray[0];
     }
+    
+    // FCMOD: Added New
+    
+	//----------- Client Side Functionality -----------//
+	
+    public boolean ShouldFirePreferToDisplayUpwards( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return ( blockAccess.doesBlockHaveSolidTopSurface( i, j - 1, k) && Block.fire.canBlockCatchFire( blockAccess, i, j - 1, k ) ) ||
+    		IsBlockInfiniteBurnToTopForRender( blockAccess, i, j - 1, k );
+    }
+    
+	public boolean IsBlockInfiniteBurnToTopForRender( IBlockAccess blockAccess, int i, int j, int k )
+	{		
+    	int iBlockID = blockAccess.getBlockId( i, j, k );    	
+    	
+    	// have to manually test for the Hibachi here as doesn't have its state
+    	// communicated to the client, and thus will not return a valid result
+    	
+		return iBlockID == Block.netherrack.blockID || 
+			iBlockID == FCBetterThanWolves.fcBBQ.blockID || 
+			DoesInfiniteBurnToFacing( blockAccess, i, j, k, 1 );
+	}
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockFlower.java b/minecraft/net/minecraft/src/BlockFlower.java
index 410afc9..37d8ec6 100644
--- a/minecraft/net/minecraft/src/BlockFlower.java
+++ b/minecraft/net/minecraft/src/BlockFlower.java
@@ -2,14 +2,24 @@ package net.minecraft.src;
 
 import java.util.Random;
 
-public class BlockFlower extends Block
+// FCMOD: Changed
+//public class BlockFlower extends Block
+public class BlockFlower extends FCBlockPlants
+// END FCMOD
 {
+	/**
+	 * FCNOTE: This class would be better called BlockPlants, as it acts as a common base class
+	 * for vegetation and crops.
+	 */
     protected BlockFlower(int par1, Material par2Material)
     {
         super(par1, par2Material);
         this.setTickRandomly(true);
         float var3 = 0.2F;
-        this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3);
+        InitBlockBounds( 0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3 );
+        // END FCMOD
         this.setCreativeTab(CreativeTabs.tabDecorations);
     }
 
@@ -18,22 +28,27 @@ public class BlockFlower extends Block
         this(par1, Material.plants);
     }
 
-    /**
-     * Checks to see if its valid to put this block at the specified coordinates. Args: world, x, y, z
-     */
+    // FCMOD: Removed and replaced
+    /*
     public boolean canPlaceBlockAt(World par1World, int par2, int par3, int par4)
     {
         return super.canPlaceBlockAt(par1World, par2, par3, par4) && this.canThisPlantGrowOnThisBlockID(par1World.getBlockId(par2, par3 - 1, par4));
     }
+    */
+    // END FCMOD
 
     /**
      * Gets passed in the blockID of the block below and supposed to return true if its allowed to grow on the type of
      * blockID passed in. Args: blockID
      */
+    // FCMOD: Removed as deprecated
+    /*
     protected boolean canThisPlantGrowOnThisBlockID(int par1)
     {
         return par1 == Block.grass.blockID || par1 == Block.dirt.blockID || par1 == Block.tilledField.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
@@ -65,10 +80,14 @@ public class BlockFlower extends Block
     /**
      * Can this block stay at this position.  Similar to canPlaceBlockAt except gets checked often with plants.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean canBlockStay(World par1World, int par2, int par3, int par4)
     {
         return (par1World.getFullBlockLightValue(par2, par3, par4) >= 8 || par1World.canBlockSeeTheSky(par2, par3, par4)) && this.canThisPlantGrowOnThisBlockID(par1World.getBlockId(par2, par3 - 1, par4));
     }
+    */
+    // END FCMOD
 
     /**
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
@@ -103,4 +122,24 @@ public class BlockFlower extends Block
     {
         return 1;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public boolean canBlockStay( World world, int i, int j, int k )
+    {
+        return ( world.getFullBlockLightValue( i, j, k ) >= 8 || 
+        	world.canBlockSeeTheSky( i, j, k ) ) && super.canBlockStay( world, i, j, k ); 
+    }
+    
+    @Override
+    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+    	EntityAnimal animal )
+    {
+		return animal.CanGrazeOnRoughVegetation();
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockFlowing.java b/minecraft/net/minecraft/src/BlockFlowing.java
index 2bee21b..0cf8032 100644
--- a/minecraft/net/minecraft/src/BlockFlowing.java
+++ b/minecraft/net/minecraft/src/BlockFlowing.java
@@ -65,6 +65,12 @@ public class BlockFlowing extends BlockFluid
             var12 = this.getSmallestFlowDecay(par1World, par2 + 1, par3, par4, var12);
             var12 = this.getSmallestFlowDecay(par1World, par2, par3, par4 - 1, var12);
             var12 = this.getSmallestFlowDecay(par1World, par2, par3, par4 + 1, var12);
+            
+            // FCMOD: Code added
+        	var12 = GetSmallestFlowDecayFromCustomSources( par1World, par2, par3, par4, var12 );          
+        	int iTickRate = tickRate(par1World);
+            // END FCMOD
+        	
             var10 = var12 + var7;
 
             if (var10 >= 8 || var12 < 0)
@@ -98,11 +104,19 @@ public class BlockFlowing extends BlockFluid
                 }
             }
 
+        	// FCMOD: Code change to import 1.6 lava flow fix with additional variability so it doesn't look as weird
+            /*
             if (this.blockMaterial == Material.lava && var6 < 8 && var10 < 8 && var10 > var6 && par5Random.nextInt(4) != 0)
             {
                 var10 = var6;
                 var8 = false;
             }
+            */
+            if ( this.blockMaterial == Material.lava && var6 < 8 && var10 < 8 && var10 > var6 )
+            {
+            	iTickRate += iTickRate * ( 1 + par5Random.nextInt( 4 ) );
+            }
+            // END FCMOD
 
             if (var10 == var6)
             {
@@ -122,7 +136,12 @@ public class BlockFlowing extends BlockFluid
                 else
                 {
                     par1World.setBlockMetadataWithNotify(par2, par3, par4, var10, 2);
+                	// FCMOD: Code change to import 1.6 lava flow fix with additional variability so it doesn't look as weird
+                    /*
                     par1World.scheduleBlockUpdate(par2, par3, par4, this.blockID, this.tickRate(par1World));
+                    */
+                    par1World.scheduleBlockUpdate( par2, par3, par4, this.blockID, iTickRate );
+                    // END FCMOD
                     par1World.notifyBlocksOfNeighborChange(par2, par3, par4, this.blockID);
                 }
             }
@@ -136,7 +155,11 @@ public class BlockFlowing extends BlockFluid
         {
             if (this.blockMaterial == Material.lava && par1World.getBlockMaterial(par2, par3 - 1, par4) == Material.water)
             {
-                par1World.setBlock(par2, par3 - 1, par4, Block.stone.blockID);
+            	// FCMOD: Changed
+                //par1World.setBlock(par2, par3 - 1, par4, Block.stone.blockID);
+                par1World.setBlock( par2, par3 - 1, par4, 
+                	FCBetterThanWolves.fcBlockLavaPillow.blockID );
+                // END FCMOD
                 this.triggerLavaMixEffects(par1World, par2, par3 - 1, par4);
                 return;
             }
@@ -205,7 +228,10 @@ public class BlockFlowing extends BlockFluid
                 }
                 else
                 {
-                    Block.blocksList[var6].dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
+                	// FCMOD: Changed                	
+                    //Block.blocksList[var6].dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
+                	Block.blocksList[var6].OnFluidFlowIntoBlock( par1World, par2, par3, par4, this );
+                	// END FCMOD
                 }
             }
 
@@ -342,6 +368,8 @@ public class BlockFlowing extends BlockFluid
     /**
      * Returns true if block at coords blocks fluids
      */
+    // FCMOD: Removed and replaced later
+    /*
     private boolean blockBlocksFlow(World par1World, int par2, int par3, int par4)
     {
         int var5 = par1World.getBlockId(par2, par3, par4);
@@ -363,6 +391,8 @@ public class BlockFlowing extends BlockFluid
             return true;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * getSmallestFlowDecay(World world, intx, int y, int z, int currentSmallestFlowDecay) - Looks up the flow decay at
@@ -420,4 +450,58 @@ public class BlockFlowing extends BlockFluid
     {
         return false;
     }
+    
+    // FCMOD: Added New   
+    @Override
+    public void onNeighborBlockChange( World world, int i, int j, int k, int iNeighborBlockID )
+    {
+    	super.onNeighborBlockChange( world, i, j, k, iNeighborBlockID );
+    	
+    	// these blocks normally have an update scheduled, and randomly get ticked to 
+    	// ensure they don't get stalled on chunk load, but can sit there for extend periods
+    	// until that happens, so this ensures player interaction will get them going again
+    	
+    	if ( !world.IsUpdatePendingThisTickForBlock( i, j, k, blockID ) )
+    	{
+    		world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+    	}
+    }
+
+	private int GetSmallestFlowDecayFromCustomSources( World world, int i, int j, int k, int iSmallestFlowDecay )
+	{
+		// note that this function doesn't update numAdjacentSources as that is used for new source block creation
+		
+        if ( iSmallestFlowDecay != 0 )
+        {
+        	for ( int iFacing = 0; iFacing < 6; iFacing++ )
+        	{
+        		int iTargetDecay = FCUtilsWorld.IsValidSourceForFluidBlockToFacing( world, i, j, k, iFacing );
+        		
+				if ( iTargetDecay == 0 )
+				{
+					iSmallestFlowDecay = 0;
+					
+					break;
+				}
+				
+				if ( iTargetDecay > 0 )
+				{
+					if ( iSmallestFlowDecay < 0 || iTargetDecay < iSmallestFlowDecay )
+					{
+						iSmallestFlowDecay = iTargetDecay;
+					}
+				}
+        	}
+        }
+        
+		return iSmallestFlowDecay;
+	}
+	
+    public boolean blockBlocksFlow( World world, int i, int j, int k )
+    {
+        Block block = blocksList[world.getBlockId( i, j, k )];
+        
+        return block != null && block.GetPreventsFluidFlow( world, i, j, k, this );
+    }
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockFluid.java b/minecraft/net/minecraft/src/BlockFluid.java
index 8ffc33c..e62b727 100644
--- a/minecraft/net/minecraft/src/BlockFluid.java
+++ b/minecraft/net/minecraft/src/BlockFluid.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.Random;
 
 public abstract class BlockFluid extends Block
@@ -11,7 +12,10 @@ public abstract class BlockFluid extends Block
         super(par1, par2Material);
         float var3 = 0.0F;
         float var4 = 0.0F;
-        this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
+        InitBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
+        // END FCMOD
         this.setTickRandomly(true);
     }
 
@@ -22,7 +26,7 @@ public abstract class BlockFluid extends Block
 
     public int getBlockColor()
     {
-        return 16777215;
+        return ColorizeBlock.colorizeBlock(this) ? ColorizeBlock.blockColor : 16777215;
     }
 
     /**
@@ -31,7 +35,11 @@ public abstract class BlockFluid extends Block
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        if (this.blockMaterial != Material.water)
+    	if (ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4))
+        {
+            return ColorizeBlock.blockColor;
+        }
+        else if (this.blockMaterial != Material.water)
         {
             return 16777215;
         }
@@ -148,11 +156,15 @@ public abstract class BlockFluid extends Block
      * Returns true if the given side of this block type should be rendered, if the adjacent block is at the given
      * coordinates.  Args: blockAccess, x, y, z, side
      */
+	// FCMOD: Code removed and replaced later.  Client only
+    /*
     public boolean shouldSideBeRendered(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)
     {
         Material var6 = par1IBlockAccess.getBlockMaterial(par2, par3, par4);
         return var6 == this.blockMaterial ? false : (par5 == 1 ? true : (var6 == Material.ice ? false : super.shouldSideBeRendered(par1IBlockAccess, par2, par3, par4, par5)));
     }
+    */
+    // END FCMOD
 
     /**
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
@@ -190,6 +202,8 @@ public abstract class BlockFluid extends Block
     /**
      * Returns a vector indicating the direction and intensity of fluid flow.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     private Vec3 getFlowVector(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         Vec3 var5 = par1IBlockAccess.getWorldVec3Pool().getVecFromPool(0.0D, 0.0D, 0.0D);
@@ -296,6 +310,8 @@ public abstract class BlockFluid extends Block
         var5 = var5.normalize();
         return var5;
     }
+    */
+    // END FCMOD
 
     /**
      * Can add to the passed in vector for a movement vector to be applied to the entity. Args: x, y, z, entity, vec3d
@@ -459,8 +475,8 @@ public abstract class BlockFluid extends Block
         }
 
         double var21;
-        double var22;
         double var23;
+        double var22;
 
         if (this.blockMaterial == Material.lava && par1World.getBlockMaterial(par2, par3 + 1, par4) == Material.air && !par1World.isBlockOpaqueCube(par2, par3 + 1, par4))
         {
@@ -579,7 +595,11 @@ public abstract class BlockFluid extends Block
                     }
                     else if (var6 <= 4)
                     {
-                        par1World.setBlock(par2, par3, par4, Block.cobblestone.blockID);
+                    	// FCMOD: Changed
+                        //par1World.setBlock(par2, par3, par4, Block.cobblestone.blockID);
+                        par1World.setBlock( par2, par3, par4, 
+                        	FCBetterThanWolves.fcBlockLavaPillow.blockID );
+                        // END FCMOD
                     }
 
                     this.triggerLavaMixEffects(par1World, par2, par3, par4);
@@ -621,4 +641,107 @@ public abstract class BlockFluid extends Block
     {
         return par0Str == "water" ? Block.waterMoving.theIcon[0] : (par0Str == "water_flow" ? Block.waterMoving.theIcon[1] : (par0Str == "lava" ? Block.lavaMoving.theIcon[0] : (par0Str == "lava_flow" ? Block.lavaMoving.theIcon[1] : null)));
     }
+    
+    // FCMOD: Added New
+    @Override
+    public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    @Override
+    public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
+    {	 
+    	return null; // can't be picked up
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+    private Vec3 AddFlowVectorAtTarget( IBlockAccess iBlockAccess, int i, int j, int k, int iFlowDecay, int iTempI, int iTempK, Vec3 flowVec )
+    {
+        int iTempDecay = getEffectiveFlowDecay( iBlockAccess, iTempI, j, iTempK );
+
+        if ( iTempDecay < 0 )
+        {
+            if (!iBlockAccess.getBlockMaterial(iTempI, j, iTempK).blocksMovement())
+            {
+                iTempDecay = this.getEffectiveFlowDecay(iBlockAccess, iTempI, j - 1, iTempK);
+
+                if (iTempDecay >= 0)
+                {
+                    int iDeltaDecay = iTempDecay - (iFlowDecay - 8);
+                    return flowVec.addVector((double)((iTempI - i) * iDeltaDecay), 0D, (double)((iTempK - k) * iDeltaDecay));
+                }
+            }
+        }
+        else if (iTempDecay >= 0)
+        {
+            int iDeltaDecay = iTempDecay - iFlowDecay;
+            return flowVec.addVector((double)((iTempI - i) * iDeltaDecay), 0D, (double)((iTempK - k) * iDeltaDecay));
+        }
+        
+        return flowVec;
+    }
+    
+    private Vec3 getFlowVector( IBlockAccess iBlockAccess, int i, int j, int k )
+    {
+    	// optomized vanilla function
+    	
+        Vec3 flowVec = iBlockAccess.getWorldVec3Pool().getVecFromPool(0.0D, 0.0D, 0.0D);
+        
+        int iFlowDecay = getEffectiveFlowDecay( iBlockAccess, i, j, k );
+
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i - 1, k, flowVec );
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i, k - 1, flowVec );
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i + 1, k, flowVec );
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i, k + 1, flowVec );
+                
+        if (iBlockAccess.getBlockMetadata(i, j, k) >= 8)
+        {
+            if ( this.isBlockSolid(iBlockAccess, i, j, k - 1, 2)
+            || this.isBlockSolid(iBlockAccess, i, j, k + 1, 3)
+            || this.isBlockSolid(iBlockAccess, i - 1, j, k, 4)
+            || this.isBlockSolid(iBlockAccess, i + 1, j, k, 5)
+            || this.isBlockSolid(iBlockAccess, i, j + 1, k - 1, 2)
+            || this.isBlockSolid(iBlockAccess, i, j + 1, k + 1, 3)
+            || this.isBlockSolid(iBlockAccess, i - 1, j + 1, k, 4)
+            || this.isBlockSolid(iBlockAccess, i + 1, j + 1, k, 5) )
+            {
+                flowVec = flowVec.normalize().addVector(0.0D, -6.0D, 0.0D);
+            }
+        }
+
+        flowVec = flowVec.normalize();
+        
+        return flowVec;
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    public static boolean bIsAnySideBeingRendered; // temporary state tracking variable used by rendering    
+    
+    @Override
+    public boolean shouldSideBeRendered( IBlockAccess blockAccess, int i, int j, int k, int iSide )
+    {
+        Material material = blockAccess.getBlockMaterial( i, j, k );
+        
+        if ( material != blockMaterial && ( iSide == 1 || ( material != Material.ice && super.shouldSideBeRendered( blockAccess, i, j, k, iSide ) ) ) )
+        {
+        	bIsAnySideBeingRendered = true;
+        	
+        	return true;
+        }
+        
+        return false;
+    }
+    
+    @Override
+    public boolean RenderBlock( RenderBlocks renderer, int i, int j, int k )
+    {
+        renderer.setRenderBounds( GetBlockBoundsFromPoolBasedOnState( 
+        	renderer.blockAccess, i, j, k ) );
+        
+    	return renderer.renderBlockFluids( this, i, j, k );
+    }    
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/BlockFurnace.java b/minecraft/net/minecraft/src/BlockFurnace.java
index 9dc851b..583dfd8 100644
--- a/minecraft/net/minecraft/src/BlockFurnace.java
+++ b/minecraft/net/minecraft/src/BlockFurnace.java
@@ -10,15 +10,31 @@ public class BlockFurnace extends BlockContainer
     private final Random furnaceRand = new Random();
 
     /** True if this is an active furnace, false if idle */
+    // FCMOD: Changed to protected
+    /*
     private final boolean isActive;
+    */
+    protected final boolean isActive;
+    // END FCMOD
+    
 
     /**
      * This flag is used to prevent the furnace inventory to be dropped upon block removal, is used internally when the
      * furnace block changes from idle to active and vice-versa.
      */
-    private static boolean keepFurnaceInventory = false;
+    // FCMOD: Changed
+    //private static boolean keepFurnaceInventory = false;
+    protected static boolean keepFurnaceInventory = false;
+    // END FCMOD
+    
+    // FCMOD: Changed (client only)
+    /*
     private Icon furnaceIconTop;
     private Icon furnaceIconFront;
+    */
+    protected Icon furnaceIconTop;
+    protected Icon furnaceIconFront;
+    // END FCMOD
 
     protected BlockFurnace(int par1, boolean par2)
     {
@@ -107,6 +123,9 @@ public class BlockFurnace extends BlockContainer
         if (this.isActive)
         {
             int var6 = par1World.getBlockMetadata(par2, par3, par4);
+            //FCMOD: Added to filter out inventory state
+            var6 = var6 & 7;
+            // END FCMOD
             float var7 = (float)par2 + 0.5F;
             float var8 = (float)par3 + 0.0F + par5Random.nextFloat() * 6.0F / 16.0F;
             float var9 = (float)par4 + 0.5F;
@@ -161,7 +180,12 @@ public class BlockFurnace extends BlockContainer
     /**
      * Update which block ID the furnace is using depending on whether or not it is burning
      */
+    // FCMOD: Changed
+    /*
     public static void updateFurnaceBlockState(boolean par0, World par1World, int par2, int par3, int par4)
+    */
+    public void updateFurnaceBlockState(boolean par0, World par1World, int par2, int par3, int par4, boolean bHasContents)
+    // END FCMOD
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         TileEntity var6 = par1World.getBlockTileEntity(par2, par3, par4);
@@ -177,6 +201,16 @@ public class BlockFurnace extends BlockContainer
         }
 
         keepFurnaceInventory = false;
+        // FCMOD: Code added
+        if ( !bHasContents )
+        {
+        	var5 = var5 & 7;
+        }
+        else
+        {
+        	var5 = var5 | 8;
+        }
+        // END FCMOD        
         par1World.setBlockMetadataWithNotify(par2, par3, par4, var5, 2);
 
         if (var6 != null)
diff --git a/minecraft/net/minecraft/src/BlockGrass.java b/minecraft/net/minecraft/src/BlockGrass.java
index c7f2891..76e3d39 100644
--- a/minecraft/net/minecraft/src/BlockGrass.java
+++ b/minecraft/net/minecraft/src/BlockGrass.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.mal.block.RenderBlocksUtils;
 import java.util.Random;
 
 public class BlockGrass extends Block
@@ -28,7 +30,13 @@ public class BlockGrass extends Block
      */
     public Icon getBlockTexture(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)
     {
-        if (par5 == 1)
+    	Icon var7 = RenderBlocksUtils.getGrassTexture(this, par1IBlockAccess, par2, par3, par4, par5, this.iconGrassTop);
+
+        if (var7 != null)
+        {
+            return var7;
+        }
+        else if (par5 == 1)
         {
             return this.iconGrassTop;
         }
@@ -57,9 +65,16 @@ public class BlockGrass extends Block
 
     public int getBlockColor()
     {
-        double var1 = 0.5D;
-        double var3 = 1.0D;
-        return ColorizerGrass.getGrassColor(var1, var3);
+    	if (ColorizeBlock.colorizeBlock(this))
+        {
+            return ColorizeBlock.blockColor;
+        }
+        else
+        {
+            double var1 = 0.5D;
+            double var3 = 1.0D;
+            return ColorizerGrass.getGrassColor(var1, var3);
+        }
     }
 
     /**
@@ -67,7 +82,7 @@ public class BlockGrass extends Block
      */
     public int getRenderColor(int par1)
     {
-        return this.getBlockColor();
+        return ColorizeBlock.colorizeBlock(this, par1) ? ColorizeBlock.blockColor : this.getBlockColor();
     }
 
     /**
@@ -76,22 +91,29 @@ public class BlockGrass extends Block
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        int var5 = 0;
-        int var6 = 0;
-        int var7 = 0;
-
-        for (int var8 = -1; var8 <= 1; ++var8)
+    	if (ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4))
+        {
+    		return ColorizeBlock.blockColor;
+        }
+        else
         {
-            for (int var9 = -1; var9 <= 1; ++var9)
+            int var5 = 0;
+            int var6 = 0;
+            int var7 = 0;
+
+            for (int var8 = -1; var8 <= 1; ++var8)
             {
-                int var10 = par1IBlockAccess.getBiomeGenForCoords(par2 + var9, par4 + var8).getBiomeGrassColor();
-                var5 += (var10 & 16711680) >> 16;
-                var6 += (var10 & 65280) >> 8;
-                var7 += var10 & 255;
+            	for (int var9 = -1; var9 <= 1; ++var9)
+                {
+                    int var10 = par1IBlockAccess.getBiomeGenForCoords(par2 + var9, par4 + var8).getBiomeGrassColor();
+                    var5 += (var10 & 16711680) >> 16;
+                    var6 += (var10 & 65280) >> 8;
+                    var7 += var10 & 255;
+                }
             }
+            
+            return (var5 / 9 & 255) << 16 | (var6 / 9 & 255) << 8 | var7 / 9 & 255;
         }
-
-        return (var5 / 9 & 255) << 16 | (var6 / 9 & 255) << 8 | var7 / 9 & 255;
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/BlockHalfSlab.java b/minecraft/net/minecraft/src/BlockHalfSlab.java
index d5550a3..020ce0e 100644
--- a/minecraft/net/minecraft/src/BlockHalfSlab.java
+++ b/minecraft/net/minecraft/src/BlockHalfSlab.java
@@ -15,18 +15,26 @@ public abstract class BlockHalfSlab extends Block
         if (par2)
         {
             opaqueCubeLookup[par1] = true;
+            
+            // FCMOD: Added
+            InitBlockBounds( 0D, 0D, 0D, 1D, 1D, 1D );
+            // END FCMOD
         }
         else
         {
-            this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+        	// FCMOD: Changed
+            //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+            InitBlockBounds( 0D, 0D, 0D, 1D, 0.5D, 1D );
+            
+            useNeighborBrightness[par1] = true;
+            // END FCMOD
         }
 
         this.setLightOpacity(255);
     }
 
-    /**
-     * Updates the blocks bounds based on its current state. Args: world, x, y, z
-     */
+    // FCMOD: Removed
+    /*
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         if (this.isDoubleSlab)
@@ -47,10 +55,7 @@ public abstract class BlockHalfSlab extends Block
             }
         }
     }
-
-    /**
-     * Sets the block's bounds for rendering it as an item
-     */
+    
     public void setBlockBoundsForItemRender()
     {
         if (this.isDoubleSlab)
@@ -62,16 +67,14 @@ public abstract class BlockHalfSlab extends Block
             this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
         }
     }
-
-    /**
-     * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
-     * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
-     */
+    
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
         super.addCollisionBoxesToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);
-    }
+	}
+    */
+	// END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -118,6 +121,8 @@ public abstract class BlockHalfSlab extends Block
      * Returns true if the given side of this block type should be rendered, if the adjacent block is at the given
      * coordinates.  Args: blockAccess, x, y, z, side
      */
+    // FCMOD: Removed and replaced (client only)
+    /*
     public boolean shouldSideBeRendered(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)
     {
         if (this.isDoubleSlab)
@@ -137,6 +142,8 @@ public abstract class BlockHalfSlab extends Block
             return var9 ? (par5 == 0 ? true : (par5 == 1 && super.shouldSideBeRendered(par1IBlockAccess, par2, par3, par4, par5) ? true : !isBlockSingleSlab(par1IBlockAccess.getBlockId(par2, par3, par4)) || (par1IBlockAccess.getBlockMetadata(par2, par3, par4) & 8) == 0)) : (par5 == 1 ? true : (par5 == 0 && super.shouldSideBeRendered(par1IBlockAccess, par2, par3, par4, par5) ? true : !isBlockSingleSlab(par1IBlockAccess.getBlockId(par2, par3, par4)) || (par1IBlockAccess.getBlockMetadata(par2, par3, par4) & 8) != 0));
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Takes a block ID, returns true if it's the same as the ID for a stone or wooden single slab.
@@ -166,4 +173,175 @@ public abstract class BlockHalfSlab extends Block
     {
         return isBlockSingleSlab(this.blockID) ? this.blockID : (this.blockID == Block.stoneDoubleSlab.blockID ? Block.stoneSingleSlab.blockID : (this.blockID == Block.woodDoubleSlab.blockID ? Block.woodSingleSlab.blockID : Block.stoneSingleSlab.blockID));
     }
+    
+	// FCMOD: Added New
+    @Override
+    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+    	IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	AxisAlignedBB bounds;
+    	
+        if ( isDoubleSlab )
+        {
+            bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0F, 0F, 1F, 1F, 1F );
+        }
+        else
+        {
+            if ( GetIsUpsideDown( blockAccess, i, j, k ) )
+            {
+                bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0.5F, 0F, 1F, 1F, 1F );
+            }
+            else
+            {
+            	bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0F, 0F, 1F, 0.5F, 1F );
+            }
+        }
+        
+        return bounds;
+    }
+    
+    @Override
+	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+    	if ( !isDoubleSlab )
+    	{
+            boolean bIsUpsideDown = GetIsUpsideDown( blockAccess, i, j, k );
+            
+            if ( iFacing == 0  ) 
+            {
+            	if ( !bIsUpsideDown )
+            	{
+            		return true;
+            	}
+            }
+            else if ( iFacing == 1 )
+            {
+            	if ( bIsUpsideDown )
+            	{
+            		return true;
+            	}
+            }
+    	}
+    	
+		return super.HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+	}
+
+    @Override
+    public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
+    {
+        if ( !isDoubleSlab )
+        {
+            if ( ( blockAccess.getBlockMetadata( i, j, k ) & 8 ) == 0 )
+            {
+            	return -0.5F;
+            }
+        }
+        
+    	return 0F;
+    }
+    
+    @Override
+    public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
+    {
+    	return true;
+    }
+    
+    @Override
+    public boolean CanMobsSpawnOn( World world, int i, int j, int k )
+    {
+        return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId );
+    }
+
+    @Override
+    public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
+    {
+        if ( !isDoubleSlab && !GetIsUpsideDown( world, i, j, k ) )
+        {
+        	return -0.5F;
+        }
+        
+    	return 0F;
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+    public boolean GetIsUpsideDown( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetIsUpsideDown( blockAccess.getBlockMetadata( i, j, k ) );
+    }
+    
+    public boolean GetIsUpsideDown( int iMetadata )
+    {
+    	return ( iMetadata & 8 ) > 0;
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public boolean shouldSideBeRendered( IBlockAccess blockAccess, int iNeighborI, int iNeighborJ, int iNeighborK, int iSide )
+    {
+    	if ( isDoubleSlab )
+    	{
+    		return super.shouldSideBeRendered( blockAccess, iNeighborI, iNeighborJ, iNeighborK, iSide );
+    	}
+
+    	FCUtilsBlockPos myPos = new FCUtilsBlockPos( iNeighborI, iNeighborJ, iNeighborK, 
+    		GetOppositeFacing( iSide ) );
+    	
+    	boolean bUpsideDown = GetIsUpsideDown( blockAccess, myPos.i, myPos.j, myPos.k );
+    	
+    	if ( iSide < 2 )
+    	{
+	    	if ( iSide == 0 )
+	    	{
+	    		return bUpsideDown || !blockAccess.isBlockOpaqueCube( 
+	    			iNeighborI, iNeighborJ, iNeighborK );
+	    	}
+	    	else // iSide == 1
+	    	{
+	    		return !bUpsideDown || !blockAccess.isBlockOpaqueCube( 
+	    			iNeighborI, iNeighborJ, iNeighborK );
+	    	}
+    	}
+
+        return FCClientUtilsRender.ShouldRenderNeighborHalfSlabSide( blockAccess, 
+        	iNeighborI, iNeighborJ, iNeighborK, iSide, bUpsideDown );
+    }
+    
+    @Override
+    public boolean ShouldRenderNeighborHalfSlabSide( IBlockAccess blockAccess, int i, int j, int k, int iNeighborSlabSide, boolean bNeighborUpsideDown )
+    {
+    	if ( isDoubleSlab )
+    	{
+    		return false;
+    	}
+    	
+		return GetIsUpsideDown( blockAccess, i, j, k ) != bNeighborUpsideDown;
+    }
+    
+    @Override
+    public boolean ShouldRenderNeighborFullFaceSide( IBlockAccess blockAccess, int i, int j, int k, int iNeighborSide )
+    {
+    	if ( isDoubleSlab )
+    	{
+    		return false;
+    	}
+    	
+    	if ( iNeighborSide < 2 )
+    	{
+    		boolean bUpsideDown = GetIsUpsideDown( blockAccess, i, j, k );
+    		
+    		if ( iNeighborSide == 0 )
+    		{
+    			return !bUpsideDown;
+    		}
+    		else // iNeighborSide == 1
+    		{
+    			return bUpsideDown;
+    		}    			
+    	}
+    	
+		return true;
+    }    
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockLeaves.java b/minecraft/net/minecraft/src/BlockLeaves.java
index f5612e2..3852f5e 100644
--- a/minecraft/net/minecraft/src/BlockLeaves.java
+++ b/minecraft/net/minecraft/src/BlockLeaves.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.List;
 import java.util.Random;
 
@@ -20,9 +21,16 @@ public class BlockLeaves extends BlockLeavesBase
 
     public int getBlockColor()
     {
-        double var1 = 0.5D;
-        double var3 = 1.0D;
-        return ColorizerFoliage.getFoliageColor(var1, var3);
+    	if (ColorizeBlock.colorizeBlock(this))
+        {
+            return ColorizeBlock.blockColor;
+        }
+        else
+        {
+            double var1 = 0.5D;
+            double var3 = 1.0D;
+            return ColorizerFoliage.getFoliageColor(var1, var3);
+        }
     }
 
     /**
@@ -30,7 +38,7 @@ public class BlockLeaves extends BlockLeavesBase
      */
     public int getRenderColor(int par1)
     {
-        return (par1 & 3) == 1 ? ColorizerFoliage.getFoliageColorPine() : ((par1 & 3) == 2 ? ColorizerFoliage.getFoliageColorBirch() : ColorizerFoliage.getFoliageColorBasic());
+    	return ColorizeBlock.colorizeBlock(this, par1) ? ColorizeBlock.blockColor : ((par1 & 3) == 1 ? ColorizerFoliage.getFoliageColorPine() : ((par1 & 3) == 2 ? ColorizerFoliage.getFoliageColorBirch() : ColorizerFoliage.getFoliageColorBasic()));
     }
 
     /**
@@ -39,34 +47,41 @@ public class BlockLeaves extends BlockLeavesBase
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
-
-        if ((var5 & 3) == 1)
-        {
-            return ColorizerFoliage.getFoliageColorPine();
-        }
-        else if ((var5 & 3) == 2)
+    	if (ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4))
         {
-            return ColorizerFoliage.getFoliageColorBirch();
+    		return ColorizeBlock.blockColor;
         }
         else
         {
-            int var6 = 0;
-            int var7 = 0;
-            int var8 = 0;
+        	int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
 
-            for (int var9 = -1; var9 <= 1; ++var9)
+        	if ((var5 & 3) == 1)
             {
-                for (int var10 = -1; var10 <= 1; ++var10)
+        		return ColorizerFoliage.getFoliageColorPine();
+            }
+            else if ((var5 & 3) == 2)
+            {
+                return ColorizerFoliage.getFoliageColorBirch();
+            }
+            else
+            {
+                int var6 = 0;
+                int var7 = 0;
+                int var8 = 0;
+
+                for (int var9 = -1; var9 <= 1; ++var9)
                 {
-                    int var11 = par1IBlockAccess.getBiomeGenForCoords(par2 + var10, par4 + var9).getBiomeFoliageColor();
-                    var6 += (var11 & 16711680) >> 16;
-                    var7 += (var11 & 65280) >> 8;
-                    var8 += var11 & 255;
+                	for (int var10 = -1; var10 <= 1; ++var10)
+                    {
+                        int var11 = par1IBlockAccess.getBiomeGenForCoords(par2 + var10, par4 + var9).getBiomeFoliageColor();
+                        var6 += (var11 & 16711680) >> 16;
+                        var7 += (var11 & 65280) >> 8;
+                        var8 += var11 & 255;
+                    }
                 }
-            }
 
-            return (var6 / 9 & 255) << 16 | (var7 / 9 & 255) << 8 | var8 / 9 & 255;
+                return (var6 / 9 & 255) << 16 | (var7 / 9 & 255) << 8 | var8 / 9 & 255;
+            }
         }
     }
 
diff --git a/minecraft/net/minecraft/src/BlockLilyPad.java b/minecraft/net/minecraft/src/BlockLilyPad.java
index 3dbf578..0906ff2 100644
--- a/minecraft/net/minecraft/src/BlockLilyPad.java
+++ b/minecraft/net/minecraft/src/BlockLilyPad.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.List;
 
 public class BlockLilyPad extends BlockFlower
@@ -44,7 +45,7 @@ public class BlockLilyPad extends BlockFlower
 
     public int getBlockColor()
     {
-        return 2129968;
+    	return ColorizeBlock.colorizeBlock(this) ? ColorizeBlock.blockColor : 2129968;
     }
 
     /**
@@ -52,7 +53,7 @@ public class BlockLilyPad extends BlockFlower
      */
     public int getRenderColor(int par1)
     {
-        return 2129968;
+    	return ColorizeBlock.colorizeBlock(this, par1) ? ColorizeBlock.blockColor : 2129968;
     }
 
     /**
@@ -61,7 +62,7 @@ public class BlockLilyPad extends BlockFlower
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        return 2129968;
+    	return ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4) ? ColorizeBlock.blockColor : 2129968;
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/BlockLog.java b/minecraft/net/minecraft/src/BlockLog.java
index c04a14f..0eba186 100644
--- a/minecraft/net/minecraft/src/BlockLog.java
+++ b/minecraft/net/minecraft/src/BlockLog.java
@@ -162,4 +162,13 @@ public class BlockLog extends Block
             this.iconArray[var2] = par1IconRegister.registerIcon(treeTextureTypes[var2]);
         }
     }
+    
+    // FCMOD: Code added
+    protected BlockLog( int iBlockID, Material material )
+    {
+        super(iBlockID, material );
+        
+        setCreativeTab( CreativeTabs.tabBlock );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockMycelium.java b/minecraft/net/minecraft/src/BlockMycelium.java
index d785321..340e926 100644
--- a/minecraft/net/minecraft/src/BlockMycelium.java
+++ b/minecraft/net/minecraft/src/BlockMycelium.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mal.block.RenderBlocksUtils;
 import java.util.Random;
 
 public class BlockMycelium extends Block
@@ -27,7 +28,13 @@ public class BlockMycelium extends Block
      */
     public Icon getBlockTexture(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)
     {
-        if (par5 == 1)
+    	Icon var7 = RenderBlocksUtils.getGrassTexture(this, par1IBlockAccess, par2, par3, par4, par5, this.field_94422_a);
+
+        if (var7 != null)
+        {
+            return var7;
+        }
+        else if (par5 == 1)
         {
             return this.field_94422_a;
         }
diff --git a/minecraft/net/minecraft/src/BlockPistonBase.java b/minecraft/net/minecraft/src/BlockPistonBase.java
index fe5b9b9..507cad6 100644
--- a/minecraft/net/minecraft/src/BlockPistonBase.java
+++ b/minecraft/net/minecraft/src/BlockPistonBase.java
@@ -5,16 +5,28 @@ import java.util.List;
 public class BlockPistonBase extends Block
 {
     /** This pistons is the sticky one? */
-    private final boolean isSticky;
+	// FCMOD: Changed
+    //private final boolean isSticky;
+    protected final boolean isSticky;
+    // END FCMOD
 
     /** Only visible when piston is extended */
-    private Icon innerTopIcon;
+	// FCMOD: Changed (client only)
+    //private Icon innerTopIcon;
+    protected Icon innerTopIcon;
+    // END FCMOD
 
     /** Bottom side texture */
-    private Icon bottomIcon;
+	// FCMOD: Changed (client only)
+    //private Icon bottomIcon;
+    protected Icon bottomIcon;
+    // END FCMOD
 
     /** Top icon of piston depends on (either sticky or normal) */
-    private Icon topIcon;
+	// FCMOD: Changed (client only)
+    //private Icon topIcon;
+    protected Icon topIcon;
+    // END FCMOD
 
     public BlockPistonBase(int par1, boolean par2)
     {
@@ -131,7 +143,10 @@ public class BlockPistonBase extends Block
     /**
      * handles attempts to extend or retract the piston.
      */
-    private void updatePistonState(World par1World, int par2, int par3, int par4)
+    // FCMOD: Changed
+    //private void updatePistonState(World par1World, int par2, int par3, int par4)
+    protected void updatePistonState(World par1World, int par2, int par3, int par4)
+    // END FCMOD
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         int var6 = getOrientation(var5);
@@ -232,10 +247,20 @@ public class BlockPistonBase extends Block
                             var13 = true;
                         }
                     }
-                }
-
-                if (!var13 && var11 > 0 && canPushBlock(var11, par1World, var8, var9, var10, false) && (Block.blocksList[var11].getMobilityFlag() == 0 || var11 == Block.pistonBase.blockID || var11 == Block.pistonStickyBase.blockID))
+                }                
+
+                // FCMOD: Changed
+                //if (!var13 && var11 > 0 && canPushBlock(var11, par1World, var8, var9, var10, false) && (Block.blocksList[var11].getMobilityFlag() == 0 || var11 == Block.pistonBase.blockID || var11 == Block.pistonStickyBase.blockID))
+                Block targetBlock = Block.blocksList[var11];
+                
+                if ( !var13 && targetBlock != null && 
+                	targetBlock.CanBlockBePulledByPiston( par1World, var8, var9, var10, Block.GetOppositeFacing( par6 ) ) )
+                // END FCMOD                	
                 {
+                    // FCMOD: Added
+            		var12 =  targetBlock.AdjustMetadataForPistonMove( var12 );
+                    // END FCMOD
+                    
                     par2 += Facing.offsetsXForSide[par6];
                     par3 += Facing.offsetsYForSide[par6];
                     par4 += Facing.offsetsZForSide[par6];
@@ -379,6 +404,8 @@ public class BlockPistonBase extends Block
     /**
      * returns true if the piston can push the specified block
      */
+    // FCMOD: Removed and replaced in child class
+    /* 
     private static boolean canPushBlock(int par0, World par1World, int par2, int par3, int par4, boolean par5)
     {
         if (par0 == Block.obsidian.blockID)
@@ -417,10 +444,14 @@ public class BlockPistonBase extends Block
             return !(Block.blocksList[par0] instanceof ITileEntityProvider);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * checks to see if this piston could push the blocks in front of it.
      */
+    // FCMOD: Removed and replaced in child class
+    /* 
     private static boolean canExtend(World par0World, int par1, int par2, int par3, int par4)
     {
         int var5 = par1 + Facing.offsetsXForSide[par4];
@@ -465,10 +496,14 @@ public class BlockPistonBase extends Block
             return true;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * attempts to extend the piston. returns false if impossible.
      */
+    // FCMOD: Removed and replaced in child class
+    /* 
     private boolean tryExtend(World par1World, int par2, int par3, int par4, int par5)
     {
         int var6 = par2 + Facing.offsetsXForSide[par5];
@@ -565,4 +600,22 @@ public class BlockPistonBase extends Block
             return true;
         }
     }
+    */
+    // END FCMOD
+    
+    // FCMOD: Added New    
+    protected boolean canExtend( World world, int i, int j, int k, int iFacing )
+    {
+    	// intended to be overriden by child class
+    	
+    	return false;
+    }
+    
+    protected boolean tryExtend( World world, int i, int j, int k, int iFacing )
+    {
+    	// intended to be overriden by child class
+    	
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockRailBase.java b/minecraft/net/minecraft/src/BlockRailBase.java
index 2630b4c..ce843ea 100644
--- a/minecraft/net/minecraft/src/BlockRailBase.java
+++ b/minecraft/net/minecraft/src/BlockRailBase.java
@@ -21,14 +21,22 @@ public abstract class BlockRailBase extends Block
      */
     public static final boolean isRailBlock(int par0)
     {
+        // FCMOD: Changed to recognize all rail blocks
+		/*
         return par0 == Block.rail.blockID || par0 == Block.railPowered.blockID || par0 == Block.railDetector.blockID || par0 == Block.railActivator.blockID;
+        */
+    	return Block.blocksList[par0] instanceof BlockRailBase;
+    	// END FCMOD
     }
 
     protected BlockRailBase(int par1, boolean par2)
     {
         super(par1, Material.circuits);
         this.isPowered = par2;
-        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        InitBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        // END FCMOD
         this.setCreativeTab(CreativeTabs.tabTransport);
     }
 
@@ -62,15 +70,21 @@ public abstract class BlockRailBase extends Block
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
+    // FCMOD: Removed
+    /*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
         return super.collisionRayTrace(par1World, par2, par3, par4, par5Vec3, par6Vec3);
     }
+    */
+    // END FCMOD
 
     /**
      * Updates the blocks bounds based on its current state. Args: world, x, y, z
      */
+    // FCMOD: Removed
+    /*
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
@@ -84,6 +98,8 @@ public abstract class BlockRailBase extends Block
             this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * If this block doesn't render as an ordinary block it will return False (examples: signs, buttons, stairs, etc)
@@ -178,6 +194,12 @@ public abstract class BlockRailBase extends Block
 
             if (var8)
             {
+            	// FCMOD: Code added to prevent item duplication since multiple notifications can occur at once
+            	if ( par1World.getBlockId( par2, par3, par4 ) != blockID )
+            	{
+            		return;
+            	}
+            	// END FCMOD
                 this.dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
                 par1World.setBlockToAir(par2, par3, par4);
             }
@@ -235,4 +257,138 @@ public abstract class BlockRailBase extends Block
             par1World.notifyBlocksOfNeighborChange(par2, par3 - 1, par4, par5);
         }
     }
+    
+	// FCMOD: Added New
+	@Override
+	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return true;
+	}
+	
+	@Override
+	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
+	{
+		int iDirection = iMetadata;
+		
+		if ( isPowered() ) // this should never be true
+		{
+			iDirection &= 7;
+		}
+		
+		if ( iDirection == 0 )
+		{
+			iDirection = 1;
+		}
+		else if ( iDirection == 1 )
+		{
+			iDirection = 0;
+		}
+		// sloped rails
+		else if ( iDirection == 2 )
+		{
+		}
+		else if ( iDirection == 3 )
+		{
+		}
+		else if ( iDirection == 4 )
+		{
+		}
+		else if ( iDirection == 5 )
+		{
+		}
+		// curved rails
+		else if ( iDirection == 6 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 7;
+			}
+			else
+			{
+				iDirection = 9;
+			}
+		}
+		else if ( iDirection == 7 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 8;
+			}
+			else
+			{
+				iDirection = 6;
+			}
+		}
+		else if ( iDirection == 8 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 9;
+			}
+			else
+			{
+				iDirection = 7;
+			}
+		}
+		else if ( iDirection == 9 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 6;
+			}
+			else
+			{
+				iDirection = 8;
+			}
+		}
+		
+		if ( isPowered() ) // this should never be true
+		{
+			iMetadata = (iMetadata & 8) | iDirection;
+		}
+		else
+		{
+			iMetadata = iDirection;
+		}
+		
+		return iMetadata;
+	}
+	
+    @Override
+    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+    	IBlockAccess blockAccess, int i, int j, int k )
+    {
+        int iDirection = blockAccess.getBlockMetadata( i, j, k );
+
+        if ( iDirection >= 2 && iDirection <= 5 )
+        {
+        	return AxisAlignedBB.getAABBPool().getAABB(         	
+        		0D, 0D, 0D, 1D, 0.625D, 1D );
+        }
+        else
+        {
+        	return AxisAlignedBB.getAABBPool().getAABB(         	
+        		0D, 0D, 0D, 1D, 0.125F, 1D );
+        }
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public boolean RenderBlock( RenderBlocks renderer, int i, int j, int k )
+    {
+        renderer.setRenderBounds( GetBlockBoundsFromPoolBasedOnState( 
+        	renderer.blockAccess, i, j, k ) );
+        
+    	return renderer.renderBlockMinecartTrack( this, i, j, k );
+    }
+    
+    @Override
+    public boolean shouldSideBeRendered( IBlockAccess blockAccess, 
+    	int iNeighborI, int iNeighborJ, int iNeighborK, int iSide )
+    {
+		return m_currentBlockRenderer.ShouldSideBeRenderedBasedOnCurrentBounds( 
+			iNeighborI, iNeighborJ, iNeighborK, iSide );
+    }	
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockRedstoneLogic.java b/minecraft/net/minecraft/src/BlockRedstoneLogic.java
index 2c824f4..68a2f49 100644
--- a/minecraft/net/minecraft/src/BlockRedstoneLogic.java
+++ b/minecraft/net/minecraft/src/BlockRedstoneLogic.java
@@ -11,7 +11,10 @@ public abstract class BlockRedstoneLogic extends BlockDirectional
     {
         super(par1, Material.circuits);
         this.isRepeaterPowered = par2;
-        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        InitBlockBounds( 0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F );
+        // END FCMOD
     }
 
     /**
@@ -372,4 +375,17 @@ public abstract class BlockRedstoneLogic extends BlockDirectional
     {
         return this.func_94487_f(par1);
     }
+
+    // FCMOD: Added New
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public boolean RenderBlock( RenderBlocks renderer, int i, int j, int k )
+    {
+        renderer.setRenderBounds( GetBlockBoundsFromPoolBasedOnState( 
+        	renderer.blockAccess, i, j, k ) );
+        
+    	return renderer.RenderBlockRedstoneLogic( this, i, j, k );
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockRedstoneTorch.java b/minecraft/net/minecraft/src/BlockRedstoneTorch.java
index f9a2e0b..907ad81 100644
--- a/minecraft/net/minecraft/src/BlockRedstoneTorch.java
+++ b/minecraft/net/minecraft/src/BlockRedstoneTorch.java
@@ -6,7 +6,12 @@ import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
+// FCMOD: Change
+/*
 public class BlockRedstoneTorch extends BlockTorch
+*/
+public class BlockRedstoneTorch extends FCBlockTorchBase
+// END FCMOD
 {
     /** Whether the redstone torch is currently active or not. */
     private boolean torchActive = false;
@@ -122,7 +127,13 @@ public class BlockRedstoneTorch extends BlockTorch
     /**
      * Returns true or false based on whether the block the torch is attached to is providing indirect power.
      */
+    // FCMOD: Renamed function to prevent problems for add-on mods
+	/*
     private boolean isIndirectlyPowered(World par1World, int par2, int par3, int par4)
+	*/
+    private boolean isIndirectlyPoweredLocal(World par1World, int par2, int par3, int par4)
+    // END FCMOD
+
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         return var5 == 5 && par1World.getIndirectPowerOutput(par2, par3 - 1, par4, 0) ? true : (var5 == 3 && par1World.getIndirectPowerOutput(par2, par3, par4 - 1, 2) ? true : (var5 == 4 && par1World.getIndirectPowerOutput(par2, par3, par4 + 1, 3) ? true : (var5 == 1 && par1World.getIndirectPowerOutput(par2 - 1, par3, par4, 4) ? true : var5 == 2 && par1World.getIndirectPowerOutput(par2 + 1, par3, par4, 5))));
@@ -133,7 +144,12 @@ public class BlockRedstoneTorch extends BlockTorch
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
+		// FCMOD: Renamed function as per above
+		/*
         boolean var6 = this.isIndirectlyPowered(par1World, par2, par3, par4);
+		*/
+        boolean var6 = this.isIndirectlyPoweredLocal(par1World, par2, par3, par4);
+		// END FCMOD
         List var7 = (List)redstoneUpdateInfoCache.get(par1World);
 
         while (var7 != null && !var7.isEmpty() && par1World.getTotalWorldTime() - ((RedstoneUpdateInfo)var7.get(0)).updateTime > 60L)
@@ -171,6 +187,8 @@ public class BlockRedstoneTorch extends BlockTorch
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
      */
+    // FCMOD: Removed and replaced
+    /*
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)
     {
         if (!this.func_94397_d(par1World, par2, par3, par4, par5))
@@ -183,6 +201,8 @@ public class BlockRedstoneTorch extends BlockTorch
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns true if the block is emitting direct/strong redstone power on the specified side. Args: World, X, Y, Z,
@@ -278,4 +298,27 @@ public class BlockRedstoneTorch extends BlockTorch
             this.blockIcon = par1IconRegister.registerIcon("redtorch");
         }
     }
+    
+    // FCMOD: Added new
+	@Override
+    public void onNeighborBlockChange( World world, int i, int j, int k, int iNeighborBlockID )
+    {
+    	if ( !ValidateState( world, i, j, k, iNeighborBlockID ) )    	
+        {
+            boolean bPowered = isIndirectlyPoweredLocal( world, i, j, k );
+
+            if ( torchActive == bPowered &&
+            	!world.IsUpdatePendingThisTickForBlock( i, j, k, blockID ) )            	
+            {
+                world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+            }
+        }
+    }
+	
+	@Override
+	public boolean TriggersBuddy()
+	{
+		return false;
+	}
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/BlockRedstoneWire.java b/minecraft/net/minecraft/src/BlockRedstoneWire.java
index 3d5cc3c..42e6b0e 100644
--- a/minecraft/net/minecraft/src/BlockRedstoneWire.java
+++ b/minecraft/net/minecraft/src/BlockRedstoneWire.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.Colorizer;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Random;
@@ -64,7 +66,7 @@ public class BlockRedstoneWire extends Block
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        return 8388608;
+    	return ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4) ? ColorizeBlock.blockColor : ColorizeBlock.colorizeRedstoneWire(par1IBlockAccess, par2, par3, par4, 8388608);
     }
 
     /**
@@ -450,16 +452,28 @@ public class BlockRedstoneWire extends Block
             double var7 = (double)par2 + 0.5D + ((double)par5Random.nextFloat() - 0.5D) * 0.2D;
             double var9 = (double)((float)par3 + 0.0625F);
             double var11 = (double)par4 + 0.5D + ((double)par5Random.nextFloat() - 0.5D) * 0.2D;
-            float var13 = (float)var6 / 15.0F;
-            float var14 = var13 * 0.6F + 0.4F;
+            float var14;
+            float var15;
+            float var16;
 
-            if (var6 == 0)
+            if (ColorizeBlock.computeRedstoneWireColor(var6))
             {
-                var14 = 0.0F;
+            	var14 = Colorizer.setColor[0];
+                var15 = Colorizer.setColor[1];
+                var16 = Colorizer.setColor[2];
             }
+            else
+            {
+                float var13 = (float)var6 / 15.0F;
+                var14 = var13 * 0.6F + 0.4F;
+                if (var6 == 0)
+                {
+                    var14 = 0.0F;
+                }
 
-            float var15 = var13 * var13 * 0.7F - 0.5F;
-            float var16 = var13 * var13 * 0.6F - 0.7F;
+                var15 = var13 * var13 * 0.7F - 0.5F;
+                var16 = var13 * var13 * 0.6F - 0.7F;
+            }
 
             if (var15 < 0.0F)
             {
diff --git a/minecraft/net/minecraft/src/BlockStationary.java b/minecraft/net/minecraft/src/BlockStationary.java
index 68f6f5e..154f33e 100644
--- a/minecraft/net/minecraft/src/BlockStationary.java
+++ b/minecraft/net/minecraft/src/BlockStationary.java
@@ -66,7 +66,10 @@ public class BlockStationary extends BlockFluid
                 {
                     if (this.isFlammable(par1World, par2 - 1, par3, par4) || this.isFlammable(par1World, par2 + 1, par3, par4) || this.isFlammable(par1World, par2, par3, par4 - 1) || this.isFlammable(par1World, par2, par3, par4 + 1) || this.isFlammable(par1World, par2, par3 - 1, par4) || this.isFlammable(par1World, par2, par3 + 1, par4))
                     {
-                        par1World.setBlock(par2, par3, par4, Block.fire.blockID);
+                    	if (par1World.getGameRules().getGameRuleBooleanValue("doFireTick")) {
+                    		par1World.setBlock(par2, par3, par4, Block.fire.blockID);
+                    	}
+                    	
                         return;
                     }
                 }
diff --git a/minecraft/net/minecraft/src/BlockStem.java b/minecraft/net/minecraft/src/BlockStem.java
index e7b08fd..a44becf 100644
--- a/minecraft/net/minecraft/src/BlockStem.java
+++ b/minecraft/net/minecraft/src/BlockStem.java
@@ -1,11 +1,17 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.Random;
 
 public class BlockStem extends BlockFlower
 {
     /** Defines if it is a Melon or a Pumpkin that the stem is producing. */
+	// FCMOD: Changed
+	/*
     private final Block fruitType;
+    */
+    protected Block fruitType;
+	// END FCMOD
     private Icon theIcon;
 
     protected BlockStem(int par1, Block par2Block)
@@ -170,10 +176,17 @@ public class BlockStem extends BlockFlower
      */
     public int getRenderColor(int par1)
     {
-        int var2 = par1 * 32;
-        int var3 = 255 - par1 * 8;
-        int var4 = par1 * 4;
-        return var2 << 16 | var3 << 8 | var4;
+    	if (ColorizeBlock.colorizeBlock(this, par1))
+        {
+            return ColorizeBlock.blockColor;
+        }
+        else
+        {
+            int var2 = par1 * 32;
+            int var3 = 255 - par1 * 8;
+            int var4 = par1 * 4;
+            return var2 << 16 | var3 << 8 | var4;
+        }
     }
 
     /**
@@ -182,7 +195,7 @@ public class BlockStem extends BlockFlower
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        return this.getRenderColor(par1IBlockAccess.getBlockMetadata(par2, par3, par4));
+    	return ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4) ? ColorizeBlock.blockColor : this.getRenderColor(par1IBlockAccess.getBlockMetadata(par2, par3, par4));
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/BlockTallGrass.java b/minecraft/net/minecraft/src/BlockTallGrass.java
index b393c0f..475792a 100644
--- a/minecraft/net/minecraft/src/BlockTallGrass.java
+++ b/minecraft/net/minecraft/src/BlockTallGrass.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.List;
 import java.util.Random;
 
@@ -30,9 +31,16 @@ public class BlockTallGrass extends BlockFlower
 
     public int getBlockColor()
     {
-        double var1 = 0.5D;
-        double var3 = 1.0D;
-        return ColorizerGrass.getGrassColor(var1, var3);
+    	if (ColorizeBlock.colorizeBlock(this))
+        {
+            return ColorizeBlock.blockColor;
+        }
+        else
+        {
+            double var1 = 0.5D;
+            double var3 = 1.0D;
+            return ColorizerGrass.getGrassColor(var1, var3);
+        }
     }
 
     /**
@@ -40,7 +48,7 @@ public class BlockTallGrass extends BlockFlower
      */
     public int getRenderColor(int par1)
     {
-        return par1 == 0 ? 16777215 : ColorizerFoliage.getFoliageColorBasic();
+    	return ColorizeBlock.colorizeBlock(this, par1) ? ColorizeBlock.blockColor : (par1 == 0 ? 16777215 : ColorizerFoliage.getFoliageColorBasic());
     }
 
     /**
@@ -49,8 +57,15 @@ public class BlockTallGrass extends BlockFlower
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
-        return var5 == 0 ? 16777215 : par1IBlockAccess.getBiomeGenForCoords(par2, par4).getBiomeGrassColor();
+    	if (ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4))
+        {
+            return ColorizeBlock.blockColor;
+        }
+        else
+        {
+            int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
+            return var5 == 0 ? 16777215 : par1IBlockAccess.getBiomeGenForCoords(par2, par4).getBiomeGrassColor();
+        }
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/BlockVine.java b/minecraft/net/minecraft/src/BlockVine.java
index b162e97..14fc1a4 100644
--- a/minecraft/net/minecraft/src/BlockVine.java
+++ b/minecraft/net/minecraft/src/BlockVine.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
 import java.util.Random;
 
 public class BlockVine extends Block
@@ -205,7 +206,7 @@ public class BlockVine extends Block
 
     public int getBlockColor()
     {
-        return ColorizerFoliage.getFoliageColorBasic();
+    	return ColorizeBlock.colorizeBlock(this) ? ColorizeBlock.blockColor : ColorizerFoliage.getFoliageColorBasic();
     }
 
     /**
@@ -213,7 +214,7 @@ public class BlockVine extends Block
      */
     public int getRenderColor(int par1)
     {
-        return ColorizerFoliage.getFoliageColorBasic();
+    	return ColorizeBlock.colorizeBlock(this, par1) ? ColorizeBlock.blockColor : ColorizerFoliage.getFoliageColorBasic();
     }
 
     /**
@@ -222,7 +223,7 @@ public class BlockVine extends Block
      */
     public int colorMultiplier(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
-        return par1IBlockAccess.getBiomeGenForCoords(par2, par4).getBiomeFoliageColor();
+    	return ColorizeBlock.colorizeBlock(this, par1IBlockAccess, par2, par3, par4) ? ColorizeBlock.blockColor : par1IBlockAccess.getBiomeGenForCoords(par2, par4).getBiomeFoliageColor();
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/Chunk.java b/minecraft/net/minecraft/src/Chunk.java
index 5daef4d..92df06c 100644
--- a/minecraft/net/minecraft/src/Chunk.java
+++ b/minecraft/net/minecraft/src/Chunk.java
@@ -244,7 +244,12 @@ public class Chunk
             while (var3 < 16)
             {
                 this.precipitationHeightMap[var2 + (var3 << 4)] = -999;
+                // FCMOD: Changed to match 1.8
+                /*
                 int var4 = var1 + 16 - 1;
+                */
+                int var4 = var1 + 16;
+                // END FCMOD
 
                 while (true)
                 {
@@ -602,10 +607,23 @@ public class Chunk
                 {
                     Block.blocksList[var8].breakBlock(this.worldObj, var12, par2, var13, var8, var9);
                 }
+                // FCMOD: Code change
+                /*
                 else if (Block.blocksList[var8] instanceof ITileEntityProvider && var8 != par4)
                 {
                     this.worldObj.removeBlockTileEntity(var12, par2, var13);
                 }
+                */
+                else if ( var8 != par4 )
+                {
+                    Block.blocksList[var8].ClientBreakBlock(this.worldObj, var12, par2, var13, var8, var9);
+                    
+                    if ( Block.blocksList[var8] instanceof ITileEntityProvider && Block.blocksList[var8].ShouldDeleteTileEntityOnBlockChange( par4 ) )
+                    {
+                    	this.worldObj.removeBlockTileEntity(var12, par2, var13);
+                    }
+                }
+                // END FCMOD
             }
 
             if (var10.getExtBlockID(par1, par2 & 15, par3) != par4)
@@ -645,6 +663,12 @@ public class Chunk
                     {
                         Block.blocksList[par4].onBlockAdded(this.worldObj, var12, par2, var13);
                     }
+                    // FCMOD: Code added
+                    else if ( var8 != par4 )
+                    {
+                        Block.blocksList[par4].ClientBlockAdded(worldObj, var12, par2, var13);
+                    }
+                    // END FCMOD
 
                     if (Block.blocksList[par4] instanceof ITileEntityProvider)
                     {
@@ -1331,12 +1355,12 @@ public class Chunk
         }
 
         this.generateHeightMap();
-        Iterator var11 = this.chunkTileEntityMap.values().iterator();
+        Iterator var10 = this.chunkTileEntityMap.values().iterator();
 
-        while (var11.hasNext())
+        while (var10.hasNext())
         {
-            TileEntity var10 = (TileEntity)var11.next();
-            var10.updateContainingBlockInfo();
+            TileEntity var11 = (TileEntity)var10.next();
+            var11.updateContainingBlockInfo();
         }
     }
 
@@ -1445,4 +1469,56 @@ public class Chunk
             }
         }
     }
+    
+    // FCMOD: Code added
+    public void GetClosestEntityMatchingCriteriaWithinRangeSq( FCClosestEntityInfo closestEntityInfo )
+    {
+    	for ( int iVerticalIndex = closestEntityInfo.m_iChunkEntityListMinVerticalIndex; iVerticalIndex <= closestEntityInfo.m_iChunkEntityListMaxVerticalIndex; iVerticalIndex++ )
+    	{
+            List tempEntityList = entityLists[iVerticalIndex];
+            
+            if ( !tempEntityList.isEmpty() )
+            {            
+            	Iterator entityIterator = tempEntityList.iterator();
+            	
+            	while ( entityIterator.hasNext() )
+            	{
+		        	Entity tempEntity = (Entity)entityIterator.next();
+		        	
+		        	closestEntityInfo.m_criteria.ProcessEntity( closestEntityInfo, tempEntity );
+            	}
+            }
+    	}
+    }
+    
+    public int GetBlockNaturalLightValue( int i, int j, int k, int iSkylightSubtracted )
+    {
+    	// modified version of getBlockLightValue that only considers natural light
+    	
+        ExtendedBlockStorage blockStorage = this.storageArrays[j >> 4];
+
+        if ( blockStorage == null )
+        {
+            return !this.worldObj.provider.hasNoSky && iSkylightSubtracted < EnumSkyBlock.Sky.defaultLightValue ? EnumSkyBlock.Sky.defaultLightValue - iSkylightSubtracted : 0;
+        }
+        else
+        {
+            int iLightValue = this.worldObj.provider.hasNoSky ? 0 : blockStorage.getExtSkylightValue(i, j & 15, k);
+
+            if (iLightValue > 0)
+            {
+                isLit = true;
+            }
+
+            iLightValue -= iSkylightSubtracted;
+            
+            if ( iLightValue < 0 )
+            {
+            	iLightValue = 0;
+            }
+
+            return iLightValue;
+        }
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ChunkCache.java b/minecraft/net/minecraft/src/ChunkCache.java
index 60df708..b71abdc 100644
--- a/minecraft/net/minecraft/src/ChunkCache.java
+++ b/minecraft/net/minecraft/src/ChunkCache.java
@@ -159,7 +159,12 @@ public class ChunkCache implements IBlockAccess
             {
                 var5 = this.getBlockId(par1, par2, par3);
 
+                // FCMOD: Changed (Client Only) for proper lighting on mod blocks
+                /*
                 if (var5 == Block.stoneSingleSlab.blockID || var5 == Block.woodSingleSlab.blockID || var5 == Block.tilledField.blockID || var5 == Block.stairsWoodOak.blockID || var5 == Block.stairsCobblestone.blockID)
+                */
+                if ( Block.useNeighborBrightness[var5] )
+                // END FCMOD
                 {
                     var6 = this.getLightValueExt(par1, par2 + 1, par3, false);
                     int var7 = this.getLightValueExt(par1 + 1, par2, par3, false);
@@ -278,11 +283,22 @@ public class ChunkCache implements IBlockAccess
     /**
      * Returns true if the block at the given coordinate has a solid (buildable) top surface.
      */
+    // FCMOD: Changed
+    /*
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
         Block var4 = Block.blocksList[this.getBlockId(par1, par2, par3)];
         return this.worldObj.isBlockTopFacingSurfaceSolid(var4, this.getBlockMetadata(par1, par2, par3));
     }
+    */
+    public boolean doesBlockHaveSolidTopSurface( int i, int j, int k )
+    {
+        Block block = Block.blocksList[this.getBlockId(i, j, k)];
+        
+        return block != null && block.HasLargeCenterHardPointToFacing( this, i, j, k, 1 );
+    }
+    // END FCMOD
+    
 
     /**
      * Return the Vec3Pool object for this world.
diff --git a/minecraft/net/minecraft/src/ChunkProviderGenerate.java b/minecraft/net/minecraft/src/ChunkProviderGenerate.java
index 9ca95ba..c676d1f 100644
--- a/minecraft/net/minecraft/src/ChunkProviderGenerate.java
+++ b/minecraft/net/minecraft/src/ChunkProviderGenerate.java
@@ -80,6 +80,9 @@ public class ChunkProviderGenerate implements IChunkProvider
         this.worldObj = par1World;
         this.mapFeaturesEnabled = par4;
         this.rand = new Random(par2);
+        // FCMOD: Added
+        m_structureRand = new Random(par2);
+        // END FCMOD
         this.noiseGen1 = new NoiseGeneratorOctaves(this.rand, 16);
         this.noiseGen2 = new NoiseGeneratorOctaves(this.rand, 16);
         this.noiseGen3 = new NoiseGeneratorOctaves(this.rand, 8);
@@ -370,48 +373,48 @@ public class ChunkProviderGenerate implements IChunkProvider
                 var17 /= var18;
                 var16 = var16 * 0.9F + 0.1F;
                 var17 = (var17 * 4.0F - 1.0F) / 8.0F;
-                double var46 = this.noise6[var13] / 8000.0D;
+                double var47 = this.noise6[var13] / 8000.0D;
 
-                if (var46 < 0.0D)
+                if (var47 < 0.0D)
                 {
-                    var46 = -var46 * 0.3D;
+                    var47 = -var47 * 0.3D;
                 }
 
-                var46 = var46 * 3.0D - 2.0D;
+                var47 = var47 * 3.0D - 2.0D;
 
-                if (var46 < 0.0D)
+                if (var47 < 0.0D)
                 {
-                    var46 /= 2.0D;
+                    var47 /= 2.0D;
 
-                    if (var46 < -1.0D)
+                    if (var47 < -1.0D)
                     {
-                        var46 = -1.0D;
+                        var47 = -1.0D;
                     }
 
-                    var46 /= 1.4D;
-                    var46 /= 2.0D;
+                    var47 /= 1.4D;
+                    var47 /= 2.0D;
                 }
                 else
                 {
-                    if (var46 > 1.0D)
+                    if (var47 > 1.0D)
                     {
-                        var46 = 1.0D;
+                        var47 = 1.0D;
                     }
 
-                    var46 /= 8.0D;
+                    var47 /= 8.0D;
                 }
 
                 ++var13;
 
-                for (int var47 = 0; var47 < par6; ++var47)
+                for (int var46 = 0; var46 < par6; ++var46)
                 {
                     double var48 = (double)var17;
                     double var26 = (double)var16;
-                    var48 += var46 * 0.2D;
+                    var48 += var47 * 0.2D;
                     var48 = var48 * (double)par6 / 16.0D;
                     double var28 = (double)par6 / 2.0D + var48 * 4.0D;
                     double var30 = 0.0D;
-                    double var32 = ((double)var47 - var28) * 12.0D * 128.0D / 128.0D / var26;
+                    double var32 = ((double)var46 - var28) * 12.0D * 128.0D / 128.0D / var26;
 
                     if (var32 < 0.0D)
                     {
@@ -437,9 +440,9 @@ public class ChunkProviderGenerate implements IChunkProvider
 
                     var30 -= var32;
 
-                    if (var47 > par6 - 4)
+                    if (var46 > par6 - 4)
                     {
-                        double var40 = (double)((float)(var47 - (par6 - 4)) / 3.0F);
+                        double var40 = (double)((float)(var46 - (par6 - 4)) / 3.0F);
                         var30 = var30 * (1.0D - var40) + -10.0D * var40;
                     }
 
@@ -472,15 +475,40 @@ public class ChunkProviderGenerate implements IChunkProvider
         this.rand.setSeed(this.worldObj.getSeed());
         long var7 = this.rand.nextLong() / 2L * 2L + 1L;
         long var9 = this.rand.nextLong() / 2L * 2L + 1L;
+        
+        // FCMOD: Added so that future changes to structure generation will not
+        // impact the other aspects of chunk population
+        long lStructureSeedX = rand.nextLong() / 2L * 2L + 1L;
+        long lStructureSeedZ = rand.nextLong() / 2L * 2L + 1L;        
+        // END FCMOD
+        
         this.rand.setSeed((long)par2 * var7 + (long)par3 * var9 ^ this.worldObj.getSeed());
         boolean var11 = false;
 
         if (this.mapFeaturesEnabled)
         {
+        	// FCNOTE: The structure seed is intentionally not applied to mineshafts given
+        	// how frequent they are, so as not to mess too much with other details throughout the 
+        	// world
             this.mineshaftGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
+        	// FCMOD: Changed  
+            /*
             var11 = this.villageGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
             this.strongholdGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
             this.scatteredFeatureGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
+             */
+            m_structureRand.setSeed((long)par2 * lStructureSeedX + 
+            	(long)par3 * lStructureSeedZ ^ this.worldObj.getSeed());
+            
+            var11 = villageGenerator.generateStructuresInChunk( worldObj, 
+            	m_structureRand, par2, par3 );
+            
+            strongholdGenerator.generateStructuresInChunk( worldObj, 
+            	m_structureRand, par2, par3 );
+            
+            scatteredFeatureGenerator.generateStructuresInChunk( worldObj, 
+            	m_structureRand, par2, par3 );
+            // END FCMOD            
         }
 
         int var12;
@@ -543,6 +571,10 @@ public class ChunkProviderGenerate implements IChunkProvider
         }
 
         BlockSand.fallInstantly = false;
+
+        // FCMOD: Added
+        BTWPostProcessChunk( worldObj, var4 - 8, var5 - 8 ); // -8 because of += 8 offset applied above
+        // END FCMOD
     }
 
     /**
@@ -612,4 +644,67 @@ public class ChunkProviderGenerate implements IChunkProvider
             this.scatteredFeatureGenerator.generate(this, this.worldObj, par1, par2, (byte[])null);
         }
     }
+    
+    // FCMOD: Added New    
+    private Random m_structureRand;
+    
+    private void BTWPostProcessChunk( World worldObj, int iChunkX, int iChunkZ )
+    {
+    	if ( worldObj.provider.dimensionId == 0 )
+    	{
+    		GenerateStrata( worldObj, iChunkX, iChunkZ );
+    		GenerateAdditionalBrownMushrooms( worldObj, iChunkX, iChunkZ );
+    	}
+    }
+    
+    private void GenerateAdditionalBrownMushrooms( World worldObj, int iChunkX, int iChunkZ )
+    {
+        if ( worldObj.rand.nextInt( 4 ) == 0 )
+        {
+        	WorldGenerator mushroomBrownGen = new WorldGenFlowers( Block.mushroomBrown.blockID );    	
+        	
+            int iMushroomX = iChunkX + worldObj.rand.nextInt( 16 ) + 8;
+            int iMushroomY = worldObj.rand.nextInt( 25 );
+            int iMushroomZ = iChunkZ + worldObj.rand.nextInt( 16 ) + 8;
+            
+            mushroomBrownGen.generate( worldObj, worldObj.rand, iMushroomX, iMushroomY, iMushroomZ );
+        }
+    }
+    
+    private void GenerateStrata( World world, int iChunkX, int iChunkZ )
+    {
+        Chunk chunk = world.getChunkFromChunkCoords( iChunkX >> 4, iChunkZ >> 4);
+        
+        for ( int iTempI = 0; iTempI < 16; iTempI++ )
+        {
+        	for ( int iTempK = 0; iTempK < 16; iTempK++ )
+        	{
+        		int iTempJ = 0;
+        		int iStrataHeight = 24 + world.rand.nextInt( 2 );
+        		
+        		for( ; iTempJ <= iStrataHeight; iTempJ++ )
+        		{
+        			int iTempBlockID = chunk.getBlockID( iTempI, iTempJ, iTempK );
+        			
+        			if ( iTempBlockID == Block.stone.blockID )
+        			{
+        				chunk.setBlockMetadata( iTempI, iTempJ, iTempK, 2 );
+        			}
+        		}
+        		
+        		iStrataHeight = 48  + world.rand.nextInt( 2 );
+        		
+        		for( ; iTempJ <= iStrataHeight; iTempJ++ )
+        		{
+        			int iTempBlockID = chunk.getBlockID( iTempI, iTempJ, iTempK );
+        			
+        			if ( iTempBlockID == Block.stone.blockID )
+        			{
+        				chunk.setBlockMetadata( iTempI, iTempJ, iTempK, 1 );
+        			}
+        		}        		
+        	}
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ChunkProviderHell.java b/minecraft/net/minecraft/src/ChunkProviderHell.java
index 22103f6..f3e0fb3 100644
--- a/minecraft/net/minecraft/src/ChunkProviderHell.java
+++ b/minecraft/net/minecraft/src/ChunkProviderHell.java
@@ -25,7 +25,10 @@ public class ChunkProviderHell implements IChunkProvider
     /** Is the world that the nether is getting generated. */
     private World worldObj;
     private double[] noiseField;
-    public MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
+    // FCMOD: Changed
+    //public MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
+    public FCMapGenNetherBridge genNetherBridge = new FCMapGenNetherBridge();
+    // END FCMOD
 
     /**
      * Holds the noise used to determine whether slowsand can be generated at a location
@@ -500,9 +503,14 @@ public class ChunkProviderHell implements IChunkProvider
 
         for (var8 = 0; var8 < 16; ++var8)
         {
-            var9 = var4 + this.hellRNG.nextInt(16);
+        	// FCMOD: changed to fix unnecessary chunk loads and memory leaks
+            //var9 = var4 + this.hellRNG.nextInt(16);
+            //var10 = this.hellRNG.nextInt(108) + 10;
+            //var11 = var5 + this.hellRNG.nextInt(16);
+            var9 = var4 + this.hellRNG.nextInt(16) + 8;
             var10 = this.hellRNG.nextInt(108) + 10;
-            var11 = var5 + this.hellRNG.nextInt(16);
+            var11 = var5 + this.hellRNG.nextInt(16) + 8;
+            // END FCMOD
             (new WorldGenHellLava(Block.lavaMoving.blockID, true)).generate(this.worldObj, this.hellRNG, var9, var10, var11);
         }
 
@@ -549,7 +557,13 @@ public class ChunkProviderHell implements IChunkProvider
      */
     public List getPossibleCreatures(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)
     {
+    	// FCMOD: Code change to loosen spawn restrictions on wither skeletons and blazes
+    	/*
         if (par1EnumCreatureType == EnumCreatureType.monster && this.genNetherBridge.hasStructureAt(par2, par3, par4))
+        */
+        if ( par1EnumCreatureType == EnumCreatureType.monster && 
+        	genNetherBridge.HasStructureAtLoose( par2, par3, par4 ) )
+    	// END FCMOD
         {
             return this.genNetherBridge.getSpawnList();
         }
diff --git a/minecraft/net/minecraft/src/ChunkProviderServer.java b/minecraft/net/minecraft/src/ChunkProviderServer.java
index 6026688..d18a15e 100644
--- a/minecraft/net/minecraft/src/ChunkProviderServer.java
+++ b/minecraft/net/minecraft/src/ChunkProviderServer.java
@@ -46,16 +46,30 @@ public class ChunkProviderServer implements IChunkProvider
      * marks chunk for unload by "unload100OldestChunks"  if there is no spawn point, or if the center of the chunk is
      * outside 200 blocks (x or z) of the spawn
      */
+    // FCMOD: Added (server only) to provide alias to match client naming
+    /*
+    public void unloadChunksIfNotNearSpawn( int par1, int par2 )
+    {
+        dropChunk( par1, par2 );
+    }
+    */
+    // END FCMOD
     public void unloadChunksIfNotNearSpawn(int par1, int par2)
     {
         if (this.worldObj.provider.canRespawnHere())
         {
+        	// FCCHUNK: Decide on updates around original spawn
+        	// FCMOD: Changed
+        	/*
             ChunkCoordinates var3 = this.worldObj.getSpawnPoint();
             int var4 = par1 * 16 + 8 - var3.posX;
             int var5 = par2 * 16 + 8 - var3.posZ;
             short var6 = 128;
 
             if (var4 < -var6 || var4 > var6 || var5 < -var6 || var5 > var6)
+            */
+        	if ( !IsSpawnChunk( par1, par2 ) )
+        	// END FCMOD
             {
                 this.chunksToUnload.add(Long.valueOf(ChunkCoordIntPair.chunkXZ2Int(par1, par2)));
             }
@@ -346,4 +360,45 @@ public class ChunkProviderServer implements IChunkProvider
     }
 
     public void recreateStructures(int par1, int par2) {}
+    
+    // FCMOD: Added
+    IChunkProvider GetCurrentProvider()
+    {
+    	// client
+    	return currentChunkProvider;
+    	// server
+    	//return serverChunkGenerator;
+	}
+    
+	protected boolean IsSpawnChunk( int iChunkX, int iChunkZ )
+	{
+		if ( worldObj.provider.canRespawnHere() )
+		{
+		    ChunkCoordinates var3 = this.worldObj.getSpawnPoint();
+		    
+		    // uses the same math as addPlayer in PlayerManager for consistent results
+		    
+		    int iSpawnChunkX = worldObj.worldInfo.getSpawnX() >> 4;
+		    int iSpawnChunkZ = worldObj.worldInfo.getSpawnZ() >> 4;
+		    
+		    int iChunkViewDistance = 
+		    	worldObj.getMinecraftServer().getConfigurationManager().getViewDistance(); 
+	
+		    return iChunkX >= iSpawnChunkX - iChunkViewDistance &&
+		    	iChunkX <= iSpawnChunkX + iChunkViewDistance &&
+			    iChunkZ >= iSpawnChunkZ - iChunkViewDistance &&
+		    	iChunkZ <= iSpawnChunkZ + iChunkViewDistance;
+		}
+		
+		return false;
+	}
+	
+    public void ForceAddToChunksToUnload( int iChunkX, int iChunkZ )
+    {
+    	// client
+        chunksToUnload.add( Long.valueOf( ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ ) ) );
+    	// server
+    	//droppedChunksSet.add( Long.valueOf( ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ ) ) );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/CommandDifficulty.java b/minecraft/net/minecraft/src/CommandDifficulty.java
index afcfc55..7be7934 100644
--- a/minecraft/net/minecraft/src/CommandDifficulty.java
+++ b/minecraft/net/minecraft/src/CommandDifficulty.java
@@ -30,6 +30,12 @@ public class CommandDifficulty extends CommandBase
         if (par2ArrayOfStr.length > 0)
         {
             int var3 = this.getDifficultyForName(par1ICommandSender, par2ArrayOfStr[0]);
+            // FCMOD: Code added to remove peaceful and easy
+            if ( var3 < 2 )
+            {
+            	var3 = 2;
+            }
+            // END FCMOD
             MinecraftServer.getServer().setDifficultyForAllWorlds(var3);
             String var4 = StatCollector.translateToLocal(difficulties[var3]);
             notifyAdmins(par1ICommandSender, "commands.difficulty.success", new Object[] {var4});
diff --git a/minecraft/net/minecraft/src/CommandGive.java b/minecraft/net/minecraft/src/CommandGive.java
index 402fba0..ab57d97 100644
--- a/minecraft/net/minecraft/src/CommandGive.java
+++ b/minecraft/net/minecraft/src/CommandGive.java
@@ -49,6 +49,9 @@ public class CommandGive extends CommandBase
                 }
 
                 ItemStack var7 = new ItemStack(var4, var5, var6);
+                // FCMOD: Added
+                var7.getItem().InitializeStackOnGiveCommand( var3.worldObj.rand, var7 );
+                // END FCMOD
                 EntityItem var8 = var3.dropPlayerItem(var7);
                 var8.delayBeforeCanPickup = 0;
                 notifyAdmins(par1ICommandSender, "commands.give.success", new Object[] {Item.itemsList[var4].func_77653_i(var7), Integer.valueOf(var4), Integer.valueOf(var5), var3.getEntityName()});
diff --git a/minecraft/net/minecraft/src/CommandTime.java b/minecraft/net/minecraft/src/CommandTime.java
index 7afdc23..bb871b9 100644
--- a/minecraft/net/minecraft/src/CommandTime.java
+++ b/minecraft/net/minecraft/src/CommandTime.java
@@ -57,6 +57,19 @@ public class CommandTime extends CommandBase
                 return;
             }
         }
+        // FCMOD: Code added to display time
+        else
+        {
+	    	par1ICommandSender.sendChatToPlayer( (new StringBuilder()).append( "\247e"). // yellow text
+            	append("Current Overworld Time: " ).
+            	append( Long.valueOf( MinecraftServer.getServer().worldServers[0].getWorldTime() ) ).
+            	append( " Total Overworld Time: " ).
+            	append( Long.valueOf( MinecraftServer.getServer().worldServers[0].getTotalWorldTime() ) ).
+            	toString() );            	
+            
+            return;
+        }
+        // END FCMOD
 
         throw new WrongUsageException("commands.time.usage", new Object[0]);
     }
diff --git a/minecraft/net/minecraft/src/ComponentMineshaftCorridor.java b/minecraft/net/minecraft/src/ComponentMineshaftCorridor.java
index 9cf80ea..22d5bfa 100644
--- a/minecraft/net/minecraft/src/ComponentMineshaftCorridor.java
+++ b/minecraft/net/minecraft/src/ComponentMineshaftCorridor.java
@@ -199,6 +199,9 @@ public class ComponentMineshaftCorridor extends StructureComponent
             par1World.setBlock(var9, var10, var11, Block.rail.blockID, this.getMetadataWithOffset(Block.rail.blockID, par3Random.nextBoolean() ? 1 : 0), 2);
             EntityMinecartChest var12 = new EntityMinecartChest(par1World, (double)((float)var9 + 0.5F), (double)((float)var10 + 0.5F), (double)((float)var11 + 0.5F));
             WeightedRandomChestContent.generateChestContents(par3Random, par7ArrayOfWeightedRandomChestContent, var12, par8);
+            // FCMOD: Added
+            FilterChestMinecartContents( var12 );
+            // END FCMOD
             par1World.spawnEntityInWorld(var12);
             return true;
         }
@@ -226,7 +229,11 @@ public class ComponentMineshaftCorridor extends StructureComponent
 
             if (this.hasSpiders)
             {
-                this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, Block.web.blockID, 0, false);
+            	// FCMOD: Changed
+                //this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, Block.web.blockID, 0, false);
+                this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, 
+                	FCBetterThanWolves.fcBlockWeb.blockID, 0, false);
+                // END FCMOD            	
             }
 
             int var9;
@@ -236,19 +243,42 @@ public class ComponentMineshaftCorridor extends StructureComponent
             for (var9 = 0; var9 < this.sectionCount; ++var9)
             {
                 var10 = 2 + var9 * 5;
+                // FCMOD: Code change to replace fences by logs
+                /*
                 this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, var10, 0, 1, var10, Block.fence.blockID, 0, false);
                 this.fillWithBlocks(par1World, par3StructureBoundingBox, 2, 0, var10, 2, 1, var10, Block.fence.blockID, 0, false);
-
+                */
+                this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 0, var10, 0, 1, var10, Block.wood.blockID, 0, 0, 0, false);
+                this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 2, 0, var10, 2, 1, var10, Block.wood.blockID, 0, 0, 0, false);
+                // END FCMOD
+
+            	// FCMOD: Code added
+                int iHorizontalLogMetadata = getMetadataWithOffset( Block.wood.blockID, 4 );
+                // END FCMOD
+                
                 if (par2Random.nextInt(4) == 0)
                 {
+                	// FCMOD: Code change
+                	/*
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 0, 2, var10, Block.planks.blockID, 0, false);
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 2, 2, var10, 2, 2, var10, Block.planks.blockID, 0, false);
+                    */
+                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 0, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
+                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 2, 2, var10, 2, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
+                	// END FCMOD
                 }
                 else
                 {
+                	// FCMOD: Code change
+                	/*
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 2, 2, var10, Block.planks.blockID, 0, false);
+                    */
+                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 2, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
+                	// END FCMOD
                 }
 
+                // FCMOD: Changed
+                /*
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 - 1, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 - 1, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 + 1, Block.web.blockID, 0);
@@ -259,6 +289,18 @@ public class ComponentMineshaftCorridor extends StructureComponent
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 + 2, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 - 1, Block.torchWood.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 + 1, Block.torchWood.blockID, 0);
+                */
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 - 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 - 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 + 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 + 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 0, 2, var10 - 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 - 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 0, 2, var10 + 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 + 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 - 1, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 + 1, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8);                
+                // END FCMOD
 
                 if (par2Random.nextInt(100) == 0)
                 {
@@ -320,4 +362,89 @@ public class ComponentMineshaftCorridor extends StructureComponent
             return true;
         }
     }
+    
+    // FCMOD: Added
+    private void FilterChestMinecartContents( EntityMinecartChest minecart )
+    {
+        for ( int iSlot = 0; iSlot < minecart.getSizeInventory(); iSlot++ )
+        {
+            ItemStack tempStack = minecart.getStackInSlot( iSlot );
+            
+            if ( tempStack != null )
+            {
+            	int iItemID = tempStack.itemID;
+
+            	if ( iItemID == Item.ingotIron.itemID )
+            	{
+            		if ( minecart.posY > 36F )
+            		{
+                		minecart.setInventorySlotContents( iSlot, null );
+            		}
+            		else
+            		{
+            			tempStack.stackSize = 1;
+            		}
+            	}
+            	else if ( iItemID == Item.diamond.itemID )
+            	{
+            		if ( minecart.posY > 24F )
+            		{
+                		minecart.setInventorySlotContents( iSlot, null );
+            		}
+            		else
+            		{
+            			tempStack.stackSize = 1;
+            		}
+            	}
+            	else if ( iItemID == Item.pickaxeIron.itemID )
+            	{
+            		minecart.setInventorySlotContents( iSlot, null );
+            	}
+            	else if ( iItemID == Item.redstone.itemID )
+            	{
+            		if ( minecart.posY > 24F )
+            		{
+                		minecart.setInventorySlotContents( iSlot, null );
+            		}
+            	}
+            	else if ( iItemID == Item.pumpkinSeeds.itemID )
+            	{
+            		minecart.setInventorySlotContents( iSlot, null );
+            	}            	
+            }
+        }
+    }
+
+    @Override
+    protected int getMetadataWithOffset( int iBlockID, int iMetadata )
+    {
+    	// override to handle horizontal log placement in supports
+    	
+    	if ( iBlockID == Block.wood.blockID )
+    	{
+            if (this.coordBaseMode == 1 || this.coordBaseMode == 3)
+            {
+            	int iLogType = iMetadata & 3;
+            	int iDirection = iMetadata & 12;
+            	
+            	if ( iDirection == 4 )
+            	{
+            		iDirection = 8;
+            	}
+            	else if ( iDirection == 8 )
+            	{
+            		iDirection = 4;
+            	}
+            	
+            	iMetadata = iLogType | iDirection;
+            }
+            
+    		return iMetadata;
+    	}
+    	else
+    	{
+    		return super.getMetadataWithOffset( iBlockID, iMetadata );
+    	}
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ComponentNetherBridgeEntrance.java b/minecraft/net/minecraft/src/ComponentNetherBridgeEntrance.java
index e721c2f..bee5b5b 100644
--- a/minecraft/net/minecraft/src/ComponentNetherBridgeEntrance.java
+++ b/minecraft/net/minecraft/src/ComponentNetherBridgeEntrance.java
@@ -116,6 +116,10 @@ public class ComponentNetherBridgeEntrance extends ComponentNetherBridgePiece
             Block.blocksList[Block.lavaMoving.blockID].updateTick(par1World, var4, var5, var6, par2Random);
             par1World.scheduledUpdatesAreImmediate = false;
         }
+        
+        // FCMOD: Code added
+        placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockSoulforgeDormant.blockID, FCUtilsWorld.RotateFacingForCoordBaseMode( 4, coordBaseMode ), 5, 6, 6, par3StructureBoundingBox );
+        // END FCMOD
 
         return true;
     }
diff --git a/minecraft/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java b/minecraft/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java
index d981adc..de0e729 100644
--- a/minecraft/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java
+++ b/minecraft/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java
@@ -4,10 +4,13 @@ import java.util.Random;
 
 public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFeature
 {
+	// FCNOTE: Tracks the loot chests which have already been generated.
     private boolean[] field_74940_h = new boolean[4];
 
     /** List of items to generate in chests of Temples. */
-    private static final WeightedRandomChestContent[] itemsToGenerateInTemple = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // FCMOD: Removed as deprecated
+    //private static final WeightedRandomChestContent[] itemsToGenerateInTemple = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // END FCMOD
 
     public ComponentScatteredFeatureDesertPyramid(Random par1Random, int par2, int par3)
     {
@@ -18,6 +21,8 @@ public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFe
      * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes Mineshafts at
      * the end, it adds Fences...
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, -4, 0, this.scatteredFeatureSizeX - 1, 0, this.scatteredFeatureSizeZ - 1, Block.sandStone.blockID, Block.sandStone.blockID, false);
@@ -222,4 +227,316 @@ public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFe
 
         return true;
     }
+    */
+    // END FCMOD
+    
+    // FCMOD: Added New
+    private static final WeightedRandomChestContent[] m_LootListArray = 
+    	new WeightedRandomChestContent[] {
+    		// item ID, item damage, min stack size, max stack size, weight
+	    	new WeightedRandomChestContent( Item.helmetGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.plateGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.legsGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.bootsGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.swordGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.emerald.itemID, 0, 1, 5, 15 ), 
+	    	new WeightedRandomChestContent( Item.bone.itemID, 0, 4, 6, 20 ), 
+	    	new WeightedRandomChestContent( Item.rottenFlesh.itemID, 0, 3, 7, 11 ),
+	    	new WeightedRandomChestContent( Item.skull.itemID, 0, 1, 1, 5 )
+		};
+    
+    private static final WeightedRandomChestContent[] m_LootedLootListArray = 
+    	new WeightedRandomChestContent[] {
+	    	new WeightedRandomChestContent( Item.bone.itemID, 0, 4, 6, 20 ), 
+	    	new WeightedRandomChestContent( Item.rottenFlesh.itemID, 0, 3, 7, 11 ),
+	    	new WeightedRandomChestContent( Item.skull.itemID, 0, 1, 1, 5 )
+		};
+    
+    public boolean addComponentParts( World world, Random generatorRand, 
+    	StructureBoundingBox boundingBox )
+    {
+    	boolean bIsLooted = FCUtilsHardcoreSpawn.IsInLootedTempleRadius( world, 
+    		boundingBox.getCenterX(), boundingBox.getCenterZ() );
+    	
+    	// All cloth blocks from original have been replaced by obsidian, 
+    	// and allowances made for looted temples
+    	
+        fillWithBlocks(world, boundingBox, 0, -4, 0, this.scatteredFeatureSizeX - 1, 0, this.scatteredFeatureSizeZ - 1, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        int var4;
+
+        for (var4 = 1; var4 <= 9; ++var4)
+        {
+            fillWithBlocks(world, boundingBox, var4, var4, var4, this.scatteredFeatureSizeX - 1 - var4, var4, this.scatteredFeatureSizeZ - 1 - var4, Block.sandStone.blockID, Block.sandStone.blockID, false);
+            fillWithBlocks(world, boundingBox, var4 + 1, var4, var4 + 1, this.scatteredFeatureSizeX - 2 - var4, var4, this.scatteredFeatureSizeZ - 2 - var4, 0, 0, false);
+        }
+
+        int var5;
+
+        for (var4 = 0; var4 < this.scatteredFeatureSizeX; ++var4)
+        {
+            for (var5 = 0; var5 < this.scatteredFeatureSizeZ; ++var5)
+            {
+                fillCurrentPositionBlocksDownwards(world, Block.sandStone.blockID, 0, var4, -5, var5, boundingBox);
+            }
+        }
+
+        var4 = getMetadataWithOffset(Block.stairsSandStone.blockID, 3);
+        var5 = getMetadataWithOffset(Block.stairsSandStone.blockID, 2);
+        
+        int var6 = getMetadataWithOffset(Block.stairsSandStone.blockID, 0);
+        int var7 = getMetadataWithOffset(Block.stairsSandStone.blockID, 1);
+        
+        fillWithBlocks(world, boundingBox, 0, 0, 0, 4, 9, 4, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 1, 10, 1, 3, 10, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 10, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var5, 2, 10, 4, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, 0, 10, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, 4, 10, 2, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 0, 0, this.scatteredFeatureSizeX - 1, 9, 4, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 4, 10, 1, this.scatteredFeatureSizeX - 2, 10, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 10, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var5, this.scatteredFeatureSizeX - 3, 10, 4, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, this.scatteredFeatureSizeX - 5, 10, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, this.scatteredFeatureSizeX - 1, 10, 2, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 8, 0, 0, 12, 4, 4, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 9, 1, 0, 11, 3, 4, 0, 0, false);
+        
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 1, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 2, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 3, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, 3, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 3, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 2, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 1, 1, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 4, 1, 1, 8, 3, 3, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 4, 1, 2, 8, 2, 2, 0, 0, false);
+        fillWithBlocks(world, boundingBox, 12, 1, 1, 16, 3, 3, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 12, 1, 2, 16, 2, 2, 0, 0, false);
+        fillWithBlocks(world, boundingBox, 5, 4, 5, this.scatteredFeatureSizeX - 6, 4, this.scatteredFeatureSizeZ - 6, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 9, 4, 9, 11, 4, 11, 0, 0, false);
+        
+        fillWithMetadataBlocks(world, boundingBox, 8, 1, 8, 8, 3, 8, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 12, 1, 8, 12, 3, 8, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 8, 1, 12, 8, 3, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 12, 1, 12, 12, 3, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        fillWithBlocks(world, boundingBox, 1, 1, 5, 4, 4, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 1, 5, this.scatteredFeatureSizeX - 2, 4, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 6, 7, 9, 6, 7, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 7, 7, 9, this.scatteredFeatureSizeX - 7, 7, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        fillWithMetadataBlocks(world, boundingBox, 5, 5, 9, 5, 7, 11, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, this.scatteredFeatureSizeX - 6, 5, 9, this.scatteredFeatureSizeX - 6, 7, 11, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 5, 5, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 5, 6, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 6, 6, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 6, 5, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 6, 6, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 7, 6, 10, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 2, 4, 4, 2, 6, 4, 0, 0, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 3, 4, 4, this.scatteredFeatureSizeX - 3, 6, 4, 0, 0, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 4, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 3, 4, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 4, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 3, 4, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 1, 1, 3, 2, 2, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 3, 1, 3, this.scatteredFeatureSizeX - 2, 2, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, 0, 1, 1, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, 0, this.scatteredFeatureSizeX - 2, 1, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stoneSingleSlab.blockID, 1, 1, 2, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stoneSingleSlab.blockID, 1, this.scatteredFeatureSizeX - 2, 2, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, 2, 1, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, this.scatteredFeatureSizeX - 3, 1, 2, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 4, 3, 5, 4, 3, 18, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 3, 5, this.scatteredFeatureSizeX - 5, 3, 17, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 3, 1, 5, 4, 2, 16, 0, 0, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 6, 1, 5, this.scatteredFeatureSizeX - 5, 2, 16, 0, 0, false);
+        
+        int var10;
+
+        for (var10 = 5; var10 <= 17; var10 += 2)
+        {
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 4, 1, var10, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 4, 2, var10, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, this.scatteredFeatureSizeX - 5, 1, var10, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, this.scatteredFeatureSizeX - 5, 2, var10, boundingBox);
+        }
+
+        // the following is the center tiled portion of the floor, centered on 10, 0, 10
+        
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 7, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 0, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 0, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 8, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 12, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 7, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 13, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 0, 11, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 0, 11, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 12, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 13, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 10, boundingBox);
+
+        for (var10 = 0; var10 <= this.scatteredFeatureSizeX - 1; var10 += this.scatteredFeatureSizeX - 1)
+        {
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 2, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 2, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 2, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 3, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 3, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 3, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 4, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 4, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 4, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 5, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 5, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 5, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 6, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 6, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 6, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 3, boundingBox);
+        }
+
+        for (var10 = 2; var10 <= this.scatteredFeatureSizeX - 3; var10 += this.scatteredFeatureSizeX - 3 - 2)
+        {
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 2, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 2, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 2, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 3, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 3, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 3, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 4, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 4, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 4, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 5, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 5, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 5, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 6, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 6, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 6, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 7, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 7, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 8, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 8, 0, boundingBox);
+        }
+
+        fillWithMetadataBlocks(world, boundingBox, 8, 4, 0, 12, 6, 0, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 8, 6, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 12, 6, 0, boundingBox);
+        
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 5, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, 5, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 5, 0, boundingBox);
+        
+        fillWithMetadataBlocks(world, boundingBox, 8, -14, 8, 12, -11, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 8, -10, 8, 12, -10, 12, Block.sandStone.blockID, 1, Block.sandStone.blockID, 1, false);
+        fillWithMetadataBlocks(world, boundingBox, 8, -9, 8, 12, -9, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        fillWithBlocks(world, boundingBox, 8, -8, 8, 12, -1, 12, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 9, -11, 9, 11, -1, 11, 0, 0, false);
+        
+        placeBlockAtCurrentPosition(world, Block.pressurePlatePlanks.blockID, 0, 10, -11, 10, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 9, -13, 9, 11, -13, 11, Block.tnt.blockID, 0, false);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 8, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 8, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 7, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 7, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 12, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 12, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 13, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 13, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -11, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -10, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, -10, 7, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, -11, 7, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -11, 12, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -10, 12, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, -10, 13, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, -11, 13, boundingBox);
+
+        for ( var10 = 0; var10 < 4; ++var10 )
+        {
+            if ( !field_74940_h[var10] )
+            {
+                int iXOffset = Direction.offsetX[var10] * 2;
+                int iZOffset = Direction.offsetZ[var10] * 2;
+                
+                WeightedRandomChestContent[] lootList = m_LootListArray;
+                int iNumItems = 2 + generatorRand.nextInt( 5 );
+
+            	if ( bIsLooted )
+            	{
+                    lootList = m_LootedLootListArray;
+                    iNumItems /= 2;
+            	}
+            	
+                // creates a modified loot list that includes instantiated items with complex data
+                // such as the following enchanted book with a random enchantment
+                
+            	WeightedRandomChestContent[] moddedLootList =
+                	WeightedRandomChestContent.func_92080_a( lootList, 
+                		new WeightedRandomChestContent[] { 
+            			Item.enchantedBook.func_92114_b( generatorRand ) } );
+            	
+                field_74940_h[var10] = generateStructureChestContents( world, boundingBox, 
+                	generatorRand, 10 + iXOffset, -11, 10 + iZOffset, 
+                	moddedLootList, iNumItems );
+            }
+        }
+
+        if ( bIsLooted )
+        {
+        	// clear the center of the floor for access to the shaft
+        	
+            fillWithBlocks(world, boundingBox, 9, 0, 9, 10, 0, 10, 0, 0, false);
+            
+            // clear out trapped area
+            
+            this.fillWithBlocks(world, boundingBox, 9, -13, 9, 11, -11, 11, 0, 0, false);            
+            
+            // drop a ladder
+            
+            int iLadderFacing = getMetadataWithOffset( Block.ladder.blockID, 5 ); // legacy ladder metadata is straight facing
+            
+            int iLadderMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iLadderFacing ); 
+            
+            for ( int iTempY = -13; iTempY <= 0; iTempY++ )
+            {
+            	placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockLadder.blockID, iLadderMetadata, 
+            		9, iTempY, 9, boundingBox );
+            }            
+        }
+        else
+        {
+        	// place enchanting table at center
+        	
+        	placeBlockAtCurrentPosition(world, Block.enchantmentTable.blockID, 0, 10, 1, 10, boundingBox );
+        }
+        
+        return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java b/minecraft/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java
index d1f68fb..065e659 100644
--- a/minecraft/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java
+++ b/minecraft/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java
@@ -4,13 +4,19 @@ import java.util.Random;
 
 public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFeature
 {
-    private boolean field_74947_h;
+	// FCNOTE: These two track the loot chests which have already been generated.
+    private boolean field_74947_h; 
     private boolean field_74948_i;
-    private boolean field_74945_j;
-    private boolean field_74946_k;
+    
+    // FCMOD: Removed as deprecated
+    //private boolean field_74945_j;
+    //private boolean field_74946_k;
+    // END FCMOD
 
     /** List of Chest contents to be generated in the Jungle Pyramid chests. */
-    private static final WeightedRandomChestContent[] junglePyramidsChestContents = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // FCMOD: Removed as deprecated
+    //private static final WeightedRandomChestContent[] junglePyramidsChestContents = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // END FCMOD
 
     /**
      * List of Dispenser contents to be generated in the Jungle Pyramid dispensers.
@@ -29,6 +35,8 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
      * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes Mineshafts at
      * the end, it adds Fences...
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
         if (!this.func_74935_a(par1World, par3StructureBoundingBox, 0))
@@ -149,6 +157,7 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             this.placeBlockAtCurrentPosition(par1World, Block.tripWireSource.blockID, this.getMetadataWithOffset(Block.tripWireSource.blockID, 1) | 4, 4, -3, 8, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.tripWire.blockID, 4, 2, -3, 8, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.tripWire.blockID, 4, 3, -3, 8, par3StructureBoundingBox);
+            
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 7, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 6, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 5, par3StructureBoundingBox);
@@ -175,7 +184,7 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 9, -3, 5, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.cobblestoneMossy.blockID, 0, 9, -3, 4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 9, -2, 4, par3StructureBoundingBox);
-
+            
             if (!this.field_74946_k)
             {
                 this.field_74946_k = this.generateStructureDispenserContents(par1World, par3StructureBoundingBox, par2Random, 9, -2, 3, 4, junglePyramidsDispenserContents, 2);
@@ -209,13 +218,6 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             this.fillWithRandomizedBlocks(par1World, par3StructureBoundingBox, 8, -3, 8, 8, -3, 10, false, par2Random, junglePyramidsRandomScatteredStones);
             this.fillWithRandomizedBlocks(par1World, par3StructureBoundingBox, 10, -3, 8, 10, -3, 10, false, par2Random, junglePyramidsRandomScatteredStones);
             this.placeBlockAtCurrentPosition(par1World, Block.cobblestoneMossy.blockID, 0, 10, -2, 9, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 8, -2, 9, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 8, -2, 10, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 10, -1, 9, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, 1, 9, -2, 8, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, this.getMetadataWithOffset(Block.pistonStickyBase.blockID, 4), 10, -2, 8, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, this.getMetadataWithOffset(Block.pistonStickyBase.blockID, 4), 10, -1, 8, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneRepeaterIdle.blockID, this.getMetadataWithOffset(Block.redstoneRepeaterIdle.blockID, 2), 10, -2, 10, par3StructureBoundingBox);
 
             if (!this.field_74948_i)
             {
@@ -225,4 +227,291 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             return true;
         }
     }
+    */
+    // END FCMOD
+    
+    // FCMOD: Added New
+    private static final WeightedRandomChestContent[] m_LootListArray = 
+    	new WeightedRandomChestContent[] {
+    		// item ID, item damage, min stack size, max stack size, weight
+	    	new WeightedRandomChestContent( Item.pickaxeGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.shovelGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.axeGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.hoeGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( FCBetterThanWolves.fcBlockLightningRod.blockID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.emerald.itemID, 0, 1, 5, 15 ), 
+	    	new WeightedRandomChestContent( Item.bowlEmpty.itemID, 0, 1, 1, 10 ), 
+	    	new WeightedRandomChestContent( Item.book.itemID, 0, 2, 4, 25 )
+		};
+    
+    private static final WeightedRandomChestContent[] m_LootedLootListArray = 
+    	new WeightedRandomChestContent[] {
+	    	new WeightedRandomChestContent( Item.bowlEmpty.itemID, 0, 1, 1, 10 ), 
+	    	new WeightedRandomChestContent( Item.book.itemID, 0, 2, 4, 25 )
+		};
+    
+    public boolean addComponentParts( World world, Random generatorRand, 
+    	StructureBoundingBox boundingBox )
+    {
+        if ( !func_74935_a( world, boundingBox, 0 ) )
+        {
+            return false;
+        }
+        
+    	boolean bIsLooted = FCUtilsHardcoreSpawn.IsInLootedTempleRadius( world, 
+    		boundingBox.getCenterX(), boundingBox.getCenterZ() );
+    	
+        int var4 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 3 );
+        int var5 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 2 );
+        int var6 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 0 );
+        int var7 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 1 );
+        
+        fillWithRandomizedBlocks(world, boundingBox, 0, -4, 0, scatteredFeatureSizeX - 1, 0, scatteredFeatureSizeZ - 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 2, 9, 2, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 12, 9, 2, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 3, 2, 2, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 9, 1, 3, 9, 2, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 1, 10, 6, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 13, 10, 6, 13, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 2, 1, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 10, 3, 2, 10, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 3, 2, 9, 3, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 6, 2, 9, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 3, 7, 3, 8, 7, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 8, 4, 7, 8, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        fillWithAir(world, boundingBox, 3, 1, 3, 8, 2, 11);
+        fillWithAir(world, boundingBox, 4, 3, 6, 7, 3, 9);
+        fillWithAir(world, boundingBox, 2, 4, 2, 9, 5, 12);
+        fillWithAir(world, boundingBox, 4, 6, 5, 7, 6, 9);
+        fillWithAir(world, boundingBox, 5, 7, 6, 6, 7, 8);
+        fillWithAir(world, boundingBox, 5, 1, 2, 6, 2, 2);
+        fillWithAir(world, boundingBox, 5, 2, 12, 6, 2, 12);
+        fillWithAir(world, boundingBox, 5, 5, 1, 6, 5, 1);
+        fillWithAir(world, boundingBox, 5, 5, 13, 6, 5, 13);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 1, 5, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, 5, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 1, 5, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, 5, 9, boundingBox);
+        
+        int var8;
+
+        for ( var8 = 0; var8 <= 14; var8 += 14 )
+        {
+            fillWithRandomizedBlocks(world, boundingBox, 2, 4, var8, 2, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, 4, 4, var8, 4, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, 7, 4, var8, 7, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, 9, 4, var8, 9, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        this.fillWithRandomizedBlocks(world, boundingBox, 5, 6, 0, 6, 6, 0, false, generatorRand, junglePyramidsRandomScatteredStones);
+
+        for (var8 = 0; var8 <= 11; var8 += 11)
+        {
+            for (int var9 = 2; var9 <= 12; var9 += 2)
+            {
+                fillWithRandomizedBlocks(world, boundingBox, var8, 4, var9, var8, 5, var9, false, generatorRand, junglePyramidsRandomScatteredStones);
+            }
+
+            fillWithRandomizedBlocks(world, boundingBox, var8, 6, 5, var8, 6, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, var8, 6, 9, var8, 6, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        fillWithRandomizedBlocks(world, boundingBox, 2, 7, 2, 2, 9, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 9, 7, 2, 9, 9, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 7, 12, 2, 9, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 9, 7, 12, 9, 9, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 9, 4, 4, 9, 4, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, 9, 4, 7, 9, 4, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 9, 10, 4, 9, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, 9, 10, 7, 9, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 5, 9, 7, 6, 9, 7, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 5, 9, 6, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 6, 9, 6, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 5, 9, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 6, 9, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 5, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 6, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 1, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 2, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 3, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 1, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 2, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 3, 10, boundingBox);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 1, 9, 4, 1, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, 1, 9, 7, 1, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 1, 10, 7, 2, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 5, 4, 5, 6, 4, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var6, 4, 4, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var7, 7, 4, 5, boundingBox);
+
+        for (var8 = 0; var8 < 4; ++var8)
+        {
+            placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 5, 0 - var8, 6 + var8, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 6, 0 - var8, 6 + var8, boundingBox);
+            fillWithAir(world, boundingBox, 5, 0 - var8, 7 + var8, 6, 0 - var8, 9 + var8);
+        }
+
+        fillWithAir(world, boundingBox, 1, -3, 12, 10, -1, 13);
+        fillWithAir(world, boundingBox, 1, -3, 1, 3, -1, 13);
+        fillWithAir(world, boundingBox, 1, -3, 1, 9, -1, 5);
+
+        for (var8 = 1; var8 <= 13; var8 += 2)
+        {
+            this.fillWithRandomizedBlocks(world, boundingBox, 1, -3, var8, 1, -2, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        for (var8 = 2; var8 <= 12; var8 += 2)
+        {
+            this.fillWithRandomizedBlocks(world, boundingBox, 1, -1, var8, 3, -1, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        fillWithRandomizedBlocks(world, boundingBox, 2, -2, 1, 5, -2, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, -2, 1, 9, -2, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 6, -3, 1, 6, -3, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 6, -1, 1, 6, -1, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 3, -3, 1, boundingBox);
+
+        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 3, -2, 2, boundingBox);
+        
+        placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 9, -3, 4, boundingBox);
+        
+        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 8, -1, 3, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 8, -2, 3, boundingBox);
+
+        if ( !field_74947_h )
+        {
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+            WeightedRandomChestContent[] lootList = m_LootListArray;
+        	int iNumItems = 2 + generatorRand.nextInt( 5 );
+        	
+        	if ( bIsLooted )
+        	{
+                lootList = m_LootedLootListArray;
+                iNumItems /= 2;
+        	}
+        	
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+        	WeightedRandomChestContent[] moddedLootList =
+            	WeightedRandomChestContent.func_92080_a( lootList, 
+            		new WeightedRandomChestContent[] { 
+        			Item.enchantedBook.func_92114_b( generatorRand ) } );
+        	
+            field_74947_h = generateStructureChestContents( world, boundingBox, 
+            	generatorRand, 8, -3, 3, 
+            	moddedLootList, iNumItems );
+        }
+
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 9, -3, 2, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 8, -3, 1, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 4, -3, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 5, -2, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 5, -1, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 6, -3, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 7, -2, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 7, -1, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 8, -3, 5, boundingBox);
+        this.fillWithRandomizedBlocks(world, boundingBox, 9, -1, 1, 9, -1, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
+        this.fillWithAir(world, boundingBox, 8, -3, 8, 10, -1, 10);
+        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 8, -2, 11, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 9, -2, 11, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 10, -2, 11, boundingBox);
+        
+        if ( bIsLooted )
+        {
+        	// knock a hole in the wall where the levers used to be
+        	
+            this.placeBlockAtCurrentPosition(world, 0, 0, 9, -2, 11, boundingBox);
+            this.placeBlockAtCurrentPosition(world, 0, 0, 9, -3, 11, boundingBox);                
+        }
+        
+        this.fillWithRandomizedBlocks(world, boundingBox, 8, -3, 8, 8, -3, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        this.fillWithRandomizedBlocks(world, boundingBox, 10, -3, 8, 10, -3, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 10, -2, 9, boundingBox);
+        
+        if ( !field_74948_i )
+        {
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+            WeightedRandomChestContent[] lootList = m_LootListArray;
+        	int iNumItems = 2 + generatorRand.nextInt( 5 );
+        	
+        	if ( bIsLooted )
+        	{
+                lootList = m_LootedLootListArray;
+                iNumItems /= 2;
+        	}
+        	
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+        	WeightedRandomChestContent[] moddedLootList =
+            	WeightedRandomChestContent.func_92080_a( lootList, 
+            		new WeightedRandomChestContent[] { 
+        			Item.enchantedBook.func_92114_b( generatorRand ) } );
+        	
+        	field_74948_i = generateStructureChestContents( world, boundingBox, 
+            	generatorRand, 9, -3, 10, 
+            	moddedLootList, iNumItems );
+        }
+        
+        // Sacrificial altar
+        
+        placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcAestheticOpaque.blockID, FCBlockAestheticOpaque.m_iSubtypeChoppingBlockDirty, 5, 4, 11, boundingBox);
+        placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcAestheticOpaque.blockID, FCBlockAestheticOpaque.m_iSubtypeChoppingBlockDirty, 6, 4, 11, boundingBox);
+        
+        if ( !bIsLooted )
+        {
+        	if ( coordBaseMode != 3 && coordBaseMode != 2 )
+        	{
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockArcaneVessel.blockID, 0, 5, 3, 10, boundingBox);
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcHandCrank.blockID, 0, 6, 3, 10, boundingBox);
+                
+            	FillVesselWithExperience( world, boundingBox, 5, 3, 10 );
+        	}
+        	else
+        	{
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockArcaneVessel.blockID, 0, 6, 3, 10, boundingBox);
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcHandCrank.blockID, 0, 5, 3, 10, boundingBox);
+                
+            	FillVesselWithExperience( world, boundingBox, 6, 3, 10 );
+        	}                
+        }
+        else
+        {
+            placeBlockAtCurrentPosition(world, 0, 0, 5, 3, 10, boundingBox);
+            placeBlockAtCurrentPosition(world, 0, 0, 6, 3, 10, boundingBox);
+        }
+
+        return true;
+    }
+    
+    public void FillVesselWithExperience( World world, StructureBoundingBox boundingBox, int iRelativeI, int iRelativeJ, int iRelativeK )
+    {
+        int iAbsoluteI = getXWithOffset( iRelativeI, iRelativeK );
+        int iAbsoluteJ = getYWithOffset( iRelativeJ );
+        int iAbsoluteK = getZWithOffset( iRelativeI, iRelativeK );
+        
+        TileEntity tileEnt = world.getBlockTileEntity( iAbsoluteI, iAbsoluteJ, iAbsoluteK );
+        
+        if ( tileEnt != null && ( tileEnt instanceof FCTileEntityArcaneVessel ) )
+        {
+            FCTileEntityArcaneVessel vesselEnt = (FCTileEntityArcaneVessel)tileEnt;
+            
+            vesselEnt.InitTempleExperience();
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ComponentScatteredFeatureSwampHut.java b/minecraft/net/minecraft/src/ComponentScatteredFeatureSwampHut.java
index e4e331e..c330e5b 100644
--- a/minecraft/net/minecraft/src/ComponentScatteredFeatureSwampHut.java
+++ b/minecraft/net/minecraft/src/ComponentScatteredFeatureSwampHut.java
@@ -41,8 +41,14 @@ public class ComponentScatteredFeatureSwampHut extends ComponentScatteredFeature
             this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 5, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.flowerPot.blockID, 7, 1, 3, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 3, 2, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.cauldron.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+            // FCMOD: Removed
+            //this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 3, 2, 6, par3StructureBoundingBox);
+            //this.placeBlockAtCurrentPosition(par1World, Block.cauldron.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+            // END FCMOD
+            // FCMOD: Code added to add brewing stand to witch huts
+            this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 1, 2, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.brewingStand.blockID, 0, 2, 3, 6, par3StructureBoundingBox);
+            // END FCMOD
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 2, 1, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 5, 2, 1, par3StructureBoundingBox);
             int var4 = this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3);
@@ -64,6 +70,13 @@ public class ComponentScatteredFeatureSwampHut extends ComponentScatteredFeature
                 }
             }
 
+            // FCMOD: Added
+            if ( !m_bHasLootBasket )
+            {
+            	AddLootBasket( par1World, par3StructureBoundingBox, 3, 2, 6 );
+            }
+            // END FCMOD
+            
             if (!this.hasWitch)
             {
                 var8 = this.getXWithOffset(2, 5);
@@ -73,14 +86,114 @@ public class ComponentScatteredFeatureSwampHut extends ComponentScatteredFeature
                 if (par3StructureBoundingBox.isVecInside(var8, var9, var10))
                 {
                     this.hasWitch = true;
-                    EntityWitch var11 = new EntityWitch(par1World);
+                    // FCMOD: Changed
+                    //EntityWitch var11 = new EntityWitch(par1World);
+                    FCEntityWitch var11 = new FCEntityWitch(par1World);
+                    var11.PreInitCreature();
+                    // END FCMOD
                     var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
                     var11.initCreature();
+                    // FCMOD: Added
+                    var11.SetPersistent( true );
+                    // END FCMOD
                     par1World.spawnEntityInWorld(var11);
                 }
+                
+            	// FCMOD: Added
+            	SpawnAdditionalWitches( par1World );
+            	// END FCMOD
             }
 
             return true;
         }
     }
+    
+    // FCMOD: Added
+    private boolean m_bHasLootBasket = false;
+    
+    private static FCUtilsRandomItemStack[] m_LootBasketContents = null;
+    
+    private void InitContentsArray()
+    {
+    	m_LootBasketContents = new FCUtilsRandomItemStack[] {
+    		new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemHempSeeds.itemID, 0, 1, 4, 5 ),  
+        	new FCUtilsRandomItemStack( Item.glassBottle.itemID, 0, 2, 8, 10 ),  
+        	new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemMushroomRed.itemID, 0, 5, 16, 5 )
+        }; 
+    }
+    
+    private void SpawnAdditionalWitches( World world )
+    {
+    	int iNumWitches = 2;
+    	
+    	if ( !hasWitch )
+    	{
+    		iNumWitches++;
+    	}
+
+    	// constrain spawning to the chunk containing the structure component that we know is loaded
+    	// note that we can't rely on neighboring chunks with a component, like we can with a structure
+    	
+        int iMinSpawnX = ( boundingBox.minX >> 4 ) << 4;
+        int iMinSpawnZ = ( boundingBox.minZ >> 4 ) << 4;
+        
+        int iSpawnZoneWidth = 16;
+    	
+    	for ( int iTempCount = 0; iTempCount < iNumWitches; iTempCount++ )
+    	{
+    		for ( int iTempTries = 0; iTempTries < 20; iTempTries++ )
+    		{
+    			int x = iMinSpawnX + world.rand.nextInt( iSpawnZoneWidth );
+    			int z = iMinSpawnZ + world.rand.nextInt( iSpawnZoneWidth );
+    			
+    			int y = world.getTopSolidOrLiquidBlock( x, z );
+    			
+    			if (SpawnerAnimals.canEntitySpawnDuringWorldGen(FCEntityWitch.class, world, x, y, z ))
+				{
+                    hasWitch = true;
+                    
+                    FCEntityWitch witch = new FCEntityWitch( world );
+                    
+                    // FCMOD: Added
+                    witch.PreInitCreature();
+                    // END FCMOD
+                    witch.setLocationAndAngles( (double)x + 0.5D, (double)y, (double)z + 0.5D, 0.0F, 0.0F);                    
+                    witch.initCreature();                    
+                    witch.SetPersistent( true );
+                    
+                    world.spawnEntityInWorld( witch );
+                    
+                    break;
+				}
+    		}
+    	}
+    }
+    
+    private void AddLootBasket( World world, StructureBoundingBox boundingBox, int iRelX, int iRelY, int iRelZ )
+    {
+    	if ( m_LootBasketContents == null )
+    	{
+    		// only initialize array on first use to ensure referenced mod items are intialized
+    		InitContentsArray();
+    	}
+    	
+    	int i = getXWithOffset( iRelX, iRelZ );
+        int j = getYWithOffset( iRelY );
+        int k = getZWithOffset( iRelX, iRelZ );
+    	
+        if ( boundingBox.isVecInside( i, j, k) && world.getBlockId( i, j, k ) != FCBetterThanWolves.fcBlockBasketWicker.blockID )
+        {
+        	m_bHasLootBasket = true;
+        	
+	    	world.setBlock( i, j, k, FCBetterThanWolves.fcBlockBasketWicker.blockID, world.rand.nextInt( 4 ) | 4, 2 );
+	    	
+	    	FCTileEntityBasketWicker tileEntity = (FCTileEntityBasketWicker)world.getBlockTileEntity( i, j, k );
+	    	
+	    	if ( tileEntity != null )
+	    	{
+	    		tileEntity.SetStorageStack( FCUtilsRandomItemStack.GetRandomStack( world.rand, m_LootBasketContents ) );
+	    	}
+        }	    	
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ComponentStrongholdLibrary.java b/minecraft/net/minecraft/src/ComponentStrongholdLibrary.java
index b47bdc4..2628695 100644
--- a/minecraft/net/minecraft/src/ComponentStrongholdLibrary.java
+++ b/minecraft/net/minecraft/src/ComponentStrongholdLibrary.java
@@ -111,6 +111,8 @@ public class ComponentStrongholdLibrary extends ComponentStronghold
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 9, 6, 11, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 8, 6, 11, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 9, 6, 10, par3StructureBoundingBox);
+                // FCMOD: Changed
+                /*
                 var7 = this.getMetadataWithOffset(Block.ladder.blockID, 3);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 1, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 2, 13, par3StructureBoundingBox);
@@ -119,6 +121,18 @@ public class ComponentStrongholdLibrary extends ComponentStronghold
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 5, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 6, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 7, 13, par3StructureBoundingBox);
+                */
+                int iFacing = getMetadataWithOffset( Block.ladder.blockID, 3 ); // legacy ladder metadata is straight facing
+                int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
+                
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 1, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 2, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 3, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 4, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 5, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 6, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 7, 13, par3StructureBoundingBox);
+                // END FCMOD
                 byte var8 = 7;
                 byte var9 = 7;
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, var8 - 1, 9, var9, par3StructureBoundingBox);
diff --git a/minecraft/net/minecraft/src/ComponentStrongholdRoomCrossing.java b/minecraft/net/minecraft/src/ComponentStrongholdRoomCrossing.java
index 8db732d..49bf67c 100644
--- a/minecraft/net/minecraft/src/ComponentStrongholdRoomCrossing.java
+++ b/minecraft/net/minecraft/src/ComponentStrongholdRoomCrossing.java
@@ -139,9 +139,19 @@ public class ComponentStrongholdRoomCrossing extends ComponentStronghold
                         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 8, 3, var4, par3StructureBoundingBox);
                     }
 
+                    // FCMOD: Changed
+                    /*
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 1, 3, par3StructureBoundingBox);
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 2, 3, par3StructureBoundingBox);
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 3, 3, par3StructureBoundingBox);
+	                */
+	                int iFacing = getMetadataWithOffset( Block.ladder.blockID, 4 ); // legacy ladder metadata is straight facing
+	                int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
+	                
+                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 1, 3, par3StructureBoundingBox );
+                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 2, 3, par3StructureBoundingBox );
+                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 3, 3, par3StructureBoundingBox );
+	                // END FCMOD
                     this.generateStructureChestContents(par1World, par3StructureBoundingBox, par2Random, 3, 4, 8, WeightedRandomChestContent.func_92080_a(strongholdRoomCrossingChestContents, new WeightedRandomChestContent[] {Item.enchantedBook.func_92114_b(par2Random)}), 1 + par2Random.nextInt(4));
             }
 
diff --git a/minecraft/net/minecraft/src/ComponentVillage.java b/minecraft/net/minecraft/src/ComponentVillage.java
index 13fa952..9a94cc1 100644
--- a/minecraft/net/minecraft/src/ComponentVillage.java
+++ b/minecraft/net/minecraft/src/ComponentVillage.java
@@ -5,234 +5,282 @@ import java.util.Random;
 
 abstract class ComponentVillage extends StructureComponent
 {
-    /** The number of villagers that have been spawned in this component. */
-    private int villagersSpawned;
-
-    /** The starting piece of the village. */
-    protected ComponentVillageStartPiece startPiece;
-
-    protected ComponentVillage(ComponentVillageStartPiece par1ComponentVillageStartPiece, int par2)
-    {
-        super(par2);
-        this.startPiece = par1ComponentVillageStartPiece;
-    }
-
-    /**
-     * Gets the next village component, with the bounding box shifted -1 in the X and Z direction.
-     */
-    protected StructureComponent getNextComponentNN(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
-    {
-        switch (this.coordBaseMode)
-        {
-            case 0:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
-
-            case 1:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
-
-            case 2:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
-
-            case 3:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
-
-            default:
-                return null;
-        }
-    }
-
-    /**
-     * Gets the next village component, with the bounding box shifted +1 in the X and Z direction.
-     */
-    protected StructureComponent getNextComponentPP(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
-    {
-        switch (this.coordBaseMode)
-        {
-            case 0:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
-
-            case 1:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
-
-            case 2:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
-
-            case 3:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
-
-            default:
-                return null;
-        }
-    }
-
-    /**
-     * Discover the y coordinate that will serve as the ground level of the supplied BoundingBox. (A median of all the
-     * levels in the BB's horizontal rectangle).
-     */
-    protected int getAverageGroundLevel(World par1World, StructureBoundingBox par2StructureBoundingBox)
-    {
-        int var3 = 0;
-        int var4 = 0;
-
-        for (int var5 = this.boundingBox.minZ; var5 <= this.boundingBox.maxZ; ++var5)
-        {
-            for (int var6 = this.boundingBox.minX; var6 <= this.boundingBox.maxX; ++var6)
-            {
-                if (par2StructureBoundingBox.isVecInside(var6, 64, var5))
-                {
-                    var3 += Math.max(par1World.getTopSolidOrLiquidBlock(var6, var5), par1World.provider.getAverageGroundLevel());
-                    ++var4;
-                }
-            }
-        }
-
-        if (var4 == 0)
-        {
-            return -1;
-        }
-        else
-        {
-            return var3 / var4;
-        }
-    }
-
-    protected static boolean canVillageGoDeeper(StructureBoundingBox par0StructureBoundingBox)
-    {
-        return par0StructureBoundingBox != null && par0StructureBoundingBox.minY > 10;
-    }
-
-    /**
-     * Spawns a number of villagers in this component. Parameters: world, component bounding box, x offset, y offset, z
-     * offset, number of villagers
-     */
-    protected void spawnVillagers(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6)
-    {
-        if (this.villagersSpawned < par6)
-        {
-            for (int var7 = this.villagersSpawned; var7 < par6; ++var7)
-            {
-                int var8 = this.getXWithOffset(par3 + var7, par5);
-                int var9 = this.getYWithOffset(par4);
-                int var10 = this.getZWithOffset(par3 + var7, par5);
-
-                if (!par2StructureBoundingBox.isVecInside(var8, var9, var10))
-                {
-                    break;
-                }
-
-                ++this.villagersSpawned;
+	/** The number of villagers that have been spawned in this component. */
+	private int villagersSpawned;
+
+	/** The starting piece of the village. */
+	protected ComponentVillageStartPiece startPiece;
+
+	protected ComponentVillage(ComponentVillageStartPiece par1ComponentVillageStartPiece, int par2)
+	{
+		super(par2);
+		this.startPiece = par1ComponentVillageStartPiece;
+	}
+
+	/**
+	 * Gets the next village component, with the bounding box shifted -1 in the X and Z direction.
+	 */
+	protected StructureComponent getNextComponentNN(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
+	{
+		switch (this.coordBaseMode)
+		{
+		case 0:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
+
+		case 1:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
+
+		case 2:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
+
+		case 3:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
+
+		default:
+			return null;
+		}
+	}
+
+	/**
+	 * Gets the next village component, with the bounding box shifted +1 in the X and Z direction.
+	 */
+	protected StructureComponent getNextComponentPP(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
+	{
+		switch (this.coordBaseMode)
+		{
+		case 0:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
+
+		case 1:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
+
+		case 2:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
+
+		case 3:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
+
+		default:
+			return null;
+		}
+	}
+
+	/**
+	 * Discover the y coordinate that will serve as the ground level of the supplied BoundingBox. (A median of all the
+	 * levels in the BB's horizontal rectangle).
+	 */
+	protected int getAverageGroundLevel(World par1World, StructureBoundingBox par2StructureBoundingBox)
+	{
+		int var3 = 0;
+		int var4 = 0;
+
+		for (int var5 = this.boundingBox.minZ; var5 <= this.boundingBox.maxZ; ++var5)
+		{
+			for (int var6 = this.boundingBox.minX; var6 <= this.boundingBox.maxX; ++var6)
+			{
+				if (par2StructureBoundingBox.isVecInside(var6, 64, var5))
+				{
+					var3 += Math.max(par1World.getTopSolidOrLiquidBlock(var6, var5), par1World.provider.getAverageGroundLevel());
+					++var4;
+				}
+			}
+		}
+
+		if (var4 == 0)
+		{
+			return -1;
+		}
+		else
+		{
+			return var3 / var4;
+		}
+	}
+
+	protected static boolean canVillageGoDeeper(StructureBoundingBox par0StructureBoundingBox)
+	{
+		return par0StructureBoundingBox != null && par0StructureBoundingBox.minY > 10;
+	}
+
+	/**
+	 * Spawns a number of villagers in this component. Parameters: world, component bounding box, x offset, y offset, z
+	 * offset, number of villagers
+	 */
+	protected void spawnVillagers(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6)
+	{
+		// FCMOD: Code added
+		int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+
+		boolean bDirtyPeasants = false;
+
+		if ( iAbandonmentLevel > 1 )
+		{
+			if ( par1World.rand.nextInt( 20 ) != 0 )
+			{
+				// only a small chance villagers will spawn in fully abandoned villages
+
+				return;
+			}    		
+			else if ( par6 > 1 )
+			{
+				// and in small dirty numbers if they do
+
+				par6 = 1;
+			}
+
+			bDirtyPeasants = true;
+		}
+		// END FCMOD
+
+		if (this.villagersSpawned < par6)
+		{
+			for (int var7 = this.villagersSpawned; var7 < par6; ++var7)
+			{
+				int var8 = this.getXWithOffset(par3 + var7, par5);
+				int var9 = this.getYWithOffset(par4);
+				int var10 = this.getZWithOffset(par3 + var7, par5);
+
+				if (!par2StructureBoundingBox.isVecInside(var8, var9, var10))
+				{
+					break;
+				}
+
+				++this.villagersSpawned;
+
+				// FCMOD: Change
+				/*
                 EntityVillager var11 = new EntityVillager(par1World, this.getVillagerType(var7));
-                var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
-                par1World.spawnEntityInWorld(var11);
-            }
-        }
-    }
-
-    /**
-     * Returns the villager type to spawn in this component, based on the number of villagers already spawned.
-     */
-    protected int getVillagerType(int par1)
-    {
-        return 0;
-    }
-
-    /**
-     * Gets the replacement block for the current biome
-     */
-    protected int getBiomeSpecificBlock(int par1, int par2)
-    {
-        if (this.startPiece.inDesert)
-        {
-            if (par1 == Block.wood.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-
-            if (par1 == Block.cobblestone.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-
-            if (par1 == Block.planks.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-
-            if (par1 == Block.stairsWoodOak.blockID)
-            {
-                return Block.stairsSandStone.blockID;
-            }
-
-            if (par1 == Block.stairsCobblestone.blockID)
-            {
-                return Block.stairsSandStone.blockID;
-            }
-
-            if (par1 == Block.gravel.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-        }
-
-        return par1;
-    }
-
-    /**
-     * Gets the replacement block metadata for the current biome
-     */
-    protected int getBiomeSpecificBlockMetadata(int par1, int par2)
-    {
-        if (this.startPiece.inDesert)
-        {
-            if (par1 == Block.wood.blockID)
-            {
-                return 0;
-            }
-
-            if (par1 == Block.cobblestone.blockID)
-            {
-                return 0;
-            }
-
-            if (par1 == Block.planks.blockID)
-            {
-                return 2;
-            }
-        }
-
-        return par2;
-    }
-
-    /**
-     * current Position depends on currently set Coordinates mode, is computed here
-     */
-    protected void placeBlockAtCurrentPosition(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
-    {
-        int var8 = this.getBiomeSpecificBlock(par2, par3);
-        int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
-        super.placeBlockAtCurrentPosition(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
-    }
-
-    /**
-     * arguments: (World worldObj, StructureBoundingBox structBB, int minX, int minY, int minZ, int maxX, int maxY, int
-     * maxZ, int placeBlockId, int replaceBlockId, boolean alwaysreplace)
-     */
-    protected void fillWithBlocks(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6, int par7, int par8, int par9, int par10, boolean par11)
-    {
-        int var12 = this.getBiomeSpecificBlock(par9, 0);
-        int var13 = this.getBiomeSpecificBlockMetadata(par9, 0);
-        int var14 = this.getBiomeSpecificBlock(par10, 0);
-        int var15 = this.getBiomeSpecificBlockMetadata(par10, 0);
-        super.fillWithMetadataBlocks(par1World, par2StructureBoundingBox, par3, par4, par5, par6, par7, par8, var12, var13, var14, var15, par11);
-    }
-
-    /**
-     * Overwrites air and liquids from selected position downwards, stops at hitting anything else.
-     */
-    protected void fillCurrentPositionBlocksDownwards(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
-    {
-        int var8 = this.getBiomeSpecificBlock(par2, par3);
-        int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
-        super.fillCurrentPositionBlocksDownwards(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
-    }
+				 */
+				EntityLiving var11;
+
+				int iVillagerType = this.getVillagerType(var7);
+
+				if ( iVillagerType != 0 && iAbandonmentLevel > 0 )
+				{
+					if ( iAbandonmentLevel > 1 || ( iVillagerType != 3 && iVillagerType != 4 ) ) // fully abandoned or not blacksmith or butcher
+					{
+						continue;
+					}
+				}
+
+				FCEntityZombie zombieVillager = new FCEntityZombie( par1World );
+
+				zombieVillager.m_iVillagerClass = iVillagerType;
+				zombieVillager.SetPersistent( true );                	
+				zombieVillager.setVillager( true );
+
+				var11 = zombieVillager;
+				
+				var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
+				par1World.spawnEntityInWorld(var11);
+			}
+		}
+	}
+
+	/**
+	 * Returns the villager type to spawn in this component, based on the number of villagers already spawned.
+	 */
+	protected int getVillagerType(int par1)
+	{
+		return 0;
+	}
+
+	/**
+	 * Gets the replacement block for the current biome
+	 */
+	protected int getBiomeSpecificBlock(int par1, int par2)
+	{
+		if (this.startPiece.inDesert)
+		{
+			if (par1 == Block.wood.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+
+			if (par1 == Block.cobblestone.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+
+			if (par1 == Block.planks.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+
+			if (par1 == Block.stairsWoodOak.blockID)
+			{
+				return Block.stairsSandStone.blockID;
+			}
+
+			if (par1 == Block.stairsCobblestone.blockID)
+			{
+				return Block.stairsSandStone.blockID;
+			}
+
+			if (par1 == Block.gravel.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+		}
+
+		return par1;
+	}
+
+	/**
+	 * Gets the replacement block metadata for the current biome
+	 */
+	protected int getBiomeSpecificBlockMetadata(int par1, int par2)
+	{
+		if (this.startPiece.inDesert)
+		{
+			if (par1 == Block.wood.blockID)
+			{
+				return 0;
+			}
+
+			if (par1 == Block.cobblestone.blockID)
+			{
+				return 0;
+			}
+
+			if (par1 == Block.planks.blockID)
+			{
+				return 2;
+			}
+		}
+
+		return par2;
+	}
+
+	/**
+	 * current Position depends on currently set Coordinates mode, is computed here
+	 */
+	protected void placeBlockAtCurrentPosition(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
+	{
+		int var8 = this.getBiomeSpecificBlock(par2, par3);
+		int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
+		super.placeBlockAtCurrentPosition(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
+	}
+
+	/**
+	 * arguments: (World worldObj, StructureBoundingBox structBB, int minX, int minY, int minZ, int maxX, int maxY, int
+	 * maxZ, int placeBlockId, int replaceBlockId, boolean alwaysreplace)
+	 */
+	protected void fillWithBlocks(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6, int par7, int par8, int par9, int par10, boolean par11)
+	{
+		int var12 = this.getBiomeSpecificBlock(par9, 0);
+		int var13 = this.getBiomeSpecificBlockMetadata(par9, 0);
+		int var14 = this.getBiomeSpecificBlock(par10, 0);
+		int var15 = this.getBiomeSpecificBlockMetadata(par10, 0);
+		super.fillWithMetadataBlocks(par1World, par2StructureBoundingBox, par3, par4, par5, par6, par7, par8, var12, var13, var14, var15, par11);
+	}
+
+	/**
+	 * Overwrites air and liquids from selected position downwards, stops at hitting anything else.
+	 */
+	protected void fillCurrentPositionBlocksDownwards(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
+	{
+		int var8 = this.getBiomeSpecificBlock(par2, par3);
+		int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
+		super.fillCurrentPositionBlocksDownwards(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
+	}
 }
diff --git a/minecraft/net/minecraft/src/ComponentVillageChurch.java b/minecraft/net/minecraft/src/ComponentVillageChurch.java
index 89277d8..8ad5c02 100644
--- a/minecraft/net/minecraft/src/ComponentVillageChurch.java
+++ b/minecraft/net/minecraft/src/ComponentVillageChurch.java
@@ -65,6 +65,8 @@ public class ComponentVillageChurch extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 3), 3, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 1), 1, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 0), 3, 2, 7, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
@@ -84,17 +86,76 @@ public class ComponentVillageChurch extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 4, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 3, 4, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 4, 5, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 6, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 7, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 6, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 7, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 3, 8, par3StructureBoundingBox);
+            
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 4, 7, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 4, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 3, 4, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 4, 5, par3StructureBoundingBox);
+    	}
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 6, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 7, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 6, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 7, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 3, 8, par3StructureBoundingBox);
+        }
+        // END FCMOD
         int var4 = this.getMetadataWithOffset(Block.ladder.blockID, 4);
         int var5;
 
         for (var5 = 1; var5 <= 9; ++var5)
         {
-            this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, var5, 3, par3StructureBoundingBox);
+        	// FCMOD: Changed
+            //this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, var5, 3, par3StructureBoundingBox);
+            int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, var4 );
+            
+            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, var5, 3, par3StructureBoundingBox);
+            // END FCMOD
         }
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        // FCMOD: Changed
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel == 0 )
+        {
+            placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+    	// END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
         {
diff --git a/minecraft/net/minecraft/src/ComponentVillageField.java b/minecraft/net/minecraft/src/ComponentVillageField.java
index 8804122..067132c 100644
--- a/minecraft/net/minecraft/src/ComponentVillageField.java
+++ b/minecraft/net/minecraft/src/ComponentVillageField.java
@@ -44,7 +44,10 @@ public class ComponentVillageField extends ComponentVillage
                 return Block.potato.blockID;
 
             default:
-                return Block.crops.blockID;
+            	// FCMOD: Changed
+                //return Block.crops.blockID;
+                return FCBetterThanWolves.fcBlockWheatCrop.blockID;
+                // END FCMOD            	
         }
     }
 
@@ -60,6 +63,13 @@ public class ComponentVillageField extends ComponentVillage
      */
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
+    	// FCMOD: Added
+        cropTypeA = startPiece.GetPrimaryCropBlockID( par1World );
+        cropTypeB = cropTypeA;
+        cropTypeC = cropTypeA;
+        cropTypeD = startPiece.GetSecondaryCropBlockID( par1World );
+        // END FCMOD
+        
         if (this.averageGroundLevel < 0)
         {
             this.averageGroundLevel = this.getAverageGroundLevel(par1World, par3StructureBoundingBox);
@@ -73,21 +83,74 @@ public class ComponentVillageField extends ComponentVillage
         }
 
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 0, 12, 4, 8, 0, 0, false);
+    	// FCMOD: Changed
+    	/*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
+        */
+    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+    	
+    	if ( iAbandonmentLevel <= 1 )
+    	{
+            fillWithBlocks( par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+    	}
+    	else
+    	{
+            fillWithBlocks( par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+    	}
+    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, 0, 0, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 0, 0, 6, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 12, 0, 0, 12, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 0, 11, 0, 0, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 8, 11, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
+    	// FCMOD: Changed
+        /*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 0, 1, 9, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
+        */
+    	if ( iAbandonmentLevel <= 1 )
+        {
+            this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
+            this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 0, 1, 9, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
+        }
+        // END FCMOD
         int var4;
 
         for (var4 = 1; var4 <= 7; ++var4)
         {
+        	// FCMOD: Changed
+        	/*
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 1, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 2, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 4, 1, var4, par3StructureBoundingBox);
@@ -96,6 +159,74 @@ public class ComponentVillageField extends ComponentVillage
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeC, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 8, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeD, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 10, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeD, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 11, 1, var4, par3StructureBoundingBox);
+            */
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	1, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	2, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	4, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	5, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeC, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	7, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeC, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	8, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeD, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	10, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeD, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	11, 1, var4, par3StructureBoundingBox);
+        	// END FCMOD
+            
+            // FCMOD: Added
+        	if ( iAbandonmentLevel > 1 )
+            {
+            	// delete all generated crops after placing so as not to disturb random number generator
+            	
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 7, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 10, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 11, 1, var4, par3StructureBoundingBox);
+            }
+        	else if ( iAbandonmentLevel == 1 )
+        	{
+        		// randomly destroy some of the crops to give the impression of the field being only partially tended
+        		
+        		for ( int iTempCount = 1; iTempCount <= 10; iTempCount += 3 )
+        		{
+        			// use the world random so as not to mess with generation
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount, 1, var4, par3StructureBoundingBox);
+        			}
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount + 1, 1, var4, par3StructureBoundingBox);
+        			}
+        		}
+        	}
+            // END FCMOD
         }
 
         for (var4 = 0; var4 < 9; ++var4)
diff --git a/minecraft/net/minecraft/src/ComponentVillageField2.java b/minecraft/net/minecraft/src/ComponentVillageField2.java
index 5243eeb..f8f2e22 100644
--- a/minecraft/net/minecraft/src/ComponentVillageField2.java
+++ b/minecraft/net/minecraft/src/ComponentVillageField2.java
@@ -36,7 +36,10 @@ public class ComponentVillageField2 extends ComponentVillage
                 return Block.potato.blockID;
 
             default:
-                return Block.crops.blockID;
+            	// FCMOD: Changed
+                //return Block.crops.blockID;
+                return FCBetterThanWolves.fcBlockWheatCrop.blockID;
+                // END FCMOD
         }
     }
 
@@ -52,6 +55,11 @@ public class ComponentVillageField2 extends ComponentVillage
      */
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
+    	// FCMOD: Added
+        cropTypeA = startPiece.GetPrimaryCropBlockID( par1World );
+        cropTypeB = startPiece.GetSecondaryCropBlockID( par1World );
+    	// END FCMOD
+        
         if (this.averageGroundLevel < 0)
         {
             this.averageGroundLevel = this.getAverageGroundLevel(par1World, par3StructureBoundingBox);
@@ -65,21 +73,99 @@ public class ComponentVillageField2 extends ComponentVillage
         }
 
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 0, 6, 4, 8, 0, 0, false);
+    	// FCMOD: Changed
+    	/*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
+        */
+    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+    	if ( iAbandonmentLevel <= 1 )
+    	{
+            fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+    	}
+    	else
+    	{
+            fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+    	}
+    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, 0, 0, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 0, 0, 6, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 0, 5, 0, 0, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 8, 5, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
+        // FCMOD: Added
+    	if ( iAbandonmentLevel <= 1 )
+    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
         int var4;
 
         for (var4 = 1; var4 <= 7; ++var4)
         {
+        	// FCMOD: Changed
+        	/*
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 1, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 2, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 4, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 5, 1, var4, par3StructureBoundingBox);
+            */
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	1, 1, var4, par3StructureBoundingBox );
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	2, 1, var4, par3StructureBoundingBox );
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	4, 1, var4, par3StructureBoundingBox );
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	5, 1, var4, par3StructureBoundingBox );
+        	// END FCMOD
+            
+            // FCMOD: Added
+        	if ( iAbandonmentLevel > 1 )
+            {
+            	// delete all generated crops after placing so as not to disturb random number generator
+            	
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, var4, par3StructureBoundingBox);
+            }
+        	else if ( iAbandonmentLevel == 1 )
+        	{
+        		// randomly destroy some of the crops to give the impression of the field being only partially tended
+        		
+        		for ( int iTempCount = 1; iTempCount <= 4; iTempCount += 3 )
+        		{
+        			// use the world random so as not to mess with generation
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount, 1, var4, par3StructureBoundingBox);
+        			}
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount + 1, 1, var4, par3StructureBoundingBox);
+        			}
+        		}
+        	}        		
+            // END FCMOD
         }
 
         for (var4 = 0; var4 < 9; ++var4)
diff --git a/minecraft/net/minecraft/src/ComponentVillageHall.java b/minecraft/net/minecraft/src/ComponentVillageHall.java
index 93aebac..78bb814 100644
--- a/minecraft/net/minecraft/src/ComponentVillageHall.java
+++ b/minecraft/net/minecraft/src/ComponentVillageHall.java
@@ -77,6 +77,8 @@ public class ComponentVillageHall extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 4, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
@@ -85,8 +87,42 @@ public class ComponentVillageHall extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+    	}
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
+        }        	
+        // END FCMOD
+        // FCMOD: Code change to replace pressure plate tables with actual mod tables
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 2, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 2, 2, 3, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	2, 1, 3, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3), 2, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 1), 1, 1, 3, par3StructureBoundingBox);
@@ -95,8 +131,17 @@ public class ComponentVillageHall extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 6, 1, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel <= 1 )
+        {
+        	placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
+            placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
+            	this.getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+        // END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
         {
@@ -105,8 +150,17 @@ public class ComponentVillageHall extends ComponentVillage
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 6, 3, 4, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 6, 3, 4, par3StructureBoundingBox);
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 6, 3, 4, par3StructureBoundingBox);
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, 
+            	this.getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+        // END FCMOD
 
         for (var6 = 0; var6 < 5; ++var6)
         {
diff --git a/minecraft/net/minecraft/src/ComponentVillageHouse1.java b/minecraft/net/minecraft/src/ComponentVillageHouse1.java
index 4edf6ab..1c86b50 100644
--- a/minecraft/net/minecraft/src/ComponentVillageHouse1.java
+++ b/minecraft/net/minecraft/src/ComponentVillageHouse1.java
@@ -69,6 +69,8 @@ public class ComponentVillageHouse1 extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 2, 5, 7, 4, 5, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 8, 2, 1, 8, 4, 4, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 2, 0, 7, 4, 0, Block.planks.blockID, Block.planks.blockID, false);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
@@ -87,6 +89,54 @@ public class ComponentVillageHouse1 extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+    	}
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
+        }        	
+        // END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 4, 1, 7, 4, 1, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 4, 4, 7, 4, 4, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 3, 4, 7, 3, 4, Block.bookShelf.blockID, Block.bookShelf.blockID, false);
@@ -97,14 +147,33 @@ public class ComponentVillageHouse1 extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 5, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 4, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 3, 1, 4, par3StructureBoundingBox);
+        // FCMOD: Code change to replace pressure plate tables with actual mod tables
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 6, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 4, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 4, 2, 3, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 7, 1, 1, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	6, 1, 3, par3StructureBoundingBox);
+        
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	4, 1, 3, par3StructureBoundingBox);
+        // FCMOD
+        
+        // FCMOD: Removed
+        //this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 7, 1, 1, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 2, 0, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        // FCMOD: Changed
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+    	// END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 1, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 1, -1, -1, par3StructureBoundingBox) != 0)
         {
diff --git a/minecraft/net/minecraft/src/ComponentVillageHouse2.java b/minecraft/net/minecraft/src/ComponentVillageHouse2.java
index dee4293..c591249 100644
--- a/minecraft/net/minecraft/src/ComponentVillageHouse2.java
+++ b/minecraft/net/minecraft/src/ComponentVillageHouse2.java
@@ -58,21 +58,70 @@ public class ComponentVillageHouse2 extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 5, 1, 0, 5, 3, 0, Block.fence.blockID, Block.fence.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 1, 0, 9, 3, 0, Block.fence.blockID, Block.fence.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 1, 4, 9, 4, 6, Block.cobblestone.blockID, Block.cobblestone.blockID, false);
-        this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox);
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox);
+        //this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox);
+        placeBlockAtCurrentPosition( par1World, Block.waterMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox );
+        placeBlockAtCurrentPosition( par1World, Block.waterMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox );
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.fenceIron.blockID, 0, 9, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fenceIron.blockID, 0, 9, 2, 4, par3StructureBoundingBox);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 7, 2, 4, 8, 2, 5, 0, 0, false);
         this.placeBlockAtCurrentPosition(par1World, Block.cobblestone.blockID, 0, 6, 1, 3, par3StructureBoundingBox);
+        // FCMOD: Changed
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.furnaceIdle.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.furnaceIdle.blockID, 0, 6, 3, 3, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 8, 1, 1, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockFurnaceBrickIdle.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
+            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockFurnaceBrickIdle.blockID, 0, 6, 3, 3, par3StructureBoundingBox);
+    	}
+        // END FCMOD
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 8, 1, 1, par3StructureBoundingBox);
+        if ( iAbandonmentLevel == 0 )
+    	{
+        	placeBlockAtCurrentPosition(par1World, Block.anvil.blockID, par1World.rand.nextInt( 4 ), 8, 1, 1, par3StructureBoundingBox);
+    	}
+        // END FCMOD
+        
+        // FCMOD: Changed to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+        */
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+        }
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 6, par3StructureBoundingBox);
+        }        	
+        // END FCMOD
+        // FCMOD: Changed to replace pressure plate tables with actual mod tables
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 2, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	2, 1, 4, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3), 2, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 1), 1, 1, 4, par3StructureBoundingBox);
@@ -89,6 +138,25 @@ public class ComponentVillageHouse2 extends ComponentVillage
             {
                 this.hasMadeChest = true;
                 this.generateStructureChestContents(par1World, par3StructureBoundingBox, par2Random, 5, 1, 5, villageBlacksmithChestContents, 3 + par2Random.nextInt(6));
+                // FCMOD: Added
+                if ( startPiece.GetAbandonmentLevel( par1World ) > 0 )
+                {
+                	// delete the chest after generation so as not to mess with the terrain generator
+                	
+                    int iChestI = getXWithOffset( 5, 5 );
+                    int iChestJ = getYWithOffset( 1 );
+                    int iChestK = getZWithOffset( 5, 5 );
+                    
+                    TileEntityChest chestEnt = (TileEntityChest)par1World.getBlockTileEntity( iChestI, iChestJ, iChestK );
+                    
+                    if ( chestEnt != null )
+                    {
+                    	FCUtilsInventory.ClearInventoryContents( chestEnt );
+                    }
+                	
+                    placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, 5, par3StructureBoundingBox);                    
+                }
+                // END FCMOD
             }
         }
 
diff --git a/minecraft/net/minecraft/src/ComponentVillageHouse3.java b/minecraft/net/minecraft/src/ComponentVillageHouse3.java
index b39acc1..a18b476 100644
--- a/minecraft/net/minecraft/src/ComponentVillageHouse3.java
+++ b/minecraft/net/minecraft/src/ComponentVillageHouse3.java
@@ -108,34 +108,89 @@ public class ComponentVillageHouse3 extends ComponentVillage
             }
         }
 
+        // FCMOD: Code added to remove glass from abandoned villages
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        int iGlassBlockID = 0;
+        
+        if ( iAbandonmentLevel == 0 )
+        {
+        	iGlassBlockID = Block.thinGlass.blockID;
+        }
+        // END FCMOD
+        
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 0, 2, 2, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 0, 2, 3, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 5, 2, 0, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 1, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 2, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 3, par3StructureBoundingBox);        
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 8, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 6, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 8, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 7, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 8, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 9, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 8, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 2, 2, 7, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 2, 2, 8, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 2, 2, 9, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 4, 4, 10, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 4, 10, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 5, 4, 10, par3StructureBoundingBox);
+        // END FCMOD        
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 6, 4, 10, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 5, 5, 10, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+        // END FCMOD
+        	
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, -1, 3, 2, -1, 0, 0, false);
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
diff --git a/minecraft/net/minecraft/src/ComponentVillageHouse4_Garden.java b/minecraft/net/minecraft/src/ComponentVillageHouse4_Garden.java
index 88b45cc..b234e86 100644
--- a/minecraft/net/minecraft/src/ComponentVillageHouse4_Garden.java
+++ b/minecraft/net/minecraft/src/ComponentVillageHouse4_Garden.java
@@ -58,9 +58,27 @@ public class ComponentVillageHouse4_Garden extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 1, 0, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 1, 1, 4, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 4, 3, 3, 4, Block.planks.blockID, Block.planks.blockID, false);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
+    	}
+        else
+        {
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 2, par3StructureBoundingBox);
+        }
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 3, 0, par3StructureBoundingBox);
@@ -100,14 +118,31 @@ public class ComponentVillageHouse4_Garden extends ComponentVillage
 
         if (this.isRoofAccessible)
         {
+            // FCMOD: Changed
+        	/*
             var4 = this.getMetadataWithOffset(Block.ladder.blockID, 3);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 1, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 2, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 3, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 4, 3, par3StructureBoundingBox);
+            */
+            int iFacing = getMetadataWithOffset( Block.ladder.blockID, 3 ); // legacy ladder metadata is straight facing
+            int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
+            
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 1, 3, par3StructureBoundingBox );
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 2, 3, par3StructureBoundingBox );
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 3, 3, par3StructureBoundingBox );
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 4, 3, par3StructureBoundingBox );
+            // END FCMOD
         }
 
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
+        }
+        // END FCMOD
 
         for (var4 = 0; var4 < 5; ++var4)
         {
diff --git a/minecraft/net/minecraft/src/ComponentVillageStartPiece.java b/minecraft/net/minecraft/src/ComponentVillageStartPiece.java
index 1eec37b..6d7d121 100644
--- a/minecraft/net/minecraft/src/ComponentVillageStartPiece.java
+++ b/minecraft/net/minecraft/src/ComponentVillageStartPiece.java
@@ -37,4 +37,94 @@ public class ComponentVillageStartPiece extends ComponentVillageWell
     {
         return this.worldChunkMngr;
     }
+    
+    // FCMOD: Code added
+    private int m_iAbandonmentLevel;  // 0 = not abandoned, 1 = partially abandoned 2 = fully abandonded
+    private int m_iPrimaryCropBlockID;
+    private int m_iSecondaryCropBlockID;
+    private boolean m_bModSpecificDataInitialized = false;
+
+    public int GetAbandonmentLevel( World world )
+    {
+    	CheckIfModSpecificDataRequiresInit( world );
+    	
+    	return m_iAbandonmentLevel;
+    }
+    
+    public int GetPrimaryCropBlockID( World world )
+    {
+    	CheckIfModSpecificDataRequiresInit( world );
+    	
+    	return m_iPrimaryCropBlockID;
+    }
+    
+    public int GetSecondaryCropBlockID( World world )
+    {
+    	CheckIfModSpecificDataRequiresInit( world );
+    	
+    	return m_iSecondaryCropBlockID;
+    }
+    
+    private void CheckIfModSpecificDataRequiresInit( World world )
+    {
+    	if ( !m_bModSpecificDataInitialized )
+    	{
+    		InitializeModSpecificData( world );    		
+    	}
+    }
+    
+    private void InitializeModSpecificData( World world )
+    {    	
+		m_bModSpecificDataInitialized = true;
+		m_iAbandonmentLevel = 0;
+    	
+    	int iSpawnX = world.getWorldInfo().getSpawnX();
+    	int iSpawnZ = world.getWorldInfo().getSpawnZ();
+    	
+    	int iVillageX = boundingBox.getCenterX();
+    	int iVillageZ = boundingBox.getCenterZ();
+    	
+    	double dDeltaX = (double)( iSpawnX - iVillageX );
+    	double dDeltaZ = (double)( iSpawnZ - iVillageZ );
+    	
+    	double dDistSqFromSpawn = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+    	double dAbandonedRadius = FCUtilsHardcoreSpawn.GetAbandonedVillageRadius();
+    	
+    	if ( dDistSqFromSpawn < ( dAbandonedRadius * dAbandonedRadius ) )
+    	{
+    		m_iAbandonmentLevel = 2;
+    	}
+    	else
+    	{
+    		double dPartiallyAbandonedRadius = FCUtilsHardcoreSpawn.GetPartiallyAbandonedVillageRadius();
+    		
+    		if ( dDistSqFromSpawn < ( dPartiallyAbandonedRadius * dPartiallyAbandonedRadius ) )
+    		{    		
+        		m_iAbandonmentLevel = 1;
+        		
+    			m_iPrimaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    			m_iSecondaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    		}
+    		else
+    		{	
+    			m_iPrimaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    			
+    			int iRandomFactor = world.rand.nextInt( 6 ); 
+    			
+    			if ( iRandomFactor == 5 )
+    			{
+    				m_iSecondaryCropBlockID = Block.potato.blockID;
+    			}
+    			else if ( iRandomFactor == 4 )
+    			{
+    				m_iSecondaryCropBlockID = Block.carrot.blockID;
+    			}
+    			else
+    			{
+    				m_iSecondaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    			}
+    		}
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ComponentVillageTorch.java b/minecraft/net/minecraft/src/ComponentVillageTorch.java
index ae477c5..3bae64b 100644
--- a/minecraft/net/minecraft/src/ComponentVillageTorch.java
+++ b/minecraft/net/minecraft/src/ComponentVillageTorch.java
@@ -42,11 +42,24 @@ public class ComponentVillageTorch extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 0, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 2, 0, par3StructureBoundingBox);
+        // FCMOD: Code change
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.cloth.blockID, 15, 1, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 0, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 3, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 3, -1, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 1, 1, 3, 0, par3StructureBoundingBox);
+        
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 0, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 3, 1, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 3, -1, par3StructureBoundingBox);
+        }
+        // END FCMOD        
         return true;
     }
 }
diff --git a/minecraft/net/minecraft/src/ComponentVillageWoodHut.java b/minecraft/net/minecraft/src/ComponentVillageWoodHut.java
index 0384b47..c82a740 100644
--- a/minecraft/net/minecraft/src/ComponentVillageWoodHut.java
+++ b/minecraft/net/minecraft/src/ComponentVillageWoodHut.java
@@ -73,18 +73,48 @@ public class ComponentVillageWoodHut extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 1, 1, 3, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 0, 2, 3, 0, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 4, 2, 3, 4, Block.planks.blockID, Block.planks.blockID, false);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 2, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 2, par3StructureBoundingBox);
+    	}
+        else
+        {
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 2, par3StructureBoundingBox);
+        }
+        // END FCMOD
 
         if (this.tablePosition > 0)
         {
+            // FCMOD: Code change to replace pressure plate tables with actual mod tables
+            /*
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, this.tablePosition, 1, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, this.tablePosition, 2, 3, par3StructureBoundingBox);
+            */
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+            	this.tablePosition, 1, 3, par3StructureBoundingBox);
+        	// END FCMOD
         }
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 2, 0, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+    	// END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 1, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 1, -1, -1, par3StructureBoundingBox) != 0)
         {
diff --git a/minecraft/net/minecraft/src/Container.java b/minecraft/net/minecraft/src/Container.java
index 41ee47a..fb450fb 100644
--- a/minecraft/net/minecraft/src/Container.java
+++ b/minecraft/net/minecraft/src/Container.java
@@ -233,8 +233,8 @@ public abstract class Container
         else
         {
             Slot var16;
-            int var19;
-            ItemStack var22;
+            int var21;
+            ItemStack var23;
 
             if ((par3 == 0 || par3 == 1) && (par2 == 0 || par2 == 1))
             {
@@ -296,7 +296,7 @@ public abstract class Container
                     if (var16 != null)
                     {
                         var17 = var16.getStack();
-                        ItemStack var20 = var6.getItemStack();
+                        ItemStack var19 = var6.getItemStack();
 
                         if (var17 != null)
                         {
@@ -305,18 +305,18 @@ public abstract class Container
 
                         if (var17 == null)
                         {
-                            if (var20 != null && var16.isItemValid(var20))
+                            if (var19 != null && var16.isItemValid(var19))
                             {
-                                var19 = par2 == 0 ? var20.stackSize : 1;
+                                var21 = par2 == 0 ? var19.stackSize : 1;
 
-                                if (var19 > var16.getSlotStackLimit())
+                                if (var21 > var16.getSlotStackLimit())
                                 {
-                                    var19 = var16.getSlotStackLimit();
+                                    var21 = var16.getSlotStackLimit();
                                 }
 
-                                var16.putStack(var20.splitStack(var19));
+                                var16.putStack(var19.splitStack(var21));
 
-                                if (var20.stackSize == 0)
+                                if (var19.stackSize == 0)
                                 {
                                     var6.setItemStack((ItemStack)null);
                                 }
@@ -324,11 +324,11 @@ public abstract class Container
                         }
                         else if (var16.canTakeStack(par4EntityPlayer))
                         {
-                            if (var20 == null)
+                            if (var19 == null)
                             {
-                                var19 = par2 == 0 ? var17.stackSize : (var17.stackSize + 1) / 2;
-                                var22 = var16.decrStackSize(var19);
-                                var6.setItemStack(var22);
+                                var21 = par2 == 0 ? var17.stackSize : (var17.stackSize + 1) / 2;
+                                var23 = var16.decrStackSize(var21);
+                                var6.setItemStack(var23);
 
                                 if (var17.stackSize == 0)
                                 {
@@ -337,45 +337,45 @@ public abstract class Container
 
                                 var16.onPickupFromSlot(par4EntityPlayer, var6.getItemStack());
                             }
-                            else if (var16.isItemValid(var20))
+                            else if (var16.isItemValid(var19))
                             {
-                                if (var17.itemID == var20.itemID && var17.getItemDamage() == var20.getItemDamage() && ItemStack.areItemStackTagsEqual(var17, var20))
+                                if (var17.itemID == var19.itemID && var17.getItemDamage() == var19.getItemDamage() && ItemStack.areItemStackTagsEqual(var17, var19))
                                 {
-                                    var19 = par2 == 0 ? var20.stackSize : 1;
+                                    var21 = par2 == 0 ? var19.stackSize : 1;
 
-                                    if (var19 > var16.getSlotStackLimit() - var17.stackSize)
+                                    if (var21 > var16.getSlotStackLimit() - var17.stackSize)
                                     {
-                                        var19 = var16.getSlotStackLimit() - var17.stackSize;
+                                        var21 = var16.getSlotStackLimit() - var17.stackSize;
                                     }
 
-                                    if (var19 > var20.getMaxStackSize() - var17.stackSize)
+                                    if (var21 > var19.getMaxStackSize() - var17.stackSize)
                                     {
-                                        var19 = var20.getMaxStackSize() - var17.stackSize;
+                                        var21 = var19.getMaxStackSize() - var17.stackSize;
                                     }
 
-                                    var20.splitStack(var19);
+                                    var19.splitStack(var21);
 
-                                    if (var20.stackSize == 0)
+                                    if (var19.stackSize == 0)
                                     {
                                         var6.setItemStack((ItemStack)null);
                                     }
 
-                                    var17.stackSize += var19;
+                                    var17.stackSize += var21;
                                 }
-                                else if (var20.stackSize <= var16.getSlotStackLimit())
+                                else if (var19.stackSize <= var16.getSlotStackLimit())
                                 {
-                                    var16.putStack(var20);
+                                    var16.putStack(var19);
                                     var6.setItemStack(var17);
                                 }
                             }
-                            else if (var17.itemID == var20.itemID && var20.getMaxStackSize() > 1 && (!var17.getHasSubtypes() || var17.getItemDamage() == var20.getItemDamage()) && ItemStack.areItemStackTagsEqual(var17, var20))
+                            else if (var17.itemID == var19.itemID && var19.getMaxStackSize() > 1 && (!var17.getHasSubtypes() || var17.getItemDamage() == var19.getItemDamage()) && ItemStack.areItemStackTagsEqual(var17, var19))
                             {
-                                var19 = var17.stackSize;
+                                var21 = var17.stackSize;
 
-                                if (var19 > 0 && var19 + var20.stackSize <= var20.getMaxStackSize())
+                                if (var21 > 0 && var21 + var19.stackSize <= var19.getMaxStackSize())
                                 {
-                                    var20.stackSize += var19;
-                                    var17 = var16.decrStackSize(var19);
+                                    var19.stackSize += var21;
+                                    var17 = var16.decrStackSize(var21);
 
                                     if (var17.stackSize == 0)
                                     {
@@ -399,34 +399,34 @@ public abstract class Container
                 {
                     var17 = var6.getStackInSlot(par2);
                     boolean var18 = var17 == null || var16.inventory == var6 && var16.isItemValid(var17);
-                    var19 = -1;
+                    var21 = -1;
 
                     if (!var18)
                     {
-                        var19 = var6.getFirstEmptyStack();
-                        var18 |= var19 > -1;
+                        var21 = var6.getFirstEmptyStack();
+                        var18 |= var21 > -1;
                     }
 
                     if (var16.getHasStack() && var18)
                     {
-                        var22 = var16.getStack();
-                        var6.setInventorySlotContents(par2, var22.copy());
+                        var23 = var16.getStack();
+                        var6.setInventorySlotContents(par2, var23.copy());
 
                         if ((var16.inventory != var6 || !var16.isItemValid(var17)) && var17 != null)
                         {
-                            if (var19 > -1)
+                            if (var21 > -1)
                             {
                                 var6.addItemStackToInventory(var17);
-                                var16.decrStackSize(var22.stackSize);
+                                var16.decrStackSize(var23.stackSize);
                                 var16.putStack((ItemStack)null);
-                                var16.onPickupFromSlot(par4EntityPlayer, var22);
+                                var16.onPickupFromSlot(par4EntityPlayer, var23);
                             }
                         }
                         else
                         {
-                            var16.decrStackSize(var22.stackSize);
+                            var16.decrStackSize(var23.stackSize);
                             var16.putStack(var17);
-                            var16.onPickupFromSlot(par4EntityPlayer, var22);
+                            var16.onPickupFromSlot(par4EntityPlayer, var23);
                         }
                     }
                     else if (!var16.getHasStack() && var17 != null && var16.isItemValid(var17))
@@ -466,15 +466,15 @@ public abstract class Container
                 if (var17 != null && (var16 == null || !var16.getHasStack() || !var16.canTakeStack(par4EntityPlayer)))
                 {
                     var9 = par2 == 0 ? 0 : this.inventorySlots.size() - 1;
-                    var19 = par2 == 0 ? 1 : -1;
+                    var21 = par2 == 0 ? 1 : -1;
 
-                    for (int var21 = 0; var21 < 2; ++var21)
+                    for (int var20 = 0; var20 < 2; ++var20)
                     {
-                        for (int var23 = var9; var23 >= 0 && var23 < this.inventorySlots.size() && var17.stackSize < var17.getMaxStackSize(); var23 += var19)
+                        for (int var22 = var9; var22 >= 0 && var22 < this.inventorySlots.size() && var17.stackSize < var17.getMaxStackSize(); var22 += var21)
                         {
-                            Slot var24 = (Slot)this.inventorySlots.get(var23);
+                            Slot var24 = (Slot)this.inventorySlots.get(var22);
 
-                            if (var24.getHasStack() && func_94527_a(var24, var17, true) && var24.canTakeStack(par4EntityPlayer) && this.func_94530_a(var17, var24) && (var21 != 0 || var24.getStack().stackSize != var24.getStack().getMaxStackSize()))
+                            if (var24.getHasStack() && func_94527_a(var24, var17, true) && var24.canTakeStack(par4EntityPlayer) && this.func_94530_a(var17, var24) && (var20 != 0 || var24.getStack().stackSize != var24.getStack().getMaxStackSize()))
                             {
                                 int var14 = Math.min(var17.getMaxStackSize() - var17.stackSize, var24.getStack().stackSize);
                                 ItemStack var15 = var24.decrStackSize(var14);
@@ -588,6 +588,8 @@ public abstract class Container
     /**
      * merges provided ItemStack with the first avaliable one in the container/player inventory
      */
+    // FCMOD: Removed and replaced later
+    /*
     protected boolean mergeItemStack(ItemStack par1ItemStack, int par2, int par3, boolean par4)
     {
         boolean var5 = false;
@@ -677,6 +679,8 @@ public abstract class Container
 
         return var5;
     }
+    */
+    // END FCMOD
 
     public static int func_94529_b(int par0)
     {
@@ -763,4 +767,169 @@ public abstract class Container
             return MathHelper.floor_float(var2 * 14.0F) + (var1 > 0 ? 1 : 0);
         }
     }
+    
+    // FCMOD: Added
+    protected boolean mergeItemStack( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap, boolean bFavorHotbar )
+    {
+    	// test of specific player inv size shouldn't be necessary, but serves as a sanity check
+    	
+    	if ( bFavorHotbar && iSlotDestCap - iSlotDestFirst == 36 )
+    	{
+        	// favor the hotbar from left to right, then the main inventory, whereas vanilla
+    		// just reverses the order from last slot of hotbar to first of inv.
+    		
+        	return MergeItemStackFavoringHotbar( stackSource, iSlotDestFirst, iSlotDestCap );
+    	}
+    	else
+    	{    	
+    		return mergeItemStack( stackSource, iSlotDestFirst, iSlotDestCap );
+    	}
+    }
+    
+	protected boolean mergeItemStack( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap )
+	{
+	    boolean bMerged = false;
+	    
+	    if ( stackSource.isStackable() )
+	    {
+	    	// look for destination stacks already containing the same item type
+	    	
+		    for ( int iTempSlot = iSlotDestFirst; 
+		    	iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {
+		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    if ( stackSource.stackSize > 0 )
+	    {
+	    	// look for empty destination stacks
+	    	
+		    for ( int iTempSlot = iSlotDestFirst; 
+	    		iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {	
+		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    return bMerged;
+	}
+    
+	protected boolean MergeItemStackFavoringHotbar( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap )
+	{
+	    boolean bMerged = false;
+
+	    if ( stackSource.isStackable() )
+	    {
+	    	// look for destination stacks already containing the same item type
+	    	
+		    for ( int iTempSlot = iSlotDestCap - 9; 
+		    	iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {
+		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
+	        }
+		    
+		    for ( int iTempSlot = iSlotDestFirst; 
+	    		iTempSlot < iSlotDestCap - 9 && stackSource.stackSize > 0; iTempSlot++ )
+		    {
+		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    if ( stackSource.stackSize > 0 )
+	    {
+	    	// look for empty destination stacks
+	    	
+		    for ( int iTempSlot = iSlotDestCap - 9; 
+	    		iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {	
+		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
+	        }
+	    	
+		    for ( int iTempSlot = iSlotDestFirst; 
+    			iTempSlot < iSlotDestCap - 9 && stackSource.stackSize > 0; iTempSlot++ )
+	        {	
+		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    return bMerged;
+	}
+    
+    protected boolean AttemptToMergeWithSlot( ItemStack stackSource, int iTempSlot )
+    {
+        Slot tempDestSlot = (Slot)inventorySlots.get( iTempSlot );
+        ItemStack tempDestStack = tempDestSlot.getStack();
+
+        if ( tempDestStack != null && tempDestStack.itemID == stackSource.itemID && 
+        	( !stackSource.getHasSubtypes() || 
+    		stackSource.getItemDamage() == tempDestStack.getItemDamage() ) && 
+    		ItemStack.areItemStackTagsEqual( stackSource, tempDestStack ) )
+        {
+            int iDestStackSize = tempDestStack.stackSize + stackSource.stackSize;
+            int iMaxStackSize = stackSource.getMaxStackSize();
+            
+            if ( tempDestSlot.getSlotStackLimit() < iMaxStackSize )
+            {
+            	iMaxStackSize = tempDestSlot.getSlotStackLimit();
+            }
+
+            if ( tempDestStack.stackSize < iMaxStackSize )
+            {
+                if ( iDestStackSize <= iMaxStackSize )
+                {
+                    stackSource.stackSize = 0;
+                    tempDestStack.stackSize = iDestStackSize;
+                }
+                else
+                {
+                    stackSource.stackSize -= iMaxStackSize - tempDestStack.stackSize;
+                    tempDestStack.stackSize = iMaxStackSize;
+                }
+                
+                tempDestSlot.onSlotChanged();
+                
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    protected boolean AttemptToMergeWithSlotIfEmpty( ItemStack stackSource, int iTempSlot )
+    {
+    	boolean bReturnValue = false;
+    	
+        Slot tempDestSlot = (Slot)inventorySlots.get(iTempSlot);
+        ItemStack tempDestStack = tempDestSlot.getStack();
+
+        if ( tempDestStack == null )
+        {
+            int iMaxStackSize = stackSource.getMaxStackSize();
+            
+            if ( tempDestSlot.getSlotStackLimit() < iMaxStackSize )
+            {
+            	iMaxStackSize = tempDestSlot.getSlotStackLimit();
+            }
+
+            if ( stackSource.stackSize <= iMaxStackSize )
+            {
+                tempDestSlot.putStack( stackSource.copy() );
+                stackSource.stackSize = 0;
+            }
+            else
+            {
+                tempDestSlot.putStack( stackSource.copy() );
+                stackSource.stackSize -= iMaxStackSize;
+                tempDestSlot.getStack().stackSize = iMaxStackSize;
+            }
+            
+            tempDestSlot.onSlotChanged();
+            
+            return true;
+        }
+        
+        return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ContainerBrewingStand.java b/minecraft/net/minecraft/src/ContainerBrewingStand.java
index 59d050c..198c0a5 100644
--- a/minecraft/net/minecraft/src/ContainerBrewingStand.java
+++ b/minecraft/net/minecraft/src/ContainerBrewingStand.java
@@ -113,7 +113,10 @@ public class ContainerBrewingStand extends Container
                         return null;
                     }
                 }
-                else if (!this.mergeItemStack(var5, 4, 40, false))
+                // FCMOD: Change to give priority to player hotbar
+                //else if (!this.mergeItemStack(var5, 4, 40, false))
+                else if (!this.mergeItemStack(var5, 4, 40, true))
+            	// END FCMOD
                 {
                     return null;
                 }
diff --git a/minecraft/net/minecraft/src/ContainerEnchantment.java b/minecraft/net/minecraft/src/ContainerEnchantment.java
index b343b7d..8f2b127 100644
--- a/minecraft/net/minecraft/src/ContainerEnchantment.java
+++ b/minecraft/net/minecraft/src/ContainerEnchantment.java
@@ -202,6 +202,10 @@ public class ContainerEnchantment extends Container
                     }
 
                     this.onCraftMatrixChanged(this.tableInventory);
+
+                    // FCMOD: Code added
+                    worldPointer.playSoundAtEntity( par1EntityPlayer, "random.levelup", 0.25F, worldPointer.rand.nextFloat() * 0.1F + 0.5F );
+                    // END FCMOD
                 }
             }
 
diff --git a/minecraft/net/minecraft/src/ContainerMerchant.java b/minecraft/net/minecraft/src/ContainerMerchant.java
index 4e37fde..6d55ff1 100644
--- a/minecraft/net/minecraft/src/ContainerMerchant.java
+++ b/minecraft/net/minecraft/src/ContainerMerchant.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
+
 public class ContainerMerchant extends Container
 {
     /** Instance of Merchant. */
@@ -14,22 +16,42 @@ public class ContainerMerchant extends Container
         this.theMerchant = par2IMerchant;
         this.theWorld = par3World;
         this.merchantInventory = new InventoryMerchant(par1InventoryPlayer.player, par2IMerchant);
+    	// FCMOD: Changed y offset of GUI
+    	/*
         this.addSlotToContainer(new Slot(this.merchantInventory, 0, 36, 53));
         this.addSlotToContainer(new Slot(this.merchantInventory, 1, 62, 53));
         this.addSlotToContainer(new SlotMerchantResult(par1InventoryPlayer.player, par2IMerchant, this.merchantInventory, 2, 120, 53));
+        */
+        this.addSlotToContainer(new Slot(this.merchantInventory, 0, 36, 119));
+        this.addSlotToContainer(new Slot(this.merchantInventory, 1, 62, 119));
+        this.addSlotToContainer(new SlotMerchantResult(par1InventoryPlayer.player, par2IMerchant, this.merchantInventory, 2, 120, 119));
+        // END FCMOD
         int var4;
 
         for (var4 = 0; var4 < 3; ++var4)
         {
             for (int var5 = 0; var5 < 9; ++var5)
             {
+            	// FCMOD: Changing y offset of GUI
+            	/*
                 this.addSlotToContainer(new Slot(par1InventoryPlayer, var5 + var4 * 9 + 9, 8 + var5 * 18, 84 + var4 * 18));
+                */
+                this.addSlotToContainer(new Slot(par1InventoryPlayer, 
+                	var5 + var4 * 9 + 9, 
+                	8 + var5 * 18, 
+                	157 + var4 * 18));
+            	// END FCMOD
             }
         }
 
         for (var4 = 0; var4 < 9; ++var4)
         {
+        	// FCMOD: Changing y offset of GUI
+        	/*
             this.addSlotToContainer(new Slot(par1InventoryPlayer, var4, 8 + var4 * 18, 142));
+            */
+            this.addSlotToContainer(new Slot(par1InventoryPlayer, var4, 8 + var4 * 18, 215));
+        	// END FCMOD
         }
     }
 
@@ -41,6 +63,10 @@ public class ContainerMerchant extends Container
     public void addCraftingToCrafters(ICrafting par1ICrafting)
     {
         super.addCraftingToCrafters(par1ICrafting);
+        
+        // FCMOD: Added (Note that uses different function name on client and server)
+        OnCrafterAdded( par1ICrafting );
+        // END FCMOD
     }
 
     /**
@@ -49,8 +75,12 @@ public class ContainerMerchant extends Container
     public void detectAndSendChanges()
     {
         super.detectAndSendChanges();
+        
+        // FCMOD: Added        
+        DetectAndSendChangesToBTSMTradeVariables();
+        // END FCMOD
     }
-
+    
     /**
      * Callback for when the crafting matrix is changed.
      */
@@ -65,7 +95,11 @@ public class ContainerMerchant extends Container
         this.merchantInventory.setCurrentRecipeIndex(par1);
     }
 
+    // FCMOD: Code removed and replaced by mod functionality later (client only)
+    /*
     public void updateProgressBar(int par1, int par2) {}
+    */
+    // END FCMOD
 
     public boolean canInteractWith(EntityPlayer par1EntityPlayer)
     {
@@ -75,62 +109,86 @@ public class ContainerMerchant extends Container
     /**
      * Called when a player shift-clicks on a slot. You must override this or you will crash when someone does that.
      */
-    public ItemStack transferStackInSlot(EntityPlayer par1EntityPlayer, int par2)
+    public ItemStack transferStackInSlot(EntityPlayer player, int slotNum)
     {
-        ItemStack var3 = null;
-        Slot var4 = (Slot)this.inventorySlots.get(par2);
+        ItemStack stackCopy = null;
+        Slot slot = (Slot)this.inventorySlots.get(slotNum);
 
-        if (var4 != null && var4.getHasStack())
+        if (slot != null && slot.getHasStack())
         {
-            ItemStack var5 = var4.getStack();
-            var3 = var5.copy();
+            ItemStack stack = slot.getStack();
+            stackCopy = stack.copy();
 
-            if (par2 == 2)
+            if (slotNum == 2)
             {
-                if (!this.mergeItemStack(var5, 3, 39, true))
+            	// FCMOD: Code added to abort trade if it's used up
+            	if ( merchantInventory.getCurrentRecipe().func_82784_g() )
+            	{
+                    slot.putStack((ItemStack)null);
+
+            		return null;
+            	}
+            	// END FCMOD
+            	
+                if (!this.mergeItemStack(stack, 3, 39, true))
                 {
                     return null;
                 }
 
-                var4.onSlotChange(var5, var3);
+                slot.onSlotChange(stack, stackCopy);
             }
-            else if (par2 != 0 && par2 != 1)
+            else if (slotNum != 0 && slotNum != 1)
             {
-                if (par2 >= 3 && par2 < 30)
+                if (slotNum >= 3 && slotNum < 30)
                 {
+                	// FCMOD: Changed to allow shift-click transfer to merchant slots
+                	/*
                     if (!this.mergeItemStack(var5, 30, 39, false))
+                	*/
+                    if (!this.mergeItemStack(stack, 0, 2, false))
+                	// END FCMOD
                     {
                         return null;
                     }
                 }
+                // FCMOD: Changed to allow shift-click transfer to merchant slots
+                /*
                 else if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(var5, 3, 30, false))
+                */
+                else if (slotNum >= 30 && slotNum < 39 && !this.mergeItemStack(stack, 0, 2, false))
+            	// END FCMOD
                 {
                     return null;
                 }
             }
+        	// FCMOD: Changed to prioritize player hotbar
+        	/*
             else if (!this.mergeItemStack(var5, 3, 39, false))
+            */
+            else if (!this.mergeItemStack(stack, 3, 39, true))
+        	// END FCMOD
             {
                 return null;
             }
 
-            if (var5.stackSize == 0)
+            if (stack.stackSize == 0)
             {
-                var4.putStack((ItemStack)null);
+                slot.putStack((ItemStack)null);
             }
             else
             {
-                var4.onSlotChanged();
+                slot.onSlotChanged();
             }
 
-            if (var5.stackSize == var3.stackSize)
+            if (stack.stackSize == stackCopy.stackSize)
             {
                 return null;
             }
 
-            var4.onPickupFromSlot(par1EntityPlayer, var5);
+            slot.onPickupFromSlot(player, stack);
         }
 
-        return var3;
+        return stackCopy;
     }
 
     /**
@@ -159,4 +217,78 @@ public class ContainerMerchant extends Container
             }
         }
     }
+    
+    // FCMOD: Added
+    public int m_iAssociatedVillagerTradeLevel = 0;
+    public int m_iAssociatedVillagerTradeXP = 0;
+    public int m_iAssociatedVillagerTradeMaxXP = 0;
+    
+    private void DetectAndSendChangesToBTSMTradeVariables()
+    {
+        int iCurrentTradeLevel = theMerchant.GetCurrentTradeLevel();
+        
+        if ( iCurrentTradeLevel != m_iAssociatedVillagerTradeLevel )
+        {
+        	SendProgressBarUpdateToAllCrafters( 0, iCurrentTradeLevel );
+        	
+        	m_iAssociatedVillagerTradeLevel = iCurrentTradeLevel;        	
+        }
+        
+        int iCurrentTradeXP = theMerchant.GetCurrentTradeXP();
+        
+        if ( iCurrentTradeXP != m_iAssociatedVillagerTradeXP )
+        {
+        	SendProgressBarUpdateToAllCrafters( 1, iCurrentTradeXP );
+        	
+        	m_iAssociatedVillagerTradeXP = iCurrentTradeXP;         	
+        }
+        
+        int iCurrentTradeMaxXP = theMerchant.GetCurrentTradeMaxXP();
+        
+        if ( iCurrentTradeMaxXP != m_iAssociatedVillagerTradeMaxXP )
+        {
+        	SendProgressBarUpdateToAllCrafters( 2, iCurrentTradeMaxXP );
+        	
+        	m_iAssociatedVillagerTradeMaxXP = iCurrentTradeMaxXP;         	
+        }
+    }
+    
+    public void SendProgressBarUpdateToAllCrafters( int iVariableIndex, int iValue )
+    {
+        Iterator iterator = crafters.iterator();
+
+        while( iterator.hasNext() )
+        {
+            ICrafting icrafting = (ICrafting)iterator.next();
+
+            icrafting.sendProgressBarUpdate( this, iVariableIndex, iValue );
+        }
+    }
+    
+    public void OnCrafterAdded( ICrafting crafter )
+    {
+        crafter.sendProgressBarUpdate( this, 0, m_iAssociatedVillagerTradeLevel );
+        crafter.sendProgressBarUpdate( this, 1, m_iAssociatedVillagerTradeXP );
+        crafter.sendProgressBarUpdate( this, 2, m_iAssociatedVillagerTradeMaxXP );
+    }
+    
+	//----------- Client Side Functionality -----------//
+	
+	@Override
+    public void updateProgressBar( int iVariableIndex, int iValue )
+    {
+        if ( iVariableIndex == 0 )
+        {
+        	m_iAssociatedVillagerTradeLevel = iValue;
+        }
+        else if ( iVariableIndex == 1 )
+        {
+            m_iAssociatedVillagerTradeXP = iValue;
+        }
+        else if ( iVariableIndex == 2 )
+        {
+            m_iAssociatedVillagerTradeMaxXP = iValue;
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ContainerWorkbench.java b/minecraft/net/minecraft/src/ContainerWorkbench.java
index a1d0ca5..b3d97d9 100644
--- a/minecraft/net/minecraft/src/ContainerWorkbench.java
+++ b/minecraft/net/minecraft/src/ContainerWorkbench.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 08/09/2018
+
 package net.minecraft.src;
 
 public class ContainerWorkbench extends Container
diff --git a/minecraft/net/minecraft/src/CraftingManager.java b/minecraft/net/minecraft/src/CraftingManager.java
index b1ead1c..0e6ccff 100644
--- a/minecraft/net/minecraft/src/CraftingManager.java
+++ b/minecraft/net/minecraft/src/CraftingManager.java
@@ -1,5 +1,9 @@
 package net.minecraft.src;
 
+// FCMOD: Added client only
+import java.lang.reflect.Constructor;
+// END FCMOD
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -32,7 +36,9 @@ public class CraftingManager
         (new RecipesDyes()).addRecipes(this);
         this.recipes.add(new RecipesArmorDyes());
         this.recipes.add(new RecipesMapCloning());
-        this.recipes.add(new RecipesMapExtending());
+        // FCMOD: Removed
+        //this.recipes.add(new RecipesMapExtending());
+        // END FCMOD
         this.recipes.add(new RecipeFireworks());
         this.addRecipe(new ItemStack(Item.paper, 3), new Object[] {"###", '#', Item.reed});
         this.addShapelessRecipe(new ItemStack(Item.book, 1), new Object[] {Item.paper, Item.paper, Item.paper, Item.leather});
@@ -179,25 +185,25 @@ public class CraftingManager
         for (var12 = new HashMap(); var4 < par2ArrayOfObj.length; var4 += 2)
         {
             Character var13 = (Character)par2ArrayOfObj[var4];
-            ItemStack var15 = null;
+            ItemStack var14 = null;
 
             if (par2ArrayOfObj[var4 + 1] instanceof Item)
             {
-                var15 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
+                var14 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
             }
             else if (par2ArrayOfObj[var4 + 1] instanceof Block)
             {
-                var15 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
+                var14 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
             }
             else if (par2ArrayOfObj[var4 + 1] instanceof ItemStack)
             {
-                var15 = (ItemStack)par2ArrayOfObj[var4 + 1];
+                var14 = (ItemStack)par2ArrayOfObj[var4 + 1];
             }
 
-            var12.put(var13, var15);
+            var12.put(var13, var14);
         }
 
-        ItemStack[] var14 = new ItemStack[var5 * var6];
+        ItemStack[] var15 = new ItemStack[var5 * var6];
 
         for (int var16 = 0; var16 < var5 * var6; ++var16)
         {
@@ -205,20 +211,27 @@ public class CraftingManager
 
             if (var12.containsKey(Character.valueOf(var10)))
             {
-                var14[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
+                var15[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
             }
             else
             {
-                var14[var16] = null;
+                var15[var16] = null;
             }
         }
 
-        ShapedRecipes var17 = new ShapedRecipes(var5, var6, var14, par1ItemStack);
+        ShapedRecipes var17 = new ShapedRecipes(var5, var6, var15, par1ItemStack);
         this.recipes.add(var17);
         return var17;
     }
 
     void addShapelessRecipe(ItemStack par1ItemStack, Object ... par2ArrayOfObj)
+    // FCMOD: Added
+    {
+    	AddShapelessRecipe( par1ItemStack, par2ArrayOfObj );
+    }
+    
+    ShapelessRecipes AddShapelessRecipe(ItemStack par1ItemStack, Object ... par2ArrayOfObj)
+    // END FCMOD
     {
         ArrayList var3 = new ArrayList();
         Object[] var4 = par2ArrayOfObj;
@@ -247,9 +260,18 @@ public class CraftingManager
             }
         }
 
-        this.recipes.add(new ShapelessRecipes(par1ItemStack, var3));
+        // FCMOD: Changed        
+        //this.recipes.add(new ShapelessRecipes(par1ItemStack, var3));
+        ShapelessRecipes recipe = new ShapelessRecipes( par1ItemStack, var3 );
+        
+        recipes.add( recipe );
+        
+        return recipe;
+        // END FCMOD
     }
 
+    // FCMOD: Removed and replaced
+    /*
     public ItemStack findMatchingRecipe(InventoryCrafting par1InventoryCrafting, World par2World)
     {
         int var3 = 0;
@@ -307,6 +329,8 @@ public class CraftingManager
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * returns the List<> of all recipes
@@ -315,4 +339,278 @@ public class CraftingManager
     {
         return this.recipes;
     }
+    
+    // FCMOD: Added
+    public ItemStack findMatchingRecipe( InventoryCrafting inventory, World world )
+    {
+    	IRecipe recipe = FindMatchingRecipe( inventory, world );
+    	ItemStack outputStack = null;
+    	
+    	if ( recipe != null )
+    	{
+    		outputStack = recipe.getCraftingResult( inventory );
+    	}
+    	
+    	return outputStack;
+    }
+    
+    public IRecipe FindMatchingRecipe( InventoryCrafting inventory, World world )
+    {
+        for ( int iTempIndex = 0; iTempIndex < this.recipes.size(); ++iTempIndex)
+        {
+            IRecipe tempRecipe = (IRecipe)this.recipes.get(iTempIndex);
+
+            if ( tempRecipe.matches( inventory, world ) )
+            {
+                return tempRecipe;
+            }
+        }
+
+        return null;
+    }
+    
+    public boolean RemoveRecipe( ItemStack itemStack, Object recipeArray[] )
+    {
+    	ShapedRecipes recipe = CreateRecipe( itemStack, recipeArray );
+    	
+    	int iMatchingIndex = GetMatchingRecipeIndex( recipe );
+    	
+    	if ( iMatchingIndex >= 0 )
+    	{
+    		recipes.remove( iMatchingIndex );
+    		
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    
+    public boolean RemoveShapelessRecipe( ItemStack itemStack, Object recipeArray[] )
+    {
+    	ShapelessRecipes recipe = CreateShapelessRecipe( itemStack, recipeArray );
+    	
+    	int iMatchingIndex = GetMatchingRecipeIndex( recipe );
+    	
+    	if ( iMatchingIndex >= 0 )
+    	{
+    		recipes.remove( iMatchingIndex );
+    		
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    
+    private int GetMatchingRecipeIndex( IRecipe recipe )
+    {
+    	int iMatchingRecipeIndex = -1;
+    	
+        for ( int iIndex = 0; iIndex < recipes.size(); iIndex++ )
+        {
+            IRecipe tempRecipe = (IRecipe)(recipes.get( iIndex ));
+
+            if ( tempRecipe.matches( recipe ) )
+            {
+                return iIndex;
+            }            
+        }
+
+    	return -1;
+    }
+    
+    private ShapedRecipes CreateRecipe( ItemStack par1ItemStack, Object par2ArrayOfObj[] )
+    {
+        String s = "";
+        int i = 0;
+        int j = 0;
+        int k = 0;
+
+        if (par2ArrayOfObj[i] instanceof String[])
+        {
+            String as[] = (String[])par2ArrayOfObj[i++];
+            String as1[] = as;
+            int l = as1.length;
+
+            for (int j1 = 0; j1 < l; j1++)
+            {
+                String s2 = as1[j1];
+                String s3 = s2;
+                k++;
+                j = s3.length();
+                s = (new StringBuilder()).append(s).append(s3).toString();
+            }
+        }
+        else
+        {
+            while (par2ArrayOfObj[i] instanceof String)
+            {
+                String s1 = (String)par2ArrayOfObj[i++];
+                k++;
+                j = s1.length();
+                s = (new StringBuilder()).append(s).append(s1).toString();
+            }
+        }
+
+        HashMap hashmap = new HashMap();
+
+        for (; i < par2ArrayOfObj.length; i += 2)
+        {
+            Character character = (Character)par2ArrayOfObj[i];
+            ItemStack itemstack = null;
+
+            if (par2ArrayOfObj[i + 1] instanceof Item)
+            {
+                itemstack = new ItemStack((Item)par2ArrayOfObj[i + 1]);
+            }
+            else if (par2ArrayOfObj[i + 1] instanceof Block)
+            {
+                itemstack = new ItemStack((Block)par2ArrayOfObj[i + 1], 1, FCUtilsInventory.m_iIgnoreMetadata);
+            }
+            else if (par2ArrayOfObj[i + 1] instanceof ItemStack)
+            {
+                itemstack = (ItemStack)par2ArrayOfObj[i + 1];
+            }
+
+            hashmap.put(character, itemstack);
+        }
+
+        ItemStack aitemstack[] = new ItemStack[j * k];
+
+        for (int i1 = 0; i1 < j * k; i1++)
+        {
+            char c = s.charAt(i1);
+
+            if (hashmap.containsKey(Character.valueOf(c)))
+            {
+                aitemstack[i1] = ((ItemStack)hashmap.get(Character.valueOf(c))).copy();
+            }
+            else
+            {
+                aitemstack[i1] = null;
+            }
+        }
+
+        return new ShapedRecipes(j, k, aitemstack, par1ItemStack );
+    }
+    
+    private ShapelessRecipes CreateShapelessRecipe(ItemStack par1ItemStack, Object par2ArrayOfObj[])
+    {
+        ArrayList arraylist = new ArrayList();
+        Object aobj[] = par2ArrayOfObj;
+        int i = aobj.length;
+
+        for (int j = 0; j < i; j++)
+        {
+            Object obj = aobj[j];
+
+            if (obj instanceof ItemStack)
+            {
+                arraylist.add(((ItemStack)obj).copy());
+                continue;
+            }
+
+            if (obj instanceof Item)
+            {
+                arraylist.add(new ItemStack((Item)obj));
+                continue;
+            }
+
+            if (obj instanceof Block)
+            {
+                arraylist.add(new ItemStack((Block)obj));
+            }
+            else
+            {
+                throw new RuntimeException("Invalid shapeless recipy!");
+            }
+        }
+
+        return new ShapelessRecipes( par1ItemStack, arraylist );
+    }
+    
+    ShapedRecipes AddShapedRecipeWithCustomClass( Class<? extends ShapedRecipes> recipeClass, ItemStack par1ItemStack, Object ... par2ArrayOfObj )
+    {
+        String var3 = "";
+        int var4 = 0;
+        int var5 = 0;
+        int var6 = 0;
+
+        if (par2ArrayOfObj[var4] instanceof String[])
+        {
+            String[] var7 = (String[])((String[])par2ArrayOfObj[var4++]);
+
+            for (int var8 = 0; var8 < var7.length; ++var8)
+            {
+                String var9 = var7[var8];
+                ++var6;
+                var5 = var9.length();
+                var3 = var3 + var9;
+            }
+        }
+        else
+        {
+            while (par2ArrayOfObj[var4] instanceof String)
+            {
+                String var11 = (String)par2ArrayOfObj[var4++];
+                ++var6;
+                var5 = var11.length();
+                var3 = var3 + var11;
+            }
+        }
+
+        HashMap var12;
+
+        for (var12 = new HashMap(); var4 < par2ArrayOfObj.length; var4 += 2)
+        {
+            Character var13 = (Character)par2ArrayOfObj[var4];
+            ItemStack var14 = null;
+
+            if (par2ArrayOfObj[var4 + 1] instanceof Item)
+            {
+                var14 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
+            }
+            else if (par2ArrayOfObj[var4 + 1] instanceof Block)
+            {
+                var14 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
+            }
+            else if (par2ArrayOfObj[var4 + 1] instanceof ItemStack)
+            {
+                var14 = (ItemStack)par2ArrayOfObj[var4 + 1];
+            }
+
+            var12.put(var13, var14);
+        }
+
+        ItemStack[] var15 = new ItemStack[var5 * var6];
+
+        for (int var16 = 0; var16 < var5 * var6; ++var16)
+        {
+            char var10 = var3.charAt(var16);
+
+            if (var12.containsKey(Character.valueOf(var10)))
+            {
+                var15[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
+            }
+            else
+            {
+                var15[var16] = null;
+            }
+        }
+
+        try
+        {
+	        Constructor recipeConstructor = recipeClass.getDeclaredConstructor( new Class[] { int.class, int.class, ItemStack[].class, ItemStack.class } );
+	        
+	        ShapedRecipes recipe = (ShapedRecipes)( recipeConstructor.newInstance( var5, var6, var15, par1ItemStack) );
+	        
+	        recipes.add( recipe );
+	        
+	        return recipe;
+        }
+        catch( Exception e ) 
+        {
+	        throw new RuntimeException( "Haha...noob" );
+        }            
+    }
+    // END FCMOD   
 }
diff --git a/minecraft/net/minecraft/src/CreativeTabs.java b/minecraft/net/minecraft/src/CreativeTabs.java
index 7603f2a..86bae5e 100644
--- a/minecraft/net/minecraft/src/CreativeTabs.java
+++ b/minecraft/net/minecraft/src/CreativeTabs.java
@@ -135,6 +135,8 @@ public class CreativeTabs
 
     public void func_92116_a(List par1List, EnumEnchantmentType ... par2ArrayOfEnumEnchantmentType)
     {
+    	// FCMOD: Client only.  Code removed to disable enchanted books in creative inv
+    	/*
         Enchantment[] var3 = Enchantment.enchantmentsList;
         int var4 = var3.length;
 
@@ -160,5 +162,7 @@ public class CreativeTabs
                 }
             }
         }
+        */
+    	// END FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/DispenserBehaviorBoat.java b/minecraft/net/minecraft/src/DispenserBehaviorBoat.java
index 9c076a6..c77f74c 100644
--- a/minecraft/net/minecraft/src/DispenserBehaviorBoat.java
+++ b/minecraft/net/minecraft/src/DispenserBehaviorBoat.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorBoat extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -39,12 +41,18 @@ final class DispenserBehaviorBoat extends BehaviorDefaultDispenseItem
         par2ItemStack.splitStack(1);
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+    // FCMOD: Code removed
+    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         par1IBlockSource.getWorld().playAuxSFX(1000, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/DispenserBehaviorDye.java b/minecraft/net/minecraft/src/DispenserBehaviorDye.java
index 8a31fc2..276cb32 100644
--- a/minecraft/net/minecraft/src/DispenserBehaviorDye.java
+++ b/minecraft/net/minecraft/src/DispenserBehaviorDye.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorDye extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         if (par2ItemStack.getItemDamage() == 15)
@@ -36,10 +38,14 @@ final class DispenserBehaviorDye extends BehaviorDefaultDispenseItem
             return super.dispenseStack(par1IBlockSource, par2ItemStack);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+	// FCMOD: Code removed
+	/*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         if (this.field_96461_b)
@@ -51,4 +57,6 @@ final class DispenserBehaviorDye extends BehaviorDefaultDispenseItem
             par1IBlockSource.getWorld().playAuxSFX(1001, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/DispenserBehaviorEmptyBucket.java b/minecraft/net/minecraft/src/DispenserBehaviorEmptyBucket.java
index ecca50f..42e5843 100644
--- a/minecraft/net/minecraft/src/DispenserBehaviorEmptyBucket.java
+++ b/minecraft/net/minecraft/src/DispenserBehaviorEmptyBucket.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorEmptyBucket extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+    // FCMOD: Code removed to prevent usage
+    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -46,4 +48,6 @@ final class DispenserBehaviorEmptyBucket extends BehaviorDefaultDispenseItem
 
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/DispenserBehaviorFilledBucket.java b/minecraft/net/minecraft/src/DispenserBehaviorFilledBucket.java
index afac306..2741aec 100644
--- a/minecraft/net/minecraft/src/DispenserBehaviorFilledBucket.java
+++ b/minecraft/net/minecraft/src/DispenserBehaviorFilledBucket.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorFilledBucket extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+    // FCMOD: Code removed to prevent usage
+    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         ItemBucket var3 = (ItemBucket)par2ItemStack.getItem();
@@ -26,4 +28,6 @@ final class DispenserBehaviorFilledBucket extends BehaviorDefaultDispenseItem
             return this.defaultDispenserItemBehavior.dispense(par1IBlockSource, par2ItemStack);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/DispenserBehaviorFire.java b/minecraft/net/minecraft/src/DispenserBehaviorFire.java
index 75748a1..5aaf17e 100644
--- a/minecraft/net/minecraft/src/DispenserBehaviorFire.java
+++ b/minecraft/net/minecraft/src/DispenserBehaviorFire.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorFire extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+    // FCMOD: Code removed to prevent usage
+    /*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -36,10 +38,14 @@ final class DispenserBehaviorFire extends BehaviorDefaultDispenseItem
 
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+    // FCMOD: Code removed
+    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         if (this.field_96466_b)
@@ -51,4 +57,6 @@ final class DispenserBehaviorFire extends BehaviorDefaultDispenseItem
             par1IBlockSource.getWorld().playAuxSFX(1001, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/DispenserBehaviorTNT.java b/minecraft/net/minecraft/src/DispenserBehaviorTNT.java
index e6b0caf..c0f4e6d 100644
--- a/minecraft/net/minecraft/src/DispenserBehaviorTNT.java
+++ b/minecraft/net/minecraft/src/DispenserBehaviorTNT.java
@@ -5,6 +5,8 @@ final class DispenserBehaviorTNT extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -17,4 +19,6 @@ final class DispenserBehaviorTNT extends BehaviorDefaultDispenseItem
         --par2ItemStack.stackSize;
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EffectRenderer.java b/minecraft/net/minecraft/src/EffectRenderer.java
index 5deb440..1d24978 100644
--- a/minecraft/net/minecraft/src/EffectRenderer.java
+++ b/minecraft/net/minecraft/src/EffectRenderer.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.sky.FireworksHelper;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
@@ -9,7 +10,7 @@ public class EffectRenderer
 {
     /** Reference to the World object. */
     protected World worldObj;
-    private List[] fxLayers = new List[4];
+    private List[] fxLayers = new List[5];
     private RenderEngine renderer;
 
     /** RNG. */
@@ -24,7 +25,7 @@ public class EffectRenderer
 
         this.renderer = par2RenderEngine;
 
-        for (int var3 = 0; var3 < 4; ++var3)
+        for (int var3 = 0; var3 < 5; ++var3)
         {
             this.fxLayers[var3] = new ArrayList();
         }
@@ -32,7 +33,7 @@ public class EffectRenderer
 
     public void addEffect(EntityFX par1EntityFX)
     {
-        int var2 = par1EntityFX.getFXLayer();
+    	int var2 = FireworksHelper.getFXLayer(par1EntityFX);
 
         if (this.fxLayers[var2].size() >= 4000)
         {
@@ -44,7 +45,7 @@ public class EffectRenderer
 
     public void updateEffects()
     {
-        for (int var1 = 0; var1 < 4; ++var1)
+    	for (int var1 = 0; var1 < 5; ++var1)
         {
             for (int var2 = 0; var2 < this.fxLayers[var1].size(); ++var2)
             {
@@ -73,9 +74,9 @@ public class EffectRenderer
         EntityFX.interpPosY = par1Entity.lastTickPosY + (par1Entity.posY - par1Entity.lastTickPosY) * (double)par2;
         EntityFX.interpPosZ = par1Entity.lastTickPosZ + (par1Entity.posZ - par1Entity.lastTickPosZ) * (double)par2;
 
-        for (int var8 = 0; var8 < 3; ++var8)
+        for (int var8 = 0; var8 < 5; ++var8)
         {
-            if (!this.fxLayers[var8].isEmpty())
+        	if (!FireworksHelper.skipThisLayer(this.fxLayers[var8].isEmpty(), var8))
             {
                 switch (var8)
                 {
@@ -94,9 +95,13 @@ public class EffectRenderer
 
                 Tessellator var9 = Tessellator.instance;
                 GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+                // FCMOD: Code removed to fix annoying particle behind break cracking thing
+                /*
                 GL11.glDepthMask(false);
+                */
+                // END FCMOD
                 GL11.glEnable(GL11.GL_BLEND);
-                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                FireworksHelper.setParticleBlendMethod(var8, 0, true);
                 GL11.glAlphaFunc(GL11.GL_GREATER, 0.003921569F);
                 var9.startDrawingQuads();
 
@@ -141,7 +146,7 @@ public class EffectRenderer
     {
         this.worldObj = par1World;
 
-        for (int var2 = 0; var2 < 4; ++var2)
+        for (int var2 = 0; var2 < 5; ++var2)
         {
             this.fxLayers[var2].clear();
         }
diff --git a/minecraft/net/minecraft/src/Enchantment.java b/minecraft/net/minecraft/src/Enchantment.java
index dcf8c24..0a88fd2 100644
--- a/minecraft/net/minecraft/src/Enchantment.java
+++ b/minecraft/net/minecraft/src/Enchantment.java
@@ -198,7 +198,10 @@ public abstract class Enchantment
 
     public boolean canApply(ItemStack par1ItemStack)
     {
-        return this.type.canEnchantItem(par1ItemStack.getItem());
+    	// FCMOD: Changed
+        //return this.type.canEnchantItem(par1ItemStack.getItem());
+        return par1ItemStack.getItem().IsEnchantmentApplicable( this );
+    	// END FCMOD
     }
 
     static
@@ -219,4 +222,24 @@ public abstract class Enchantment
 
         field_92090_c = (Enchantment[])var0.toArray(new Enchantment[0]);
     }
+    
+    // FCMOD: Added New    
+    private boolean m_bCanBeAppliedByVanillaEnchanter = true;
+    
+    static
+    {
+        // remove the more powerful enchants from the vanilla enchanter
+    	
+        protection.m_bCanBeAppliedByVanillaEnchanter = false;
+        silkTouch.m_bCanBeAppliedByVanillaEnchanter = false;
+        fortune.m_bCanBeAppliedByVanillaEnchanter = false;
+        sharpness.m_bCanBeAppliedByVanillaEnchanter = false;
+        featherFalling.m_bCanBeAppliedByVanillaEnchanter = false;
+    }
+    
+    public boolean CanBeAppliedByVanillaEnchanter()
+    {
+    	return m_bCanBeAppliedByVanillaEnchanter;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EnchantmentHelper.java b/minecraft/net/minecraft/src/EnchantmentHelper.java
index 420ab1d..3601f59 100644
--- a/minecraft/net/minecraft/src/EnchantmentHelper.java
+++ b/minecraft/net/minecraft/src/EnchantmentHelper.java
@@ -254,7 +254,24 @@ public class EnchantmentHelper
      */
     public static int getFortuneModifier(EntityLiving par0EntityLiving)
     {
+    	// FCMOD: Code change
+    	/*
         return getEnchantmentLevel(Enchantment.fortune.effectId, par0EntityLiving.getHeldItem());
+        */
+    	int iEnchantmentLevel = getEnchantmentLevel(Enchantment.fortune.effectId, par0EntityLiving.getHeldItem());
+    	
+    	if ( par0EntityLiving.isPotionActive(FCBetterThanWolves.potionFortune ) )
+    	{
+        	int iPotionLevel = par0EntityLiving.getActivePotionEffect( FCBetterThanWolves.potionFortune ).getAmplifier() + 1;
+        	
+        	if ( iPotionLevel > iEnchantmentLevel )
+        	{
+        		iEnchantmentLevel = iPotionLevel;
+        	}        	
+    	}
+    	
+    	return iEnchantmentLevel;
+    	// END FCMOD
     }
 
     /**
@@ -262,7 +279,24 @@ public class EnchantmentHelper
      */
     public static int getLootingModifier(EntityLiving par0EntityLiving)
     {
+    	// FCMOD: Code change
+    	/*
         return getEnchantmentLevel(Enchantment.looting.effectId, par0EntityLiving.getHeldItem());
+        */
+    	int iEnchantmentLevel = getEnchantmentLevel(Enchantment.looting.effectId, par0EntityLiving.getHeldItem());
+    	
+    	if ( par0EntityLiving.isPotionActive(FCBetterThanWolves.potionLooting ) )
+    	{
+        	int iPotionLevel = par0EntityLiving.getActivePotionEffect( FCBetterThanWolves.potionLooting ).getAmplifier() + 1;
+        	
+        	if ( iPotionLevel > iEnchantmentLevel )
+        	{
+        		iEnchantmentLevel = iPotionLevel;
+        	}        	
+    	}
+    	
+    	return iEnchantmentLevel;
+    	// END FCMOD
     }
 
     /**
@@ -300,6 +334,8 @@ public class EnchantmentHelper
      * Returns the enchantability of itemstack, it's uses a singular formula for each index (2nd parameter: 0, 1 and 2),
      * cutting to the max enchantability power of the table (3rd parameter)
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public static int calcItemStackEnchantability(Random par0Random, int par1, int par2, ItemStack par3ItemStack)
     {
         Item var4 = par3ItemStack.getItem();
@@ -320,6 +356,8 @@ public class EnchantmentHelper
             return par1 == 0 ? Math.max(var6 / 3, 1) : (par1 == 1 ? var6 * 2 / 3 + 1 : Math.max(var6, par2 * 2));
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Adds a random enchantment to the specified item. Args: random, itemStack, enchantabilityLevel
@@ -456,8 +494,18 @@ public class EnchantmentHelper
         {
             Enchantment var8 = var5[var7];
 
-            if (var8 != null && (var8.type.canEnchantItem(var2) || var4))
+        	// FCMOD: Changed
+            //if (var8 != null && (var8.type.canEnchantItem(var2) || var4))
+            if ( var8 != null && (var2.IsEnchantmentApplicable( var8 ) || var4))
+        	// END FCMOD
             {
+            	// FCMOD: Added to prevent certain enchants from vanilla enchanter
+            	if ( !var8.CanBeAppliedByVanillaEnchanter() )
+            	{
+            		continue;
+            	}
+            	// END FCMOD
+            	
                 for (int var9 = var8.getMinLevel(); var9 <= var8.getMaxLevel(); ++var9)
                 {
                     if (par0 >= var8.getMinEnchantability(var9) && par0 <= var8.getMaxEnchantability(var9))
@@ -475,4 +523,56 @@ public class EnchantmentHelper
 
         return var3;
     }
+    
+    // FCMOD: Code added
+    public static int calcItemStackEnchantability( Random rand, int iTableSlotNum, int iNumBookShelves, ItemStack stack )
+    {
+    	// Replace vanilla code to double amount of bookshelves required, cap enchant level at 15, and make enchant with no shelves be level 1
+    	
+        Item item = stack.getItem();
+        int iItemEnchantability = item.getItemEnchantability();
+
+        if (iItemEnchantability <= 0)
+        {
+            return 0;
+        }
+        else
+        {
+            int iEnchantmentLevel = 1;
+            
+            if ( iTableSlotNum != 0 )
+            {
+                int iMaxEnchantmentLevel = iNumBookShelves >> 1;
+                    
+                if ( iMaxEnchantmentLevel <= 0 )
+                {
+                	iMaxEnchantmentLevel = 1;
+                }
+                else if ( iMaxEnchantmentLevel > 15 )
+                {
+                	iMaxEnchantmentLevel = 15;
+                }
+                	
+            	if ( iTableSlotNum == 1 )
+            	{
+            		if ( iMaxEnchantmentLevel > 1 )
+            		{
+                		iEnchantmentLevel = 2;
+                		
+                		if ( iMaxEnchantmentLevel > 3 )
+                		{
+                			iEnchantmentLevel += rand.nextInt( iMaxEnchantmentLevel - 2 );
+                		}
+            		}
+            	}
+            	else
+            	{
+            		iEnchantmentLevel = iMaxEnchantmentLevel;
+            	}
+            }
+            
+            return iEnchantmentLevel;
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/Entity.java b/minecraft/net/minecraft/src/Entity.java
index d9c3b69..1f10e8e 100644
--- a/minecraft/net/minecraft/src/Entity.java
+++ b/minecraft/net/minecraft/src/Entity.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
@@ -117,6 +118,9 @@ public abstract class Entity
      * The entity's Z coordinate at the previous tick, used to calculate position during rendering routines
      */
     public double lastTickPosZ;
+    /**
+     * FCNOTE: TERRIBLE NAMING.  This is actually the position offset due to player sneaking/crouching
+     */
     public float ySize;
 
     /**
@@ -299,6 +303,9 @@ public abstract class Entity
      */
     protected void setSize(float par1, float par2)
     {
+    	// FCMOD: Code change to duplicate 1.6 fix for animals suffocating and escaping fences bug
+    	// I do not believe this is actually helping anything due to the incremental nature of the 
+    	// move plus I am now ensuring sufficient space on animal grow elsewhere in the code.
         if (par1 != this.width || par2 != this.height)
         {
             this.width = par1;
@@ -309,6 +316,27 @@ public abstract class Entity
         }
 
         float var3 = par1 % 2.0F;
+        /*
+        float var3;
+
+        if (par1 != this.width || par2 != this.height)
+        {
+            var3 = this.width;
+            this.width = par1;
+            this.height = par2;
+            this.boundingBox.maxX = this.boundingBox.minX + (double)this.width;
+            this.boundingBox.maxZ = this.boundingBox.minZ + (double)this.width;
+            this.boundingBox.maxY = this.boundingBox.minY + (double)this.height;
+
+            if (this.width > var3 && !this.firstUpdate && !this.worldObj.isRemote)
+            {
+                this.moveEntity((double)(var3 - this.width), 0.0D, (double)(var3 - this.width));
+            }
+        }
+
+        var3 = par1 % 2.0F;    	
+        */
+        // END FCMOD
 
         if ((double)var3 < 0.375D)
         {
@@ -588,6 +616,8 @@ public abstract class Entity
     /**
      * Tries to moves the entity by the passed in displacement. Args: x, y, z
      */
+    // FCMOD: Removed and replaced
+    /*
     public void moveEntity(double par1, double par3, double par5)
     {
         if (this.noClip)
@@ -691,11 +721,11 @@ public abstract class Entity
                 }
             }
 
-            List var34 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(par1, par3, par5));
+            List var35 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(par1, par3, par5));
 
-            for (int var22 = 0; var22 < var34.size(); ++var22)
+            for (int var22 = 0; var22 < var35.size(); ++var22)
             {
-                par3 = ((AxisAlignedBB)var34.get(var22)).calculateYOffset(this.boundingBox, par3);
+                par3 = ((AxisAlignedBB)var35.get(var22)).calculateYOffset(this.boundingBox, par3);
             }
 
             this.boundingBox.offset(0.0D, par3, 0.0D);
@@ -707,12 +737,12 @@ public abstract class Entity
                 par1 = 0.0D;
             }
 
-            boolean var35 = this.onGround || var15 != par3 && var15 < 0.0D;
+            boolean var34 = this.onGround || var15 != par3 && var15 < 0.0D;
             int var23;
 
-            for (var23 = 0; var23 < var34.size(); ++var23)
+            for (var23 = 0; var23 < var35.size(); ++var23)
             {
-                par1 = ((AxisAlignedBB)var34.get(var23)).calculateXOffset(this.boundingBox, par1);
+                par1 = ((AxisAlignedBB)var35.get(var23)).calculateXOffset(this.boundingBox, par1);
             }
 
             this.boundingBox.offset(par1, 0.0D, 0.0D);
@@ -724,9 +754,9 @@ public abstract class Entity
                 par1 = 0.0D;
             }
 
-            for (var23 = 0; var23 < var34.size(); ++var23)
+            for (var23 = 0; var23 < var35.size(); ++var23)
             {
-                par5 = ((AxisAlignedBB)var34.get(var23)).calculateZOffset(this.boundingBox, par5);
+                par5 = ((AxisAlignedBB)var35.get(var23)).calculateZOffset(this.boundingBox, par5);
             }
 
             this.boundingBox.offset(0.0D, 0.0D, par5);
@@ -743,7 +773,7 @@ public abstract class Entity
             int var30;
             double var36;
 
-            if (this.stepHeight > 0.0F && var35 && (var20 || this.ySize < 0.05F) && (var13 != par1 || var17 != par5))
+            if (this.stepHeight > 0.0F && var34 && (var20 || this.ySize < 0.05F) && (var13 != par1 || var17 != par5))
             {
                 var36 = par1;
                 var25 = par3;
@@ -753,11 +783,11 @@ public abstract class Entity
                 par5 = var17;
                 AxisAlignedBB var29 = this.boundingBox.copy();
                 this.boundingBox.setBB(var19);
-                var34 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(var13, par3, var17));
+                var35 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(var13, par3, var17));
 
-                for (var30 = 0; var30 < var34.size(); ++var30)
+                for (var30 = 0; var30 < var35.size(); ++var30)
                 {
-                    par3 = ((AxisAlignedBB)var34.get(var30)).calculateYOffset(this.boundingBox, par3);
+                    par3 = ((AxisAlignedBB)var35.get(var30)).calculateYOffset(this.boundingBox, par3);
                 }
 
                 this.boundingBox.offset(0.0D, par3, 0.0D);
@@ -769,9 +799,9 @@ public abstract class Entity
                     par1 = 0.0D;
                 }
 
-                for (var30 = 0; var30 < var34.size(); ++var30)
+                for (var30 = 0; var30 < var35.size(); ++var30)
                 {
-                    par1 = ((AxisAlignedBB)var34.get(var30)).calculateXOffset(this.boundingBox, par1);
+                    par1 = ((AxisAlignedBB)var35.get(var30)).calculateXOffset(this.boundingBox, par1);
                 }
 
                 this.boundingBox.offset(par1, 0.0D, 0.0D);
@@ -783,9 +813,9 @@ public abstract class Entity
                     par1 = 0.0D;
                 }
 
-                for (var30 = 0; var30 < var34.size(); ++var30)
+                for (var30 = 0; var30 < var35.size(); ++var30)
                 {
-                    par5 = ((AxisAlignedBB)var34.get(var30)).calculateZOffset(this.boundingBox, par5);
+                    par5 = ((AxisAlignedBB)var35.get(var30)).calculateZOffset(this.boundingBox, par5);
                 }
 
                 this.boundingBox.offset(0.0D, 0.0D, par5);
@@ -807,9 +837,9 @@ public abstract class Entity
                 {
                     par3 = (double)(-this.stepHeight);
 
-                    for (var30 = 0; var30 < var34.size(); ++var30)
+                    for (var30 = 0; var30 < var35.size(); ++var30)
                     {
-                        par3 = ((AxisAlignedBB)var34.get(var30)).calculateYOffset(this.boundingBox, par3);
+                        par3 = ((AxisAlignedBB)var35.get(var30)).calculateYOffset(this.boundingBox, par3);
                     }
 
                     this.boundingBox.offset(0.0D, par3, 0.0D);
@@ -860,7 +890,7 @@ public abstract class Entity
                 var30 = MathHelper.floor_double(this.posY - 0.20000000298023224D - (double)this.yOffset);
                 int var31 = MathHelper.floor_double(this.posZ);
                 int var32 = this.worldObj.getBlockId(var37, var30, var31);
-
+                
                 if (var32 == 0)
                 {
                     int var33 = this.worldObj.blockGetRenderType(var37, var30 - 1, var31);
@@ -931,6 +961,8 @@ public abstract class Entity
             this.worldObj.theProfiler.endSection();
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Checks for block collisions, and calls the associated onBlockCollided method for the collided block.
@@ -969,13 +1001,28 @@ public abstract class Entity
      */
     protected void playStepSound(int par1, int par2, int par3, int par4)
     {
+    	// FCMOD: Changed
+    	/*
         StepSound var5 = Block.blocksList[par4].stepSound;
-
+        
         if (this.worldObj.getBlockId(par1, par2 + 1, par3) == Block.snow.blockID)
         {
             var5 = Block.snow.stepSound;
             this.playSound(var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch());
         }
+        */
+        StepSound var5 = Block.blocksList[par4].GetStepSound( worldObj, par1, par2, par3 );
+        
+        int iBlockAboveID = worldObj.getBlockId( par1, par2 + 1, par3 );
+        Block blockAbove = Block.blocksList[iBlockAboveID];
+        
+        if ( blockAbove != null && blockAbove.IsGroundCover( ) )
+        {
+            var5 = blockAbove.stepSound;
+            
+            playSound( var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch() );
+        }
+    	// END FCMOD
         else if (!Block.blocksList[par4].blockMaterial.isLiquid())
         {
             this.playSound(var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch());
@@ -1057,7 +1104,10 @@ public abstract class Entity
      */
     public boolean isWet()
     {
-        return this.inWater || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + (double)this.height), MathHelper.floor_double(this.posZ));
+    	// FCMOD: Changed
+        //return this.inWater || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + (double)this.height), MathHelper.floor_double(this.posZ));
+        return inWater || IsBeingRainedOn();
+        // END FCMOD
     }
 
     /**
@@ -1480,6 +1530,12 @@ public abstract class Entity
         try
         {
             par1NBTTagCompound.setTag("Pos", this.newDoubleNBTList(new double[] {this.posX, this.posY + (double)this.ySize, this.posZ}));
+        	// FCMOD: Added to fix collision errors on load 
+            par1NBTTagCompound.setTag( "fcMin", newDoubleNBTList( 
+            	new double[] { boundingBox.minX, boundingBox.minY, boundingBox.minZ } ) );
+            par1NBTTagCompound.setTag( "fcMax", newDoubleNBTList(
+            	new double[] { boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ } ) );
+            // END FCMOD
             par1NBTTagCompound.setTag("Motion", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
             par1NBTTagCompound.setTag("Rotation", this.newFloatNBTList(new float[] {this.rotationYaw, this.rotationPitch}));
             par1NBTTagCompound.setFloat("FallDistance", this.fallDistance);
@@ -1515,6 +1571,8 @@ public abstract class Entity
     /**
      * Reads the entity from NBT (calls an abstract helper method to read specialized data)
      */
+    // FCMOD: Removed and replaced
+    /*
     public void readFromNBT(NBTTagCompound par1NBTTagCompound)
     {
         try
@@ -1571,6 +1629,8 @@ public abstract class Entity
             throw new ReportedException(var3);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the string that identifies this Entity's class
@@ -1842,6 +1902,7 @@ public abstract class Entity
 
     /**
      * Called when a player unounts an entity.
+     * FCNOTE: Call mountEntity( null ) for regular entities.  This searches area for solid ground, and is intended for the player.
      */
     public void unmountEntity(Entity par1Entity)
     {
@@ -2344,7 +2405,12 @@ public abstract class Entity
 
     public float func_82146_a(Explosion par1Explosion, World par2World, int par3, int par4, int par5, Block par6Block)
     {
+    	// FCMOD: Code change
+    	/*
         return par6Block.getExplosionResistance(this);
+        */
+        return par6Block.getExplosionResistance(this, par2World, par3, par4, par5);
+    	// END FCMOD
     }
 
     public boolean func_96091_a(Explosion par1Explosion, World par2World, int par3, int par4, int par5, int par6, float par7)
@@ -2400,4 +2466,709 @@ public abstract class Entity
     {
         return this.getEntityName();
     }
+
+    // FCMOD: Added New
+    public boolean IsAffectedByMovementModifiers()
+    {
+    	return true;
+    }
+    
+    public void NotifyOfWolfHowl( Entity sourceEntity )
+    {
+    }
+    
+    protected boolean ShouldSetPositionOnLoad()
+    {
+    	return true;
+    }
+    
+    public boolean CanCollideWithEntity( Entity entity )
+    {
+    	return true;
+    }
+    
+    public boolean IsItemEntity()
+    {
+    	return false;
+    }
+    
+    public boolean CanEntityTriggerTripwire()
+    {
+    	return true;
+    }
+    
+    public AxisAlignedBB GetVisualBoundingBox()
+    {
+    	return boundingBox;    	
+    }
+    
+    public boolean IsSecondaryTargetForSquid()
+    {
+    	return false;
+    }
+    
+    public boolean GetCanBeHeadCrabbed( boolean bSquidInWater )
+    {
+    	return isEntityAlive() && riddenByEntity == null && ridingEntity == null && 
+    		IsSecondaryTargetForSquid();
+    }
+    
+    public boolean IsValidOngoingAttackTargetForSquid()
+    {
+    	return IsSecondaryTargetForSquid() && isEntityAlive();
+    }
+    
+    public void OnFlungBySquidTentacle( FCEntitySquid squid )
+    {
+    }
+    
+    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
+    {
+    }
+    
+    public boolean HasHeadCrabbedSquid()
+    {
+    	return riddenByEntity != null && riddenByEntity instanceof FCEntitySquid;
+    }
+    
+    public Entity GetHeadCrabSharedAttackTarget()
+    {
+    	return null;
+    }
+    
+	public boolean IsImmuneToHeadCrabDamage()
+	{
+		return false;
+	}
+	
+    public void OnKickedByCow( FCEntityCow cow )
+	{
+    	FlingAwayFromEntity( cow, GetCowKickMovementMultiplier() );    	
+    }
+    
+    protected double GetCowKickMovementMultiplier()
+    {
+    	return 1D;
+    }
+	
+    public void FlingAwayFromEntity( Entity repulsingEntity, double dForceMultiplier )
+	{
+        if ( ridingEntity != null )
+        {
+        	mountEntity( null );
+        }
+        
+        double dVelocityX = motionX;
+        double dVelocityZ = motionZ;
+        
+		double dDeltaX = posX - repulsingEntity.posX; 
+		double dDeltaZ = posZ - repulsingEntity.posZ;
+		
+		double dFlatDistToTargetSq = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+
+		if ( dFlatDistToTargetSq > 0.1D )
+		{
+			double dFlatDistToTarget = MathHelper.sqrt_double( dFlatDistToTargetSq );
+			
+			dVelocityX += ( dDeltaX / dFlatDistToTarget ) * 0.5D * dForceMultiplier;
+			dVelocityZ += ( dDeltaZ / dFlatDistToTarget ) * 0.5F * dForceMultiplier;
+		}
+		
+		isAirBorne = true;
+
+        double dVelocityY = motionY + ( 0.25D * dForceMultiplier );
+        
+        dVelocityX *= ( rand.nextDouble() * 0.2D ) + 0.9;
+        dVelocityZ *= ( rand.nextDouble() * 0.2D ) + 0.9;
+        
+		motionX = FCUtilsMath.ClampDouble( dVelocityX, -1D, 1D );
+		motionY = FCUtilsMath.ClampDoubleTop( dVelocityY, 0.75D );
+		motionZ = FCUtilsMath.ClampDouble( dVelocityZ, -1D, 1D );
+    }
+    
+    public boolean DoesEntityApplyToSpawnCap()
+    {
+    	// by default entities do not apply to the spawn cap as this avoids a lot of unnecessary instanceof checks in World.CountEntitiesThatApplyToSpawnCap()
+    	// Note that this behavior is overriden in EntityLiving, which is where it really matters.
+    	
+    	return false;
+    }
+    
+	public void OutOfUpdateRangeUpdate()
+	{
+	}
+	
+	public boolean AppliesConstantForceWhenRidingBoat()
+	{
+		return false;
+	}
+	
+	public double MovementModifierWhenRidingBoat()
+	{
+		return 1.0D;
+	}
+	
+	/**
+	 * Returns true if this function has handled the possession transfer from the dead entity.  Called on server only.
+	 */
+	public boolean OnPossesedRidingEntityDeath()
+	{
+		return false;
+	}
+	
+    public boolean IsBeingRainedOn()
+    {
+        int i = MathHelper.floor_double( posX );
+        int j = MathHelper.floor_double( boundingBox.maxY );
+        int k = MathHelper.floor_double( posZ );
+    	
+    	return worldObj.IsRainingAtPos( i, j, k );
+    }
+    
+    public boolean DoesEntityApplyToSquidPossessionCap()
+    {
+    	return false;
+    }
+    
+    public boolean IsValidZombieSecondaryTarget( EntityZombie zombie )
+    {
+    	return false;
+    }
+
+    public boolean AttractsLightning()
+    {
+    	return false;
+    }
+    
+    public void OnStruckByLightning( FCEntityLightningBolt boltEntity )
+    {
+        dealFireDamage( 7 );
+        
+        fire++;
+
+        if ( fire == 0 )
+        {
+            setFire( 8 );
+        }
+
+        if ( !isEntityInvulnerable() )
+        {
+        	FlingAwayFromEntity( boltEntity, 2D );
+        }
+    }
+    
+    public void moveEntity( double dMoveX, double dMoveY, double dMoveZ )
+    {
+    	// replacement for vanilla function that cleans up the code for readability while retaining
+    	// same functionality.  Modifications to vanilla functionality listed as FCMOD
+    	
+    	// Note: I've elminated all references to field_70135_K as this seems to be a lingering
+    	// debug value that serves no actual purpose
+    	
+        if ( noClip )
+        {
+            boundingBox.offset( dMoveX, dMoveY, dMoveZ );
+            
+            posX = ( boundingBox.minX + boundingBox.maxX ) / 2D;
+            posY = boundingBox.minY + (double)yOffset - (double)ySize;
+            posZ = ( boundingBox.minZ + boundingBox.maxZ ) / 2D;
+            
+            return;
+        }
+        
+        worldObj.theProfiler.startSection("move");
+        ySize *= 0.4F; // This is actually the position offset due to player sneaking/crouching 
+        
+        double dOldPosX = posX;
+        double dOldPosY = posY;
+        double dOldPosZ = posZ;
+
+        AxisAlignedBB oldBoundingBox = boundingBox.copy();
+        
+        if ( isInWeb )
+        {
+            isInWeb = false;
+            
+            dMoveX *= 0.25D;
+            dMoveY *= 0.05000000074505806D;
+            dMoveZ *= 0.25D;
+            
+            motionX = 0.0D;
+            motionY = 0.0D;
+            motionZ = 0.0D;
+        }
+
+        boolean bIsSneakingPlayer = onGround && isSneaking() && this instanceof EntityPlayer;
+
+        if ( bIsSneakingPlayer )
+        {
+            double dStepSize = 0.05D;
+
+            while ( dMoveX != 0D && worldObj.getCollidingBoundingBoxes( this, 
+        		boundingBox.getOffsetBoundingBox( dMoveX, -1D, 0D ) ).isEmpty() )
+            {
+                if (dMoveX < dStepSize && dMoveX >= -dStepSize)
+                {
+                    dMoveX = 0D;
+                }
+                else if ( dMoveX > 0D )
+                {
+                    dMoveX -= dStepSize;
+                }
+                else
+                {
+                    dMoveX += dStepSize;
+                }
+            }
+
+            while ( dMoveZ != 0D && worldObj.getCollidingBoundingBoxes( this, 
+            	boundingBox.getOffsetBoundingBox( 0D, -1D, dMoveZ ) ).isEmpty() )
+            {
+                if ( dMoveZ < dStepSize && dMoveZ >= -dStepSize )
+                {
+                    dMoveZ = 0D;
+                }
+                else if ( dMoveZ > 0D )
+                {
+                    dMoveZ -= dStepSize;
+                }
+                else
+                {
+                    dMoveZ += dStepSize;
+                }
+            }
+
+            // FCNOTE: the dMoveX != 0D && dMoveZ != 0D below looks a bit weird,
+            // but it's valid as single axis collisions have already been checked above
+            while ( dMoveX != 0D && dMoveZ != 0D && worldObj.getCollidingBoundingBoxes( this, 
+            	boundingBox.getOffsetBoundingBox( dMoveX, -1D, dMoveZ ) ).isEmpty() )
+            {
+                if ( dMoveX < dStepSize && dMoveX >= -dStepSize )
+                {
+                    dMoveX = 0D;
+                }
+                else if ( dMoveX > 0D )
+                {
+                    dMoveX -= dStepSize;
+                }
+                else
+                {
+                    dMoveX += dStepSize;
+                }
+
+                if ( dMoveZ < dStepSize && dMoveZ >= -dStepSize )
+                {
+                    dMoveZ = 0D;
+                }
+                else if ( dMoveZ > 0D )
+                {
+                    dMoveZ -= dStepSize;
+                }
+                else
+                {
+                    dMoveZ += dStepSize;
+                }
+            }
+        }
+
+        double dUnboundedMoveX = dMoveX;
+        double dUnboundedMoveY = dMoveY;
+        double dUnboundedMoveZ = dMoveZ;
+        
+        // addCoord() below returns a new box expanded in the direction of the point
+        
+        // FCMOD: Changed the following bit to calculate one collision list that takes steps
+        // into account right from the start, instead of doing this whole thing a second time 
+        // when steps are checked for later
+        //List<AxisAlignedBB> moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
+        	//boundingBox.addCoord( dMoveX, dMoveY, dMoveZ ) );
+        AxisAlignedBB moveRangeBoundingBox = boundingBox.addCoord( dMoveX, dMoveY, dMoveZ );
+        
+        if ( stepHeight > dMoveY )
+        {
+        	moveRangeBoundingBox.maxY = boundingBox.maxY + stepHeight;
+        }
+        
+        List<AxisAlignedBB> moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
+        	moveRangeBoundingBox );
+        // END FCMOD
+
+        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+        {
+        	// Keep reducing the magnitude of the y movement until it is within the vertical gap
+        	// between the original position and any potentially colliding blocks
+        	
+            dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset( 
+            	boundingBox, dMoveY );
+        }
+
+        boundingBox.offset( 0D, dMoveY, 0D );
+
+        boolean bVerticallySupported = onGround || 
+        	( dUnboundedMoveY != dMoveY && dUnboundedMoveY < 0D );
+        
+        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+        {        	
+            dMoveX = moveRangeCollisionList.get( iTempIndex ).calculateXOffset( 
+            	boundingBox, dMoveX );
+        }
+
+        boundingBox.offset( dMoveX, 0D, 0D );
+
+        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+        {
+            dMoveZ = moveRangeCollisionList.get( iTempIndex ).calculateZOffset(
+            	boundingBox, dMoveZ );
+        }
+
+        boundingBox.offset( 0D, 0D, dMoveZ );
+        
+        if ( stepHeight > 0F && bVerticallySupported && 
+        	( bIsSneakingPlayer || ySize < 0.05F ) && 
+        	( dUnboundedMoveX != dMoveX || dUnboundedMoveZ != dMoveZ ) )
+        {
+            double dBoundedMoveX = dMoveX;
+            double dBoundedMoveY = dMoveY;
+            double dBoundedMoveZ = dMoveZ;
+            
+            dMoveX = dUnboundedMoveX;
+            dMoveY = stepHeight;
+            dMoveZ = dUnboundedMoveZ;
+            
+            AxisAlignedBB dBoundedMoveBox = boundingBox.copy();
+            
+            boundingBox.setBB( oldBoundingBox );
+            
+            // FCMOD: Removed to use precomputed collision list
+            //moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
+            	//boundingBox.addCoord( dUnboundedMoveX, dMoveY, dUnboundedMoveZ ) );
+            // END FCMOD
+
+            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+            {
+                dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset(
+                	boundingBox, dMoveY );
+            }
+
+            boundingBox.offset( 0D, dMoveY, 0D );
+
+            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+            {
+                dMoveX = moveRangeCollisionList.get( iTempIndex ).calculateXOffset(
+                	boundingBox, dMoveX );
+            }
+
+            boundingBox.offset( dMoveX, 0D, 0D );
+
+            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+            {
+                dMoveZ = moveRangeCollisionList.get( iTempIndex ).calculateZOffset(
+                	boundingBox, dMoveZ );
+            }
+
+            boundingBox.offset( 0D, 0D, dMoveZ );
+
+            // the following portion drops the entity downward after stepping up, to find
+            // the surface it should be resting on
+
+            if ( dMoveY > 0D )
+            {
+	            // FCMOD: Changed so that the entity doesn't end up descending further than it 
+            	// climbed fixing a bug with mobs falling through slabs [MC-72868]
+	            //dMoveY = -stepHeight;
+	            dMoveY = -dMoveY;
+	
+	            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+	            {
+	                dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset(
+	                	boundingBox, dMoveY );
+	            }
+
+	            boundingBox.offset( 0D, dMoveY, 0D );
+            }
+
+            if ( dBoundedMoveX * dBoundedMoveX + dBoundedMoveZ * dBoundedMoveZ >= 
+            	dMoveX * dMoveX + dMoveZ * dMoveZ )
+            {
+                dMoveX = dBoundedMoveX;
+                dMoveY = dBoundedMoveY;
+                dMoveZ = dBoundedMoveZ;
+                
+                boundingBox.setBB(dBoundedMoveBox);
+            }
+        }
+
+        worldObj.theProfiler.endSection();
+        
+        worldObj.theProfiler.startSection("rest");
+        
+        posX = ( boundingBox.minX + boundingBox.maxX ) / 2D;
+        posY = boundingBox.minY + yOffset - ySize;
+        posZ = ( boundingBox.minZ + boundingBox.maxZ ) / 2D;
+        
+        isCollidedHorizontally = dUnboundedMoveX != dMoveX || dUnboundedMoveZ != dMoveZ;
+        isCollidedVertically = dUnboundedMoveY != dMoveY;        
+        onGround = dUnboundedMoveY != dMoveY && dUnboundedMoveY < 0.0D;
+        
+        isCollided = isCollidedHorizontally || isCollidedVertically;
+        
+        updateFallState( dMoveY, onGround );
+
+        if ( dUnboundedMoveX != dMoveX )
+        {
+            motionX = 0D;
+        }
+
+        if ( dUnboundedMoveY != dMoveY )
+        {
+            motionY = 0D;
+        }
+
+        if ( dUnboundedMoveZ != dMoveZ )
+        {
+            motionZ = 0D;
+        }
+
+        double dDeltaX = posX - dOldPosX;
+        double dDeltaY = posY - dOldPosY;
+        double dDeltaZ = posZ - dOldPosZ;
+
+        if ( canTriggerWalking() && !bIsSneakingPlayer && ridingEntity == null )
+        {
+            int iGroundI = MathHelper.floor_double( posX );
+            // FCMOD: Changed to refine step sounds
+            //int iGroundJ = MathHelper.floor_double( posY - 0.20000000298023224D - yOffset );
+            int iGroundJ = MathHelper.floor_double( posY - 0.03D - yOffset );
+            // END FCMOD
+            int iGroundK = MathHelper.floor_double( posZ );
+            
+            int iGroundBlockID = worldObj.getBlockId(iGroundI, iGroundJ, iGroundK);
+            
+            // FCMOD: Added
+            int iTempY = iGroundJ;
+            // END FCMOD
+
+            if ( iGroundBlockID == 0 )
+            {
+                int iGroundRenderType = worldObj.blockGetRenderType( iGroundI, iGroundJ - 1, 
+                	iGroundK );
+
+                if ( iGroundRenderType == 11 || iGroundRenderType == 32 || 
+                	iGroundRenderType == 21 )
+                {
+                    iGroundBlockID = worldObj.getBlockId( iGroundI, iGroundJ - 1, iGroundK );
+                    // FCMOD: Added
+                    iTempY = iGroundJ - 1;
+                    // END FCMOD
+                }
+            }
+
+            // FCMOD: Changed
+            /*
+            if (var32 != Block.ladder.blockID)
+            {
+                var25 = 0.0D;
+            }
+            */
+            Block inBlock = Block.blocksList[iGroundBlockID];
+            
+            if ( inBlock == null || !inBlock.IsBlockClimbable( worldObj, iGroundI, iTempY, iGroundK ) )
+            {
+                dDeltaY = 0D;
+            }                
+            // END FCMOD
+
+            distanceWalkedModified = distanceWalkedModified + MathHelper.sqrt_double(
+            	dDeltaX * dDeltaX + dDeltaZ * dDeltaZ ) * 0.6F;
+            
+            distanceWalkedOnStepModified = distanceWalkedOnStepModified + MathHelper.sqrt_double( 
+            	dDeltaX * dDeltaX + dDeltaY * dDeltaY + dDeltaZ * dDeltaZ ) * 0.6F;
+
+            if ( distanceWalkedOnStepModified > nextStepDistance && iGroundBlockID > 0 )
+            {
+                nextStepDistance = (int)distanceWalkedOnStepModified + 1;
+
+                if ( isInWater() )
+                {
+                    float fSwimSoundVolume = MathHelper.sqrt_double(
+                    	motionX * motionX * 0.20000000298023224D + motionY * motionY + 
+                    	motionZ * motionZ * 0.20000000298023224D ) * 0.35F;
+
+                    if ( fSwimSoundVolume > 1F )
+                    {
+                        fSwimSoundVolume = 1F;
+                    }
+
+                    playSound( "liquid.swim", fSwimSoundVolume, 
+                    	1F + ( rand.nextFloat() - rand.nextFloat() ) * 0.4F );
+                }
+
+                playStepSound( iGroundI, iGroundJ, iGroundK, iGroundBlockID );
+                
+                Block.blocksList[iGroundBlockID].onEntityWalking( worldObj, 
+                	iGroundI, iGroundJ, iGroundK, this );
+            }
+        }
+
+        doBlockCollisions(); // notifies blocks of intersections, doesn't move entity
+        
+        boolean bWet = isWet();
+
+        // FCMOD: Changed
+        //if ( worldObj.isBoundingBoxBurning( boundingBox.contract( 0.001D, 0.001D, 0.001D ) ) )
+        if ( worldObj.isBoundingBoxBurning( this ) )
+    	// END FCMOD
+        {
+            dealFireDamage( 1 );
+
+            if ( !bWet )
+            {
+                fire++;
+
+                if ( fire == 0 )
+                {
+                    setFire( 8 );
+                }
+            }
+        }
+        else if ( fire <= 0 )
+        {
+            fire = -fireResistance;
+        }
+
+        if ( bWet && fire > 0 )
+        {
+            playSound( "random.fizz", 0.7F, 1.6F + ( rand.nextFloat() - 
+            	rand.nextFloat() ) * 0.4F );
+            
+            fire = -fireResistance;
+        }
+
+        worldObj.theProfiler.endSection();
+    }
+    
+    public void readFromNBT( NBTTagCompound tag )
+    {
+        try
+        {
+        	boolean bHasBoundingData = false;
+        	
+    		NBTTagList posTag = tag.getTagList( "Pos" );
+    		
+    		prevPosX = lastTickPosX = posX = ( (NBTTagDouble)posTag.tagAt( 0 ) ).data;
+    		prevPosY = lastTickPosY = posY = ( (NBTTagDouble)posTag.tagAt( 1 ) ).data;
+    		prevPosZ = lastTickPosZ = posZ = ( (NBTTagDouble)posTag.tagAt( 2 ) ).data;
+        	
+        	if ( tag.hasKey( "fcMin" ) )
+        	{
+        		bHasBoundingData = true; 
+        			
+        		// fix for entities getting stuck in blocks on load
+        		
+        		NBTTagList minTag = tag.getTagList( "fcMin" );
+        		
+                double dMinX = ( (NBTTagDouble )minTag.tagAt( 0 ) ).data;
+                double dMinY = ( (NBTTagDouble )minTag.tagAt( 1 ) ).data;
+                double dMinZ = ( (NBTTagDouble )minTag.tagAt( 2 ) ).data;                
+	            
+        		NBTTagList maxTag = tag.getTagList( "fcMax" );
+        		
+                double dMaxX = ( (NBTTagDouble )maxTag.tagAt( 0 ) ).data;
+                double dMaxY = ( (NBTTagDouble )maxTag.tagAt( 1 ) ).data;
+                double dMaxZ = ( (NBTTagDouble )maxTag.tagAt( 2 ) ).data;
+                
+                boundingBox.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );
+        	}
+        	else
+        	{   
+                setPosition( posX, posY, posZ );        		
+        	}
+        	
+            NBTTagList motionTag = tag.getTagList("Motion");
+            
+            motionX = ((NBTTagDouble)motionTag.tagAt(0)).data;
+            motionY = ((NBTTagDouble)motionTag.tagAt(1)).data;
+            motionZ = ((NBTTagDouble)motionTag.tagAt(2)).data;
+
+            if (Math.abs(this.motionX) > 10.0D)
+            {
+                this.motionX = 0.0D;
+            }
+
+            if (Math.abs(this.motionY) > 10.0D)
+            {
+                this.motionY = 0.0D;
+            }
+
+            if (Math.abs(this.motionZ) > 10.0D)
+            {
+                this.motionZ = 0.0D;
+            }
+
+            NBTTagList rotationTag = tag.getTagList("Rotation");
+            
+            this.prevRotationYaw = this.rotationYaw = ((NBTTagFloat)rotationTag.tagAt(0)).data;
+            this.prevRotationPitch = this.rotationPitch = ((NBTTagFloat)rotationTag.tagAt(1)).data;
+            
+            this.fallDistance = tag.getFloat("FallDistance");
+            this.fire = tag.getShort("Fire");
+            this.setAir(tag.getShort("Air"));
+            this.onGround = tag.getBoolean("OnGround");
+            this.dimension = tag.getInteger("Dimension");
+            this.invulnerable = tag.getBoolean("Invulnerable");
+            this.timeUntilPortal = tag.getInteger("PortalCooldown");
+
+            if (tag.hasKey("UUIDMost") && tag.hasKey("UUIDLeast"))
+            {
+                this.entityUniqueID = new UUID(tag.getLong("UUIDMost"), tag.getLong("UUIDLeast"));
+            }
+
+            this.setRotation(this.rotationYaw, this.rotationPitch);
+            
+            readEntityFromNBT(tag);
+            
+            if ( !bHasBoundingData && ShouldSetPositionOnLoad() )
+            {
+            	// added to duplicate 1.6 fix for animals suffocating and escaping.
+            	// I believe this was due to stuff like child animals modifying their dimensions
+            	// during init, but is not required with the changes made to save full bounding
+            	// boxes
+            	
+                setPosition( posX, posY, posZ);
+            }
+        }
+        catch (Throwable var5)
+        {
+            CrashReport var3 = CrashReport.makeCrashReport(var5, "Loading entity NBT");
+            CrashReportCategory var4 = var3.makeCategory("Entity being loaded");
+            this.func_85029_a(var4);
+            throw new ReportedException(var3);
+        }
+    }
+
+    /**
+     * Called when clients receive a packed from the server indicating that they should
+     * mount an entity as part of fix for MC-1291.
+     */
+    public void MountEntityRemote( Entity entityToMount )
+    {
+    	mountEntity( entityToMount );
+    }
+    
+    public void FlagAllWatchedObjectsDirty()
+    {
+    	List watchList = dataWatcher.getAllWatched();
+    	
+    	if ( watchList != null )
+    	{
+	        Iterator watchIterator = watchList.iterator();
+	
+	        while ( watchIterator.hasNext() )
+	        {
+	            WatchableObject tempWatchable = (WatchableObject)watchIterator.next();
+	            dataWatcher.setObjectWatched( tempWatchable.getDataValueId() );
+	        }
+    	}
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAIAttackOnCollide.java b/minecraft/net/minecraft/src/EntityAIAttackOnCollide.java
index e9dbb69..268da4d 100644
--- a/minecraft/net/minecraft/src/EntityAIAttackOnCollide.java
+++ b/minecraft/net/minecraft/src/EntityAIAttackOnCollide.java
@@ -80,6 +80,12 @@ public class EntityAIAttackOnCollide extends EntityAIBase
      */
     public void resetTask()
     {
+    	// FCMOD: Added
+    	if ( attacker.getAttackTarget() == entityTarget )
+    	{
+    		attacker.setAttackTarget( null );
+    	}
+    	// END FCMOD
         this.entityTarget = null;
         this.attacker.getNavigator().clearPathEntity();
     }
@@ -98,7 +104,20 @@ public class EntityAIAttackOnCollide extends EntityAIBase
         }
 
         this.attackTick = Math.max(this.attackTick - 1, 0);
+        // FCMOD: Code change to take width of target into account as the original code assumes it's the same as the attacker
+        /*
         double var1 = (double)(this.attacker.width * 2.0F * this.attacker.width * 2.0F);
+        */
+        double dCombinedWidth = attacker.width + entityTarget.width;
+        double var1 = dCombinedWidth * dCombinedWidth;
+        
+        if ( entityTarget == attacker.riddenByEntity )
+        {
+        	// stop stuff like wolves biting squid on their backs
+        	
+        	return;
+        }
+        // END FCMOD
 
         if (this.attacker.getDistanceSq(this.entityTarget.posX, this.entityTarget.boundingBox.minY, this.entityTarget.posZ) <= var1)
         {
diff --git a/minecraft/net/minecraft/src/EntityAICreeperSwell.java b/minecraft/net/minecraft/src/EntityAICreeperSwell.java
index 89b8be6..f53c193 100644
--- a/minecraft/net/minecraft/src/EntityAICreeperSwell.java
+++ b/minecraft/net/minecraft/src/EntityAICreeperSwell.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityAICreeperSwell extends EntityAIBase
diff --git a/minecraft/net/minecraft/src/EntityAIDoorInteract.java b/minecraft/net/minecraft/src/EntityAIDoorInteract.java
index 61704ab..e049e9e 100644
--- a/minecraft/net/minecraft/src/EntityAIDoorInteract.java
+++ b/minecraft/net/minecraft/src/EntityAIDoorInteract.java
@@ -106,6 +106,10 @@ public abstract class EntityAIDoorInteract extends EntityAIBase
     private BlockDoor findUsableDoor(int par1, int par2, int par3)
     {
         int var4 = this.theEntity.worldObj.getBlockId(par1, par2, par3);
-        return var4 != Block.doorWood.blockID ? null : (BlockDoor)Block.blocksList[var4];
+        // FCMOD: Changed
+        //return var4 != Block.doorWood.blockID ? null : (BlockDoor)Block.blocksList[var4];
+        return ( var4 != Block.doorWood.blockID && var4 != FCBetterThanWolves.fcBlockDoorWood.blockID ) ? 
+        	null : (BlockDoor)Block.blocksList[var4];
+    	// END FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/EntityAIEatGrass.java b/minecraft/net/minecraft/src/EntityAIEatGrass.java
index 15500a1..eadde58 100644
--- a/minecraft/net/minecraft/src/EntityAIEatGrass.java
+++ b/minecraft/net/minecraft/src/EntityAIEatGrass.java
@@ -85,7 +85,12 @@ public class EntityAIEatGrass extends EntityAIBase
             else if (this.theWorld.getBlockId(var1, var2 - 1, var3) == Block.grass.blockID)
             {
                 this.theWorld.playAuxSFX(2001, var1, var2 - 1, var3, Block.grass.blockID);
+                // FCMOD: Changed to send notification
+                /*
                 this.theWorld.setBlock(var1, var2 - 1, var3, Block.dirt.blockID, 0, 2);
+                */
+                this.theWorld.setBlock(var1, var2 - 1, var3, Block.dirt.blockID, 0, 3);
+                // END FCMOD
                 this.theEntity.eatGrassBonus();
             }
         }
diff --git a/minecraft/net/minecraft/src/EntityAIFollowOwner.java b/minecraft/net/minecraft/src/EntityAIFollowOwner.java
index 6698b3c..4ab2c7e 100644
--- a/minecraft/net/minecraft/src/EntityAIFollowOwner.java
+++ b/minecraft/net/minecraft/src/EntityAIFollowOwner.java
@@ -84,6 +84,13 @@ public class EntityAIFollowOwner extends EntityAIBase
     {
         this.thePet.getLookHelper().setLookPositionWithEntity(this.theOwner, 10.0F, (float)this.thePet.getVerticalFaceSpeed());
 
+        // FCMOD: Code added to prevent pets sitting in Minecarts from teleporting
+        if ( thePet.ridingEntity != null )
+        {
+        	return;
+        }
+        // END FCMOD
+        
         if (!this.thePet.isSitting())
         {
             if (--this.field_75343_h <= 0)
@@ -94,10 +101,11 @@ public class EntityAIFollowOwner extends EntityAIBase
                 {
                     if (this.thePet.getDistanceSqToEntity(this.theOwner) >= 144.0D)
                     {
+                        // FCMOD: Code changed
+                    	/*
                         int var1 = MathHelper.floor_double(this.theOwner.posX) - 2;
                         int var2 = MathHelper.floor_double(this.theOwner.posZ) - 2;
                         int var3 = MathHelper.floor_double(this.theOwner.boundingBox.minY);
-
                         for (int var4 = 0; var4 <= 4; ++var4)
                         {
                             for (int var5 = 0; var5 <= 4; ++var5)
@@ -110,9 +118,57 @@ public class EntityAIFollowOwner extends EntityAIBase
                                 }
                             }
                         }
+                        */
+				        HandleTeleportation();
+				    	// END FCMOD
                     }
                 }
             }
         }
     }
+    
+    // FCMOD: Added
+    private void HandleTeleportation()
+    {
+    	if ( !thePet.IsAITryingToSit() )
+    	{
+	        // Code changed so that pets will teleport *behind* the player instead of just randomly around him
+	        Float xVector = ( MathHelper.sin((theOwner.rotationYaw / 180F) * (float)Math.PI) * 4.0F );
+	        Float zVector = -( MathHelper.cos((theOwner.rotationYaw / 180F) * (float)Math.PI) * 4.0F );
+	
+	        int var1 = MathHelper.floor_double(theOwner.posX + xVector);
+	        int var2 = MathHelper.floor_double(theOwner.posZ + zVector);
+	        int var3 = MathHelper.floor_double(theOwner.boundingBox.minY);
+	        
+	        // Changed this so that the searching starts at the center of the location
+	        
+	        for (int xCount = 0; xCount <= 4; xCount++)
+	        {
+	            for (int zCount = 0; zCount <= 4; zCount++)
+	            {
+	            	int xOffset = ( xCount + 1 ) >> 1;
+	            	int zOffset = ( zCount + 1 ) >> 1;
+	        
+	        		if ( ( xCount & 1 ) == 0 )
+	        		{
+	        			xOffset = -xOffset;
+	        		}
+	        		
+	        		if ( ( zOffset & 1 ) == 0 )
+	        		{
+	        			zOffset = -zOffset;
+	        		}
+	        		
+	                if ( theWorld.doesBlockHaveSolidTopSurface( var1 + xOffset, var3 - 1, var2 + zOffset) && 
+	            		!theWorld.isBlockNormalCube(var1 + xOffset, var3, var2 + zOffset) && !theWorld.isBlockNormalCube(var1 + xOffset, var3 + 1, var2 + zOffset))
+	                {
+	                    thePet.setLocationAndAngles((float)(var1 + xOffset) + 0.5F, var3, (float)(var2 + zOffset) + 0.5F, thePet.rotationYaw, thePet.rotationPitch);
+	                    petPathfinder.clearPathEntity();
+	                    return;
+	                }
+	            }
+	        }
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAIFollowParent.java b/minecraft/net/minecraft/src/EntityAIFollowParent.java
index a47aecd..0a08711 100644
--- a/minecraft/net/minecraft/src/EntityAIFollowParent.java
+++ b/minecraft/net/minecraft/src/EntityAIFollowParent.java
@@ -15,6 +15,10 @@ public class EntityAIFollowParent extends EntityAIBase
     {
         this.childAnimal = par1EntityAnimal;
         this.field_75347_c = par2;
+        
+        // FCMOD: Added
+        setMutexBits( 1 );
+        // END FCMOD
     }
 
     /**
@@ -70,6 +74,12 @@ public class EntityAIFollowParent extends EntityAIBase
      */
     public boolean continueExecuting()
     {
+    	// FCMOD: Added to prevent adult children from following their parents
+    	if ( !childAnimal.isChild() )
+    	{
+    		return false;
+    	}
+    	// FCMOD
         if (!this.parentAnimal.isEntityAlive())
         {
             return false;
diff --git a/minecraft/net/minecraft/src/EntityAIHurtByTarget.java b/minecraft/net/minecraft/src/EntityAIHurtByTarget.java
index 32ca596..845b448 100644
--- a/minecraft/net/minecraft/src/EntityAIHurtByTarget.java
+++ b/minecraft/net/minecraft/src/EntityAIHurtByTarget.java
@@ -5,15 +5,21 @@ import java.util.List;
 
 public class EntityAIHurtByTarget extends EntityAITarget
 {
+	// FCMOD: Changed the name of the following for clarity
+	/*
     boolean field_75312_a;
+	*/ 
+    private boolean m_bNearbyEntitiesOfSameTypeAttack;
+    // END FCMOD
 
     /** The PathNavigate of our entity. */
+    // FCNOTE: This is actually the target entity
     EntityLiving entityPathNavigate;
 
     public EntityAIHurtByTarget(EntityLiving par1EntityLiving, boolean par2)
     {
         super(par1EntityLiving, 16.0F, false);
-        this.field_75312_a = par2;
+        this.m_bNearbyEntitiesOfSameTypeAttack = par2;
         this.setMutexBits(1);
     }
 
@@ -22,7 +28,12 @@ public class EntityAIHurtByTarget extends EntityAITarget
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Changed this to ignore players in creative mode to reduce overall code complexity
+    	/*
         return this.isSuitableTarget(this.taskOwner.getAITarget(), true);
+        */
+        return this.isSuitableTarget(this.taskOwner.getAITarget(), false);
+        // END FCMOD    	
     }
 
     /**
@@ -30,7 +41,16 @@ public class EntityAIHurtByTarget extends EntityAITarget
      */
     public boolean continueExecuting()
     {
+    	// FCMOD: Change to stop executing when the target is dead, and to fix vanilla bug where this would immediately stop executing
+    	/*
         return this.taskOwner.getAITarget() != null && this.taskOwner.getAITarget() != this.entityPathNavigate;
+        */    	
+        return taskOwner.getAITarget() != null && 
+    		taskOwner.getAITarget().isEntityAlive() && 
+        	taskOwner.getAITarget() == entityPathNavigate && 
+        	taskOwner.getAttackTarget() != null &&
+        	taskOwner.getAttackTarget() == entityPathNavigate;
+    	// END FCMOD
     }
 
     /**
@@ -41,7 +61,7 @@ public class EntityAIHurtByTarget extends EntityAITarget
         this.taskOwner.setAttackTarget(this.taskOwner.getAITarget());
         this.entityPathNavigate = this.taskOwner.getAITarget();
 
-        if (this.field_75312_a)
+        if (this.m_bNearbyEntitiesOfSameTypeAttack)
         {
             List var1 = this.taskOwner.worldObj.getEntitiesWithinAABB(this.taskOwner.getClass(), AxisAlignedBB.getAABBPool().getAABB(this.taskOwner.posX, this.taskOwner.posY, this.taskOwner.posZ, this.taskOwner.posX + 1.0D, this.taskOwner.posY + 1.0D, this.taskOwner.posZ + 1.0D).expand((double)this.targetDistance, 10.0D, (double)this.targetDistance));
             Iterator var2 = var1.iterator();
@@ -50,10 +70,19 @@ public class EntityAIHurtByTarget extends EntityAITarget
             {
                 EntityLiving var3 = (EntityLiving)var2.next();
 
+            	// FCMOD: Changed this so any other creatures that glom on will trigger this same AI instead of having an attack target without a corresponding
+            	// AI state
+            	/*
                 if (this.taskOwner != var3 && var3.getAttackTarget() == null)
                 {
                     var3.setAttackTarget(this.taskOwner.getAITarget());
                 }
+                */
+                if (this.taskOwner != var3 && var3.getAttackTarget() == null && var3.getAITarget() == null )
+                {
+                	var3.setRevengeTarget( taskOwner.getAITarget() );
+                }
+            	// END FCMOD
             }
         }
 
@@ -65,9 +94,26 @@ public class EntityAIHurtByTarget extends EntityAITarget
      */
     public void resetTask()
     {
+    	// FCMOD: Code change to prevent problems with AI not resetting its target when it dies
+    	/*
         if (this.taskOwner.getAttackTarget() != null && this.taskOwner.getAttackTarget() instanceof EntityPlayer && ((EntityPlayer)this.taskOwner.getAttackTarget()).capabilities.disableDamage)
         {
             super.resetTask();
+            
+            // FCMOD: Code added to fix flickering between angry and not in creative            
+            taskOwner.entityLivingToAttack = null;
+            // END FCMOD
         }
+        */
+    	if ( taskOwner.getAttackTarget() != null && entityPathNavigate == taskOwner.getAttackTarget() )
+    	{
+            taskOwner.setAttackTarget((EntityLiving)null);
+    	}
+    	
+    	if ( taskOwner.getAITarget() != null && entityPathNavigate == taskOwner.getAITarget() )
+    	{
+    		taskOwner.setRevengeTarget( null );
+    	}
+    	// END FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/EntityAIMate.java b/minecraft/net/minecraft/src/EntityAIMate.java
index 52f2049..6de33d6 100644
--- a/minecraft/net/minecraft/src/EntityAIMate.java
+++ b/minecraft/net/minecraft/src/EntityAIMate.java
@@ -6,9 +6,9 @@ import java.util.Random;
 
 public class EntityAIMate extends EntityAIBase
 {
-    private EntityAnimal theAnimal;
+    protected EntityAnimal theAnimal;
     World theWorld;
-    private EntityAnimal targetMate;
+    protected EntityAnimal targetMate;
 
     /**
      * Delay preventing a baby from spawning immediately when two mate-able animals find each other.
@@ -47,6 +47,12 @@ public class EntityAIMate extends EntityAIBase
      */
     public boolean continueExecuting()
     {
+    	// FCMOD: Added
+        if ( !theAnimal.isInLove() )
+        {
+            return false;
+        }
+    	// END FCMOD
         return this.targetMate.isEntityAlive() && this.targetMate.isInLove() && this.spawnBabyDelay < 60;
     }
 
@@ -70,7 +76,11 @@ public class EntityAIMate extends EntityAIBase
 
         if (this.spawnBabyDelay >= 60 && this.theAnimal.getDistanceSqToEntity(this.targetMate) < 9.0D)
         {
+        	/* FCMOD: Changed to use entity function to make birthing behavior easier to override and to consolodate it in one place
             this.spawnBaby();
+            */
+        	theAnimal.procreate( targetMate );
+        	// END FCMOD
         }
     }
 
@@ -103,6 +113,8 @@ public class EntityAIMate extends EntityAIBase
     /**
      * Spawns a baby animal of the same type.
      */
+    // FCMOD: Removed dead code
+    /*
     private void spawnBaby()
     {
         EntityAgeable var1 = this.theAnimal.createChild(this.targetMate);
@@ -126,7 +138,9 @@ public class EntityAIMate extends EntityAIBase
                 this.theWorld.spawnParticle("heart", this.theAnimal.posX + (double)(var2.nextFloat() * this.theAnimal.width * 2.0F) - (double)this.theAnimal.width, this.theAnimal.posY + 0.5D + (double)(var2.nextFloat() * this.theAnimal.height), this.theAnimal.posZ + (double)(var2.nextFloat() * this.theAnimal.width * 2.0F) - (double)this.theAnimal.width, var4, var6, var8);
             }
 
-            this.theWorld.spawnEntityInWorld(new EntityXPOrb(this.theWorld, this.theAnimal.posX, this.theAnimal.posY, this.theAnimal.posZ, var2.nextInt(7) + 1));
-        }
+            this.theWorld.spawnEntityInWorld(new EntityXPOrb(this.theWorld, this.theAnimal.posX, this.theAnimal.posY, this.theAnimal.posZ, var2.nextInt(7) + 1));            
+        }        
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAIOpenDoor.java b/minecraft/net/minecraft/src/EntityAIOpenDoor.java
index 6b1f702..b4ce78a 100644
--- a/minecraft/net/minecraft/src/EntityAIOpenDoor.java
+++ b/minecraft/net/minecraft/src/EntityAIOpenDoor.java
@@ -26,7 +26,12 @@ public class EntityAIOpenDoor extends EntityAIDoorInteract
     public void startExecuting()
     {
         this.field_75360_j = 20;
+        // FCMOD: Code change
+        /*
         this.targetDoor.onPoweredBlockChange(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, true);
+        */        
+        this.targetDoor.OnAIOpenDoor(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, true);
+        // END FCMOD
     }
 
     /**
@@ -36,7 +41,12 @@ public class EntityAIOpenDoor extends EntityAIDoorInteract
     {
         if (this.field_75361_i)
         {
+            // FCMOD: Code change
+            /*
             this.targetDoor.onPoweredBlockChange(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, false);
+            */
+            this.targetDoor.OnAIOpenDoor(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, false);
+        	// END FCMOD
         }
     }
 
diff --git a/minecraft/net/minecraft/src/EntityAIOwnerHurtByTarget.java b/minecraft/net/minecraft/src/EntityAIOwnerHurtByTarget.java
index 540c235..977440b 100644
--- a/minecraft/net/minecraft/src/EntityAIOwnerHurtByTarget.java
+++ b/minecraft/net/minecraft/src/EntityAIOwnerHurtByTarget.java
@@ -17,6 +17,12 @@ public class EntityAIOwnerHurtByTarget extends EntityAITarget
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Code added to check if sitting before attacking    	
+    	if ( theDefendingTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	// END FCMOD
         if (!this.theDefendingTameable.isTamed())
         {
             return false;
@@ -45,4 +51,17 @@ public class EntityAIOwnerHurtByTarget extends EntityAITarget
         this.taskOwner.setAttackTarget(this.theOwnerAttacker);
         super.startExecuting();
     }
+
+    // FCMOD: Inherited function added
+    @Override
+    public boolean continueExecuting()
+    {
+    	if ( theDefendingTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	
+    	return super.continueExecuting();
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAIOwnerHurtTarget.java b/minecraft/net/minecraft/src/EntityAIOwnerHurtTarget.java
index 7fcd2d9..d4eafad 100644
--- a/minecraft/net/minecraft/src/EntityAIOwnerHurtTarget.java
+++ b/minecraft/net/minecraft/src/EntityAIOwnerHurtTarget.java
@@ -17,6 +17,12 @@ public class EntityAIOwnerHurtTarget extends EntityAITarget
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Code added to check if sitting before attacking    	
+    	if ( theEntityTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	// END FCMOD
         if (!this.theEntityTameable.isTamed())
         {
             return false;
@@ -45,4 +51,17 @@ public class EntityAIOwnerHurtTarget extends EntityAITarget
         this.taskOwner.setAttackTarget(this.theTarget);
         super.startExecuting();
     }
+
+    // FCMOD: Inherited function added
+    @Override
+    public boolean continueExecuting()
+    {
+    	if ( theEntityTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	
+    	return super.continueExecuting();
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAISit.java b/minecraft/net/minecraft/src/EntityAISit.java
index f709bff..633f9a4 100644
--- a/minecraft/net/minecraft/src/EntityAISit.java
+++ b/minecraft/net/minecraft/src/EntityAISit.java
@@ -33,7 +33,12 @@ public class EntityAISit extends EntityAIBase
         else
         {
             EntityLiving var1 = this.theEntity.getOwner();
+            // FCMOD: Line change to prevent wolves from standing when player is attacked
+            /*
             return var1 == null ? true : (this.theEntity.getDistanceSqToEntity(var1) < 144.0D && var1.getAITarget() != null ? false : this.isSitting);
+            */
+            return var1 == null ? true : this.isSitting;
+            // END FCMOD
         }
     }
 
@@ -61,4 +66,11 @@ public class EntityAISit extends EntityAIBase
     {
         this.isSitting = par1;
     }
-}
+    
+    // FCMOD: Added
+    public boolean IsTryingToSit()
+    {
+    	return this.isSitting;
+    }
+    // END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/EntityAITasks.java b/minecraft/net/minecraft/src/EntityAITasks.java
index 35df3ee..ac607d6 100644
--- a/minecraft/net/minecraft/src/EntityAITasks.java
+++ b/minecraft/net/minecraft/src/EntityAITasks.java
@@ -178,4 +178,48 @@ public class EntityAITasks
     {
         return (par1EntityAITaskEntry.action.getMutexBits() & par2EntityAITaskEntry.action.getMutexBits()) == 0;
     }
+    
+    // FCMOD: Added New
+    public void RemoveAllTasksOfClass( Class classToRemove )
+    {
+        Iterator<EntityAITaskEntry> entries = taskEntries.iterator();
+
+        while ( entries.hasNext())
+        {
+            EntityAITaskEntry tempEntry = entries.next();
+            EntityAIBase tempAction = tempEntry.action;
+
+            if ( classToRemove.isAssignableFrom( tempAction.getClass() ) )
+            {
+                if ( executingTaskEntries.contains( tempEntry ) )
+                {
+                    tempAction.resetTask();
+                    
+                    executingTaskEntries.remove( tempEntry );
+                }
+
+                entries.remove();
+            }
+        }
+    }
+    
+    public void RemoveAllTasks()
+    {
+        Iterator<EntityAITaskEntry> entries = taskEntries.iterator();
+
+        while ( entries.hasNext())
+        {
+            EntityAITaskEntry tempEntry = entries.next();
+
+            if ( executingTaskEntries.contains( tempEntry ) )
+            {
+                tempEntry.action.resetTask();
+                
+                executingTaskEntries.remove( tempEntry );
+            }
+
+            entries.remove();
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAITempt.java b/minecraft/net/minecraft/src/EntityAITempt.java
index 870e031..cb54816 100644
--- a/minecraft/net/minecraft/src/EntityAITempt.java
+++ b/minecraft/net/minecraft/src/EntityAITempt.java
@@ -97,7 +97,12 @@ public class EntityAITempt extends EntityAIBase
             this.field_75279_g = (double)this.temptingPlayer.rotationYaw;
         }
 
+        // FCMOD: Changed this line
+        /*
         return this.shouldExecute();
+        */
+        return ShouldContinueFollowing();
+        // END FCMOD
     }
 
     /**
@@ -120,7 +125,12 @@ public class EntityAITempt extends EntityAIBase
     {
         this.temptingPlayer = null;
         this.temptedEntity.getNavigator().clearPathEntity();
+        // FCMOD: Code change to make animals more responsive to tempting.  Note that AI is only checked every three ticks
+        /*
         this.delayTemptCounter = 100;
+        */
+        this.delayTemptCounter = 33;
+        // END FCMOD
         this.field_75287_j = false;
         this.temptedEntity.getNavigator().setAvoidsWater(this.field_75286_m);
     }
@@ -146,4 +156,34 @@ public class EntityAITempt extends EntityAIBase
     {
         return this.field_75287_j;
     }
+    
+    // FCMOD: Function added
+    private boolean ShouldContinueFollowing()
+    {
+        if (delayTemptCounter > 0)
+        {
+            delayTemptCounter--;
+            return false;
+        }
+
+        if (temptingPlayer == null || temptingPlayer.isLivingDead )
+        {
+            return false;
+        }
+
+        if (temptedEntity.getDistanceSqToEntity(temptingPlayer) > 256D)
+        {
+        	return false;
+        }
+
+        ItemStack itemstack = temptingPlayer.getCurrentEquippedItem();
+
+        if (itemstack == null)
+        {
+            return false;
+        }
+
+        return itemstack.itemID == breedingFood;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAIWander.java b/minecraft/net/minecraft/src/EntityAIWander.java
index cd0aaf4..0d54571 100644
--- a/minecraft/net/minecraft/src/EntityAIWander.java
+++ b/minecraft/net/minecraft/src/EntityAIWander.java
@@ -20,11 +20,20 @@ public class EntityAIWander extends EntityAIBase
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Code removed to disable AI activation distance
+    	/*
         if (this.entity.getAge() >= 100)
         {
             return false;
         }
+        */
+    	// END FCMOD
+    	
+    	// FCMOD: Line change to get rid of else
+    	/*
         else if (this.entity.getRNG().nextInt(120) != 0)
+        */
+        if (this.entity.getRNG().nextInt(120) != 0)
         {
             return false;
         }
diff --git a/minecraft/net/minecraft/src/EntityAgeable.java b/minecraft/net/minecraft/src/EntityAgeable.java
index 7bdbf48..b3f4ee2 100644
--- a/minecraft/net/minecraft/src/EntityAgeable.java
+++ b/minecraft/net/minecraft/src/EntityAgeable.java
@@ -1,9 +1,16 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
+
 public abstract class EntityAgeable extends EntityCreature
 {
-    private float field_98056_d = -1.0F;
-    private float field_98057_e;
+	// FCMOD: Changed for clarity
+    //private float field_98056_d = -1.0F;
+    //private float field_98057_e;
+    private float m_fAdultWidth = -1.0F; // -1 flags super entity size has not been initialized
+    private float m_fAdultHeight;
+    // END FCMOD
 
     public EntityAgeable(World par1World)
     {
@@ -16,6 +23,13 @@ public abstract class EntityAgeable extends EntityCreature
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
     public boolean interact(EntityPlayer par1EntityPlayer)
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	return EntityAgeableInteract( par1EntityPlayer );
+    }
+    
+    public boolean EntityAgeableInteract( EntityPlayer par1EntityPlayer )
+    // END FCMOD
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
 
@@ -29,7 +43,10 @@ public abstract class EntityAgeable extends EntityCreature
 
                 if (var4 != null)
                 {
-                    var4.setGrowingAge(-24000);
+                	// FCMOD: Changed
+                    //var4.setGrowingAge(-24000);
+                    var4.setGrowingAge( -GetTicksForChildToGrow() );
+                	// END FCMOD
                     var4.setLocationAndAngles(this.posX, this.posY, this.posZ, 0.0F, 0.0F);
                     this.worldObj.spawnEntityInWorld(var4);
 
@@ -77,7 +94,12 @@ public abstract class EntityAgeable extends EntityCreature
     public void setGrowingAge(int par1)
     {
         this.dataWatcher.updateObject(12, Integer.valueOf(par1));
-        this.func_98054_a(this.isChild());
+        // FCNOTE: This seems grossly ineffecient as I believe this data will get sent to the 
+        // clients every tick for child animals, and those waiting to recharge their love juice
+        // FCMOD: Changed
+        //this.func_98054_a(this.isChild());
+    	AdjustSizeForAge( isChild() );
+        // END FCMOD
     }
 
     /**
@@ -108,7 +130,10 @@ public abstract class EntityAgeable extends EntityCreature
 
         if (this.worldObj.isRemote)
         {
-            this.func_98054_a(this.isChild());
+        	// FCMOD: Changed
+            //this.func_98054_a(this.isChild());
+        	AdjustSizeForAge( isChild() );
+            // END FCMOD
         }
         else
         {
@@ -116,17 +141,49 @@ public abstract class EntityAgeable extends EntityCreature
 
             if (var1 < 0)
             {
+	        	// FCMOD: Added
+	        	if ( !CanChildGrow() )
+	        	{
+	        		return;
+	        	}
+	        	// END FCMOD
+	        	
                 ++var1;
-                this.setGrowingAge(var1);
+                
+                // FCMOD: Added
+        		if ( var1 == 0 )
+        		{
+        			// child is about to grow to adulthood.  Make sure it has enough space
+        			AxisAlignedBB adultBounds = AxisAlignedBB.getAABBPool().getAABB(
+        				boundingBox.minX, boundingBox.minY, boundingBox.minZ,
+        				boundingBox.minX + m_fAdultWidth, 
+        				boundingBox.minY + m_fAdultHeight, 
+        				boundingBox.minZ + m_fAdultWidth ); 
+        			
+        			if ( !worldObj.getCollidingBoundingBoxes( this, adultBounds ).isEmpty() )
+        			{
+        				var1 = -20;
+        			}        			
+        		}
+        		// END FCMOD
+        		
+                this.setGrowingAge(var1);                
             }
             else if (var1 > 0)
             {
+	        	// FCMOD: Added
+	        	if ( !CanLoveJuiceRegenerate() )
+	        	{
+	        		return;
+	        	}
+	        	// END FCMOD
+	        	
                 --var1;
                 this.setGrowingAge(var1);
             }
         }
     }
-
+    
     /**
      * If Animal, checks if the age timer is negative
      */
@@ -135,14 +192,13 @@ public abstract class EntityAgeable extends EntityCreature
         return this.getGrowingAge() < 0;
     }
 
+	// FCMOD: Removed and replaced
+	/*
     public void func_98054_a(boolean par1)
     {
         this.func_98055_j(par1 ? 0.5F : 1.0F);
     }
 
-    /**
-     * Sets the width and height of the entity. Args: width, height
-     */
     protected final void setSize(float par1, float par2)
     {
         boolean var3 = this.field_98056_d > 0.0F;
@@ -159,4 +215,48 @@ public abstract class EntityAgeable extends EntityCreature
     {
         super.setSize(this.field_98056_d * par1, this.field_98057_e * par1);
     }
+    */
+	// END FCMOD
+    
+    // FCMOD: Added New
+	protected final void setSize( float fWidth, float fHeight )
+	{
+        boolean bSizeAlreadyInitialized = m_fAdultWidth > 0F;
+        
+        m_fAdultWidth = fWidth;
+        m_fAdultHeight = fHeight;
+
+        if ( !bSizeAlreadyInitialized )
+        {
+        	AdjustedSizeToScale( 1F );
+        }
+	}
+
+    private void AdjustedSizeToScale( float fScale )
+    {
+        super.setSize( m_fAdultWidth * fScale, m_fAdultHeight * fScale );
+    }
+    
+    public void AdjustSizeForAge( boolean bIsChild )
+    {
+    	AdjustedSizeToScale( bIsChild ? 0.5F : 1F );
+    }
+    
+    public boolean CanChildGrow()
+    {
+    	// prevent animals growing up in the end
+    	
+    	return worldObj.provider.dimensionId != 1;
+    }
+    
+    public boolean CanLoveJuiceRegenerate()
+    {
+    	return true;
+    }
+    
+    protected int GetTicksForChildToGrow()
+    {
+    	return FCUtilsMisc.m_iTicksPerGameDay;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAnimal.java b/minecraft/net/minecraft/src/EntityAnimal.java
index 09672b3..55e4d43 100644
--- a/minecraft/net/minecraft/src/EntityAnimal.java
+++ b/minecraft/net/minecraft/src/EntityAnimal.java
@@ -2,15 +2,24 @@ package net.minecraft.src;
 
 import java.util.List;
 
+// FCMOD: Added
+import java.util.Iterator;
+// END FCMOD
+
 public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 {
-    private int inLove;
+	// FCMOD: Removed and replaced with a watchable value
+    //private int inLove;
+	// END FCMOD
 
     /**
      * This is representation of a counter for reproduction progress. (Note that this is different from the inLove which
      * represent being in Love-Mode)
      */
-    private int breeding = 0;
+	// FCMOD: Changed
+    //private int breeding = 0;
+    protected int breeding = 0;
+    // END FCMOD
 
     public EntityAnimal(World par1World)
     {
@@ -24,7 +33,12 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
     {
         if (this.getGrowingAge() != 0)
         {
+        	// FCMOD: Change
+        	/*
             this.inLove = 0;
+            */
+        	resetInLove();
+        	// END FCMOD
         }
 
         super.updateAITick();
@@ -40,15 +54,35 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 
         if (this.getGrowingAge() != 0)
         {
+        	// FCMOD: Change
+        	/*
             this.inLove = 0;
+            */
+        	resetInLove();
+        	// END FCMOD
         }
 
+        // FCMOD: Change
+        /*
         if (this.inLove > 0)
+        */
+        if ( isInLove() )
+    	// END FCMOD
         {
+            // FCMOD: Change
+            /*
             --this.inLove;
+            */
+            setInLove( getInLove() - 1 );
+        	// END FCMOD
             String var1 = "heart";
 
+            // FCMOD: Change
+            /*
             if (this.inLove % 10 == 0)
+            */
+            if ( getInLove() % 10 == 0 )
+        	// END FCMOD
             {
                 double var2 = this.rand.nextGaussian() * 0.02D;
                 double var4 = this.rand.nextGaussian() * 0.02D;
@@ -59,7 +93,7 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
         else
         {
             this.breeding = 0;
-        }
+        }        
     }
 
     /**
@@ -95,7 +129,12 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
                     this.hasAttacked = true;
                 }
             }
+            // FCMOD: Change
+            /*
             else if (this.inLove > 0 && var8.inLove > 0)
+            */
+            else if ( isInLove() && var8.isInLove() )
+        	// END FCMOD
             {
                 if (var8.entityToAttack == null)
                 {
@@ -104,8 +143,14 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 
                 if (var8.entityToAttack == this && (double)par2 < 3.5D)
                 {
+                	// FCMOD: Code change: 
+                	/*
                     ++var8.inLove;
                     ++this.inLove;
+                    */
+                    setInLove( getInLove() + 1 );
+                    var8.setInLove( var8.getInLove() + 1 );
+                    // END FCMOD
                     ++this.breeding;
 
                     if (this.breeding % 4 == 0)
@@ -135,6 +180,8 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
      * Creates a baby animal according to the animal type of the target at the actual position and spawns 'love'
      * particles.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     private void procreate(EntityAnimal par1EntityAnimal)
     {
         EntityAgeable var2 = this.createChild(par1EntityAnimal);
@@ -163,7 +210,9 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
             this.worldObj.spawnEntityInWorld(var2);
         }
     }
-
+    */
+    // END FCMOD
+    
     /**
      * Called when the entity is attacked.
      */
@@ -177,7 +226,13 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
         {
             this.fleeingTick = 60;
             this.entityToAttack = null;
+            // FCMOD: Code change
+            /*
             this.inLove = 0;
+            */
+        	resetInLove();
+        	PanickNearbyAnimals( par1DamageSource );
+        	// END FCMOD
             return super.attackEntityFrom(par1DamageSource, par2);
         }
     }
@@ -186,28 +241,40 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
      * Takes a coordinate in and returns a weight to determine how likely this creature will try to path to the block.
      * Args: x, y, z
      */
+    // FCMOD: Removed and replaced
+    /*
     public float getBlockPathWeight(int par1, int par2, int par3)
     {
         return this.worldObj.getBlockId(par1, par2 - 1, par3) == Block.grass.blockID ? 10.0F : this.worldObj.getLightBrightness(par1, par2, par3) - 0.5F;
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to write subclass entity data to NBT.
      */
+    // FCMOD: Removed and replaced
+    /*
     public void writeEntityToNBT(NBTTagCompound par1NBTTagCompound)
     {
         super.writeEntityToNBT(par1NBTTagCompound);
         par1NBTTagCompound.setInteger("InLove", this.inLove);
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to read subclass entity data from NBT.
      */
+    // FCMOD: Removed and replaced
+    /*
     public void readEntityFromNBT(NBTTagCompound par1NBTTagCompound)
     {
         super.readEntityFromNBT(par1NBTTagCompound);
         this.inLove = par1NBTTagCompound.getInteger("InLove");
     }
+    */
+    // END FCMOD
 
     /**
      * Finds the closest player within 16 blocks to attack, or null if this Entity isn't interested in attacking
@@ -226,8 +293,15 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
             int var3;
             EntityAnimal var4;
 
+            // FCMOD: Change
+            /*
             if (this.inLove > 0)
+            */
+            if ( isInLove() )
+        	// END FCMOD
             {
+	        	// FCMOD: Changed the following to find the closest animal instead of just a random one
+	        	/*	        	
                 var2 = this.worldObj.getEntitiesWithinAABB(this.getClass(), this.boundingBox.expand((double)var1, (double)var1, (double)var1));
 
                 for (var3 = 0; var3 < var2.size(); ++var3)
@@ -239,6 +313,30 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
                         return var4;
                     }
                 }
+                */
+	        	double dClosestAnimalDistanceSq = 0.0F;
+	        	EntityAnimal closestValidAnimal = null;
+	        	
+	            List list = worldObj.getEntitiesWithinAABB(getClass(), boundingBox.expand( var1, var1, var1 ));
+
+	            for (int i = 0; i < list.size(); i++)
+	            {
+	                EntityAnimal entityanimal = (EntityAnimal)list.get(i);
+	                
+	                if (entityanimal != this && entityanimal.isInLove() )
+	                {
+	                	double dDistanceSqToAnimal = getDistanceSqToEntity( entityanimal );
+	                	
+	                	if ( closestValidAnimal == null || dDistanceSqToAnimal < dClosestAnimalDistanceSq )
+	                	{
+	                		dClosestAnimalDistanceSq = dDistanceSqToAnimal;
+	                		closestValidAnimal = entityanimal;
+	                	}
+	        		}
+	            }
+            
+            	return closestValidAnimal;
+	            // END FCMOD
             }
             else if (this.getGrowingAge() == 0)
             {
@@ -320,6 +418,8 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
     /**
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean interact(EntityPlayer par1EntityPlayer)
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
@@ -354,18 +454,26 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
             return super.interact(par1EntityPlayer);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns if the entity is currently in 'love mode'.
      */
     public boolean isInLove()
     {
-        return this.inLove > 0;
+    	// FCMOD: Changed
+        //return this.inLove > 0;
+    	return getInLove() > 0;
+    	// END FCMOD    	
     }
 
     public void resetInLove()
     {
-        this.inLove = 0;
+    	// FCMOD: Changed
+        //this.inLove = 0;
+    	setInLove( 0 );
+    	// END FCMOD
     }
 
     /**
@@ -375,4 +483,1007 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
     {
         return par1EntityAnimal == this ? false : (par1EntityAnimal.getClass() != this.getClass() ? false : this.isInLove() && par1EntityAnimal.isInLove());
     }
+    
+    // FCMOD: Added New
+    protected static final int m_iHungerLevelDataWatcherID = 21;
+	protected static final int m_iInLoveDataWatcherID = 22;
+	protected static final int m_iWearingBreedingHarnessDataWatcherID = 23;
+	
+    @Override
+    protected void entityInit()
+    {
+        super.entityInit();
+        
+        dataWatcher.addObject( m_iHungerLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iInLoveDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iWearingBreedingHarnessDataWatcherID, Byte.valueOf( (byte)0 ) );
+    }
+    
+    @Override
+    public void writeEntityToNBT( NBTTagCompound tag )
+    {
+        super.writeEntityToNBT( tag );
+        
+        tag.setInteger( "InLove", getInLove() );
+        tag.setByte( "fcHungerLvl", (byte)GetHungerLevel() );
+        tag.setBoolean( "BreedingHarness", getWearingBreedingHarness() );
+        tag.setInteger( "fcHungerCnt", m_iHungerCountdown );
+        tag.setInteger( "fcHealCnt", m_iHealingCountdown );
+    }
+
+    @Override
+    public void readEntityFromNBT( NBTTagCompound tag )
+    {
+        super.readEntityFromNBT( tag );
+        
+        setInLove( tag.getInteger( "InLove" ) );
+        
+        if ( tag.hasKey( "BreedingHarness" ) )
+        {
+        	setWearingBreedingHarness( tag.getBoolean( "BreedingHarness" ) );
+        }
+        
+        if ( tag.hasKey( "fcHungerLvl" ) )
+        {
+            SetHungerLevel( tag.getByte( "fcHungerLvl" ) );
+        }
+        
+        if ( tag.hasKey( "fcHungerCnt" ) )
+        {
+        	m_iHungerCountdown = tag.getInteger( "fcHungerCnt" );
+        }
+        else
+        {
+        	ResetHungerCountdown();
+        }
+        
+        if ( tag.hasKey( "fcHealCnt" ) )
+        {
+        	m_iHealingCountdown = tag.getInteger( "fcHealCnt" );
+        }
+        else
+        {
+        	ResetHealingCountdown();
+        }
+    }
+    
+    @Override
+    protected void ModSpecificOnLivingUpdate()
+    {
+    	super.ModSpecificOnLivingUpdate();
+    	
+	    if ( !worldObj.isRemote )
+	    {
+	    	if ( isEntityAlive() )
+	    	{
+		        CheckForLooseFood();
+		        CheckForIntersectingBreedingHarnesses();
+	
+		        UpdateHealing();
+		        UpdateHungerState();
+	    	}
+	    }
+	    else
+	    {
+	        if ( m_iGrazeProgressCounter > 0 )
+	        {
+	        	// update the graze counter on the client as we only get an initial 
+	        	// notification when it starts in a healthUpdate
+	        	
+	            m_iGrazeProgressCounter--;
+	        }
+	    }
+	    
+	    if ( isInLove() )
+	    {
+	    	if ( entityToAttack != null && entityToAttack instanceof EntityAnimal )
+	    	{
+	            EntityAnimal entityanimal = (EntityAnimal)entityToAttack;
+	            
+	            if ( !entityanimal.isInLove() )
+	            {
+	            	// the targeted animal is no longer in love mode.  Reset the target so another will be selected on the following update
+	            	
+	            	entityToAttack = null;
+	            }
+	    	}
+	    }
+    }
+    
+	@Override
+    protected void jump()
+    {
+    	if ( isChild() )
+    	{
+    		// jump half height if child or starving
+    		
+            motionY = 0.21D;
+            isAirBorne = true;    		
+    	}
+    	else
+    	{
+    		super.jump();
+    	}
+    }
+    
+	@Override
+    public void onDeath( DamageSource damageSource )
+    {
+    	super.onDeath( damageSource );
+    	
+    	if ( !worldObj.isRemote && getWearingBreedingHarness() )
+    	{
+            dropItem( FCBetterThanWolves.fcItemBreedingHarness.itemID, 1 );
+    	}        
+    }
+    
+	@Override
+    protected void updateEntityActionState()
+    {
+		super.updateEntityActionState();
+		
+    	if ( getWearingBreedingHarness() )
+    	{
+            moveStrafing = 0F;
+            moveForward = 0F;
+    	}
+    }
+	
+	@Override
+    public void CheckForScrollDrop()
+    {
+		// this is overridden to prevent potentially expensive (and useless) checks every 
+		// time an animal dies, since none of them drop scrolls
+    }
+
+    @Override
+    protected float getSoundPitch()
+    {
+    	float fPitch = super.getSoundPitch();
+
+    	if ( IsPossessed() )
+    	{
+    		fPitch *= 0.60F;
+    	}
+    	
+        return fPitch;
+    }
+    
+	@Override
+    public void setRevengeTarget( EntityLiving targetEntity )
+    {
+		// override to lengthen panic time on animals
+    	
+        entityLivingToAttack = targetEntity;
+        
+        if ( entityLivingToAttack != null )
+        {
+        	revengeTimer = 300; // 15 seconds
+        }
+        else
+        {
+        	revengeTimer = 0;
+        }
+    }
+    
+    @Override
+    public float getBlockPathWeight( int i, int j, int k )
+    {
+    	if ( CanGrazeOnBlock( i, j - 1, k ) || CanGrazeOnBlock( i, j, k ) )
+    	{
+    		return 10F;
+    	}
+    	
+    	return worldObj.GetNaturalLightBrightness( i, j, k ) - 0.5F;
+    }
+    
+    @Override
+    public boolean IsSecondaryTargetForSquid()
+    {
+    	return true;
+    }
+    
+    @Override
+    public void OnFlungBySquidTentacle( FCEntitySquid squid )
+    {
+		DamageSource squidSource = DamageSource.causeMobDamage( squid );
+		
+		attackEntityFrom( squidSource, 0 );
+    }
+    
+    @Override
+    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
+    {
+		DamageSource squidSource = DamageSource.causeMobDamage( squid );
+		
+		attackEntityFrom( squidSource, 0 );
+    }
+    
+    @Override
+    protected void AttemptToPossessNearbyCreatureOnDeath()
+    {
+		AttemptToPossessNearbyCreature( 16D, true );
+    }
+    
+    @Override
+    public float getSpeedModifier()
+    {
+    	return super.getSpeedModifier() * GetHungerSpeedModifier();    	
+    }
+    
+    @Override
+    public boolean CanChildGrow()
+    {
+    	return super.CanChildGrow() && !IsTooHungryToGrow();
+    }
+    
+    @Override
+    public boolean CanLoveJuiceRegenerate()
+    {
+    	return IsFullyFed();
+    }
+    
+    @Override
+    protected int GetTicksForChildToGrow()
+    {
+    	return FCUtilsMisc.m_iTicksPerGameDay * 2;
+    }
+    
+    @Override
+    public boolean interact( EntityPlayer player )
+    {
+    	return EntityAnimalInteract( player );
+    }
+    
+    @Override
+    public void initCreature() 
+    {
+    	InitHungerWithVariance();
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+    public int getInLove()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iInLoveDataWatcherID );
+    }
+    
+    public void setInLove( int iInLove )
+    {
+        dataWatcher.updateObject( m_iInLoveDataWatcherID, Integer.valueOf( iInLove ) );
+    }
+   
+    public boolean getWearingBreedingHarness()
+    {
+        return ( dataWatcher.getWatchableObjectByte( m_iWearingBreedingHarnessDataWatcherID ) > 0 );
+    }
+    
+    public void setWearingBreedingHarness( boolean bWearingHarness )
+    {
+    	Byte wearing = 0;
+    	
+    	if ( bWearingHarness )
+    	{
+    		wearing = 1;
+    	}
+    	
+        dataWatcher.updateObject( m_iWearingBreedingHarnessDataWatcherID, Byte.valueOf( wearing ) );
+    }
+   
+    public void CheckForIntersectingBreedingHarnesses()
+    {    
+    	if ( getWearingBreedingHarness()  )
+    	{
+            AxisAlignedBB tempBoundingBox = boundingBox.copy();
+            
+            tempBoundingBox.contract(0.1D, 0.1D, 0.1D );
+            
+		    List collisionList = worldObj.getEntitiesWithinAABB( EntityAnimal.class, 
+	    		tempBoundingBox );
+		    
+		    if ( !collisionList.isEmpty() )
+		    {
+	            for ( int listIndex = 0; listIndex < collisionList.size(); listIndex++ )
+	            {
+		    		EntityAnimal entityAnimal = (EntityAnimal)collisionList.get( listIndex );;
+		    		
+		    		if ( entityAnimal != this )
+		    		{		    		
+				        if ( entityAnimal.getWearingBreedingHarness() && !(entityAnimal.isLivingDead) )
+				        {
+				        	attackEntityFrom( DamageSource.inWall, 1 );
+				        	
+			    			break;				            
+			    		}
+		    		}
+	            }
+		    }
+    	}
+    }
+    
+	public void PanickNearbyAnimals( DamageSource damageSource )
+	{
+		Entity attackingEntity = damageSource.getEntity();
+
+		if ( attackingEntity != null && ( attackingEntity instanceof EntityLiving ) )
+		{
+			EntityLiving attackingEntityLiving = (EntityLiving)attackingEntity;
+			
+	        List animalList = worldObj.getEntitiesWithinAABB( EntityAnimal.class, boundingBox.expand( 16D, 8D, 16D ) );
+	        
+	        Iterator itemIterator = animalList.iterator();
+	
+	        while ( itemIterator.hasNext())
+	        {
+	    		EntityAnimal tempAnimal = (EntityAnimal)itemIterator.next();
+	    		
+		        if ( !(tempAnimal.isLivingDead) && tempAnimal != this && tempAnimal != attackingEntityLiving )
+		        {
+		        	tempAnimal.OnNearbyAnimalAttacked( this, attackingEntityLiving ); 
+		        }
+		        
+	        }
+		}
+	}
+	
+	public void OnNearbyAnimalAttacked( EntityAnimal attackedAnimal, EntityLiving attackSource )
+	{
+		// only freak the animal out if it isn't already freaked by something else
+		
+		if ( entityLivingToAttack == null )
+		{
+	        entityLivingToAttack = attackSource;	        
+        	revengeTimer = 150; // 7.5 seconds
+		}
+		else if ( revengeTimer < 150 )
+		{
+			revengeTimer = 150;
+		}
+	}
+
+	public void OnNearbyFireStartAttempt( EntityPlayer player )
+	{
+		OnNearbyPlayerStartles( player );
+	}
+	
+	public void OnNearbyPlayerBlockAddOrRemove( EntityPlayer player )
+	{
+		OnNearbyPlayerStartles( player );
+	}
+	
+	protected void OnNearbyPlayerStartles( EntityPlayer player )
+	{
+		// only freak the animal out if it isn't already freaked by something else
+		
+		if ( entityLivingToAttack == null )
+		{
+	        entityLivingToAttack = player;	        
+        	revengeTimer = 150; // 7.5 seconds
+		}
+		else if ( revengeTimer < 150 )
+		{
+			revengeTimer = 150;
+		}
+	}
+	
+    protected void procreate( EntityAnimal targetMate )
+    {
+    	// Replacement for vanilla function above
+    	
+		double dChildX = posX;
+		double dChildY = posY;
+		double dChildZ = posZ;
+		
+        if ( getWearingBreedingHarness() )
+        {
+        	dChildX = ( posX + targetMate.posX ) / 2.0F;
+        	dChildY = ( posY + targetMate.posY ) / 2.0F;
+        	dChildZ = ( posZ + targetMate.posZ ) / 2.0F;                	
+        }
+        
+        GiveBirthAtTargetLocation( targetMate, dChildX, dChildY, dChildZ );
+        
+    	ResetMatingStateOfBothParents( targetMate );
+    	
+        SpawnBirthHeartParticles();
+
+        worldObj.playSoundAtEntity( this, getDeathSound(), getSoundVolume(), (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F );
+        
+        worldObj.playAuxSFX( FCBetterThanWolves.m_iAnimalBirthingAuxFXID,  
+    		MathHelper.floor_double( dChildX ), MathHelper.floor_double( dChildY ), MathHelper.floor_double( dChildZ ), 
+    		0 );            
+    }
+    
+    protected void GiveBirthAtTargetLocation( EntityAnimal targetMate, double dChildX, double dChildY, double dChildZ )
+    {
+        EntityAgeable childEntity = createChild( targetMate );
+
+        if ( childEntity != null )
+        {
+            childEntity.setGrowingAge( -GetTicksForChildToGrow() );
+            
+        	childEntity.setLocationAndAngles( dChildX, dChildY, dChildZ, rotationYaw, rotationPitch );
+            
+            worldObj.spawnEntityInWorld( childEntity );            
+        }
+    }
+    
+    protected void ResetMatingStateOfBothParents( EntityAnimal targetMate )
+    {
+        setGrowingAge( GetTicksToRegenerateLoveJuice() );
+        targetMate.setGrowingAge( targetMate.GetTicksToRegenerateLoveJuice() );
+        
+        resetInLove();            
+        breeding = 0;
+        entityToAttack = null;
+        
+        targetMate.resetInLove();            
+        targetMate.entityToAttack = null;
+        targetMate.breeding = 0;        
+    }
+    
+    protected void SpawnBirthHeartParticles()
+    {
+        for ( int iTempCount = 0; iTempCount < 7; ++iTempCount )
+        {
+            double dParticleVelX = this.rand.nextGaussian() * 0.02D;
+            double dParticleVelY = this.rand.nextGaussian() * 0.02D;
+            double dParticleVelZ = this.rand.nextGaussian() * 0.02D;
+            
+            worldObj.spawnParticle( "heart", 
+            	this.posX + (double)(this.rand.nextFloat() * this.width * 2.0F) - (double)this.width, 
+            	this.posY + 0.5D + (double)(this.rand.nextFloat() * this.height), 
+            	this.posZ + (double)(this.rand.nextFloat() * this.width * 2.0F) - (double)this.width, 
+            	dParticleVelX, dParticleVelY, dParticleVelZ);
+        }
+    }
+    
+    //-------------- Hunger related functionality ------------//
+    
+    protected static final int m_iFullHungerCount = ( FCUtilsMisc.m_iTicksPerGameDay );
+    protected static final int m_iLevelUpHungerCount = ( m_iFullHungerCount + 
+    	( m_iFullHungerCount / 16 ) );
+    
+    protected static final int m_iMaxHealingCount = ( FCUtilsMisc.m_iTicksPerGameDay );
+    
+    protected int m_iHungerCountdown = m_iFullHungerCount;
+    protected int m_iHealingCountdown = m_iFullHungerCount;
+    
+    public static final int m_iBaseGrazeFoodValue = 200;
+    
+    protected static final int m_iDelayBetweenEatLoose = ( FCUtilsMisc.m_iTicksPerSecond / 2 );
+    
+    protected static final int m_iDelayBetweenEatLooseVariance = 
+    	( FCUtilsMisc.m_iTicksPerSecond / 2 );
+    
+    protected int m_iEatLooseCooldownCounter = ( m_iDelayBetweenEatLoose + 
+    	m_iDelayBetweenEatLooseVariance );
+    
+    protected int m_iGrazeProgressCounter = 0;
+    
+    public void InitHungerWithVariance()
+    {
+    	// prevent initially spawned animals from all eating at the same time.
+    	
+    	if ( IsSubjectToHunger() )
+    	{
+    		m_iHungerCountdown = m_iFullHungerCount - rand.nextInt( GetGrazeHungerGain() );
+    	}
+    }
+    
+    protected int GetHungerLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHungerLevelDataWatcherID );
+    }
+    
+    protected void SetHungerLevel( int iHungerLevel )
+    {
+        dataWatcher.updateObject( m_iHungerLevelDataWatcherID, Byte.valueOf( (byte)iHungerLevel ) );
+    }
+    
+    protected boolean IsFullyFed()
+    {
+        return GetHungerLevel() == 0;
+    }
+    
+    protected boolean IsFamished()
+    {
+        return GetHungerLevel() == 1;
+    }
+    
+    protected boolean IsStarving()
+    {
+        return GetHungerLevel() >= 2;
+    }    
+    
+    protected void OnBecomeFamished()
+    {
+		SetHungerLevel( 1 );
+    }
+    
+    public void OnBecomeStarving()
+    {
+		SetHungerLevel( 2 );
+    }
+    
+    protected void OnStarvingCountExpired()
+    {
+		// max health 20 wolves, 15 cows, 10 pigs, 8 sheep, 4 chicken
+		
+		attackEntityFrom( DamageSource.starve, 5 );
+    }
+    
+    public boolean IsSubjectToHunger()
+    {
+    	return false;
+    }
+    
+    protected void UpdateHungerState()
+    {
+    	if ( IsSubjectToHunger() )
+    	{
+    		if ( !isChild() )
+    		{
+    			m_iHungerCountdown--;
+    		}
+    		else    			
+    		{
+    			// children burn more energy
+    			
+    			m_iHungerCountdown -= 2;
+    		}
+	    	
+	    	if ( m_iHungerCountdown <= 0 )
+	    	{
+	    		if ( !isChild() )
+	        	{
+		    		if ( IsFullyFed() )
+		    		{
+	    				OnBecomeFamished();
+		    		}
+		    		else if ( IsFamished() )
+		    		{
+		    			OnBecomeStarving();
+		    		}
+		    		else // starving
+		    		{
+		    			OnStarvingCountExpired();
+		    		}
+		    		
+		    		ResetHungerCountdown();
+	        	}
+	    		else 
+	    		{ 
+	    			// children can not survive being famished.  They'll
+	    			// just keep taking damage once their countdown expires
+	    			
+	    			attackEntityFrom( DamageSource.starve, 1 );
+	    		}		
+	    	}
+    	}
+    }
+    
+    protected void ResetHungerCountdown()
+    {
+    	m_iHungerCountdown = m_iFullHungerCount; 
+    }    
+    
+    protected void AddToHungerCount( int iAddedHunger )
+    {
+    	m_iHungerCountdown += iAddedHunger;
+    	
+    	// don't level up immediately when full to prevent flickering state
+    	
+    	if ( m_iHungerCountdown > m_iLevelUpHungerCount )
+    	{
+    		int iHungerLevel = GetHungerLevel();
+    		
+    		if ( iHungerLevel > 0 )
+    		{
+        		m_iHungerCountdown -= m_iFullHungerCount;
+        		
+    			SetHungerLevel( iHungerLevel - 1 );
+    		}
+    	}    	
+    }
+    
+    protected int GetGrazeHungerGain()
+    {
+    	return m_iBaseGrazeFoodValue * GetFoodValueMultiplier();
+    }
+    
+    protected int GetFoodValueMultiplier()
+    {
+    	return 2;
+    }
+    
+    public void OnGrazeBlock( int i, int j, int k )
+    {
+    	AddToHungerCount( GetGrazeHungerGain() );
+    }
+    
+    public boolean ShouldNotifyBlockOnGraze()
+    {
+    	return true;
+    }
+    
+    public void PlayGrazeFX( int i, int j, int k, int iBlockID )
+    {
+		worldObj.playAuxSFX( 2001, i, j, k, iBlockID ); 
+    }
+    
+    public int GetGrazeDuration()
+    {
+    	return 40;
+    }
+    
+    public boolean IsHungryEnoughToGraze()
+    {
+		return !IsFullyFed() || m_iHungerCountdown + GetGrazeHungerGain() <= 
+			m_iFullHungerCount;
+    }
+    
+    public boolean IsHungryEnoughToForceMoveToGraze()
+    {
+		return isChild() || !IsFullyFed() || m_iHungerCountdown < m_iFullHungerCount / 2;
+    }
+    
+    protected boolean IsTooHungryToGrow()
+    {
+    	return !IsFullyFed() || m_iHungerCountdown < ( m_iFullHungerCount * 3 ) / 4;    	
+    }
+    
+    protected boolean IsTooHungryToHeal()
+    {
+    	return !IsFullyFed() || m_iHungerCountdown < ( m_iFullHungerCount * 3 ) / 4;    	
+    }
+    
+    public boolean CanGrazeMycelium()
+    {
+    	return false;
+    }
+    
+    public boolean GetDisruptsEarthOnGraze()
+    {
+    	return false;
+    }
+    
+    public boolean CanGrazeOnRoughVegetation()
+    {
+    	return false;
+    }
+    
+    /**
+     * Returns null if no valid graze block exists at location
+     */    
+    public FCUtilsBlockPos GetGrazeBlockForPos()
+    {
+    	FCUtilsBlockPos targetPos = new FCUtilsBlockPos( MathHelper.floor_double( posX ), 
+    		(int)boundingBox.minY, MathHelper.floor_double( posZ ) );
+    	
+    	if ( CanGrazeOnBlock( targetPos.i, targetPos.j, targetPos.k ) )
+    	{
+    		return targetPos;
+    	}
+    	else
+    	{
+    		targetPos.j--;
+    		
+        	if ( CanGrazeOnBlock( targetPos.i, targetPos.j, targetPos.k ) )
+        	{
+        		return targetPos;
+        	}
+    	}
+        
+        return null;
+    }
+    
+    public boolean ShouldStayInPlaceToGraze()
+    {
+    	return GetGrazeBlockForPos() != null;
+    }
+    
+    public boolean CanGrazeOnBlock( int i, int j, int k )
+    {
+    	Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
+    	
+    	if ( block != null )
+    	{
+    		return block.CanBeGrazedOn( worldObj, i, j, k, this );
+    	}
+    	
+    	return false;
+    }
+    
+    protected float GetHungerSpeedModifier()
+    {
+    	if ( IsStarving() )
+    	{
+    		return 0.5F;
+    	}
+    	else if ( IsFamished() )
+    	{
+    		return 0.75F;
+    	}
+    	
+    	return 1F;
+    }
+
+    public boolean IsTemptingItem( ItemStack stack )
+    {
+    	return GetItemFoodValue( stack ) > 0 || 
+    		( isBreedingItem( stack ) && IsReadyToEatBreedingItem() );
+    }
+    
+    public boolean IsEdibleItem( ItemStack stack )
+    {
+    	return isBreedingItem( stack ) || GetItemFoodValue( stack ) > 0;
+    }
+
+    protected boolean IsHungryEnoughToEatLooseFood()
+    {
+		return !IsFullyFed() || m_iHungerCountdown <= m_iFullHungerCount;
+    }
+    
+    protected boolean IsReadyToEatBreedingItem()
+    {
+    	return IsFullyFed() && getGrowingAge() == 0 && !isInLove();
+    }
+    
+    protected int GetItemFoodValue( ItemStack stack )
+    {
+    	return stack.getItem().GetHerbivoreFoodValue( stack.getItemDamage() ) * 
+    		GetFoodValueMultiplier();
+    }
+    
+    protected boolean AttemptToEatItemForBreeding( ItemStack stack )
+    {
+        if ( isBreedingItem( stack ) && IsReadyToEatBreedingItem() )
+        {
+        	OnEatBreedingItem();
+			
+			return true;
+        }
+        
+        return false;
+    }
+    
+    protected void OnEatBreedingItem()
+    {
+        setInLove( 600 );
+        entityToAttack = null;
+        
+        for( int iTempCount = 0; iTempCount < 7; iTempCount++ )
+        {
+            worldObj.spawnParticle( "heart", 
+            	posX + (double)( ( rand.nextFloat() * width * 2F ) - width ), 
+            	posY + 0.5D + (double)( rand.nextFloat() * height ), 
+            	posZ + (double)( ( rand.nextFloat() * width * 2.0F ) - width ), 
+        		rand.nextGaussian() * 0.02D, rand.nextGaussian() * 0.02D, 
+        		rand.nextGaussian() * 0.02D ); // last 3 are velocity
+        }
+    }
+    
+    protected boolean AttemptToEatItem( ItemStack stack )
+    {
+    	int iFoodValue = GetItemFoodValue( stack );
+    	
+		if ( AttemptToEatItemForBreeding( stack ) || ( iFoodValue > 0 && 
+			IsHungryEnoughToEatLooseFood() ) )
+		{
+        	AddToHungerCount( iFoodValue );
+            
+            worldObj.setEntityState( this, (byte)10 ); // trigger eating anim on client
+            
+	        worldObj.playAuxSFX( FCBetterThanWolves.m_iAnimalEatAuxFXID,	                
+                MathHelper.floor_double( posX ), (int)( posY + height ),
+                MathHelper.floor_double( posZ ), 0 );
+	        
+        	return true;
+		}
+		
+        return false;
+    }
+    
+    public boolean AttemptToBeHandFedItem( ItemStack stack )
+    {
+    	return AttemptToEatItem( stack );
+    }
+
+    protected boolean AttemptToEatLooseItem( ItemStack stack )
+    {
+    	return AttemptToEatItem( stack );
+    }
+    
+    public boolean IsReadyToEatLooseFood()
+    {
+    	return IsHungryEnoughToEatLooseFood() || IsReadyToEatBreedingItem();
+    }
+    
+    public boolean IsReadyToEatLooseItem( ItemStack stack )
+    {
+    	return ( GetItemFoodValue( stack ) > 0 && IsHungryEnoughToEatLooseFood() ) || 
+			( isBreedingItem( stack ) && IsReadyToEatBreedingItem() );
+    }
+    
+    protected void CheckForLooseFood()
+    {    
+    	if ( m_iEatLooseCooldownCounter > 0 )
+    	{
+    		m_iEatLooseCooldownCounter--;
+    	}
+    	else if ( IsReadyToEatLooseFood() )
+    	{
+		    List<EntityItem> entityList = worldObj.getEntitiesWithinAABB( 
+		    	EntityItem.class, AxisAlignedBB.getAABBPool().getAABB( 
+				boundingBox.minX - 1.5F, boundingBox.minY - 1F, boundingBox.minZ - 1.5F, 
+				boundingBox.maxX + 1.5F, boundingBox.maxY + 1F, boundingBox.maxZ + 1.5F ) );
+		    
+		    if ( !entityList.isEmpty() )
+		    {
+		    	Iterator<EntityItem> entityIterator = entityList.iterator();
+
+		    	while ( entityIterator.hasNext() )
+	            {
+		    		EntityItem tempEntity = entityIterator.next();
+		    		
+			        if ( tempEntity.delayBeforeCanPickup == 0 && tempEntity.isEntityAlive() )
+			        {
+			        	ItemStack tempStack = tempEntity.getEntityItem();
+			        	
+			        	if ( AttemptToEatLooseItem( tempEntity.getEntityItem() ) )
+		        		{
+			                tempStack.stackSize--;
+			                
+			                if ( tempStack.stackSize <= 0 )
+			                {
+			    	            tempEntity.setDead();					            
+			                }
+			                else
+			                {
+			                	// slight delay on pickup so animals don't all eat from a stack
+			                	// at once
+			                	
+			                	tempEntity.delayBeforeCanPickup = 2; 			                	
+			                }
+			                
+		    	            m_iEatLooseCooldownCounter = m_iDelayBetweenEatLoose +
+		    	            	rand.nextInt( m_iDelayBetweenEatLooseVariance + 1 );
+					        
+			    			break;				            
+		        		}			        		
+		    		}
+	            }
+		    }
+    	}
+    }
+    
+    public boolean EntityAnimalInteract( EntityPlayer player )
+    {
+        ItemStack heldItem = player.inventory.getCurrentItem();
+
+        if ( heldItem != null )
+        {
+        	if ( IsEdibleItem( heldItem ) )
+        	{
+	        	if ( !worldObj.isRemote && AttemptToBeHandFedItem( heldItem ) )
+	        	{
+	                heldItem.stackSize--;
+	
+	                if ( heldItem.stackSize <= 0 )
+	                {
+	                    player.inventory.setInventorySlotContents( player.inventory.currentItem, 
+	                    	null );
+	                }
+	        	}
+	        	
+	            return true;
+        	}
+        }
+        
+        return super.interact( player );
+    }
+    
+    protected int GetTicksToRegenerateLoveJuice()
+    {
+    	return FCUtilsMisc.m_iTicksPerGameDay;
+    }
+    
+    public float GetGrazeHeadVerticalOffset( float fPartialTick )
+    {
+    	int iGrazeDuration = GetGrazeDuration(); 
+		
+    	if ( getWearingBreedingHarness() || m_iGrazeProgressCounter <= 0 )
+    	{
+            return 0F;
+    	}
+    	else if ( m_iGrazeProgressCounter >= 4 && m_iGrazeProgressCounter <= iGrazeDuration - 4 )
+    	{
+    		return 1F;
+    	}
+    	else if ( m_iGrazeProgressCounter < 4 )
+    	{
+    		return ( (float)m_iGrazeProgressCounter - fPartialTick ) / 4F;
+    	}
+    	else
+    	{
+            return -( (float)( m_iGrazeProgressCounter - iGrazeDuration ) - fPartialTick ) / 4F;
+    	}    	
+    }
+    
+    public float GetGrazeHeadRotation( float fPartialTick )
+    {
+    	int iGrazeDuration = GetGrazeDuration(); 
+		
+    	if ( getWearingBreedingHarness() || m_iGrazeProgressCounter <= 0 )
+    	{
+            return rotationPitch / ( 180F / (float)Math.PI );
+    	}
+    	else if ( m_iGrazeProgressCounter > 4 && m_iGrazeProgressCounter <= iGrazeDuration - 4 )
+        {
+            float fProgress = ((float)( m_iGrazeProgressCounter - 4 ) - fPartialTick ) / 
+            	(float)( iGrazeDuration - 8 );
+            
+            return ( (float)Math.PI / GetGrazeHeadRotationMagnitudeDivisor() ) + 
+            	( (float)Math.PI * 7F / 100F ) * 
+            	MathHelper.sin( fProgress * GetGrazeHeadRotationRateMultiplier() );
+        }
+        else
+        {
+            return (float)Math.PI / GetGrazeHeadRotationMagnitudeDivisor(); 
+        }
+    }
+    
+    protected float GetGrazeHeadRotationMagnitudeDivisor()
+    {
+    	return 5F;
+    }
+    
+    protected float GetGrazeHeadRotationRateMultiplier()
+    {
+    	return 28.7F;
+    }
+    
+    protected void UpdateHealing()
+    {
+    	if ( IsSubjectToHunger() && !isChild() )
+    	{
+    		if ( IsTooHungryToHeal() )
+    		{
+    			ResetHealingCountdown();
+    		}
+    		else
+    		{
+    			m_iHealingCountdown--;
+    			
+    			if ( m_iHealingCountdown <= 0 )
+    			{
+    				heal( 1 );
+    				
+        			ResetHealingCountdown();
+    			}
+    		}
+    	}
+    }
+    
+    protected void ResetHealingCountdown()
+    {
+    	m_iHealingCountdown = m_iMaxHealingCount; 
+    }    
+    
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public void handleHealthUpdate( byte bUpdateType )
+    {
+        if ( bUpdateType == 10 )
+        {
+        	m_iGrazeProgressCounter = GetGrazeDuration();
+        }
+        else
+        {
+            super.handleHealthUpdate( bUpdateType );
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityArrow.java b/minecraft/net/minecraft/src/EntityArrow.java
index dfce7a1..497f8d7 100644
--- a/minecraft/net/minecraft/src/EntityArrow.java
+++ b/minecraft/net/minecraft/src/EntityArrow.java
@@ -4,12 +4,22 @@ import java.util.List;
 
 public class EntityArrow extends Entity implements IProjectile
 {
+	// FCMOD: Changed to protected
+	/*
     private int xTile = -1;
     private int yTile = -1;
     private int zTile = -1;
     private int inTile = 0;
     private int inData = 0;
     private boolean inGround = false;
+    */
+    protected int xTile = -1;
+    protected int yTile = -1;
+    protected int zTile = -1;
+    protected int inTile = 0;
+    protected int inData = 0;
+    protected boolean inGround = false;
+	// END FCMOD
 
     /** 1 if the player can pick up the arrow */
     public int canBePickedUp = 0;
@@ -174,7 +184,9 @@ public class EntityArrow extends Entity implements IProjectile
 
         if (var16 > 0)
         {
-            Block.blocksList[var16].setBlockBoundsBasedOnState(this.worldObj, this.xTile, this.yTile, this.zTile);
+        	// FCMOD: Removed due to deprecation
+            //Block.blocksList[var16].setBlockBoundsBasedOnState(this.worldObj, this.xTile, this.yTile, this.zTile);
+        	// END FCMOD
             AxisAlignedBB var2 = Block.blocksList[var16].getCollisionBoundingBoxFromPool(this.worldObj, this.xTile, this.yTile, this.zTile);
 
             if (var2 != null && var2.isVecInside(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ)))
@@ -193,11 +205,21 @@ public class EntityArrow extends Entity implements IProjectile
             int var18 = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
             int var19 = this.worldObj.getBlockMetadata(this.xTile, this.yTile, this.zTile);
 
+            // FCMOD: Changed this line
+			/*
             if (var18 == this.inTile && var19 == this.inData)
+			*/
+            if (var18 == this.inTile && ( var19 == this.inData || var18 == FCBetterThanWolves.fcBlockDetector.blockID ) )
+    		// END FCMOD
             {
                 ++this.ticksInGround;
 
+                // FCMOD: Changed this to increase arrow despawn time to be same as items
+                /*
                 if (this.ticksInGround == 1200)
+                */
+                if ( ticksInGround >= 6000 )
+            	// END FCMOD
                 {
                     this.setDead();
                 }
@@ -262,38 +284,38 @@ public class EntityArrow extends Entity implements IProjectile
 
             if (var4 != null && var4.entityHit != null && var4.entityHit instanceof EntityPlayer)
             {
-                EntityPlayer var20 = (EntityPlayer)var4.entityHit;
+                EntityPlayer var21 = (EntityPlayer)var4.entityHit;
 
-                if (var20.capabilities.disableDamage || this.shootingEntity instanceof EntityPlayer && !((EntityPlayer)this.shootingEntity).func_96122_a(var20))
+                if (var21.capabilities.disableDamage || this.shootingEntity instanceof EntityPlayer && !((EntityPlayer)this.shootingEntity).func_96122_a(var21))
                 {
                     var4 = null;
                 }
             }
 
-            float var21;
+            float var20;
             float var27;
 
             if (var4 != null)
             {
                 if (var4.entityHit != null)
                 {
-                    var21 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
-                    int var22 = MathHelper.ceiling_double_int((double)var21 * this.damage);
+                    var20 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
+                    int var24 = MathHelper.ceiling_double_int((double)var20 * this.damage);
 
                     if (this.getIsCritical())
                     {
-                        var22 += this.rand.nextInt(var22 / 2 + 2);
+                        var24 += this.rand.nextInt(var24 / 2 + 2);
                     }
 
-                    DamageSource var23 = null;
+                    DamageSource var22 = null;
 
                     if (this.shootingEntity == null)
                     {
-                        var23 = DamageSource.causeArrowDamage(this, this);
+                        var22 = DamageSource.causeArrowDamage(this, this);
                     }
                     else
                     {
-                        var23 = DamageSource.causeArrowDamage(this, this.shootingEntity);
+                        var22 = DamageSource.causeArrowDamage(this, this.shootingEntity);
                     }
 
                     if (this.isBurning() && !(var4.entityHit instanceof EntityEnderman))
@@ -301,7 +323,12 @@ public class EntityArrow extends Entity implements IProjectile
                         var4.entityHit.setFire(5);
                     }
 
-                    if (var4.entityHit.attackEntityFrom(var23, var22))
+                    // FCMOD: Line changed
+                    /*
+                    if (var4.entityHit.attackEntityFrom(var22, var24))
+                    */
+	                if ( var4.entityHit.attackEntityFrom( var22, (int)((float)var24 * GetDamageMultiplier() ) ))
+	            	// END FCMOD
                     {
                         if (var4.entityHit instanceof EntityLiving)
                         {
@@ -357,13 +384,16 @@ public class EntityArrow extends Entity implements IProjectile
                     this.zTile = var4.blockZ;
                     this.inTile = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
                     this.inData = this.worldObj.getBlockMetadata(this.xTile, this.yTile, this.zTile);
+                    // FCMOD: Added
+                    NotifyColldingBlockOfImpact();
+                    // END FCMOD
                     this.motionX = (double)((float)(var4.hitVec.xCoord - this.posX));
                     this.motionY = (double)((float)(var4.hitVec.yCoord - this.posY));
                     this.motionZ = (double)((float)(var4.hitVec.zCoord - this.posZ));
-                    var21 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
-                    this.posX -= this.motionX / (double)var21 * 0.05000000074505806D;
-                    this.posY -= this.motionY / (double)var21 * 0.05000000074505806D;
-                    this.posZ -= this.motionZ / (double)var21 * 0.05000000074505806D;
+                    var20 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
+                    this.posX -= this.motionX / (double)var20 * 0.05000000074505806D;
+                    this.posY -= this.motionY / (double)var20 * 0.05000000074505806D;
+                    this.posZ -= this.motionZ / (double)var20 * 0.05000000074505806D;
                     this.playSound("random.bowhit", 1.0F, 1.2F / (this.rand.nextFloat() * 0.2F + 0.9F));
                     this.inGround = true;
                     this.arrowShake = 7;
@@ -387,10 +417,10 @@ public class EntityArrow extends Entity implements IProjectile
             this.posX += this.motionX;
             this.posY += this.motionY;
             this.posZ += this.motionZ;
-            var21 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            var20 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
             this.rotationYaw = (float)(Math.atan2(this.motionX, this.motionZ) * 180.0D / Math.PI);
 
-            for (this.rotationPitch = (float)(Math.atan2(this.motionY, (double)var21) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
+            for (this.rotationPitch = (float)(Math.atan2(this.motionY, (double)var20) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
             {
                 ;
             }
@@ -412,7 +442,7 @@ public class EntityArrow extends Entity implements IProjectile
 
             this.rotationPitch = this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
             this.rotationYaw = this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
-            float var24 = 0.99F;
+            float var23 = 0.99F;
             var11 = 0.05F;
 
             if (this.isInWater())
@@ -423,16 +453,19 @@ public class EntityArrow extends Entity implements IProjectile
                     this.worldObj.spawnParticle("bubble", this.posX - this.motionX * (double)var27, this.posY - this.motionY * (double)var27, this.posZ - this.motionZ * (double)var27, this.motionX, this.motionY, this.motionZ);
                 }
 
-                var24 = 0.8F;
+                var23 = 0.8F;
             }
 
-            this.motionX *= (double)var24;
-            this.motionY *= (double)var24;
-            this.motionZ *= (double)var24;
+            this.motionX *= (double)var23;
+            this.motionY *= (double)var23;
+            this.motionZ *= (double)var23;
             this.motionY -= (double)var11;
             this.setPosition(this.posX, this.posY, this.posZ);
             this.doBlockCollisions();
         }
+        // FCMOD: Added        
+        NotifyAnyCollidingBlocks();
+        // END FCMOD
     }
 
     /**
@@ -449,6 +482,10 @@ public class EntityArrow extends Entity implements IProjectile
         par1NBTTagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
         par1NBTTagCompound.setByte("pickup", (byte)this.canBePickedUp);
         par1NBTTagCompound.setDouble("damage", this.damage);
+        
+        // FCMOD: Added
+        par1NBTTagCompound.setShort( "fcInTileEx", (short)this.inTile );
+	    // END FCMOD    
     }
 
     /**
@@ -477,6 +514,13 @@ public class EntityArrow extends Entity implements IProjectile
         {
             this.canBePickedUp = par1NBTTagCompound.getBoolean("player") ? 1 : 0;
         }
+        
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcInTileEx" ) )
+        {
+        	inTile = par1NBTTagCompound.getShort( "fcInTileEx" );
+        }
+	    // END FCMOD    
     }
 
     /**
@@ -488,7 +532,12 @@ public class EntityArrow extends Entity implements IProjectile
         {
             boolean var2 = this.canBePickedUp == 1 || this.canBePickedUp == 2 && par1EntityPlayer.capabilities.isCreativeMode;
 
+            // FCMOD: Changed line
+            /*
             if (this.canBePickedUp == 1 && !par1EntityPlayer.inventory.addItemStackToInventory(new ItemStack(Item.arrow, 1)))
+	        */
+	        if ( canBePickedUp == 1 && !AddArrowToPlayerInv( par1EntityPlayer ) )
+	    	// END FCMOD
             {
                 var2 = false;
             }
@@ -567,4 +616,49 @@ public class EntityArrow extends Entity implements IProjectile
         byte var1 = this.dataWatcher.getWatchableObjectByte(16);
         return (var1 & 1) != 0;
     }
+    
+    // FCMOD: Code added
+    protected float GetDamageMultiplier()
+    {
+    	return 1F;
+    }
+    
+	protected boolean AddArrowToPlayerInv( EntityPlayer player )
+	{
+		return player.inventory.addItemStackToInventory( new ItemStack( GetCorrespondingItem(), 1 ) );
+	}
+	
+	public Item GetCorrespondingItem()
+	{
+		return Item.arrow;
+	}
+	
+	public boolean CanHopperCollect()
+	{
+		return true;
+	}
+	
+	private void NotifyAnyCollidingBlocks()
+	{
+        if ( inGround )
+        {
+            Block blockHit = Block.blocksList[inTile];
+            
+            if ( blockHit != null )
+            {
+            	blockHit.OnArrowCollide( worldObj, xTile, yTile, zTile, this );
+            }
+        }
+	}
+	
+    private void NotifyColldingBlockOfImpact()
+    {
+	    Block blockHit = Block.blocksList[inTile];
+	    
+	    if ( blockHit != null )
+	    {
+	    	blockHit.OnArrowImpact( worldObj, xTile, yTile, zTile, this );
+	    }
+    }
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityAuraFX.java b/minecraft/net/minecraft/src/EntityAuraFX.java
index 119b63b..2c5c6a8 100644
--- a/minecraft/net/minecraft/src/EntityAuraFX.java
+++ b/minecraft/net/minecraft/src/EntityAuraFX.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntityAuraFX extends EntityFX
 {
     public EntityAuraFX(World par1World, double par2, double par4, double par6, double par8, double par10, double par12)
@@ -37,4 +40,16 @@ public class EntityAuraFX extends EntityFX
             this.setDead();
         }
     }
+    
+    public EntityAuraFX colorize()
+    {
+        if (ColorizeEntity.computeMyceliumParticleColor())
+        {
+            this.particleRed = Colorizer.setColor[0];
+            this.particleGreen = Colorizer.setColor[1];
+            this.particleBlue = Colorizer.setColor[2];
+        }
+
+        return this;
+    }
 }
diff --git a/minecraft/net/minecraft/src/EntityBat.java b/minecraft/net/minecraft/src/EntityBat.java
index f73e485..7356231 100644
--- a/minecraft/net/minecraft/src/EntityBat.java
+++ b/minecraft/net/minecraft/src/EntityBat.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/23/2018
+
 package net.minecraft.src;
 
 import java.util.Calendar;
diff --git a/minecraft/net/minecraft/src/EntityBlaze.java b/minecraft/net/minecraft/src/EntityBlaze.java
index ba0a70b..b5cf059 100644
--- a/minecraft/net/minecraft/src/EntityBlaze.java
+++ b/minecraft/net/minecraft/src/EntityBlaze.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/27/2018
+
 package net.minecraft.src;
 
 public class EntityBlaze extends EntityMob
diff --git a/minecraft/net/minecraft/src/EntityBoat.java b/minecraft/net/minecraft/src/EntityBoat.java
index 6f02101..4fb95f2 100644
--- a/minecraft/net/minecraft/src/EntityBoat.java
+++ b/minecraft/net/minecraft/src/EntityBoat.java
@@ -4,6 +4,7 @@ import java.util.List;
 
 public class EntityBoat extends Entity
 {
+	// FCNOTE: The following seems to be false if the boat is ridden by the local player
     private boolean field_70279_a;
     private double speedMultiplier;
     private int boatPosRotationIncrements;
@@ -196,7 +197,7 @@ public class EntityBoat extends Entity
     public void onUpdate()
     {
         super.onUpdate();
-
+    	
         if (this.getTimeSinceHit() > 0)
         {
             this.setTimeSinceHit(this.getTimeSinceHit() - 1);
@@ -224,6 +225,15 @@ public class EntityBoat extends Entity
                 var2 += 1.0D / (double)var1;
             }
         }
+        
+        // FCMOD: Added
+        if ( var2 > 0.1F )
+        {
+        	// var 2 tracks how deep the boat is resting in the water
+            fallDistance = 0.0F;
+            extinguish();
+        }
+        // END FCMOD
 
         double var23 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
         double var6;
@@ -259,6 +269,7 @@ public class EntityBoat extends Entity
         double var12;
         double var25;
 
+        // FCNOTE: The below test is "if remote and not ridden by the local player" (field_70279_a is false if ridden by local player)
         if (this.worldObj.isRemote && this.field_70279_a)
         {
             if (this.boatPosRotationIncrements > 0)
@@ -309,6 +320,8 @@ public class EntityBoat extends Entity
                 this.motionY += 0.007000000216066837D;
             }
 
+            // FCMOD: modify boat speed by whether player is holding a sail
+            /*
             if (this.riddenByEntity != null)
             {
                 this.motionX += this.riddenByEntity.motionX * this.speedMultiplier;
@@ -324,6 +337,40 @@ public class EntityBoat extends Entity
                 this.motionZ *= var8;
                 var6 = 0.35D;
             }
+            */
+            double dMaxSpeed = 0.35D;
+            
+            if ( riddenByEntity != null )
+            {
+            	dMaxSpeed *= riddenByEntity.MovementModifierWhenRidingBoat();
+            	
+                this.motionX += this.riddenByEntity.motionX * this.speedMultiplier;
+                this.motionZ += this.riddenByEntity.motionZ * this.speedMultiplier;
+                
+            	if ( riddenByEntity.AppliesConstantForceWhenRidingBoat() )
+            	{
+            		motionX -= Math.cos( (double)rotationYaw * Math.PI / 180.0D ) * dMaxSpeed * 0.02;
+            		motionZ -= Math.sin( (double)rotationYaw * Math.PI / 180.0D ) * dMaxSpeed * 0.02;
+            	}
+            }
+
+            var6 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+
+            if ( var6 > dMaxSpeed )
+            {
+                double dSpeedModifier = dMaxSpeed / var6;
+                
+                if ( dSpeedModifier < 0.9D )
+                {
+                	dSpeedModifier = 0.9D;
+                }
+                
+                motionX *= dSpeedModifier;
+                motionZ *= dSpeedModifier;
+                
+                var6 *= dSpeedModifier;
+            }
+            // END FCMOD
 
             if (var6 > var23 && this.speedMultiplier < 0.35D)
             {
@@ -355,6 +402,8 @@ public class EntityBoat extends Entity
 
             if (this.isCollidedHorizontally && var23 > 0.2D)
             {
+            	// FCMOD: Changed
+            	/*
                 if (!this.worldObj.isRemote && !this.isDead)
                 {
                     this.setDead();
@@ -368,8 +417,11 @@ public class EntityBoat extends Entity
                     for (var24 = 0; var24 < 2; ++var24)
                     {
                         this.dropItemWithOffset(Item.stick.itemID, 1, 0.0F);
-                    }
+                    }                    
                 }
+                */
+            	BreakBoat();
+            	// END FCMOD
             }
             else
             {
@@ -431,7 +483,14 @@ public class EntityBoat extends Entity
                         int var21 = MathHelper.floor_double(this.posY) + var20;
                         int var22 = this.worldObj.getBlockId(var27, var21, var19);
 
+                        // FCMOD: Changed
+                        /*
                         if (var22 == Block.snow.blockID)
+                        */
+                        Block tempBlock = Block.blocksList[var22];
+                        
+                        if ( tempBlock != null && tempBlock.IsGroundCover( ) )
+                        // END FCMOD
                         {
                             this.worldObj.setBlockToAir(var27, var21, var19);
                         }
@@ -547,4 +606,40 @@ public class EntityBoat extends Entity
     {
         this.field_70279_a = par1;
     }
+    
+    // FCMOD: Code added
+    @Override
+    public boolean CanCollideWithEntity( Entity entity )
+    {
+    	return !entity.IsItemEntity();
+    }
+    
+    @Override
+    protected void fall( float fFallDistance )
+    {
+    	super.fall( fFallDistance );
+    	
+    	if ( fFallDistance > 5F )
+    	{
+    		BreakBoat();
+    	}
+    }
+    
+    public void BreakBoat()
+    {
+        if ( !worldObj.isRemote && !isDead )
+        {
+            setDead();
+
+            for ( int iCount = 0; iCount < 4; iCount++ )
+            {
+                dropItemWithOffset( Item.stick.itemID, 1, 0.0F );
+                
+                dropItemWithOffset( FCBetterThanWolves.fcItemSawDust.itemID, 1, 0.0F );
+            }
+            
+            playSound( "mob.zombie.woodbreak", 0.5F, 0.50F + ( rand.nextFloat() * 0.25F ) );
+        }
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityBubbleFX.java b/minecraft/net/minecraft/src/EntityBubbleFX.java
index 5df19bb..616a770 100644
--- a/minecraft/net/minecraft/src/EntityBubbleFX.java
+++ b/minecraft/net/minecraft/src/EntityBubbleFX.java
@@ -1,13 +1,27 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntityBubbleFX extends EntityFX
 {
     public EntityBubbleFX(World par1World, double par2, double par4, double par6, double par8, double par10, double par12)
     {
         super(par1World, par2, par4, par6, par8, par10, par12);
-        this.particleRed = 1.0F;
-        this.particleGreen = 1.0F;
-        this.particleBlue = 1.0F;
+        
+        if (ColorizeBlock.computeWaterColor(false, (int)this.posX, (int)this.posY, (int)this.posZ))
+        {
+            this.particleRed = Colorizer.setColor[0];
+            this.particleGreen = Colorizer.setColor[1];
+            this.particleBlue = Colorizer.setColor[2];
+        }
+        else
+        {
+            this.particleRed = 1.0F;
+            this.particleGreen = 1.0F;
+            this.particleBlue = 1.0F;
+        }
+        
         this.setParticleTextureIndex(32);
         this.setSize(0.02F, 0.02F);
         this.particleScale *= this.rand.nextFloat() * 0.6F + 0.2F;
diff --git a/minecraft/net/minecraft/src/EntityCaveSpider.java b/minecraft/net/minecraft/src/EntityCaveSpider.java
index 8d00f4f..beffc81 100644
--- a/minecraft/net/minecraft/src/EntityCaveSpider.java
+++ b/minecraft/net/minecraft/src/EntityCaveSpider.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityCaveSpider extends EntitySpider
@@ -59,5 +61,5 @@ public class EntityCaveSpider extends EntitySpider
     /**
      * Initialize this creature.
      */
-    public void initCreature() {}
+    public void initCreature() {}    
 }
diff --git a/minecraft/net/minecraft/src/EntityChicken.java b/minecraft/net/minecraft/src/EntityChicken.java
index a3974f4..e8859bb 100644
--- a/minecraft/net/minecraft/src/EntityChicken.java
+++ b/minecraft/net/minecraft/src/EntityChicken.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 08/10/2018
+
 package net.minecraft.src;
 
 public class EntityChicken extends EntityAnimal
diff --git a/minecraft/net/minecraft/src/EntityCow.java b/minecraft/net/minecraft/src/EntityCow.java
index dde7228..4fba4a8 100644
--- a/minecraft/net/minecraft/src/EntityCow.java
+++ b/minecraft/net/minecraft/src/EntityCow.java
@@ -1,5 +1,13 @@
+// FCMOD: Class changes deprecated 07/23/2018
+
 package net.minecraft.src;
 
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+
 public class EntityCow extends EntityAnimal
 {
     public EntityCow(World par1World)
diff --git a/minecraft/net/minecraft/src/EntityCreature.java b/minecraft/net/minecraft/src/EntityCreature.java
index 3482f3f..e443681 100644
--- a/minecraft/net/minecraft/src/EntityCreature.java
+++ b/minecraft/net/minecraft/src/EntityCreature.java
@@ -1,5 +1,10 @@
 package net.minecraft.src;
 
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.util.Iterator;
+import java.util.List;
+
 public abstract class EntityCreature extends EntityLiving
 {
     private PathEntity pathToEntity;
@@ -27,7 +32,7 @@ public abstract class EntityCreature extends EntityLiving
     {
         return false;
     }
-
+    
     protected void updateEntityActionState()
     {
         this.worldObj.theProfiler.startSection("ai");
@@ -53,10 +58,25 @@ public abstract class EntityCreature extends EntityLiving
         {
             float var2 = this.entityToAttack.getDistanceToEntity(this);
 
+            // FCMOD: Changed
+            /*
             if (this.canEntityBeSeen(this.entityToAttack))
             {
                 this.attackEntity(this.entityToAttack, var2);
             }
+            */
+            if ( ShouldContinueAttacking( var2 ) )
+        	{
+                if (this.canEntityBeSeen(this.entityToAttack))
+                {
+                    this.attackEntity(this.entityToAttack, var2);
+                }
+        	}
+            else
+            {
+                entityToAttack = null;
+            }
+            // END FCMOD
         }
         else
         {
@@ -69,7 +89,12 @@ public abstract class EntityCreature extends EntityLiving
         {
             this.pathToEntity = this.worldObj.getPathEntityToEntity(this, this.entityToAttack, var1, true, false, false, true);
         }
+        // FCMOD: Code changed to stop AI deactivating with distance
+        /*
         else if (!this.hasAttacked && (this.pathToEntity == null && this.rand.nextInt(180) == 0 || this.rand.nextInt(120) == 0 || this.fleeingTick > 0) && this.entityAge < 100)
+        */
+        else if (!this.hasAttacked && (this.pathToEntity == null && this.rand.nextInt(180) == 0 || this.rand.nextInt(120) == 0 || this.fleeingTick > 0))
+        // END FCMOD
         {
             this.updateWanderPath();
         }
@@ -156,6 +181,13 @@ public abstract class EntityCreature extends EntityLiving
             }
 
             this.worldObj.theProfiler.endSection();
+            
+            // FCMOD: Added as the lack of super call in this condition was causing spiders 
+            // with targets to hang out for an exceedingly long time without despawning
+            entityAge++;
+            
+            despawnEntity();            
+            // END FCMOD
         }
         else
         {
@@ -282,4 +314,299 @@ public abstract class EntityCreature extends EntityLiving
 
         return var1;
     }
+    
+    // FCMOD: Added New
+    private static final int m_iIsPossessedDataWatcherID = 24;
+    
+    protected int m_iPossessionTimer = -1; // - 1 is not possessed
+    
+    @Override
+    protected void entityInit()
+    {
+    	EntityCreatureEntityInit();
+    }
+    
+    protected void EntityCreatureEntityInit()
+    {
+    	// Added to alow calling entityInit() directly regardless of class hierarchy
+    	
+        super.entityInit();
+        
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+        	dataWatcher.addObject( m_iIsPossessedDataWatcherID, new Byte( (byte)0 ) );
+        }
+    }
+    
+    @Override
+    public void writeEntityToNBT( NBTTagCompound tag )
+    {
+        super.writeEntityToNBT( tag );
+        
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+	        tag.setInteger( "fcPossessionTimer", m_iPossessionTimer );
+	        
+	        tag.setByte( "fcPossessionLevel", (byte)GetPossessionLevel() );
+        }
+    }
+
+    @Override
+    public void readEntityFromNBT( NBTTagCompound tag )
+    {
+        super.readEntityFromNBT( tag );
+        
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+	        if ( tag.hasKey( "fcPossessionTimer" ) )
+	    	{
+	        	m_iPossessionTimer = tag.getInteger( "fcPossessionTimer" );
+	        
+	        	if ( m_iPossessionTimer >= 0 )
+	        	{
+	        		SetPossessionLevel( 1 );
+	        	}
+	        	else
+	        	{
+	        		SetPossessionLevel( 0 );
+	        	}
+	    	}
+	        else
+	        {
+	        	m_iPossessionTimer = -1;
+	        	
+	    		SetPossessionLevel( 0 );
+	        }
+	        
+	        if ( tag.hasKey( "fcPossessionLevel" ) )
+	        {
+	        	SetPossessionLevel( tag.getByte( "fcPossessionLevel" ) );
+	        }
+        }
+    }
+
+    @Override
+    protected void ModSpecificOnLivingUpdate()
+    {
+    	super.ModSpecificOnLivingUpdate();
+    	
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+        	HandlePossession();
+        }
+    }
+    
+    protected boolean GetCanCreatureTypeBePossessed()
+    {
+    	return false;
+    }
+    
+    protected boolean GetCanCreatureBePossessedFromDistance( boolean bPersistentSpirit )
+    {
+        return GetCanCreatureTypeBePossessed() && isEntityAlive() && !IsPossessed();
+    }
+    
+    protected boolean IsPossessed()
+    {
+    	return GetCanCreatureTypeBePossessed() && dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) != 0;    	
+    }
+    
+    protected boolean IsFullyPossessed()
+    {
+    	return GetCanCreatureTypeBePossessed() && dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) > 1;
+    }
+    
+    protected void SetPossessionLevel( int iLevel )
+    {    	
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+	    	byte byteValue = (byte)iLevel;
+	    	
+	        dataWatcher.updateObject( m_iIsPossessedDataWatcherID, Byte.valueOf( byteValue ) );
+        }
+    }
+
+    protected int GetPossessionLevel()
+    {    	
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+        	return (int)( dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) );
+        }
+        
+        return 0;
+    }
+    
+    protected int GetInitialPossessionChance()
+    {
+    	return 1000;    	
+    }
+    
+    protected int GetTimeToFullPossession()
+    {
+    	return 2400 + worldObj.rand.nextInt( 2400 ); // 2 to 4 minutes    	
+    }
+    
+    protected void OnInitialPossession()
+    {
+        worldObj.playSoundAtEntity( this, getDeathSound(), getSoundVolume(), (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F );
+        
+        worldObj.playAuxSFX( FCBetterThanWolves.m_iGhastMoanSoundAuxFXID, 
+        	MathHelper.floor_double( posX ), MathHelper.floor_double( posY ), MathHelper.floor_double( posZ ), 0 );            
+    }
+    
+    protected void OnFullPossession()
+    {
+    }
+    
+    public void InitiatePossession()
+    {
+		SetPossessionLevel( 1 );
+		
+		m_iPossessionTimer = GetTimeToFullPossession();
+		
+		OnInitialPossession();	    				
+    }
+    
+    protected void HandlePossession()
+    {
+    	if ( worldObj.getWorldInfo().getGameType() == EnumGameType.CREATIVE )
+    	{
+    		return;
+    	}
+    	
+        if ( !worldObj.isRemote )
+        {
+	    	if ( !IsPossessed() )
+	    	{
+	    		if ( worldObj.provider.dimensionId == -1 ) // is nether
+	    		{
+	    			if ( worldObj.rand.nextInt( GetInitialPossessionChance() ) == 0 )
+	    			{
+	    				InitiatePossession();	    				
+	    			}
+	    		}
+	    	}
+	    	else if ( !isChild() ) // children can be possessed but it won't take full effect until they grow up
+	    	{
+	    		if ( GetPossessionLevel() == 1 )
+	    		{
+		    		m_iPossessionTimer--;
+		    		
+		    		if ( m_iPossessionTimer < 0 )
+		    		{
+		    			m_iPossessionTimer = 0;
+		    		}
+		    		
+		    		if ( m_iPossessionTimer == 0 )
+		    		{
+		    			SetPossessionLevel( 2 );
+		    			
+		    			OnFullPossession();	    			
+		    		}
+	    		}
+	    	}
+        }
+    }
+    
+    protected boolean AttemptToPossessNearbyCreature( double dRange, boolean bPersistentSpirit )
+    {    	
+        List nearbyCreatures = worldObj.getEntitiesWithinAABB( EntityCreature.class, boundingBox.expand( dRange, dRange, dRange ) );
+        
+        Iterator itemIterator = nearbyCreatures.iterator();
+    	
+        while ( itemIterator.hasNext() )
+        {
+    		EntityCreature tempCreature = (EntityCreature)itemIterator.next();
+    		
+	        if ( tempCreature.GetCanCreatureBePossessedFromDistance( bPersistentSpirit ) && tempCreature != this )
+	        {
+	        	tempCreature.InitiatePossession();
+        		
+        		return true;
+	        }	        
+        }
+        
+    	return false;
+    }
+    
+    static public int AttemptToPossessCreaturesAroundBlock( World world, int i, int j, int k, int iPossessionCount, int iCubicRange )
+    {
+		AxisAlignedBB possessionBox = AxisAlignedBB.getAABBPool().getAABB( 
+			(double)( i - iCubicRange ), (double)( j - iCubicRange ), (double)( k - iCubicRange ),
+			(double)( i + 1 + iCubicRange ), (double)( j + 1 + iCubicRange ), (double)( k + 1 + iCubicRange ) );
+		
+        List nearbyCreatures = world.getEntitiesWithinAABB( EntityCreature.class, possessionBox );
+        
+        Iterator creatureIterator = nearbyCreatures.iterator();
+    	
+        while ( creatureIterator.hasNext() && iPossessionCount > 0 )
+        {
+        	EntityCreature tempCreature = (EntityCreature)creatureIterator.next();
+    		
+	        if ( tempCreature.GetCanCreatureBePossessedFromDistance( false ) )
+	        {
+	        	tempCreature.InitiatePossession();
+	        	
+	        	iPossessionCount--;        		
+	        }        	        
+        }    
+        
+        return iPossessionCount;
+    }
+    
+    protected void AttemptToPossessNearbyCreatureOnDeath()
+    {
+		AttemptToPossessNearbyCreature( 16D, false );
+    }
+    
+    @Override
+    public void onDeath( DamageSource source )
+    {
+    	super.onDeath( source );
+    	
+    	// if a possessed creature dies, the spirits attempt to possess another nearby
+    	
+    	if ( !worldObj.isRemote && IsPossessed() )
+    	{
+    		if ( riddenByEntity == null || !riddenByEntity.OnPossesedRidingEntityDeath() )
+    		{
+    			AttemptToPossessNearbyCreatureOnDeath();
+    		}
+    	}
+    }
+    
+    protected boolean ShouldContinueAttacking( float fDistanceToTarget )
+    {
+    	return true;
+    }
+
+    protected void TransmitAttackTargetToClients()
+    {
+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
+        DataOutputStream dataStream = new DataOutputStream( byteStream );
+        
+        try
+        {
+	        dataStream.writeInt( entityId );
+	        dataStream.writeByte( (byte)FCBetterThanWolves.fcCustomEntityEventPacketTypeSetAttackTarget );
+
+	        if ( entityToAttack != null )
+	        {
+	        	dataStream.writeInt( entityToAttack.entityId );
+	        }
+	        else
+	        {
+	        	dataStream.writeInt( -1 );
+	        }
+        }
+        catch (Exception exception)
+        {
+            exception.printStackTrace();
+        }        
+	        
+        Packet250CustomPayload packet = new Packet250CustomPayload( FCBetterThanWolves.fcCustomPacketChannelCustomEntityEvent, byteStream.toByteArray() );
+        
+        FCUtilsWorld.SendPacketToAllPlayersTrackingEntity( (WorldServer)worldObj, this, packet );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityCreeper.java b/minecraft/net/minecraft/src/EntityCreeper.java
index 6e13caa..6f10d8f 100644
--- a/minecraft/net/minecraft/src/EntityCreeper.java
+++ b/minecraft/net/minecraft/src/EntityCreeper.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityCreeper extends EntityMob
diff --git a/minecraft/net/minecraft/src/EntityDragon.java b/minecraft/net/minecraft/src/EntityDragon.java
index 52527d6..cd7eabb 100644
--- a/minecraft/net/minecraft/src/EntityDragon.java
+++ b/minecraft/net/minecraft/src/EntityDragon.java
@@ -174,7 +174,7 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
             double var6;
             double var8;
             double var26;
-            float var31;
+            float var33;
 
             if (this.worldObj.isRemote)
             {
@@ -226,16 +226,16 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
                 }
 
                 var4 /= (double)MathHelper.sqrt_double(var26 * var26 + var6 * var6);
-                var31 = 0.6F;
+                var33 = 0.6F;
 
-                if (var4 < (double)(-var31))
+                if (var4 < (double)(-var33))
                 {
-                    var4 = (double)(-var31);
+                    var4 = (double)(-var33);
                 }
 
-                if (var4 > (double)var31)
+                if (var4 > (double)var33)
                 {
-                    var4 = (double)var31;
+                    var4 = (double)var33;
                 }
 
                 this.motionY += var4 * 0.10000000149011612D;
@@ -254,8 +254,8 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
                 }
 
                 Vec3 var15 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.targetX - this.posX, this.targetY - this.posY, this.targetZ - this.posZ).normalize();
-                Vec3 var39 = this.worldObj.getWorldVec3Pool().getVecFromPool((double)MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F), this.motionY, (double)(-MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F))).normalize();
-                float var17 = (float)(var39.dotProduct(var15) + 0.5D) / 1.5F;
+                Vec3 var40 = this.worldObj.getWorldVec3Pool().getVecFromPool((double)MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F), this.motionY, (double)(-MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F))).normalize();
+                float var17 = (float)(var40.dotProduct(var15) + 0.5D) / 1.5F;
 
                 if (var17 < 0.0F)
                 {
@@ -287,7 +287,7 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
                 }
 
                 Vec3 var23 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.motionX, this.motionY, this.motionZ).normalize();
-                float var24 = (float)(var23.dotProduct(var39) + 1.0D) / 2.0F;
+                float var24 = (float)(var23.dotProduct(var40) + 1.0D) / 2.0F;
                 var24 = 0.8F + 0.15F * var24;
                 this.motionX *= (double)var24;
                 this.motionZ *= (double)var24;
@@ -307,16 +307,16 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
             this.dragonPartWing2.width = 4.0F;
             var2 = (float)(this.getMovementOffsets(5, 1.0F)[1] - this.getMovementOffsets(10, 1.0F)[1]) * 10.0F / 180.0F * (float)Math.PI;
             var3 = MathHelper.cos(var2);
-            float var27 = -MathHelper.sin(var2);
+            float var28 = -MathHelper.sin(var2);
             float var5 = this.rotationYaw * (float)Math.PI / 180.0F;
-            float var28 = MathHelper.sin(var5);
+            float var27 = MathHelper.sin(var5);
             float var7 = MathHelper.cos(var5);
             this.dragonPartBody.onUpdate();
-            this.dragonPartBody.setLocationAndAngles(this.posX + (double)(var28 * 0.5F), this.posY, this.posZ - (double)(var7 * 0.5F), 0.0F, 0.0F);
+            this.dragonPartBody.setLocationAndAngles(this.posX + (double)(var27 * 0.5F), this.posY, this.posZ - (double)(var7 * 0.5F), 0.0F, 0.0F);
             this.dragonPartWing1.onUpdate();
-            this.dragonPartWing1.setLocationAndAngles(this.posX + (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ + (double)(var28 * 4.5F), 0.0F, 0.0F);
+            this.dragonPartWing1.setLocationAndAngles(this.posX + (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ + (double)(var27 * 4.5F), 0.0F, 0.0F);
             this.dragonPartWing2.onUpdate();
-            this.dragonPartWing2.setLocationAndAngles(this.posX - (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ - (double)(var28 * 4.5F), 0.0F, 0.0F);
+            this.dragonPartWing2.setLocationAndAngles(this.posX - (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ - (double)(var27 * 4.5F), 0.0F, 0.0F);
 
             if (!this.worldObj.isRemote && this.hurtTime == 0)
             {
@@ -327,38 +327,38 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
 
             double[] var29 = this.getMovementOffsets(5, 1.0F);
             double[] var9 = this.getMovementOffsets(0, 1.0F);
-            var31 = MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
-            float var33 = MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
+            var33 = MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
+            float var32 = MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
             this.dragonPartHead.onUpdate();
-            this.dragonPartHead.setLocationAndAngles(this.posX + (double)(var31 * 5.5F * var3), this.posY + (var9[1] - var29[1]) * 1.0D + (double)(var27 * 5.5F), this.posZ - (double)(var33 * 5.5F * var3), 0.0F, 0.0F);
+            this.dragonPartHead.setLocationAndAngles(this.posX + (double)(var33 * 5.5F * var3), this.posY + (var9[1] - var29[1]) * 1.0D + (double)(var28 * 5.5F), this.posZ - (double)(var32 * 5.5F * var3), 0.0F, 0.0F);
 
             for (int var30 = 0; var30 < 3; ++var30)
             {
-                EntityDragonPart var32 = null;
+                EntityDragonPart var31 = null;
 
                 if (var30 == 0)
                 {
-                    var32 = this.dragonPartTail1;
+                    var31 = this.dragonPartTail1;
                 }
 
                 if (var30 == 1)
                 {
-                    var32 = this.dragonPartTail2;
+                    var31 = this.dragonPartTail2;
                 }
 
                 if (var30 == 2)
                 {
-                    var32 = this.dragonPartTail3;
+                    var31 = this.dragonPartTail3;
                 }
 
-                double[] var34 = this.getMovementOffsets(12 + var30 * 2, 1.0F);
-                float var35 = this.rotationYaw * (float)Math.PI / 180.0F + this.simplifyAngle(var34[0] - var29[0]) * (float)Math.PI / 180.0F * 1.0F;
-                float var37 = MathHelper.sin(var35);
-                float var36 = MathHelper.cos(var35);
-                float var38 = 1.5F;
-                float var40 = (float)(var30 + 1) * 2.0F;
-                var32.onUpdate();
-                var32.setLocationAndAngles(this.posX - (double)((var28 * var38 + var37 * var40) * var3), this.posY + (var34[1] - var29[1]) * 1.0D - (double)((var40 + var38) * var27) + 1.5D, this.posZ + (double)((var7 * var38 + var36 * var40) * var3), 0.0F, 0.0F);
+                double[] var35 = this.getMovementOffsets(12 + var30 * 2, 1.0F);
+                float var34 = this.rotationYaw * (float)Math.PI / 180.0F + this.simplifyAngle(var35[0] - var29[0]) * (float)Math.PI / 180.0F * 1.0F;
+                float var38 = MathHelper.sin(var34);
+                float var37 = MathHelper.cos(var34);
+                float var36 = 1.5F;
+                float var39 = (float)(var30 + 1) * 2.0F;
+                var31.onUpdate();
+                var31.setLocationAndAngles(this.posX - (double)((var27 * var36 + var38 * var39) * var3), this.posY + (var35[1] - var29[1]) * 1.0D - (double)((var39 + var36) * var28) + 1.5D, this.posZ + (double)((var7 * var36 + var37 * var39) * var3), 0.0F, 0.0F);
             }
 
             if (!this.worldObj.isRemote)
@@ -459,12 +459,32 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
     private void setNewTarget()
     {
         this.forceNewTarget = false;
+        
+        // FCMOD: Code added
+        boolean bTargetSelected = false;
+        // END FCMOD
 
         if (this.rand.nextInt(2) == 0 && !this.worldObj.playerEntities.isEmpty())
         {
             this.target = (Entity)this.worldObj.playerEntities.get(this.rand.nextInt(this.worldObj.playerEntities.size()));
+            
+            // FCMOD: Code added
+            long lTargetChangedDimensionTime = ((EntityPlayer)target).m_lTimeOfLastDimensionSwitch;
+            long lWorldTime = worldObj.getWorldTime();
+            
+            if ( lWorldTime < lTargetChangedDimensionTime || lWorldTime - lTargetChangedDimensionTime > m_iPlayerSwitchDimensionsGracePeriod )
+            {
+            	bTargetSelected = true;
+            }
+            // END FCMOD
         }
+        
+        // FCMOD: Code change
+        /*
         else
+        */
+        if ( !bTargetSelected )
+    	// END FCMOD
         {
             boolean var1 = false;
 
@@ -749,4 +769,8 @@ public class EntityDragon extends EntityLiving implements IBossDisplayData, IEnt
     {
         return 5.0F;
     }
+    
+    // FCMOD: Code added
+    private static final long m_iPlayerSwitchDimensionsGracePeriod = 600; // 30 seconds 
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityDropParticleFX.java b/minecraft/net/minecraft/src/EntityDropParticleFX.java
index 36dcff0..e7d3f32 100644
--- a/minecraft/net/minecraft/src/EntityDropParticleFX.java
+++ b/minecraft/net/minecraft/src/EntityDropParticleFX.java
@@ -1,5 +1,9 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.ColorizeEntity;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntityDropParticleFX extends EntityFX
 {
     /** the material type for dropped items/blocks */
@@ -15,9 +19,18 @@ public class EntityDropParticleFX extends EntityFX
 
         if (par8Material == Material.water)
         {
-            this.particleRed = 0.0F;
-            this.particleGreen = 0.0F;
-            this.particleBlue = 1.0F;
+        	if (ColorizeBlock.computeWaterColor(true, (int)this.posX, (int)this.posY, (int)this.posZ))
+            {
+                this.particleRed = Colorizer.setColor[0];
+                this.particleGreen = Colorizer.setColor[1];
+                this.particleBlue = Colorizer.setColor[2];
+            }
+            else
+            {
+                this.particleRed = 0.2F;
+                this.particleGreen = 0.3F;
+                this.particleBlue = 1.0F;
+            }
         }
         else
         {
@@ -57,17 +70,20 @@ public class EntityDropParticleFX extends EntityFX
         this.prevPosY = this.posY;
         this.prevPosZ = this.posZ;
 
-        if (this.materialType == Material.water)
-        {
-            this.particleRed = 0.2F;
-            this.particleGreen = 0.3F;
-            this.particleBlue = 1.0F;
-        }
-        else
+        if (this.materialType != Material.water)
         {
-            this.particleRed = 1.0F;
-            this.particleGreen = 16.0F / (float)(40 - this.bobTimer + 16);
-            this.particleBlue = 4.0F / (float)(40 - this.bobTimer + 8);
+        	if (ColorizeEntity.computeLavaDropColor(40 - this.bobTimer))
+            {
+                this.particleRed = Colorizer.setColor[0];
+                this.particleGreen = Colorizer.setColor[1];
+                this.particleBlue = Colorizer.setColor[2];
+            }
+            else
+            {
+                this.particleRed = 1.0F;
+                this.particleGreen = 16.0F / (float)(40 - this.bobTimer + 16);
+                this.particleBlue = 4.0F / (float)(40 - this.bobTimer + 8);
+            }
         }
 
         this.motionY -= (double)this.particleGravity;
diff --git a/minecraft/net/minecraft/src/EntityEgg.java b/minecraft/net/minecraft/src/EntityEgg.java
index 63ca719..d2abdec 100644
--- a/minecraft/net/minecraft/src/EntityEgg.java
+++ b/minecraft/net/minecraft/src/EntityEgg.java
@@ -38,12 +38,23 @@ public class EntityEgg extends EntityThrowable
 
             for (int var3 = 0; var3 < var2; ++var3)
             {
-                EntityChicken var4 = new EntityChicken(this.worldObj);
-                var4.setGrowingAge(-24000);
+            	// FCMOD: Changed
+                //EntityChicken var4 = new EntityChicken(this.worldObj);
+                //var4.setGrowingAge(-24000);
+                FCEntityChicken var4 = new FCEntityChicken( worldObj );
+                var4.setGrowingAge( -var4.GetTicksForChildToGrow() );
+                // END FCMOD
                 var4.setLocationAndAngles(this.posX, this.posY, this.posZ, this.rotationYaw, 0.0F);
                 this.worldObj.spawnEntityInWorld(var4);
             }
         }
+        // FCMOD: Added
+        else if ( !worldObj.isRemote )
+        {
+        	FCUtilsItem.EjectSingleItemWithRandomVelocity( worldObj, (float)posX, (float)posY, (float)posZ, FCBetterThanWolves.fcItemRawEgg.itemID, 0 );
+        	
+        }
+        // END FCMOD
 
         for (int var5 = 0; var5 < 8; ++var5)
         {
diff --git a/minecraft/net/minecraft/src/EntityEnderman.java b/minecraft/net/minecraft/src/EntityEnderman.java
index 29a9582..a1ccba5 100644
--- a/minecraft/net/minecraft/src/EntityEnderman.java
+++ b/minecraft/net/minecraft/src/EntityEnderman.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/24/2018
+
 package net.minecraft.src;
 
 public class EntityEnderman extends EntityMob
@@ -299,6 +301,13 @@ public class EntityEnderman extends EntityMob
 
                 if (this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox).isEmpty() && !this.worldObj.isAnyLiquid(this.boundingBox))
                 {
+                    // FCMOD: Added
+                    Block blockBelow = Block.blocksList[worldObj.getBlockId( 
+                    	var14, var15 - 1, var16 )];
+
+                    if ( blockBelow != null && blockBelow.CanMobsSpawnOn( 
+                    	worldObj, var14, var15 - 1, var16 ) )
+                    // END FCMOD
                     var13 = true;
                 }
             }
diff --git a/minecraft/net/minecraft/src/EntityFallingSand.java b/minecraft/net/minecraft/src/EntityFallingSand.java
index 4342917..f545844 100644
--- a/minecraft/net/minecraft/src/EntityFallingSand.java
+++ b/minecraft/net/minecraft/src/EntityFallingSand.java
@@ -179,7 +179,7 @@ public class EntityFallingSand extends Entity
             }
         }
     }
-
+    
     /**
      * Called when the mob is falling. Calculates and applies fall damage.
      */
diff --git a/minecraft/net/minecraft/src/EntityFireball.java b/minecraft/net/minecraft/src/EntityFireball.java
index 9582b1c..bc20fcf 100644
--- a/minecraft/net/minecraft/src/EntityFireball.java
+++ b/minecraft/net/minecraft/src/EntityFireball.java
@@ -105,6 +105,15 @@ public abstract class EntityFireball extends Entity
             else
             {
                 ++this.ticksInAir;
+                
+                // FCMOD: Added as fix for undying fireballs MC-4465
+                if ( ticksInAir >= 600 )
+                {
+                    setDead();
+                    
+                    return;
+                }
+                // END FCMOD
             }
 
             Vec3 var15 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
@@ -187,10 +196,10 @@ public abstract class EntityFireball extends Entity
 
             if (this.isInWater())
             {
-                for (int var18 = 0; var18 < 4; ++var18)
+                for (int var19 = 0; var19 < 4; ++var19)
                 {
-                    float var19 = 0.25F;
-                    this.worldObj.spawnParticle("bubble", this.posX - this.motionX * (double)var19, this.posY - this.motionY * (double)var19, this.posZ - this.motionZ * (double)var19, this.motionX, this.motionY, this.motionZ);
+                    float var18 = 0.25F;
+                    this.worldObj.spawnParticle("bubble", this.posX - this.motionX * (double)var18, this.posY - this.motionY * (double)var18, this.posZ - this.motionZ * (double)var18, this.motionX, this.motionY, this.motionZ);
                 }
 
                 var17 = 0.8F;
@@ -231,6 +240,10 @@ public abstract class EntityFireball extends Entity
         par1NBTTagCompound.setByte("inTile", (byte)this.inTile);
         par1NBTTagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
         par1NBTTagCompound.setTag("direction", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
+        
+        // FCMOD: Added as fix for undying fireballs MC-4465
+        par1NBTTagCompound.setShort( "ticksInAir", (short)ticksInAir );
+        // END FCMOD        
     }
 
     /**
@@ -255,6 +268,13 @@ public abstract class EntityFireball extends Entity
         {
             this.setDead();
         }
+        
+        // FCMOD: Added as fix for undying fireballs MC-4465
+        if (par1NBTTagCompound.hasKey( "ticksInAir" ) )
+        {
+        	ticksInAir = par1NBTTagCompound.getShort( "ticksInAir" );
+        }
+        // END FCMOD        
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/EntityFishHook.java b/minecraft/net/minecraft/src/EntityFishHook.java
index 66dd4b5..535010b 100644
--- a/minecraft/net/minecraft/src/EntityFishHook.java
+++ b/minecraft/net/minecraft/src/EntityFishHook.java
@@ -51,6 +51,9 @@ public class EntityFishHook extends Entity
         this.bobber = null;
         this.setSize(0.25F, 0.25F);
         this.ignoreFrustumCheck = true;
+        // FCMOD: Added
+        m_bIsBaited = false;
+        // END FCMOD
     }
 
     public EntityFishHook(World par1World, double par2, double par4, double par6, EntityPlayer par8EntityPlayer)
@@ -89,6 +92,9 @@ public class EntityFishHook extends Entity
         this.motionZ = (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI) * var3);
         this.motionY = (double)(-MathHelper.sin(this.rotationPitch / 180.0F * (float)Math.PI) * var3);
         this.calculateVelocity(this.motionX, this.motionY, this.motionZ, 1.5F, 1.0F);
+        // FCMOD: Added
+        m_bIsBaited = false;
+        // END FCMOD
     }
 
     protected void entityInit() {}
@@ -177,7 +183,15 @@ public class EntityFishHook extends Entity
             {
                 ItemStack var1 = this.angler.getCurrentEquippedItem();
 
+                // FCMOD: Changed
+                /*
                 if (this.angler.isDead || !this.angler.isEntityAlive() || var1 == null || var1.getItem() != Item.fishingRod || this.getDistanceSqToEntity(this.angler) > 1024.0D)
+                */
+                if ( angler.isDead || !angler.isEntityAlive() || var1 == null || 
+                	!( ( var1.getItem() == Item.fishingRod && !m_bIsBaited ) || 
+            		( var1.getItem() == FCBetterThanWolves.fcItemFishingRodBaited && m_bIsBaited ) ) ||
+                	getDistanceSqToEntity( angler ) > 1024D )
+                // END FCMOD
                 {
                     this.setDead();
                     this.angler.fishEntity = null;
@@ -325,22 +339,22 @@ public class EntityFishHook extends Entity
                     var25 = 0.5F;
                 }
 
-                byte var26 = 5;
-                double var27 = 0.0D;
+                byte var27 = 5;
+                double var26 = 0.0D;
 
-                for (int var28 = 0; var28 < var26; ++var28)
+                for (int var29 = 0; var29 < var27; ++var29)
                 {
-                    double var14 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var28 + 0) / (double)var26 - 0.125D + 0.125D;
-                    double var16 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var28 + 1) / (double)var26 - 0.125D + 0.125D;
+                    double var14 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var29 + 0) / (double)var27 - 0.125D + 0.125D;
+                    double var16 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var29 + 1) / (double)var27 - 0.125D + 0.125D;
                     AxisAlignedBB var18 = AxisAlignedBB.getAABBPool().getAABB(this.boundingBox.minX, var14, this.boundingBox.minZ, this.boundingBox.maxX, var16, this.boundingBox.maxZ);
 
                     if (this.worldObj.isAABBInMaterial(var18, Material.water))
                     {
-                        var27 += 1.0D / (double)var26;
+                        var26 += 1.0D / (double)var27;
                     }
                 }
 
-                if (var27 > 0.0D)
+                if (var26 > 0.0D)
                 {
                     if (this.ticksCatchable > 0)
                     {
@@ -348,14 +362,19 @@ public class EntityFishHook extends Entity
                     }
                     else
                     {
-                        short var29 = 500;
+                        // FCMOD: Changed
+                        /*
+                        short var28 = 500;
 
                         if (this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY) + 1, MathHelper.floor_double(this.posZ)))
                         {
-                            var29 = 300;
+                            var28 = 300;
                         }
-
-                        if (this.rand.nextInt(var29) == 0)
+                        
+                        if (this.rand.nextInt(var28) == 0)
+                        */
+                        if ( CheckForBite() )
+                    	// END FCMOD
                         {
                             this.ticksCatchable = this.rand.nextInt(30) + 10;
                             this.motionY -= 0.20000000298023224D;
@@ -378,6 +397,13 @@ public class EntityFishHook extends Entity
                                 var17 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
                                 this.worldObj.spawnParticle("splash", this.posX + (double)var31, (double)(var30 + 1.0F), this.posZ + (double)var17, this.motionX, this.motionY, this.motionZ);
                             }
+                            
+                            // FCMOD: Added
+                            if ( rand.nextInt( 5 ) == 0 )
+                            {
+                            	LoseBait();
+                            }
+                            // END FCMOD
                         }
                     }
                 }
@@ -387,10 +413,10 @@ public class EntityFishHook extends Entity
                     this.motionY -= (double)(this.rand.nextFloat() * this.rand.nextFloat() * this.rand.nextFloat()) * 0.2D;
                 }
 
-                var13 = var27 * 2.0D - 1.0D;
+                var13 = var26 * 2.0D - 1.0D;
                 this.motionY += 0.03999999910593033D * var13;
 
-                if (var27 > 0.0D)
+                if (var26 > 0.0D)
                 {
                     var25 = (float)((double)var25 * 0.9D);
                     this.motionY *= 0.8D;
@@ -460,6 +486,16 @@ public class EntityFishHook extends Entity
             else if (this.ticksCatchable > 0)
             {
                 EntityItem var13 = new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.fishRaw));
+            	// FCMOD: Added
+            	LoseBait();
+            	
+            	if ( this.rand.nextInt( 100 ) == 0 )
+            	{
+            		var13 = new EntityItem( worldObj, posX, posY, posZ, new ItemStack( Item.bootsLeather ) );
+            		
+            		var13.getEntityItem().setItemDamage( var13.getEntityItem().getMaxDamage() - ( 1 + this.rand.nextInt( 10 ) ) );
+            	}
+            	// END FCMOD
                 double var3 = this.angler.posX - this.posX;
                 double var5 = this.angler.posY - this.posY;
                 double var7 = this.angler.posZ - this.posZ;
@@ -470,7 +506,11 @@ public class EntityFishHook extends Entity
                 var13.motionZ = var7 * var11;
                 this.worldObj.spawnEntityInWorld(var13);
                 this.angler.addStat(StatList.fishCaughtStat, 1);
+                // FCMOD: Removed
+                /*
                 this.angler.worldObj.spawnEntityInWorld(new EntityXPOrb(this.angler.worldObj, this.angler.posX, this.angler.posY + 0.5D, this.angler.posZ + 0.5D, this.rand.nextInt(6) + 1));
+                */
+                // END FCMOD
                 var1 = 1;
             }
 
@@ -497,4 +537,123 @@ public class EntityFishHook extends Entity
             this.angler.fishEntity = null;
         }
     }
+    
+    // FCMOD: Added New
+    private boolean m_bIsBaited;
+    
+    public EntityFishHook( World world, EntityPlayer player, boolean bIsBaited )
+    {
+    	this( world, player );
+    	
+    	m_bIsBaited = bIsBaited;
+    }
+    
+	private void LoseBait()
+	{
+		if ( m_bIsBaited )
+		{
+			m_bIsBaited = false;
+			
+            ItemStack rodStack = angler.getCurrentEquippedItem();
+            
+            if ( rodStack != null && rodStack.getItem() == FCBetterThanWolves.fcItemFishingRodBaited )
+            {
+            	ItemStack unbaitedStack = rodStack.copy();
+            	unbaitedStack.stackSize = 1;
+            	unbaitedStack.itemID = Item.fishingRod.itemID;
+            	
+            	angler.inventory.setInventorySlotContents( angler.inventory.currentItem, unbaitedStack );
+            }
+		}
+	}
+	
+	private boolean IsBodyOfWaterLargeEnoughForFishing()
+	{
+        int i = MathHelper.floor_double( posX );
+        int j = MathHelper.floor_double( posY ) - 1;
+        int k = MathHelper.floor_double( posZ );
+
+        for ( int iTempI = i - 2; iTempI <= i + 2; iTempI++ )
+        {
+            for ( int iTempJ = j - 2; iTempJ <= j; iTempJ++ )
+            {
+                for ( int iTempK = k - 2; iTempK <= k + 2; iTempK++ )
+                {
+                	if ( !FCUtilsWorld.IsWaterSourceBlock( worldObj, iTempI, iTempJ, iTempK ) )
+            		{
+                		return false;
+            		}                		
+                }
+            }
+        }
+        
+		return true;
+	}
+
+    private boolean CheckForBite()
+    {
+    	if ( m_bIsBaited )
+    	{
+	        int iBiteOdds = 1500; // previously 1000
+	        
+	        int iTimeOfDay = (int)( worldObj.worldInfo.getWorldTime() % 24000L );
+	        
+	        if ( iTimeOfDay > 14000 && iTimeOfDay < 22000 )
+	        {
+	        	// at night
+	        	
+	        	int iMoonPhase = worldObj.getMoonPhase();
+	        	
+	        	if ( iMoonPhase == 0 )
+	        	{
+	        		iBiteOdds /= 10;
+	        	}
+	        	else
+	        	{
+	        		iBiteOdds *= 4;
+	        		
+	                if ( worldObj.IsPrecipitatingAtPos( MathHelper.floor_double( posX ), 
+	                	MathHelper.floor_double( posZ ) ) )
+	                {
+		            	// in the rain
+		            	
+	                	iBiteOdds /= 2;
+	                }
+	        	}
+	        }
+	        else
+	        {
+	        	if ( iTimeOfDay < 2000 || iTimeOfDay > 22000 || 
+	        		( iTimeOfDay > 10000 && iTimeOfDay < 14000 ) ) 
+	            {
+	        		// dawn or dusk
+	        		
+	        		iBiteOdds /= 2;
+	            }
+	
+                if ( worldObj.IsPrecipitatingAtPos( MathHelper.floor_double( posX ), 
+                	MathHelper.floor_double( posZ ) ) )
+	            {
+	            	// in the rain
+	            	
+	            	iBiteOdds /= 2;
+	            }
+	        }
+	
+	        if ( rand.nextInt( iBiteOdds ) == 0 )
+	        {
+	        	if ( worldObj.canBlockSeeTheSky( MathHelper.floor_double( posX ), 
+	        		MathHelper.floor_double( posY) + 1, MathHelper.floor_double( posZ) ) )
+	        	{	        		
+		        	if ( IsBodyOfWaterLargeEnoughForFishing() )
+		        	{
+		        		return true;
+		        	}
+	        	}
+	        }
+    	}
+    	
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityGhast.java b/minecraft/net/minecraft/src/EntityGhast.java
index 2c2f572..1aa4c68 100644
--- a/minecraft/net/minecraft/src/EntityGhast.java
+++ b/minecraft/net/minecraft/src/EntityGhast.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityGhast extends EntityFlying implements IMob
@@ -198,7 +200,7 @@ public class EntityGhast extends EntityFlying implements IMob
             if (!this.worldObj.getCollidingBoundingBoxes(this, var15).isEmpty())
             {
                 return false;
-            }
+            }            
         }
 
         return true;
diff --git a/minecraft/net/minecraft/src/EntityHanging.java b/minecraft/net/minecraft/src/EntityHanging.java
index cce35e2..116daf9 100644
--- a/minecraft/net/minecraft/src/EntityHanging.java
+++ b/minecraft/net/minecraft/src/EntityHanging.java
@@ -198,7 +198,12 @@ public abstract class EntityHanging extends Entity
 
                 var11 = (Entity)var10.next();
             }
+        	// FCMOD: Code change so that paintings and canvas can't overlap
+            /*
             while (!(var11 instanceof EntityHanging));
+            */
+            while (!(var11 instanceof EntityHanging) && !(var11 instanceof FCEntityCanvas));
+            // END FCMOD
 
             return false;
         }
@@ -348,4 +353,12 @@ public abstract class EntityHanging extends Entity
      * Drop the item currently on this item frame.
      */
     public abstract void dropItemStack();
+    
+    // FCMOD: Code added
+    @Override
+    protected boolean ShouldSetPositionOnLoad()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityItem.java b/minecraft/net/minecraft/src/EntityItem.java
index 3f3f2e1..1ee4572 100644
--- a/minecraft/net/minecraft/src/EntityItem.java
+++ b/minecraft/net/minecraft/src/EntityItem.java
@@ -2,6 +2,8 @@ package net.minecraft.src;
 
 import java.util.Iterator;
 
+import net.minecraft.server.MinecraftServer;
+
 public class EntityItem extends Entity
 {
     /**
@@ -77,7 +79,19 @@ public class EntityItem extends Entity
         this.prevPosY = this.posY;
         this.prevPosZ = this.posZ;
         this.motionY -= 0.03999999910593033D;
+        // FCMOD: Added
+        UpdateHardcoreBuoy();
+        // END FCMOD
+        // FCMOD: Changed this to reverse Mojang's "fix" to items getting stuck in blocks
+        // and to reduce discrepancies between client and server by pushing only on server
+        /*
         this.noClip = this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+        */
+        if ( !worldObj.isRemote )
+        {
+        	pushOutOfBlocks( posX, ( boundingBox.minY + boundingBox.maxY) / 2D, posZ );
+        }
+        // END FCMOD
         this.moveEntity(this.motionX, this.motionY, this.motionZ);
         boolean var1 = (int)this.prevPosX != (int)this.posX || (int)this.prevPosY != (int)this.posY || (int)this.prevPosZ != (int)this.posZ;
 
@@ -118,13 +132,18 @@ public class EntityItem extends Entity
         {
             this.motionY *= -0.5D;
         }
-
+        
         ++this.age;
 
+        // FCMOD: Code change
+        /*
         if (!this.worldObj.isRemote && this.age >= 6000)
         {
             this.setDead();
         }
+        */
+        CheckForItemDespawn();
+        // END FCMOD
     }
 
     /**
@@ -238,6 +257,14 @@ public class EntityItem extends Entity
         else
         {
             this.setBeenAttacked();
+	        // FCMOD: Code added
+	        if ( !worldObj.isRemote && !isDead && getEntityItem().getItem().itemID == FCBetterThanWolves.fcItemBlastingOil.itemID )
+	        {
+	    		DetonateBlastingOil();
+	    		
+	    		return false;
+		    }
+	        // END FCMOD
             this.health -= par2;
 
             if (this.health <= 0)
@@ -261,6 +288,10 @@ public class EntityItem extends Entity
         {
             par1NBTTagCompound.setCompoundTag("Item", this.getEntityItem().writeToNBT(new NBTTagCompound()));
         }
+        
+        // FCMOD: Code added
+        par1NBTTagCompound.setLong( "fcDespawnTime", m_lAbsoluteItemDespawnTime );
+	    // END FCMOD    
     }
 
     /**
@@ -273,10 +304,18 @@ public class EntityItem extends Entity
         NBTTagCompound var2 = par1NBTTagCompound.getCompoundTag("Item");
         this.setEntityItemStack(ItemStack.loadItemStackFromNBT(var2));
 
+        // FCMOD: Code added
+	    if ( par1NBTTagCompound.hasKey( "fcDespawnTime" ) )
+	    {
+	    	m_lAbsoluteItemDespawnTime = par1NBTTagCompound.getLong( "fcDespawnTime" );
+	    }
+	    // END FCMOD	    
+        
         if (this.getEntityItem() == null)
         {
             this.setDead();
         }
+        
     }
 
     /**
@@ -382,4 +421,343 @@ public class EntityItem extends Entity
         this.getDataWatcher().updateObject(10, par1ItemStack);
         this.getDataWatcher().setObjectWatched(10);
     }
+
+    // FCMOD: Code added    
+    private long m_lAbsoluteItemDespawnTime = 0;
+    
+    private void UpdateHardcoreBuoy()
+    {
+        if ( FCBetterThanWolves.IsHardcoreBuoyEnabled( worldObj ) )
+        {
+	        int numDepthChecks = 10;
+	        double d = 0.0D;
+	        double dBoundingYOffset = 0.10D;
+	
+	        for ( int j = 0; j < numDepthChecks; j++ )
+	        {
+	            double d2 = ( boundingBox.minY + ( ( boundingBox.maxY - boundingBox.minY) * (double)(j + 0) ) * ( 0.375D ) ) + dBoundingYOffset;
+	            double d8 = ( boundingBox.minY + ( ( boundingBox.maxY - boundingBox.minY) * (double)(j + 1) ) * ( 0.375D ) ) + dBoundingYOffset;
+	            
+	            AxisAlignedBB axisalignedbb = AxisAlignedBB.getAABBPool().getAABB(boundingBox.minX, d2, boundingBox.minZ, boundingBox.maxX, d8, boundingBox.maxZ);
+	
+	            if ( worldObj.isAABBInMaterial( axisalignedbb, Material.water ) )
+	            {
+	                d += 1.0D / (double)numDepthChecks;
+	            }
+	            else 
+	            {
+	            	break;
+	            }
+	        }
+	        
+	        if ( d > 0.001D )
+	        {
+	    		if ( !IsInUndertow() )
+	    		{
+		        	float fBuoyancyShifted = getEntityItem().getItem().GetBuoyancy( getEntityItem().getItemDamage() ) + 1.0F;
+		        	
+		        	// positive velocity due to boyancy
+		        	
+		        	motionY += 0.04D * fBuoyancyShifted * d;
+	    		}
+		  
+		        // drag due to being in water
+		        
+	        	motionX *= 0.90F;
+	        	motionY *= 0.90F;
+	        	motionZ *= 0.90F;	        	
+	        }	        
+        }
+    }
+
+    @Override
+    protected void doBlockCollisions()
+    {
+		//Inherited function added so that blocks like Hoppers get collision events with items on top.  
+    	// Copy of code from Entity.java, changes marked with FCMOD.
+
+        int i = MathHelper.floor_double(boundingBox.minX + 0.001D);
+        // FCMOD: code change
+        /*
+        int j = MathHelper.floor_double(boundingBox.minY + 0.001D);
+        */
+        int j = MathHelper.floor_double(boundingBox.minY - 0.01D);
+        // END FCMOD
+        int k = MathHelper.floor_double(boundingBox.minZ + 0.001D);
+        int l = MathHelper.floor_double(boundingBox.maxX - 0.001D);
+        int i1 = MathHelper.floor_double(boundingBox.maxY - 0.001D);
+        int j1 = MathHelper.floor_double(boundingBox.maxZ - 0.001D);
+
+        if (worldObj.checkChunksExist(i, j, k, l, i1, j1))
+        {
+            for (int k1 = i; k1 <= l; k1++)
+            {
+                for (int l1 = j; l1 <= i1; l1++)
+                {
+                    for (int i2 = k; i2 <= j1; i2++)
+                    {
+                        int j2 = worldObj.getBlockId(k1, l1, i2);
+
+                        if (j2 > 0)
+                        {
+                            Block.blocksList[j2].onEntityCollidedWithBlock(worldObj, k1, l1, i2, this);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean IsInUndertow()
+    {
+        int minI = MathHelper.floor_double( boundingBox.minX);
+        int maxI = MathHelper.floor_double( boundingBox.maxX + 1.0D);
+        
+        int minJ = MathHelper.floor_double( boundingBox.minY);
+        int maxJ = MathHelper.floor_double( boundingBox.maxY + 1.0D);
+        
+        int minK = MathHelper.floor_double( boundingBox.minZ);
+        int maxK = MathHelper.floor_double( boundingBox.maxZ + 1.0D );
+
+        for ( int i = minI; i < maxI; i++ )
+        {
+            for ( int j = minJ; j < maxJ; j++ )
+            {
+                for ( int k = minK; k < maxK; k++ )
+                {
+                	if ( DoesBlockHaveUndertow( i, j, k ) )
+            		{
+                		return true;
+            		}                	
+                }
+            }
+        }
+
+        return false;
+    }
+    
+    private boolean DoesBlockHaveUndertow( int i, int j, int k )
+    {
+		int iBlockID = worldObj.getBlockId( i, j, k );
+		
+		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
+		{
+			int iFluidHeight = worldObj.getBlockMetadata( i, j, k );
+			
+			if ( iFluidHeight >= 8 )
+			{
+				return true;
+			}
+	    		
+			iBlockID = worldObj.getBlockId( i, j - 1, k );
+	    		
+    		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
+    		{
+    			iFluidHeight = worldObj.getBlockMetadata( i, j - 1, k );
+    			
+    			if ( iFluidHeight >= 8 )
+    			{
+    				return true;
+    			}
+    		}	    	 
+	    		
+    		iBlockID = worldObj.getBlockId( i, j + 1, k );
+    		
+    		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
+    		{
+    			iFluidHeight = worldObj.getBlockMetadata( i, j + 1, k );
+    			
+    			if ( iFluidHeight >= 8 )
+    			{
+    				return true;
+    			}
+    		}	    	 
+		}
+		
+		return false;
+    }    
+    
+    @Override
+    protected void fall( float fFallDistance )
+    {
+        super.fall( fFallDistance );
+
+        if ( !worldObj.isRemote )
+        {
+	        if ( getEntityItem().getItem().itemID == FCBetterThanWolves.fcItemBlastingOil.itemID )
+	        {
+	        	if ( fFallDistance > 3F )
+	        	{
+	        		DetonateBlastingOil();
+	        	}
+		    }
+        }
+    }
+    
+    private void DetonateBlastingOil()
+    {
+		int iStackSize = getEntityItem().stackSize;
+		
+    	health = 0;
+		setDead();
+		
+		if ( iStackSize > 0 )
+		{
+			// cap the explosion size at that of TNT to avoid overly weaponzing Blasting Oil
+			
+	        float fExplosionSize = 1.5F + ( ( iStackSize - 1 ) * 2.5F / 63.0F );
+
+	        worldObj.createExplosion( null, posX, posY, posZ, fExplosionSize, true );
+		}
+    }
+
+    @Override
+    protected boolean pushOutOfBlocks(double par1, double par3, double par5)
+    {
+    	// Inherited function added to revert Mojang's changes 
+
+        int var7 = MathHelper.floor_double(par1);
+        int var8 = MathHelper.floor_double(par3);
+        int var9 = MathHelper.floor_double(par5);
+        double var10 = par1 - (double)var7;
+        double var12 = par3 - (double)var8;
+        double var14 = par5 - (double)var9;
+
+        if (this.worldObj.isBlockNormalCube(var7, var8, var9))
+        {
+            boolean var16 = !this.worldObj.isBlockNormalCube(var7 - 1, var8, var9);
+            boolean var17 = !this.worldObj.isBlockNormalCube(var7 + 1, var8, var9);
+            boolean var18 = !this.worldObj.isBlockNormalCube(var7, var8 - 1, var9);
+            boolean var19 = !this.worldObj.isBlockNormalCube(var7, var8 + 1, var9);
+            boolean var20 = !this.worldObj.isBlockNormalCube(var7, var8, var9 - 1);
+            boolean var21 = !this.worldObj.isBlockNormalCube(var7, var8, var9 + 1);
+            byte var22 = -1;
+            double var23 = 9999.0D;
+
+            if (var16 && var10 < var23)
+            {
+                var23 = var10;
+                var22 = 0;
+            }
+
+            if (var17 && 1.0D - var10 < var23)
+            {
+                var23 = 1.0D - var10;
+                var22 = 1;
+            }
+
+            if (var18 && var12 < var23)
+            {
+                var23 = var12;
+                var22 = 2;
+            }
+
+            if (var19 && 1.0D - var12 < var23)
+            {
+                var23 = 1.0D - var12;
+                var22 = 3;
+            }
+
+            if (var20 && var14 < var23)
+            {
+                var23 = var14;
+                var22 = 4;
+            }
+
+            if (var21 && 1.0D - var14 < var23)
+            {
+                var23 = 1.0D - var14;
+                var22 = 5;
+            }
+
+            float var25 = this.rand.nextFloat() * 0.2F + 0.1F;
+
+            if (var22 == 0)
+            {
+                this.motionX = (double)(-var25);
+            }
+
+            if (var22 == 1)
+            {
+                this.motionX = (double)var25;
+            }
+
+            if (var22 == 2)
+            {
+                this.motionY = (double)(-var25);
+            }
+
+            if (var22 == 3)
+            {
+                this.motionY = (double)var25;
+            }
+
+            if (var22 == 4)
+            {
+                this.motionZ = (double)(-var25);
+            }
+
+            if (var22 == 5)
+            {
+                this.motionZ = (double)var25;
+            }
+
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+    
+    @Override
+    public boolean IsItemEntity()
+    {
+    	return true;
+    }
+    
+    @Override
+    public boolean CanEntityTriggerTripwire()
+    {
+    	return false;
+    }
+    
+    private void CheckForItemDespawn()
+    {
+        if ( !worldObj.isRemote )
+        {
+	        if ( m_lAbsoluteItemDespawnTime > 0 )
+	        {
+	        	// using getTotalWorldTime() here so that /time commands and time advancement due to HC Spawn don't affect it
+	        	
+				long lOverworldTime = MinecraftServer.getServer().worldServers[0].getTotalWorldTime();
+				
+				if ( lOverworldTime >= m_lAbsoluteItemDespawnTime  )
+				{
+					setDead();
+				}				
+	        }
+	        else
+	        {
+		        if ( age >= 6000 )
+		        {
+		            setDead();
+		        }
+	        }
+        }
+    }
+    
+    public void SetEntityItemAsDroppedOnPlayerDeath( EntityPlayer player )
+    {
+    	// set items dropped on player death to despawn 1 Minecraft day (20 minutes) later
+    	// using getTotalWorldTime() here so that /time commands and time advancement due to HC Spawn don't affect it
+    	
+    	m_lAbsoluteItemDespawnTime = MinecraftServer.getServer().worldServers[0].getTotalWorldTime() + 24000L;
+    }
+    
+    static public boolean InstallationIntegrityTestEntityItem()
+    {
+    	return true;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/EntityLightningBolt.java b/minecraft/net/minecraft/src/EntityLightningBolt.java
index bf7662e..52803d1 100644
--- a/minecraft/net/minecraft/src/EntityLightningBolt.java
+++ b/minecraft/net/minecraft/src/EntityLightningBolt.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 11/20/2018
+
 package net.minecraft.src;
 
 import java.util.List;
diff --git a/minecraft/net/minecraft/src/EntityList.java b/minecraft/net/minecraft/src/EntityList.java
index 558cd0d..5869e88 100644
--- a/minecraft/net/minecraft/src/EntityList.java
+++ b/minecraft/net/minecraft/src/EntityList.java
@@ -1,9 +1,14 @@
 package net.minecraft.src;
 
+import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 
+import com.prupe.mcpatcher.cc.ColorizeItem;
+
 public class EntityList
 {
     /** Provides a mapping between entity classes and a string */
@@ -27,7 +32,12 @@ public class EntityList
     /**
      * adds a mapping between Entity classes and both a string representation and an ID
      */
+    // FCMOD: Code change
+    /*
     private static void addMapping(Class par0Class, String par1Str, int par2)
+    */
+    public static void addMapping(Class par0Class, String par1Str, int par2)
+    // END FCMOD
     {
         stringToClassMapping.put(par1Str, par0Class);
         classToStringMapping.put(par0Class, par1Str);
@@ -39,8 +49,12 @@ public class EntityList
     /**
      * Adds a entity mapping with egg info.
      */
-    private static void addMapping(Class par0Class, String par1Str, int par2, int par3, int par4)
+    public static void addMapping(Class par0Class, String par1Str, int par2, int par3, int par4)
     {
+    	//Client only
+    	ColorizeItem.setupSpawnerEgg(par1Str, par2, par3, par4);
+    	//
+    	
         addMapping(par0Class, par1Str, par2);
         entityEggs.put(Integer.valueOf(par2), new EntityEggInfo(par2, par3, par4));
     }
@@ -58,7 +72,12 @@ public class EntityList
 
             if (var3 != null)
             {
-                var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	if (FCEntityVillager.class.equals(var3)) {
+            		var2 = FCEntityVillager.createVillager(par1World);
+            	}
+            	else {
+            		var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	}
             }
         }
         catch (Exception var4)
@@ -101,7 +120,14 @@ public class EntityList
 
             if (var3 != null)
             {
-                var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	if (FCEntityVillager.class.equals(var3)) {
+            		int profession = par0NBTTagCompound.getInteger("Profession");
+
+            		var2 = FCEntityVillager.createVillagerFromProfession(par1World, profession);
+            	}
+            	else {
+            		var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	}
             }
         }
         catch (Exception var4)
@@ -115,7 +141,10 @@ public class EntityList
         }
         else
         {
+        	//Client
             par1World.getWorldLogAgent().logWarning("Skipping Entity with id " + par0NBTTagCompound.getString("id"));
+            //Server
+            //par1World.getWorldLogAgent().func_98236_b("Skipping Entity with id " + par0NBTTagCompound.getString("id"));
         }
 
         return var2;
@@ -134,7 +163,12 @@ public class EntityList
 
             if (var3 != null)
             {
-                var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	if (FCEntityVillager.class.equals(var3)) {
+            		var2 = FCEntityVillager.createVillager(par1World);
+            	}
+            	else {
+            		var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	}
             }
         }
         catch (Exception var4)
@@ -144,7 +178,10 @@ public class EntityList
 
         if (var2 == null)
         {
+        	//Client
             par1World.getWorldLogAgent().logWarning("Skipping Entity with id " + par0);
+            //Server
+            //par1World.getWorldLogAgent().func_98236_b("Skipping Entity with id " + par0);
         }
 
         return var2;
@@ -241,4 +278,205 @@ public class EntityList
         addMapping(EntityVillager.class, "Villager", 120, 5651507, 12422002);
         addMapping(EntityEnderCrystal.class, "EnderCrystal", 200);
     }
-}
+
+    public static void AddMapping( Class entityClass, String sName, int iID )
+    {
+    	addMapping( entityClass, sName, iID );
+    }
+
+    public static boolean RemoveMapping( String sName, boolean bRemoveEgg )
+    {
+    	Integer iID = (Integer)stringToIDMapping.get( sName );
+
+    	if ( iID != null )
+    	{
+	    	Class mappedClass = (Class)IDtoClassMapping.get( Integer.valueOf( iID ) );
+
+	    	if ( mappedClass != null )
+	    	{
+	    		stringToClassMapping.remove( sName );
+	    		classToStringMapping.remove( mappedClass );
+	    		IDtoClassMapping.remove( iID );
+	    		classToIDMapping.remove( mappedClass );
+	    		stringToIDMapping.remove( sName );
+
+	    		if ( bRemoveEgg )
+	    		{
+		    		// may or may not have an egg, but this is a safe operation
+
+	    			entityEggs.remove( iID );
+	    		}
+
+	    		return true;
+	    	}
+    	}
+
+    	return false;
+    }
+
+    public static boolean ReplaceExistingMapping( Class newClass, String sName )
+    {    	
+    	Integer iID = (Integer)stringToIDMapping.get( sName );
+
+    	if ( iID != null )
+    	{
+    		if ( RemoveMapping( sName, false ) ) // egg mapping intentionally left in place
+    		{    		
+    			addMapping( newClass, sName, iID );
+    		}
+    	}
+
+    	return false;
+    }
+
+    /**
+     * Replaces entity mapping but leaves the mapping from class to id so the game won't crash if it tries to spawn something of a class which has been replaced
+     * Does not handle spawnable mobs
+     * @param newClass The new class to be added to the mapping
+     * @param entityName The internal name of the entity
+     * @return
+     */
+    public static boolean replaceExistingMappingSafe(Class newClass, String entityName) {
+        int id = (Integer) stringToIDMapping.get(entityName);
+
+        if (removeMappingSafe(entityName, false)) {
+            addMapping(newClass, entityName, id);
+        }
+
+        return false;
+    }
+    
+    /**
+     * Same behavior as replaceExistingMappingSafe except with a wrapper to handle replacing mob spawn lists
+     * @param newEntity
+     * @param entityName
+     * @return
+     */
+    public static boolean replaceSpawnableMappingSafe(Class newEntity, String entityName) {
+    	Class oldEntity = (Class) stringToClassMapping.get(entityName);
+    	
+    	//Super janky implementation
+    	//Code ripped from old version of deco
+    	//Reflection should not be necessary here, but for now I am using code that works, it can be cleaned up later
+    	
+    	//TODO: Clean up
+    	try {
+			for (BiomeGenBase b : BiomeGenBase.biomeList) {
+				if (b == null)
+					continue;
+
+				Field creatureList;
+				Field monsterList;
+				Field waterCreatureList;
+				Field caveCreatureList;
+
+				if (FCUtilsReflection.isObfuscated()) {
+					if (b.getClass().getSuperclass().equals(BiomeGenBase.class)) {
+						creatureList = b.getClass().getSuperclass().getDeclaredField("K");
+						monsterList = b.getClass().getSuperclass().getDeclaredField("J");
+						waterCreatureList = b.getClass().getSuperclass().getDeclaredField("L");
+						caveCreatureList = b.getClass().getSuperclass().getDeclaredField("M");
+					}
+					else {
+						creatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("K");
+						monsterList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("J");
+						waterCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("L");
+						caveCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("M");
+					}
+				}
+				else {
+					if (b.getClass().getSuperclass().equals(BiomeGenBase.class)) {
+						creatureList = b.getClass().getSuperclass().getDeclaredField("spawnableCreatureList");
+						monsterList = b.getClass().getSuperclass().getDeclaredField("spawnableMonsterList");
+						waterCreatureList = b.getClass().getSuperclass().getDeclaredField("spawnableWaterCreatureList");
+						caveCreatureList = b.getClass().getSuperclass().getDeclaredField("spawnableCaveCreatureList");
+					}
+					else {
+						creatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableCreatureList");
+						monsterList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableMonsterList");
+						waterCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableWaterCreatureList");
+						caveCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableCaveCreatureList");
+					}
+				}
+
+				creatureList.setAccessible(true);
+				monsterList.setAccessible(true);
+				waterCreatureList.setAccessible(true);
+				caveCreatureList.setAccessible(true);
+
+				ArrayList<SpawnListEntry> creature = (ArrayList<SpawnListEntry>)creatureList.get(b);
+				ArrayList<SpawnListEntry> monster = (ArrayList<SpawnListEntry>)monsterList.get(b);
+				ArrayList<SpawnListEntry> water = (ArrayList<SpawnListEntry>)waterCreatureList.get(b);
+				ArrayList<SpawnListEntry> cave = (ArrayList<SpawnListEntry>)caveCreatureList.get(b);
+
+				for (SpawnListEntry s : creature) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : monster) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : water) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : cave) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				return replaceExistingMappingSafe(newEntity, entityName);
+			}
+		} catch (NoSuchFieldException e) {
+			if (FCUtilsReflection.isObfuscated()) {
+				e.printStackTrace();
+			}
+			else {
+				FCUtilsReflection.setObfuscated(true);
+				replaceSpawnableMappingSafe(newEntity, entityName);
+			}
+			e.printStackTrace();
+		} catch (SecurityException e) {
+			e.printStackTrace();
+		} catch (IllegalArgumentException e) {
+			e.printStackTrace();
+		} catch (IllegalAccessException e) {
+			e.printStackTrace();
+		}
+    	
+    	return false;
+    }
+
+    public static boolean removeMappingSafe(String var0, boolean var1)
+    {
+        Integer var2 = (Integer)stringToIDMapping.get(var0);
+
+        if (var2 != null)
+        {
+            Class var3 = (Class)IDtoClassMapping.get(Integer.valueOf(var2.intValue()));
+
+            if (var3 != null)
+            {
+                stringToClassMapping.remove(var0);
+                IDtoClassMapping.remove(var2);
+
+                if (var1)
+                {
+                    entityEggs.remove(var2);
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/EntityLiving.java b/minecraft/net/minecraft/src/EntityLiving.java
index 6253e99..e108a87 100644
--- a/minecraft/net/minecraft/src/EntityLiving.java
+++ b/minecraft/net/minecraft/src/EntityLiving.java
@@ -1,10 +1,13 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mob.MobRandomizer.ExtraInfo;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.Map;
+import java.util.HashMap;
 
 public abstract class EntityLiving extends Entity
 {
@@ -12,16 +15,36 @@ public abstract class EntityLiving extends Entity
      * An array of probabilities that determines whether a random enchantment should be added to the held item. Indexed
      * by difficulty.
      */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+	/*
     private static final float[] enchantmentProbability = new float[] {0.0F, 0.0F, 0.1F, 0.2F};
+    */
+    private static final float[] enchantmentProbability = new float[] {0.05F, 0.05F, 0.05F, 0.05F};
+    // END FCMOD
 
     /** Probability to get enchanted armor */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+	/*
     private static final float[] armorEnchantmentProbability = new float[] {0.0F, 0.0F, 0.25F, 0.5F};
+    */
+    private static final float[] armorEnchantmentProbability = new float[] {0.05F, 0.05F, 0.05F, 0.05F};
+    // END FCMOD
 
     /** Probability to get armor */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+    /*
     private static final float[] armorProbability = new float[] {0.0F, 0.0F, 0.05F, 0.07F};
+    */
+    private static final float[] armorProbability = new float[] {0.0025F, 0.0025F, 0.0025F, 0.0025F};
+    // END FCMOD
 
     /** Probability to pick up loot */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+    /*
     public static final float[] pickUpLootProability = new float[] {0.0F, 0.1F, 0.15F, 0.45F};
+    */
+    public static final float[] pickUpLootProability = new float[] {0.15F, 0.15F, 0.15F, 0.15F};
+    // END FCMOD
     public int maxHurtResistantTime = 20;
     public float field_70769_ao;
     public float field_70770_ap;
@@ -97,10 +120,15 @@ public abstract class EntityLiving extends Entity
     public float prevCameraPitch;
     public float cameraPitch;
 
+    // FCMOD: Changed for clarity with Entity.isDead.  This one tells you if a creature has shed its mortal coil.  Entity.isDead is whether an entity is flagged to be removed from the game
+    /*
+    protected boolean dead = false;
+    */
     /**
-     * This gets set on entity death, but never used. Looks like a duplicate of isDead
+     * Tells if a creature has shed its mortal coil.  Entity.isDead is whether an entity is flagged to be removed from the game
      */
-    protected boolean dead = false;
+    protected boolean isLivingDead = false;
+    // END FCMOD
 
     /** The experience points the Entity gives. */
     protected int experienceValue;
@@ -125,8 +153,14 @@ public abstract class EntityLiving extends Entity
     protected int recentlyHit = 0;
 
     /** is only being set, has no uses as of MC 1.1 */
+    // FCMOD: Changed to public
+    /*
     private EntityLiving entityLivingToAttack = null;
     private int revengeTimer = 0;
+    */
+    public EntityLiving entityLivingToAttack = null;
+    public int revengeTimer = 0;
+    // END FCMOD
     private EntityLiving lastAttackingEntity = null;
     public int arrowHitTimer = 0;
     protected HashMap activePotionsMap = new HashMap();
@@ -241,6 +275,10 @@ public abstract class EntityLiving extends Entity
         }
 
         this.stepHeight = 0.5F;
+        
+        // FCMOD: Code added to prevent all living sounds playing very rapidly as entities are loaded (was particularly noticeable with ghasts)
+        livingSoundTime = -getTalkInterval();
+        // END FCMOD        
     }
 
     protected int func_96121_ay()
@@ -336,8 +374,11 @@ public abstract class EntityLiving extends Entity
 
     public boolean attackEntityAsMob(Entity par1Entity)
     {
-        this.setLastAttackingEntity(par1Entity);
-        return false;
+        // FCMOD: Changed
+        //this.setLastAttackingEntity(par1Entity);
+        //return false;
+        return MeleeAttack( par1Entity );
+        // END FCMOD
     }
 
     /**
@@ -352,6 +393,13 @@ public abstract class EntityLiving extends Entity
      * Sets the active target the Task system uses for tracking
      */
     public void setAttackTarget(EntityLiving par1EntityLiving)
+    // FCMOD: Added to allow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingSetAttackTarget(par1EntityLiving);
+    }
+    
+    protected void EntityLivingSetAttackTarget(EntityLiving par1EntityLiving)
+    // END FCMOD
     {
         this.attackTarget = par1EntityLiving;
     }
@@ -361,7 +409,12 @@ public abstract class EntityLiving extends Entity
      */
     public boolean canAttackClass(Class par1Class)
     {
+    	// FCMOD: Changed
+    	/*
         return EntityCreeper.class != par1Class && EntityGhast.class != par1Class;
+        */
+        return FCEntityCreeper.class != par1Class && FCEntityGhast.class != par1Class;
+        // END FCMOD
     }
 
     /**
@@ -464,10 +517,15 @@ public abstract class EntityLiving extends Entity
     /**
      * returns true if the entity provided in the argument can be seen. (Raytrace)
      */
+	// FCMOD: Code removed and replaced later so that entities can be seen through blocks that don't stop movement
+	/*
     public boolean canEntityBeSeen(Entity par1Entity)
     {
         return this.worldObj.rayTraceBlocks(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ), this.worldObj.getWorldVec3Pool().getVecFromPool(par1Entity.posX, par1Entity.posY + (double)par1Entity.getEyeHeight(), par1Entity.posZ)) == null;
     }
+    */
+    // END FCMOD
+
 
     /**
      * Returns the texture's file path as a String.
@@ -565,11 +623,16 @@ public abstract class EntityLiving extends Entity
                 this.attackEntityFrom(DamageSource.drown, 2);
             }
 
-            this.extinguish();
+            this.extinguish();            
         }
         else
         {
+        	// FCMOD: Code change for players to recover air gradually
+        	/*
             this.setAir(300);
+            */
+        	RecoverAirSupply();
+        	// END FCMOD
         }
 
         this.prevCameraPitch = this.cameraPitch;
@@ -623,6 +686,13 @@ public abstract class EntityLiving extends Entity
                 this.setRevengeTarget((EntityLiving)null);
             }
         }
+        
+        // FCMOD: Added to prevent problems with the AI sometimes going into limbo due to dead targets 
+        if ( attackTarget != null && !attackTarget.isEntityAlive() )
+        {
+    		setAttackTarget( null );
+        }
+        // END FCMOD
 
         this.updatePotionEffects();
         this.field_70763_ax = this.field_70764_aw;
@@ -655,6 +725,17 @@ public abstract class EntityLiving extends Entity
                     this.worldObj.spawnEntityInWorld(new EntityXPOrb(this.worldObj, this.posX, this.posY, this.posZ, var2));
                 }
             }
+            // FCMOD: Code added to spawn Dragon Orbs when the creature is not killed by a player
+            else if (!worldObj.isRemote && !isChild())
+	        {
+            	int iExperienceDropped = getExperiencePoints(attackingPlayer);
+
+            	if ( iExperienceDropped > 0 )
+            	{
+            		worldObj.spawnEntityInWorld(new EntityXPOrb(worldObj, posX, posY, posZ, getExperiencePoints(attackingPlayer), true ) );
+            	}
+	        }
+	        // END FCMOD
 
             this.setDead();
 
@@ -964,6 +1045,12 @@ public abstract class EntityLiving extends Entity
             }
             else
             {
+            	// FCMOD: Code added
+            	if ( par1DamageSource == FCDamageSourceCustom.m_DamageSourceChoppingBlock )
+        		{
+            		m_iRecentlyOnChoppingBlockCountdown = m_iOnChoppingBlockMaxCountdown;
+            	}
+            	// END FCMOD
                 if ((par1DamageSource == DamageSource.anvil || par1DamageSource == DamageSource.fallingBlock) && this.getCurrentItemOrArmor(4) != null)
                 {
                     this.getCurrentItemOrArmor(4).damageItem(par2 * 4 + this.rand.nextInt(par2 * 2), this);
@@ -1040,6 +1127,9 @@ public abstract class EntityLiving extends Entity
                         }
 
                         this.attackedAtYaw = (float)(Math.atan2(var7, var9) * 180.0D / Math.PI) - this.rotationYaw;
+                        // FCMOD: Added to limit knockback with crappy weapons
+                        if ( par2 > 1 || var4.isSprinting() )
+                    	// END FCMOD
                         this.knockBack(var4, par2, var9, var7);
                     }
                     else
@@ -1224,7 +1314,10 @@ public abstract class EntityLiving extends Entity
     {
         this.isAirBorne = true;
         float var7 = MathHelper.sqrt_double(par3 * par3 + par5 * par5);
-        float var8 = 0.4F;
+        // FCMOD: Changed
+        //float var8 = 0.4F;
+        float var8 = KnockbackMagnitude();
+        // END FCMOD
         this.motionX /= 2.0D;
         this.motionY /= 2.0D;
         this.motionZ /= 2.0D;
@@ -1241,6 +1334,8 @@ public abstract class EntityLiving extends Entity
     /**
      * Called when the mob's health reaches 0.
      */
+    // FCMOD: Function removed and replaced by custom one below
+    /*
     public void onDeath(DamageSource par1DamageSource)
     {
         Entity var2 = par1DamageSource.getEntity();
@@ -1286,6 +1381,8 @@ public abstract class EntityLiving extends Entity
 
         this.worldObj.setEntityState(this, (byte)3);
     }
+    */
+    // END FCMOD
 
     protected void dropRareDrop(int par1) {}
 
@@ -1294,6 +1391,13 @@ public abstract class EntityLiving extends Entity
      * par2 - Level of Looting used to kill this mob.
      */
     protected void dropFewItems(boolean par1, int par2)
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingDropFewItems( par1, par2 );
+    }
+    
+    protected void EntityLivingDropFewItems(boolean par1, int par2)
+    // END FCMOD
     {
         int var3 = this.getDropItemId();
 
@@ -1325,6 +1429,13 @@ public abstract class EntityLiving extends Entity
      * Called when the mob is falling. Calculates and applies fall damage.
      */
     protected void fall(float par1)
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingFall(par1);
+    }
+    
+    protected void EntityLivingFall(float par1)
+    // END FCMOD
     {
         super.fall(par1);
         int var2 = MathHelper.ceiling_float_int(par1 - 3.0F);
@@ -1368,6 +1479,12 @@ public abstract class EntityLiving extends Entity
             this.motionZ *= 0.800000011920929D;
             this.motionY -= 0.02D;
 
+            // FCMOD: Code added to apply move penalties in water
+            float fModifier = GetSwimmingHorizontalModifier();
+            motionX *= fModifier;
+            motionZ *= fModifier;
+            // END FCMOD
+
             if (this.isCollidedHorizontally && this.isOffsetPositionInLiquid(this.motionX, this.motionY + 0.6000000238418579D - this.posY + var9, this.motionZ))
             {
                 this.motionY = 0.30000001192092896D;
@@ -1394,12 +1511,25 @@ public abstract class EntityLiving extends Entity
 
             if (this.onGround)
             {
+            	// FCMOD: Changed
+            	/*
                 var3 = 0.54600006F;
                 int var4 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
+                */
+            	var3 = GetDefaultSlipperinessOnGround();
+                int var4 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), 
+                	MathHelper.floor_double(this.boundingBox.minY - 0.25F), // reduced from full block offset above to not slip on partial blocks like slabs 
+                	MathHelper.floor_double(this.posZ));
+            	// END FCMOD
 
                 if (var4 > 0)
                 {
+                	// FCMOD: Changed
+                	/*
                     var3 = Block.blocksList[var4].slipperiness * 0.91F;
+                    */
+                	var3 = GetSlipperinessRelativeToBlock( var4 );
+                	// END FCMOD
                 }
             }
 
@@ -1429,12 +1559,25 @@ public abstract class EntityLiving extends Entity
 
             if (this.onGround)
             {
+            	// FCMOD: Changed
+            	/*
                 var3 = 0.54600006F;
                 int var6 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
+                */
+            	var3 = GetDefaultSlipperinessOnGround();
+                int var6 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), 
+                	MathHelper.floor_double(this.boundingBox.minY - 0.25F), // reduced from full block offset above to not slip on partial blocks like slabs 
+                	MathHelper.floor_double(this.posZ));
+            	// END FCMOD
 
                 if (var6 > 0)
                 {
+                	// FCMOD: Changed
+                	/*
                     var3 = Block.blocksList[var6].slipperiness * 0.91F;
+                    */
+                	var3 = GetSlipperinessRelativeToBlock( var6 );
+                	// END FCMOD
                 }
             }
 
@@ -1475,6 +1618,10 @@ public abstract class EntityLiving extends Entity
                 {
                     this.motionY = 0.0D;
                 }
+                // FCMOD: Code added to apply move penalties on ladders                
+                float fModifier = GetLadderVerticalMovementModifier();
+                motionY *= fModifier;
+                // END FCMOD
             }
 
             this.moveEntity(this.motionX, this.motionY, this.motionZ);
@@ -1507,21 +1654,23 @@ public abstract class EntityLiving extends Entity
 
         this.prevLimbYaw = this.limbYaw;
         var9 = this.posX - this.prevPosX;
-        double var11 = this.posZ - this.prevPosZ;
-        float var12 = MathHelper.sqrt_double(var9 * var9 + var11 * var11) * 4.0F;
+        double var12 = this.posZ - this.prevPosZ;
+        float var11 = MathHelper.sqrt_double(var9 * var9 + var12 * var12) * 4.0F;
 
-        if (var12 > 1.0F)
+        if (var11 > 1.0F)
         {
-            var12 = 1.0F;
+            var11 = 1.0F;
         }
 
-        this.limbYaw += (var12 - this.limbYaw) * 0.4F;
+        this.limbYaw += (var11 - this.limbYaw) * 0.4F;
         this.limbSwing += this.limbYaw;
     }
 
     /**
      * returns true if this entity is by a ladder, false otherwise
      */
+    // FCMOD: Removed and replaced later
+    /*
     public boolean isOnLadder()
     {
         int var1 = MathHelper.floor_double(this.posX);
@@ -1530,12 +1679,16 @@ public abstract class EntityLiving extends Entity
         int var4 = this.worldObj.getBlockId(var1, var2, var3);
         return var4 == Block.ladder.blockID || var4 == Block.vine.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to write subclass entity data to NBT.
      */
     public void writeEntityToNBT(NBTTagCompound par1NBTTagCompound)
     {
+    	ExtraInfo.writeToNBT(this, par1NBTTagCompound);
+    	
         if (this.health < -32768)
         {
             this.health = -32768;
@@ -1595,6 +1748,7 @@ public abstract class EntityLiving extends Entity
      */
     public void readEntityFromNBT(NBTTagCompound par1NBTTagCompound)
     {
+    	ExtraInfo.readFromNBT(this, par1NBTTagCompound);
         this.health = par1NBTTagCompound.getShort("Health");
 
         if (!par1NBTTagCompound.hasKey("Health"))
@@ -1678,6 +1832,13 @@ public abstract class EntityLiving extends Entity
      * use this to react to sunlight and start to burn.
      */
     public void onLivingUpdate()
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingOnLivingUpdate();
+    }
+    
+    protected void EntityLivingOnLivingUpdate()
+    // END FCMOD
     {
         if (this.jumpTicks > 0)
         {
@@ -1749,9 +1910,19 @@ public abstract class EntityLiving extends Entity
 
         if (this.isJumping)
         {
+        	// FCMOD: Line change
+        	/*
             if (!this.isInWater() && !this.handleLavaMovement())
+            */
+            if ( ( !this.isInWater() && !this.handleLavaMovement() ) || !CanSwim() )
+        	// END FCMOD
             {
+            	// FCMOD: Changed
+            	/*
                 if (this.onGround && this.jumpTicks == 0)
+                */
+                if ( CanJump() && ( onGround || CanJumpMidWater() ) && this.jumpTicks == 0)
+        		// END FCMOD            		
                 {
                     this.jump();
                     this.jumpTicks = 10;
@@ -1787,7 +1958,12 @@ public abstract class EntityLiving extends Entity
         this.worldObj.theProfiler.endSection();
         this.worldObj.theProfiler.startSection("looting");
 
+        // FCMOD: Changed for "isLivingDead"
+        /*
         if (!this.worldObj.isRemote && this.canPickUpLoot() && !this.dead && this.worldObj.getGameRules().getGameRuleBooleanValue("mobGriefing"))
+        */
+        if (!this.worldObj.isRemote && this.canPickUpLoot() && !isLivingDead && this.worldObj.getGameRules().getGameRuleBooleanValue("mobGriefing"))
+        // END FCMOD
         {
             List var2 = this.worldObj.getEntitiesWithinAABB(EntityItem.class, this.boundingBox.expand(1.0D, 0.0D, 1.0D));
             Iterator var12 = var2.iterator();
@@ -1876,6 +2052,9 @@ public abstract class EntityLiving extends Entity
         }
 
         this.worldObj.theProfiler.endSection();
+        // FCMOD: Added
+        ModSpecificOnLivingUpdate();
+        // END FCMOD
     }
 
     protected void func_85033_bc()
@@ -1911,6 +2090,7 @@ public abstract class EntityLiving extends Entity
 
     /**
      * Returns whether the entity is in a local (client) world
+     * FCNOTE: This is horribly named.  For everything other than EntityPlayerSP, this returns true if !world.isRemote
      */
     protected boolean isClientWorld()
     {
@@ -1942,7 +2122,12 @@ public abstract class EntityLiving extends Entity
             this.motionY += (double)((float)(this.getActivePotionEffect(Potion.jump).getAmplifier() + 1) * 0.1F);
         }
 
+        // FCMOD: Changed to avoid jump exploit in shallow water while weighted
+		/*
         if (this.isSprinting())
+		*/
+        if (isSprinting() && !isInWater())
+    	// END FCMOD
         {
             float var1 = this.rotationYaw * 0.017453292F;
             this.motionX -= (double)(MathHelper.sin(var1) * 0.2F);
@@ -1963,6 +2148,8 @@ public abstract class EntityLiving extends Entity
     /**
      * Makes the entity despawn if requirements are reached
      */
+    // FCMOD: Removed and replaced
+    /*
     protected void despawnEntity()
     {
         if (!this.persistenceRequired)
@@ -1992,8 +2179,17 @@ public abstract class EntityLiving extends Entity
             }
         }
     }
+    */
+    // END FCMOD
 
     protected void updateAITasks()
+    // FCMOD: Added to allow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingUpdateAITasks();
+    }
+    
+    protected void EntityLivingUpdateAITasks()
+    // END FCMOD
     {
         ++this.entityAge;
         this.worldObj.theProfiler.startSection("checkDespawn");
@@ -2382,6 +2578,12 @@ public abstract class EntityLiving extends Entity
 
         if (var12 > 0)
         {
+            // FCMOD: Code added to not display potion particles if all effects come from beacons     
+            if ( HasOnlyAmbientPotionEffects( activePotionsMap.values() ) )
+            {
+            	return;
+            }
+            // END FCMOD
             boolean var4 = false;
 
             if (!this.isInvisible())
@@ -2470,6 +2672,8 @@ public abstract class EntityLiving extends Entity
 
     public boolean isPotionApplicable(PotionEffect par1PotionEffect)
     {
+    	// FCMOD: Code removed to get rid of undead special casing on potion use
+    	/*
         if (this.getCreatureAttribute() == EnumCreatureAttribute.UNDEAD)
         {
             int var2 = par1PotionEffect.getPotionID();
@@ -2479,6 +2683,8 @@ public abstract class EntityLiving extends Entity
                 return false;
             }
         }
+        */
+    	// END FCMOD
 
         return true;
     }
@@ -2531,6 +2737,8 @@ public abstract class EntityLiving extends Entity
      * This method returns a value to be applied directly to entity speed, this factor is less than 1 when a slowdown
      * potion effect is applied, more than 1 when a haste potion effect is applied and 2 for fleeing entities.
      */
+    // FCMOD: Function removed and replaced later
+    /*
     public float getSpeedModifier()
     {
         float var1 = 1.0F;
@@ -2552,6 +2760,8 @@ public abstract class EntityLiving extends Entity
 
         return var1;
     }
+    */
+    // END FCMOD
 
     /**
      * Move the entity to the coordinates informed, but keep yaw/pitch values.
@@ -2605,6 +2815,8 @@ public abstract class EntityLiving extends Entity
         }
         else
         {
+        	// FCTODO: As far as I can tell, the following code can never be anything other than zero unless health is greater than max health (which shouldn't happen), 
+        	// and thus has no effect.  Figure out what's going on here and if difficulty actually impacts anything.
             int var1 = (int)((float)this.health - (float)this.getMaxHealth() * 0.33F);
             var1 -= (3 - this.worldObj.difficultySetting) * 4;
 
@@ -2666,6 +2878,9 @@ public abstract class EntityLiving extends Entity
                 if (!var5 && var4.isItemStackDamageable())
                 {
                     int var6 = Math.max(var4.getMaxDamage() - 25, 1);
+                    // FCMOD: Code added to provide a better range on damage
+                    var6 = Math.max( (int)((float)var4.getMaxDamage() * 0.95F), 1);
+                    // END FCMOD
                     int var7 = var4.getMaxDamage() - this.rand.nextInt(this.rand.nextInt(var6) + 1);
 
                     if (var7 > var6)
@@ -2690,12 +2905,23 @@ public abstract class EntityLiving extends Entity
      * Makes entity wear random armor based on difficulty
      */
     protected void addRandomArmor()
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingAddRandomArmor();
+    }
+    
+    protected void EntityLivingAddRandomArmor()
+    // END FCMOD
     {
         if (this.rand.nextFloat() < armorProbability[this.worldObj.difficultySetting])
         {
             int var1 = this.rand.nextInt(2);
             float var2 = this.worldObj.difficultySetting == 3 ? 0.1F : 0.25F;
 
+            // FCMOD: Code added to make armor drop rate equal on all difficulty levels
+            var2 = 0.1F;
+            // END FCMOD
+
             if (this.rand.nextFloat() < 0.095F)
             {
                 ++var1;
@@ -2727,6 +2953,10 @@ public abstract class EntityLiving extends Entity
                     if (var5 != null)
                     {
                         this.setCurrentItemOrArmor(var3 + 1, new ItemStack(var5));
+                        
+                        // FCMOD: Code added to increase armor drop on mobs
+                        equipmentDropChances[var3 + 1] = 0.75F;
+                        // END FCMOD
                     }
                 }
             }
@@ -2792,6 +3022,8 @@ public abstract class EntityLiving extends Entity
     /**
      * Params: Armor slot, Item tier
      */
+    // FCMOD: Function removed and replaced by custom one below
+    /*
     public static Item getArmorItemForSlot(int par0, int par1)
     {
         switch (par0)
@@ -2888,12 +3120,19 @@ public abstract class EntityLiving extends Entity
                 return null;
         }
     }
+    */
+    // END FCMOD
 
     protected void func_82162_bC()
     {
         if (this.getHeldItem() != null && this.rand.nextFloat() < enchantmentProbability[this.worldObj.difficultySetting])
         {
+        	// FCMOD: Code change to make enchant strength on mob drops uniform accross difficulty levels
+        	/*
             EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItem(), 5 + this.worldObj.difficultySetting * this.rand.nextInt(6));
+            */
+            EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItem(), 7 * this.rand.nextInt(6));
+        	// END FCMOD
         }
 
         for (int var1 = 0; var1 < 4; ++var1)
@@ -2902,7 +3141,12 @@ public abstract class EntityLiving extends Entity
 
             if (var2 != null && this.rand.nextFloat() < armorEnchantmentProbability[this.worldObj.difficultySetting])
             {
+            	// FCMOD: Code change to make enchant strength on mob drops uniform accross difficulty levels
+            	/*
                 EnchantmentHelper.addRandomEnchantment(this.rand, var2, 5 + this.worldObj.difficultySetting * this.rand.nextInt(6));
+                */
+                EnchantmentHelper.addRandomEnchantment(this.rand, var2, 7 * this.rand.nextInt(6));
+            	// END FCMOD
             }
         }
     }
@@ -2910,6 +3154,10 @@ public abstract class EntityLiving extends Entity
     /**
      * Initialize this creature.
      */
+    /**
+     * FCNOTE: this function is only called when creatures spawn into the world, NOT
+     * when they are birthed or loaded.
+     */
     public void initCreature() {}
 
     /**
@@ -3021,8 +3269,615 @@ public abstract class EntityLiving extends Entity
         this.canPickUpLoot = par1;
     }
 
-    public boolean func_104002_bU()
+    // FCMOD: Changed for clarity
+    //public boolean func_104002_bU()
+    public boolean GetIsPersistent()
+    // END FCMOD
     {
         return this.persistenceRequired;
     }
+
+    // FCMOD: Added New
+    private int m_iRecentlyOnChoppingBlockCountdown = 0;
+    
+    public static final int m_iOnChoppingBlockMaxCountdown = 40;
+    
+    public boolean isOnLadder()
+    {
+        int i = MathHelper.floor_double( posX );
+        int j = MathHelper.floor_double( boundingBox.minY );
+        int k = MathHelper.floor_double( posZ );
+        
+        Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
+        
+    	return block != null && block.IsBlockClimbable( worldObj, i, j, k );  
+    }
+    
+    protected void ModSpecificOnLivingUpdate()
+    {
+    	if ( m_iRecentlyOnChoppingBlockCountdown > 0 )
+    	{
+    		m_iRecentlyOnChoppingBlockCountdown--;
+    	}
+    }
+    
+    public float getSpeedModifier()
+    {
+        float fMoveSpeed = 1.0F;
+
+        if (this.isPotionActive(Potion.moveSlowdown))
+        {
+            fMoveSpeed *= 1.0F - 0.15F * (float)(this.getActivePotionEffect(Potion.moveSlowdown).getAmplifier() + 1);
+        }
+        else if (this.isPotionActive(Potion.moveSpeed))
+        {
+            fMoveSpeed *= 1.0F + 0.15F * (float)(this.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1);
+        }
+
+        if ( onGround && IsAffectedByMovementModifiers() )
+        {
+        	int iGroundI = MathHelper.floor_double( posX );
+        	int iGroundJ = MathHelper.floor_double( posY - 0.03D - (double)yOffset ); // same calc used for step sound
+        	int iGroundK = MathHelper.floor_double( posZ );
+        	
+        	if ( FCUtilsWorld.IsGroundCoverOnBlock( worldObj, iGroundI, iGroundJ, iGroundK ) )
+        	{
+        		fMoveSpeed *= 0.8F;
+        	}
+        	
+        	Block blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+        	
+        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+        	{
+        		float fHalfWidth = width / 2F;
+        		
+        		// block we are standing on directly is air or has no collision box.  Check the horizontal extents of our box for a movement modifier
+
+        		int iCenterGroundI = iGroundI;
+        		
+        		iGroundI = MathHelper.floor_double( posX + fHalfWidth );	        		
+	        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+	        	
+	        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+	        	{
+	        		iGroundI = MathHelper.floor_double( posX - fHalfWidth );
+		        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+		        	
+		        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+		        	{
+		        		iGroundI = iCenterGroundI;
+		        		
+		        		iGroundK = MathHelper.floor_double( posZ + fHalfWidth );
+			        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+			        	
+			        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+			        	{
+			        		iGroundK = MathHelper.floor_double( posZ - fHalfWidth );
+				        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];					        	
+			        	}
+		        	}
+	        	}
+	        	
+        	}
+        	
+        	if ( blockOn != null )
+        	{
+        		fMoveSpeed *= blockOn.GetMovementModifier( worldObj, iGroundI, iGroundJ, iGroundK );        		
+        	}
+        	
+        	fMoveSpeed *= GetLandMovementModifier();
+        }
+        
+        if ( fMoveSpeed < 0.0F)
+        {
+            fMoveSpeed = 0.0F;
+        }
+
+        return fMoveSpeed;
+    }
+    
+    protected float GetHealthAndExhaustionModifier()
+    {
+    	return 1.0F;
+    }
+    
+    protected float GetSwimmingHorizontalModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+    protected float GetLandMovementModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+    protected float GetLadderVerticalMovementModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+    public static Item getArmorItemForSlot(int par0, int par1)
+    {
+        switch (par0)
+        {
+            case 4:
+            	
+                if ( par1 == 4 )
+                {
+                    return Item.helmetChain;
+                }
+                else
+                {
+                    return Item.helmetIron;
+                }
+
+            case 3:
+
+                if (par1 == 4)
+                {
+                    return Item.plateChain;
+                }
+                else
+                {
+                    return Item.plateIron;
+                }
+
+            case 2:
+
+                if (par1 == 4)
+                {
+                    return Item.legsChain;
+                }
+                else
+                {
+                    return Item.legsIron;
+                }
+
+            case 1:
+
+                if (par1 == 4)
+                {
+                    return Item.bootsChain;
+                }
+                else
+                {
+                    return Item.bootsIron;
+                }
+
+            default:
+            	
+                return null;
+        }
+    }
+    
+    public void onDeath( DamageSource source )
+    {
+    	EntityLivingOnDeath( source );
+    }
+    
+    public void EntityLivingOnDeath( DamageSource source )
+    {
+        EntityLiving killCreditedEntity = this.func_94060_bK();
+
+        if (this.scoreValue >= 0 && killCreditedEntity != null)
+        {
+            killCreditedEntity.addToPlayerScore(this, this.scoreValue);
+        }
+
+        Entity sourceEntity = source.getEntity();
+
+        if ( sourceEntity != null )
+        {
+            sourceEntity.onKillEntity( this );
+        }
+
+        isLivingDead = true;
+
+        if ( !worldObj.isRemote )
+        {
+            if ( !isChild() && worldObj.getGameRules().getGameRuleBooleanValue( "doMobLoot" ) )
+            {
+                int iLootingModifier = GetAmbientLootingModifier();
+
+                if ( sourceEntity instanceof EntityPlayer )
+                {
+                    int iPlayerLootingModifier = EnchantmentHelper.getLootingModifier((EntityLiving)sourceEntity);
+                    
+                    if ( iPlayerLootingModifier > iLootingModifier )
+                    {
+                    	iLootingModifier = iPlayerLootingModifier;
+                    }
+                }
+
+                dropFewItems( true, iLootingModifier);
+                dropEquipment( true, iLootingModifier);
+                
+                CheckForRareDrop( source, iLootingModifier );
+
+                CheckForHeadDrop( source, iLootingModifier );
+                
+            	CheckForScrollDrop();
+            }
+        }
+
+        this.worldObj.setEntityState(this, (byte)3);
+    }
+
+    protected void CheckForRareDrop( DamageSource source, int iLootingModifier )
+    {
+        int iChance = rand.nextInt(800) - ( iLootingModifier * 4 );
+
+        if ( iChance < 5 )
+        {
+            dropRareDrop( iChance <= 0 ? 1 : 0 );
+        }        
+    }
+    
+    public void CheckForScrollDrop()
+    {
+    }
+    
+    protected void CheckForHeadDrop( DamageSource source, int iLootingModifier )
+    {
+        Entity sourceEntity = source.getEntity();
+
+        int iHeadChance = rand.nextInt(200);
+        
+        if ( sourceEntity instanceof EntityPlayer )
+        {
+            iHeadChance -= iLootingModifier;
+            
+        	if ( ((EntityPlayer)sourceEntity).getHeldItem() != null && 
+        		((EntityPlayer)sourceEntity).getHeldItem().getItem().itemID == FCBetterThanWolves.fcItemBattleAxe.itemID )
+        	{
+        		iHeadChance = iHeadChance >> 2;
+    		}
+		}
+        else if ( source == FCDamageSourceCustom.m_DamageSourceChoppingBlock || m_iRecentlyOnChoppingBlockCountdown > 0 )
+        {
+    		iHeadChance = iHeadChance >> 2;
+        }
+        
+        if ( iHeadChance < 5 )
+        {
+            dropHead();
+        }   
+    }
+    
+    protected int GetAmbientLootingModifier()
+    {
+    	int iLocI = MathHelper.floor_double( posX );
+    	int iLocJ = MathHelper.floor_double( posY );
+    	int iLocK = MathHelper.floor_double( posZ );
+    	
+    	return worldObj.GetAmbientLootingEffectAtLocation( iLocI, iLocJ, iLocK );
+    }
+    
+    protected void dropHead()
+    {
+    }
+    
+    public boolean CanJump()
+    {
+    	return true;
+    }
+    
+    public boolean CanSwim()
+    {
+    	return !isWeighted();
+    }
+    
+    public boolean isWeighted()
+    {
+		int iWeight = GetWornArmorWeight();
+		
+		if ( iWeight >= 10 )
+		{
+			return true;
+		}
+		
+    	return IsWeightedByHeadCrab();
+    }
+    
+    protected boolean IsWeightedByHeadCrab()
+    {
+    	return HasHeadCrabbedSquid();
+    }
+    
+    @Override
+    public void OnFlungBySquidTentacle( FCEntitySquid squid )
+    {
+    	// doesn't call attackEntityFrom() by default so that monsters remain chill about it and don't attack back
+    	
+        playSound( getHurtSound(), getSoundVolume(), getSoundPitch() );        
+    }
+    
+    @Override
+    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
+    {
+    	// doesn't call attackEntityFrom() by default so that monsters remain chill about it and don't attack back
+    	
+        playSound( getHurtSound(), getSoundVolume(), getSoundPitch() );        
+    }
+    
+	protected int GetWornArmorWeight()
+	{
+		int iWeight = 0;
+		
+		for ( int iTempSlot = 0; iTempSlot < 4; iTempSlot++ )
+		{
+			ItemStack tempStack = this.getCurrentArmor( iTempSlot );
+			
+			if ( tempStack != null )
+			{
+				iWeight += tempStack.getItem().GetWeightWhenWorn();
+			}
+		}
+        
+		return iWeight;
+	}
+	
+    private boolean HasOnlyAmbientPotionEffects( Collection effectCollection )
+    {    	
+        if ( effectCollection != null && !effectCollection.isEmpty() )
+        {
+            Iterator effectIterator = effectCollection.iterator();
+
+            while (effectIterator.hasNext())
+            {
+                PotionEffect tempEffect = (PotionEffect)effectIterator.next();
+                
+                if ( !tempEffect.getIsAmbient() )
+                {
+                	return false;
+                }
+            }
+            
+        	return true;
+        }
+        
+    	return false;
+    }
+    
+    public void SpawnerInitCreature()
+    {
+    	initCreature();
+    }
+    
+    /** Initialize state variables which may affect ability to spawn, such as bounding box size */
+    public void PreInitCreature() {}
+    
+    public boolean canEntityBeSeen( Entity entity )
+    {
+    	// Vanilla code replaced so that entities can be seen through blocks that don't stop movement
+    	
+        return worldObj.rayTraceBlocks_do_do( 
+        	worldObj.getWorldVec3Pool().getVecFromPool( posX, posY + (double)getEyeHeight(), posZ ), 
+        	worldObj.getWorldVec3Pool().getVecFromPool( entity.posX, entity.posY + 
+    		(double)entity.getEyeHeight(), entity.posZ ), false, true ) == null;
+    }
+    
+    public boolean CanEntityCenterOfMassBeSeen( Entity entity )
+    {
+    	// Same as above, but to other entities' center rather than eye to eye
+    	
+        return worldObj.rayTraceBlocks_do_do( 
+        	worldObj.getWorldVec3Pool().getVecFromPool( posX, posY + (double)getEyeHeight(), posZ ), 
+        	worldObj.getWorldVec3Pool().getVecFromPool( entity.posX, entity.posY + 
+    		( entity.height / 2F ), entity.posZ ), false, true ) == null;
+    }
+    
+    protected void RecoverAirSupply()
+    {
+		setAir(300);		
+    }
+    
+    public void SetPersistent( boolean bPersistant )
+    {
+    	persistenceRequired = bPersistant;
+    }
+
+    @Override
+    public boolean DoesEntityApplyToSpawnCap()
+    {
+    	// entities with persistance set do not apply to the spawn cap
+    	
+    	return !GetIsPersistent();
+    }
+    
+    @Override
+	public void OutOfUpdateRangeUpdate()
+	{
+    	despawnEntity();
+	}
+    
+	public float GetDefaultSlipperinessOnGround()
+    {
+        return 0.54600006F;
+    }
+    
+	public float GetSlipperinessRelativeToBlock( int iBlockID )
+	{
+    	return Block.blocksList[iBlockID].slipperiness  * 0.91F;
+	}
+	
+	public boolean CanJumpMidWater()
+	{
+		return false;
+	}
+	
+	public void OnClimbWhileSwimming()
+	{
+	}
+	
+    protected void despawnEntity()
+    {
+    	// FCCHUNK: Decide on updates around original spawn
+        if ( !persistenceRequired && canDespawn() )
+        {
+        	int iChunkX = MathHelper.floor_double( posX / 16D ); 
+    		int iChunkZ = MathHelper.floor_double( posZ / 16D );
+    		
+    		if ( !worldObj.IsChunkActive( iChunkX, iChunkZ ) )
+    		{
+        		setDead();    			
+    		}
+    		else
+    		{
+	            EntityPlayer closestPlayer = worldObj.getClosestPlayerToEntity( this, 
+	            	MinDistFromPlayerForDespawn() );
+	
+	            if ( closestPlayer != null )
+	            {
+                	// don't despawn creatures close to a player
+                	
+                    entityAge = 0;
+	            }	
+	            else if ( entityAge > 600 && rand.nextInt( 800 ) == 0 ) 
+	            {
+	                setDead();
+	            }
+    		}
+        }
+        else
+        {
+            entityAge = 0;
+        }
+    }
+    
+    protected double MinDistFromPlayerForDespawn()
+    {
+    	return 32D;
+    }
+    
+    protected boolean IsInsideSpawnAreaAroundPlayer( EntityPlayer player )
+    {
+    	return IsInsideSpawnAreaAroundChunk( 
+    		MathHelper.floor_double( player.posX / 16D ), 
+    		MathHelper.floor_double( player.posZ / 16D ) ); 
+    }
+    
+    protected boolean IsInsideSpawnAreaAroundOriginalSpawn()
+    {
+    	return worldObj.provider.dimensionId == 0 && 
+    		IsInsideSpawnAreaAroundChunk( worldObj.worldInfo.getSpawnX() >> 4,
+    			worldObj.worldInfo.getSpawnZ() >> 4 );
+    }
+    
+    protected boolean IsInsideSpawnAreaAroundChunk( int iChunkX, int iChunkZ )
+    {
+        int iValidRange = worldObj.GetMobSpawnRangeInChunks();
+        
+        int iEntityChunkX = MathHelper.floor_double( posX / 16D );
+        int iDeltaX = iChunkX - iEntityChunkX;
+        
+        if ( iDeltaX >= -iValidRange && iDeltaX <= iValidRange )
+        {
+	        int iEntityChunkZ = MathHelper.floor_double( posZ / 16D );
+	        int iDeltaZ = iChunkZ - iEntityChunkZ;
+	        
+	        if ( iDeltaZ >= -iValidRange && iDeltaZ <= iValidRange )
+	        {
+	        	return true;
+	        }
+        }   
+                    
+        return false;
+    }
+
+    @Override
+    public boolean AttractsLightning()
+    {
+    	return true;
+    }
+    
+    public int GetMeleeAttackStrength( Entity target )
+    {
+    	return 2;
+    }
+    
+    public boolean MeleeAttack( Entity target )
+    {
+        setLastAttackingEntity( target );
+        
+        int iStrength = GetMeleeAttackStrength( target );
+
+        if ( isPotionActive( Potion.damageBoost ) )
+        {
+            iStrength += 3 << getActivePotionEffect( Potion.damageBoost ).getAmplifier();
+        }
+
+        if ( isPotionActive( Potion.weakness ) )
+        {
+            iStrength -= 2 << getActivePotionEffect( Potion.weakness ).getAmplifier();
+        }
+
+        int iKnockback = 0;
+
+        if ( target instanceof EntityLiving )
+        {
+            iStrength += EnchantmentHelper.getEnchantmentModifierLiving( this, 
+            	(EntityLiving)target );
+            
+            iKnockback += EnchantmentHelper.getKnockbackModifier( this, (EntityLiving)target );
+        }
+
+        boolean bAttackSuccess = target.attackEntityFrom( DamageSource.causeMobDamage( this ), 
+        	iStrength );
+
+        if ( bAttackSuccess )
+        {
+            if ( iKnockback > 0 )
+            {
+                target.addVelocity( 
+                	-MathHelper.sin( rotationYaw * (float)Math.PI / 180F ) * iKnockback * 0.5F, 
+                	0.1D, 
+                	MathHelper.cos( rotationYaw * (float)Math.PI / 180F ) * iKnockback * 0.5F );
+                
+                motionX *= 0.6D;
+                motionZ *= 0.6D;
+            }
+
+            int iFireModifier = EnchantmentHelper.getFireAspectModifier( this );
+
+            if ( iFireModifier > 0 )
+            {
+                target.setFire( iFireModifier * 4 );
+            }
+            else if ( isBurning() && rand.nextFloat() < 0.6F )
+            {
+                target.setFire( 4 );
+            }
+
+            if ( target instanceof EntityLiving )
+            {
+                EnchantmentThorns.func_92096_a(this, (EntityLiving)target, rand);
+            }
+        }
+
+        return bAttackSuccess;
+    }
+    
+    public float KnockbackMagnitude()
+    {
+    	return 0.4F;
+    }
+    
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    public MovingObjectPosition MouseOverCustomRayTrace( double dDistance, float fInterpolationFactor )
+    {
+        Vec3 posVector = getPosition( fInterpolationFactor );
+        Vec3 lookVector = getLook( fInterpolationFactor );
+        
+        Vec3 targetVector = posVector.addVector( lookVector.xCoord * dDistance, lookVector.yCoord * dDistance, lookVector.zCoord * dDistance );
+        
+        return worldObj.MouseOverRayTrace( posVector, targetVector );
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityMagmaCube.java b/minecraft/net/minecraft/src/EntityMagmaCube.java
index 5f03071..67f8aa6 100644
--- a/minecraft/net/minecraft/src/EntityMagmaCube.java
+++ b/minecraft/net/minecraft/src/EntityMagmaCube.java
@@ -1,13 +1,16 @@
 package net.minecraft.src;
 
-public class EntityMagmaCube extends EntitySlime
+// FCMOD: Changed
+//public class EntityMagmaCube extends EntitySlime
+public class EntityMagmaCube extends FCEntitySlime
+// END FCMOD
 {
     public EntityMagmaCube(World par1World)
     {
         super(par1World);
         this.texture = "/mob/lava.png";
         this.isImmuneToFire = true;
-        this.landMovementFactor = 0.2F;
+        this.landMovementFactor = 0.5F;
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/EntityMinecart.java b/minecraft/net/minecraft/src/EntityMinecart.java
index bd8e345..c59f67a 100644
--- a/minecraft/net/minecraft/src/EntityMinecart.java
+++ b/minecraft/net/minecraft/src/EntityMinecart.java
@@ -685,9 +685,25 @@ public abstract class EntityMinecart extends Entity
         }
         else
         {
+            // FCMOD: Changed the following for less drag on non-ridden carts
+            /*
             this.motionX *= 0.9599999785423279D;
             this.motionY *= 0.0D;
             this.motionZ *= 0.9599999785423279D;
+            */
+            if ( FCBetterThanWolves.fcDisableMinecartChanges )
+            {
+                motionX *= 0.96D;
+                motionY *= 0.0D;
+                motionZ *= 0.96D;
+        	}
+            else
+            {
+                motionX *= 0.985D;
+                motionY *= 0.0D;
+                motionZ *= 0.985D;
+            }
+            // END FCMOD
         }
     }
 
@@ -1133,4 +1149,12 @@ public abstract class EntityMinecart extends Entity
     {
         return this.entityName;
     }
+    
+    // FCMOD: Code added
+    @Override
+    public boolean CanCollideWithEntity( Entity entity )
+    {
+    	return !entity.IsItemEntity();
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityMinecartChest.java b/minecraft/net/minecraft/src/EntityMinecartChest.java
index eb7e4ca..93421ff 100644
--- a/minecraft/net/minecraft/src/EntityMinecartChest.java
+++ b/minecraft/net/minecraft/src/EntityMinecartChest.java
@@ -15,7 +15,17 @@ public class EntityMinecartChest extends EntityMinecartContainer
     public void killMinecart(DamageSource par1DamageSource)
     {
         super.killMinecart(par1DamageSource);
-        this.dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
+        
+        // FCMOD: Changed
+        //this.dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
+    	dropItemWithOffset( FCBetterThanWolves.fcItemSawDust.itemID, 6, 0.0F );
+    	dropItemWithOffset( Item.stick.itemID, 2, 0.0F );
+    	
+        if ( !worldObj.isRemote )
+        {        
+			playSound( "mob.zombie.woodbreak", 0.25F, 0.75F + ( worldObj.rand.nextFloat() * 0.25F ) );
+        }
+        // END FCMOD        
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/EntityMob.java b/minecraft/net/minecraft/src/EntityMob.java
index 8252d4c..45c396c 100644
--- a/minecraft/net/minecraft/src/EntityMob.java
+++ b/minecraft/net/minecraft/src/EntityMob.java
@@ -13,6 +13,13 @@ public abstract class EntityMob extends EntityCreature implements IMob
      * use this to react to sunlight and start to burn.
      */
     public void onLivingUpdate()
+    // FCMOD: Addded so that method can be called directly regardless of hierarchy
+    {
+    	EntityMobOnLivingUpdate();
+    }
+    
+    public void EntityMobOnLivingUpdate()
+    // END FCMOD
     {
         this.updateArmSwingProgress();
         float var1 = this.getBrightness(1.0F);
@@ -52,6 +59,13 @@ public abstract class EntityMob extends EntityCreature implements IMob
      * Called when the entity is attacked.
      */
     public boolean attackEntityFrom(DamageSource par1DamageSource, int par2)
+    // FCMOD: Addded so that method can be called directly regardless of hierarchy
+    {
+    	return EntityMobAttackEntityFrom(par1DamageSource, par2);
+    }
+    
+    public boolean EntityMobAttackEntityFrom(DamageSource par1DamageSource, int par2)
+    // END FCMOD
     {
         if (this.isEntityInvulnerable())
         {
@@ -65,6 +79,9 @@ public abstract class EntityMob extends EntityCreature implements IMob
             {
                 if (var3 != this)
                 {
+                	// FCMOD: Code added so that mobs won't lose their target if they take damage from an environmental source
+                	if ( var3 != null )
+            		// END FCMOD
                     this.entityToAttack = var3;
                 }
 
@@ -81,6 +98,8 @@ public abstract class EntityMob extends EntityCreature implements IMob
         }
     }
 
+    // FCMOD: Removed and moved up in hiearchy
+	/*
     public boolean attackEntityAsMob(Entity par1Entity)
     {
         int var2 = this.getAttackStrength(par1Entity);
@@ -120,6 +139,12 @@ public abstract class EntityMob extends EntityCreature implements IMob
             {
                 par1Entity.setFire(var5 * 4);
             }
+            // FCMOD: Added so all mobs set fire to others when burning, not just zombies
+            else if ( isBurning() && rand.nextFloat() < 0.6F )
+            {
+                par1Entity.setFire( 4 );
+            }
+            // END FCMOD
 
             if (par1Entity instanceof EntityLiving)
             {
@@ -129,11 +154,20 @@ public abstract class EntityMob extends EntityCreature implements IMob
 
         return var4;
     }
+    */
+    // END FCMOD
 
     /**
      * Basic mob attack. Default to touch of death in EntityCreature. Overridden by each mob to define their attack.
      */
     protected void attackEntity(Entity par1Entity, float par2)
+    // FCMOD: Addded so that method can be called directly regardless of hierarchy
+    {
+    	EntityMobAttackEntity( par1Entity, par2 );
+    }
+    
+    protected void EntityMobAttackEntity(Entity par1Entity, float par2)
+    // END FCMOD
     {
         if (this.attackTime <= 0 && par2 < 2.0F && par1Entity.boundingBox.maxY > this.boundingBox.minY && par1Entity.boundingBox.minY < this.boundingBox.maxY)
         {
@@ -185,9 +219,12 @@ public abstract class EntityMob extends EntityCreature implements IMob
      */
     public boolean getCanSpawnHere()
     {
-        return this.isValidLightLevel() && super.getCanSpawnHere();
+    	// FCMOD: Changed
+        //return this.isValidLightLevel() && super.getCanSpawnHere();
+    	return isValidLightLevel() && super.getCanSpawnHere() && CanSpawnOnBlockBelow();
+        // END FCMOD
     }
-
+    
     /**
      * Returns the amount of damage a mob should deal.
      */
@@ -195,4 +232,60 @@ public abstract class EntityMob extends EntityCreature implements IMob
     {
         return 2;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public int GetMeleeAttackStrength( Entity target )
+    {
+    	return getAttackStrength( target );
+    }
+    
+    protected boolean CanSpawnOnBlockBelow()
+    {
+        int i = MathHelper.floor_double( posX );
+        int j = (int)boundingBox.minY - 1;
+        int k = MathHelper.floor_double( posZ );
+        
+        return CanSpawnOnBlock( worldObj.getBlockId( i, j, k ) );        
+    }
+    
+    protected boolean CanSpawnOnBlock( int iBlockID )
+    {
+    	return iBlockID != Block.leaves.blockID;
+    }
+
+    protected void CheckForCatchFireInSun()
+    {
+        if ( !worldObj.isRemote && worldObj.isDaytime() && !isChild() && !inWater )
+        {
+            float fBrightness = getBrightness( 1F );
+
+            if ( fBrightness > 0.5F && rand.nextFloat() * 30F < ( fBrightness - 0.4F ) * 2F && 
+            	worldObj.canBlockSeeTheSky( MathHelper.floor_double( posX ), 
+            		MathHelper.floor_double( posY + (double)getEyeHeight() ), 
+            		MathHelper.floor_double( posZ ) ) )
+            {
+            	// check to make sure water isn't directly below to prevent catching fire while bobbing
+            	
+            	int iBlockBelowID = worldObj.getBlockId( MathHelper.floor_double( posX ), 
+            		MathHelper.floor_double( posY - 0.1F ), MathHelper.floor_double( posZ ) );
+            	
+            	Block blockBelow = Block.blocksList[iBlockBelowID];
+            	
+            	if ( blockBelow == null || blockBelow.blockMaterial != Material.water ) 
+            	{            	                                    
+	            	// client
+	                ItemStack headStack = getCurrentItemOrArmor( 4 );
+	            	// server
+	                //ItemStack headStack = getEquipmentInSlot( 4 );
+	
+	                if ( headStack == null && !HasHeadCrabbedSquid() )
+	                {
+	                    setFire( 8 );
+	                }
+            	}
+            }
+        }
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityMooshroom.java b/minecraft/net/minecraft/src/EntityMooshroom.java
index 3708327..b6b8fad 100644
--- a/minecraft/net/minecraft/src/EntityMooshroom.java
+++ b/minecraft/net/minecraft/src/EntityMooshroom.java
@@ -1,6 +1,9 @@
 package net.minecraft.src;
 
-public class EntityMooshroom extends EntityCow
+// FCMOD: Changed
+//public class EntityMooshroom extends EntityCow
+public class EntityMooshroom extends FCEntityCow
+// END FCMOD
 {
     public EntityMooshroom(World par1World)
     {
@@ -12,6 +15,8 @@ public class EntityMooshroom extends EntityCow
     /**
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean interact(EntityPlayer par1EntityPlayer)
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
@@ -49,7 +54,7 @@ public class EntityMooshroom extends EntityCow
                     this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY + (double)this.height, this.posZ, new ItemStack(Block.mushroomRed)));
                 }
             }
-
+            
             return true;
         }
         else
@@ -57,6 +62,8 @@ public class EntityMooshroom extends EntityCow
             return super.interact(par1EntityPlayer);
         }
     }
+    */
+    // END FCMOD    
 
     public EntityMooshroom func_94900_c(EntityAgeable par1EntityAgeable)
     {
@@ -66,7 +73,10 @@ public class EntityMooshroom extends EntityCow
     /**
      * This function is used when two same-species animals in 'love mode' breed to generate the new baby animal.
      */
-    public EntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
+    // FCMOD: Changed
+    //public EntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
+    public FCEntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
+    // END FCMOD
     {
         return this.func_94900_c(par1EntityAgeable);
     }
@@ -75,4 +85,86 @@ public class EntityMooshroom extends EntityCow
     {
         return this.func_94900_c(par1EntityAgeable);
     }
+
+    // FCMOD: Added New
+    @Override
+    public void CheckForGrazeSideEffects( int i, int j, int k )
+    {
+    	// override to get rid of mooshroom conversion on eat mycellium
+    }
+    
+    @Override
+    public void ConvertToMooshroom()
+    {
+    }
+    
+    @Override
+    public void onLivingUpdate()
+    {
+        if ( !worldObj.isRemote )
+        {
+            CheckForMyceliumSpread();
+        }
+
+        super.onLivingUpdate();
+    }
+    
+    @Override
+    public boolean interact( EntityPlayer player )
+    {
+        ItemStack heldStack = player.inventory.getCurrentItem();
+
+        if ( heldStack != null && heldStack.itemID == Item.bowlEmpty.itemID && GotMilk() )
+        {
+            attackEntityFrom( DamageSource.generic, 0 );
+            
+            if ( !worldObj.isRemote )
+        	{
+            	SetGotMilk( false );
+            	
+		        worldObj.playAuxSFX( FCBetterThanWolves.m_iCowMilkedAuxFXID,
+	                MathHelper.floor_double( posX ), (int)posY,
+	                MathHelper.floor_double( posZ ), 0 );
+            }
+            
+            if ( heldStack.stackSize == 1 )
+            {
+                player.inventory.setInventorySlotContents( player.inventory.currentItem, 
+                	new ItemStack( Item.bowlSoup ) );
+            }
+            else if ( player.inventory.addItemStackToInventory( new ItemStack( Item.bowlSoup ) ) ) 
+            {
+                player.inventory.decrStackSize(player.inventory.currentItem, 1);
+            }
+            
+            return true;
+        }
+        
+        // skip over parent to avoid vanilla milking
+        
+        return EntityAnimalInteract( player ); 
+    }
+    
+	//------------- Class Specific Methods ------------//
+    
+    private void CheckForMyceliumSpread()
+    {
+    	if ( worldObj.provider.dimensionId != 1 && rand.nextInt( 1000 ) == 0 )
+    	{
+    		FCBlockMycelium.CheckForMyceliumSpreadToRandomBlockAround( worldObj,
+    			MathHelper.floor_double( posX ), (int)posY - 1, 
+    			MathHelper.floor_double( posZ ) );
+    	}
+    }
+    
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public String getTexture()
+    {
+    	// override to prevent cow hunger textures being displayed
+    	
+        return texture;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/EntityOcelot.java b/minecraft/net/minecraft/src/EntityOcelot.java
index d27b6d1..ecd4e55 100644
--- a/minecraft/net/minecraft/src/EntityOcelot.java
+++ b/minecraft/net/minecraft/src/EntityOcelot.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/30/2018
+
 package net.minecraft.src;
 
 public class EntityOcelot extends EntityTameable
diff --git a/minecraft/net/minecraft/src/EntityOtherPlayerMP.java b/minecraft/net/minecraft/src/EntityOtherPlayerMP.java
index e666ad5..eeed456 100644
--- a/minecraft/net/minecraft/src/EntityOtherPlayerMP.java
+++ b/minecraft/net/minecraft/src/EntityOtherPlayerMP.java
@@ -21,7 +21,10 @@ public class EntityOtherPlayerMP extends EntityPlayer
 
         if (par2Str != null && par2Str.length() > 0)
         {
-            this.skinUrl = "http://skins.minecraft.net/MinecraftSkins/" + StringUtils.stripControlCodes(par2Str) + ".png";
+        	// FCMOD: Changed, client only        	
+            //this.skinUrl = "http://skins.minecraft.net/MinecraftSkins/" + StringUtils.stripControlCodes(par2Str) + ".png";
+            this.skinUrl = FCBetterThanWolves.fcPlayerSkinURL + StringUtils.stripControlCodes(par2Str) + ".png";
+            // END FCMOD
         }
 
         this.noClip = true;
@@ -61,7 +64,10 @@ public class EntityOtherPlayerMP extends EntityPlayer
 
     public void updateCloak()
     {
-        this.cloakUrl = "http://skins.minecraft.net/MinecraftCloaks/" + StringUtils.stripControlCodes(this.username) + ".png";
+    	// FCMOD: Changed, client only        	
+        //this.cloakUrl = "http://skins.minecraft.net/MinecraftCloaks/" + StringUtils.stripControlCodes(this.username) + ".png";
+        this.cloakUrl = FCBetterThanWolves.fcPlayerCloakURL + StringUtils.stripControlCodes(this.username) + ".png";
+        // END FCMOD
     }
 
     /**
@@ -197,4 +203,14 @@ public class EntityOtherPlayerMP extends EntityPlayer
     {
         return new ChunkCoordinates(MathHelper.floor_double(this.posX + 0.5D), MathHelper.floor_double(this.posY + 0.5D), MathHelper.floor_double(this.posZ + 0.5D));
     }
+    
+    // FCMOD: Code added (client only)
+    @Override
+    public double getMountedYOffset()
+    {
+    	// need this to be different from regular players as for some reason their offset varies
+    	
+        return (double)height * 0.93D;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityPig.java b/minecraft/net/minecraft/src/EntityPig.java
index a026109..18b9725 100644
--- a/minecraft/net/minecraft/src/EntityPig.java
+++ b/minecraft/net/minecraft/src/EntityPig.java
@@ -1,5 +1,10 @@
+// FCMOD: Class changes deprecated 07/23/2018
+
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class EntityPig extends EntityAnimal
 {
     /** AI task for player control. */
@@ -143,7 +148,7 @@ public class EntityPig extends EntityAnimal
     protected void dropFewItems(boolean par1, int par2)
     {
         int var3 = this.rand.nextInt(3) + 1 + this.rand.nextInt(1 + par2);
-
+        
         for (int var4 = 0; var4 < var3; ++var4)
         {
             if (this.isBurning())
diff --git a/minecraft/net/minecraft/src/EntityPigZombie.java b/minecraft/net/minecraft/src/EntityPigZombie.java
index 0c2282a..1df6e11 100644
--- a/minecraft/net/minecraft/src/EntityPigZombie.java
+++ b/minecraft/net/minecraft/src/EntityPigZombie.java
@@ -2,7 +2,10 @@ package net.minecraft.src;
 
 import java.util.List;
 
-public class EntityPigZombie extends EntityZombie
+// FCMOD: Changed
+//public class EntityPigZombie extends EntityZombie
+public class EntityPigZombie extends FCEntityZombie
+// END FCMOD
 {
     /** Above zero if this PigZombie is Angry. */
     private int angerLevel = 0;
@@ -122,7 +125,10 @@ public class EntityPigZombie extends EntityZombie
     /**
      * Causes this PigZombie to become angry at the supplied Entity (which will be a player).
      */
-    private void becomeAngryAt(Entity par1Entity)
+    // FCMOD: Changed
+    //private void becomeAngryAt(Entity par1Entity)
+    protected void becomeAngryAt(Entity par1Entity)
+    // END FCMOD
     {
         this.entityToAttack = par1Entity;
         this.angerLevel = 400 + this.rand.nextInt(400);
diff --git a/minecraft/net/minecraft/src/EntityPlayer.java b/minecraft/net/minecraft/src/EntityPlayer.java
index d43bd99..e8b5926 100644
--- a/minecraft/net/minecraft/src/EntityPlayer.java
+++ b/minecraft/net/minecraft/src/EntityPlayer.java
@@ -105,7 +105,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     public EntityPlayer(World par1World)
     {
         super(par1World);
-        this.inventoryContainer = new ContainerPlayer(this.inventory, !par1World.isRemote, this);
+        // FCMOD: Changed
+        //this.inventoryContainer = new ContainerPlayer(this.inventory, !par1World.isRemote, this);
+        inventoryContainer = new FCContainerPlayer( inventory, !par1World.isRemote, this );
+        // END FCMOD
         this.openContainer = this.inventoryContainer;
         this.yOffset = 1.62F;
         ChunkCoordinates var2 = par1World.getSpawnPoint();
@@ -127,6 +130,20 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         this.dataWatcher.addObject(16, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(17, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(18, Integer.valueOf(0));
+        
+        // FCMOD: Added
+        dataWatcher.addObject( m_iHasValidMagneticPointForLocationDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iStongestMagneticPointForLocationIDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iStongestMagneticPointForLocationKDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iGloomLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iFatPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iHungerPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iHealthPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
+        
+        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationIDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationJDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationKDataWatcherID, new Integer( 0 ) );
+        // END FCMOD
     }
 
     /**
@@ -192,16 +209,34 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
      */
     public void onUpdate()
     {
+    	// FCMOD: Added
+    	m_iTimesCraftedThisTick = 0;
+        m_iTicksSinceEmoteSound++;
+    	// END FCMOD
+    	
         if (this.itemInUse != null)
         {
             ItemStack var1 = this.inventory.getCurrentItem();
 
-            if (var1 == this.itemInUse)
+            // FCMOD: Changed
+            //if (var1 == this.itemInUse)
+            if ( var1 == this.itemInUse || 
+            	( var1 != null && itemInUse.getItem().IgnoreDamageWhenComparingDuringUse() && 
+        		var1.itemID == itemInUse.itemID && ItemStack.areItemStackTagsEqual( itemInUse, var1 ) ) )
+        	// END FCMOD
             {
+            	// FCMOD: Added
+            	itemInUse = var1;
+            	// END FCMOD
+            	
                 if (this.itemInUseCount <= 25 && this.itemInUseCount % 4 == 0)
                 {
                     this.updateItemUse(var1, 5);
                 }
+                
+                // FCMOD: Added
+        		var1.getItem().UpdateUsingItem( var1, this.worldObj, this );
+                // END FCMOD 
 
                 if (--this.itemInUseCount == 0 && !this.worldObj.isRemote)
                 {
@@ -313,8 +348,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
         if (!this.worldObj.isRemote)
         {
-            this.foodStats.onUpdate(this);
+            this.foodStats.onUpdate(this);            
         }
+        
+        // FCMOD: Added
+        UpdateModStatusVariables();
+        // END FCMOD
     }
 
     /**
@@ -333,6 +372,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         return 10;
     }
 
+    // FCMOD: Comment added
+    /**
+	/* the playSound function both plays the sound locally on the client, and plays it remotely on the server without it being sent again to the same player
+	 */ // END FCMOD
     public void playSound(String par1Str, float par2, float par3)
     {
         this.worldObj.playSoundToNearExcept(this, par1Str, par2, par3);
@@ -503,6 +546,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         super.onLivingUpdate();
         this.landMovementFactor = this.capabilities.getWalkSpeed();
         this.jumpMovementFactor = this.speedInAir;
+        // FCMOD: Code added to apply move penalties to jumping
+        jumpMovementFactor *= GetJumpingHorizontalMovementModifier();        
+        // END FCMOD
 
         if (this.isSprinting())
         {
@@ -547,7 +593,7 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     }
                 }
             }
-        }
+        }        
     }
 
     private void collideWithPlayer(Entity par1Entity)
@@ -680,6 +726,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 var3.motionX = (double)(-MathHelper.sin(var6) * var5);
                 var3.motionZ = (double)(MathHelper.cos(var6) * var5);
                 var3.motionY = 0.20000000298023224D;
+                // FCMOD: Code added: par2 flag indicates that the item has been dropped on death
+                var3.SetEntityItemAsDroppedOnPlayerDeath( this );
+                // END FCMOD
             }
             else
             {
@@ -712,9 +761,19 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     /**
      * Returns how strong the player is against the specified block at this moment
      */
+    // FCMOD: Code change
+    /*
     public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2)
+    */
+    public float getCurrentPlayerStrVsBlock(Block par1Block, int i, int j, int k)
+    // END FCMOD
     {
+        // FCMOD: Code change
+        /*
         float var3 = this.inventory.getStrVsBlock(par1Block);
+        */
+        float var3 = this.inventory.getStrVsBlock(worldObj, par1Block, i, j, k);
+    	// END FCMOD
 
         if (var3 > 1.0F)
         {
@@ -725,7 +784,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             {
                 float var6 = (float)(var4 * var4 + 1);
 
+                // FCMOD: Code change
+                /*
                 if (!var5.canHarvestBlock(par1Block) && var3 <= 1.0F)
+                */
+                if (!var5.canHarvestBlock( worldObj, par1Block, i, j, k) && var3 <= 1.0F)
+                // END FCMOD
                 {
                     var3 += var6 * 0.08F;
                 }
@@ -755,6 +819,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             var3 /= 5.0F;
         }
+        
+        // FCMOD: Added
+        var3 *= GetMiningSpeedModifier();
+        // END FCMOD        
 
         return var3;
     }
@@ -762,10 +830,14 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     /**
      * Checks if the player has the ability to harvest a block (checks current inventory item for a tool if necessary)
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return this.inventory.canHarvestBlock(par1Block);
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to read subclass entity data from NBT.
@@ -803,6 +875,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             NBTTagList var3 = par1NBTTagCompound.getTagList("EnderItems");
             this.theInventoryEnderChest.loadInventoryFromNBT(var3);
         }
+        // FCMOD: Code added
+        ReadModDataFromNBT( par1NBTTagCompound );
+        // END FCMOD
     }
 
     /**
@@ -831,6 +906,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         this.foodStats.writeNBT(par1NBTTagCompound);
         this.capabilities.writeCapabilitiesToNBT(par1NBTTagCompound);
         par1NBTTagCompound.setTag("EnderItems", this.theInventoryEnderChest.saveInventoryToNBT());
+        // FCMOD: Code added
+        WriteModDataToNBT( par1NBTTagCompound );
+        // END FCMOD
     }
 
     /**
@@ -932,6 +1010,14 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     }
 
                     this.addStat(StatList.damageTakenStat, par2);
+                    // FCMOD: Code added
+                    if ( !isDead && IsCarryingBlastingOil() )
+                    {
+                    	DetonateCarriedBlastingOil();
+                    	
+                    	return false;
+                    }
+                    // END FCMOD
                     return super.attackEntityFrom(par1DamageSource, par2);
                 }
             }
@@ -951,7 +1037,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
      */
     protected void alertWolves(EntityLiving par1EntityLiving, boolean par2)
     {
-        if (!(par1EntityLiving instanceof EntityCreeper) && !(par1EntityLiving instanceof EntityGhast))
+    	// FCMOD: Added to make sure that wolves don't attack if sitting
+    	par2 = true;
+    	// END FCMOD
+    	// FCMOD: Changed
+        //if (!(par1EntityLiving instanceof EntityCreeper) && !(par1EntityLiving instanceof EntityGhast))
+        if (!(par1EntityLiving instanceof FCEntityCreeper) && !(par1EntityLiving instanceof FCEntityGhast))
+    	// END FCMOD
         {
             if (par1EntityLiving instanceof EntityWolf)
             {
@@ -1024,7 +1116,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             if (!par1DamageSource.isUnblockable() && this.isBlocking())
             {
+        		// FCMOD: Code added
+        		OnBlockedDamage( par1DamageSource, par2 );
+        		// END FCMOD
+        		
                 par2 = 1 + par2 >> 1;
+        
             }
 
             par2 = this.applyArmorCalculations(par1DamageSource, par2);
@@ -1160,6 +1257,15 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     ++var3;
                 }
 
+                // FCMOD: Code added to modify player attack damage by health and exhaustion
+                float fModifier = GetMeleeDamageModifier();
+                
+                if ( fModifier < 0.99F )
+                {
+                	var2 = (int)((float)var2 * fModifier);                	
+                }
+                // END FCMOD
+
                 if (var2 > 0 || var4 > 0)
                 {
                     boolean var5 = this.fallDistance > 0.0F && !this.onGround && !this.isOnLadder() && !this.isInWater() && !this.isPotionActive(Potion.blindness) && this.ridingEntity == null && par1Entity instanceof EntityLiving;
@@ -1258,6 +1364,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
                     this.addExhaustion(0.3F);
                 }
+                // FCMOD: Code added
+                else // else from "if (var2 > 0 || var4 > 0)" above, indicating zero damage attack
+                {
+            		OnZeroDamageAttack();
+                }
+                // END FCMOD
             }
         }
     }
@@ -1303,6 +1415,11 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
      */
     public EnumStatus sleepInBedAt(int par1, int par2, int par3)
     {
+    	// FCMOD: Code added
+        return EnumStatus.OTHER_PROBLEM;
+        // END FCMOD
+    	// FCMOD: Code removed
+        /*
         if (!this.worldObj.isRemote)
         {
             if (this.isPlayerSleeping() || !this.isEntityAlive())
@@ -1382,6 +1499,8 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         }
 
         return EnumStatus.OK;
+        */
+        // END FCMOD
     }
 
     private void func_71013_b(int par1)
@@ -1590,6 +1709,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             this.spawnChunk = null;
             this.spawnForced = false;
         }
+        
+        // FCMOD: Code added
+        m_iSpawnDimension = 0;
+        // END FCMOD
     }
 
     /**
@@ -1613,6 +1736,8 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         super.jump();
         this.addStat(StatList.jumpStat, 1);
 
+        // FCMOD: Changed
+        /*
         if (this.isSprinting())
         {
             this.addExhaustion(0.8F);
@@ -1621,6 +1746,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             this.addExhaustion(0.2F);
         }
+        */
+        AddExhaustionForJump();
+        // END FCMOD
     }
 
     /**
@@ -1657,6 +1785,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         if (this.ridingEntity == null)
         {
             int var7;
+            
+            // FCMOD: Added
+            if ( isInWater() && par3 > 0D && CanSwim() )
+            {
+                addExhaustion( 0.025F );
+            }
+            // END FCMOD
 
             if (this.isInsideOfMaterial(Material.water))
             {
@@ -1665,8 +1800,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 if (var7 > 0)
                 {
                     this.addStat(StatList.distanceDoveStat, var7);
+                    // FCMOD: Code change
+                    /*
                     this.addExhaustion(0.015F * (float)var7 * 0.01F);
-                }
+                    */
+                    this.AddExhaustionWithoutVisualFeedback(0.015F * (float)var7 * 0.01F);
+                    // END FCMOD
+                }                
             }
             else if (this.isInWater())
             {
@@ -1675,7 +1815,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 if (var7 > 0)
                 {
                     this.addStat(StatList.distanceSwumStat, var7);
+                    // FCMOD: Code change
+                    /*
                     this.addExhaustion(0.015F * (float)var7 * 0.01F);
+                    */
+                    this.AddExhaustionWithoutVisualFeedback(0.015F * (float)var7 * 0.01F);
+                    // END FCMOD
                 }
             }
             else if (this.isOnLadder())
@@ -1699,7 +1844,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     }
                     else
                     {
+                        // FCMOD: Code change
+                        /*
                         this.addExhaustion(0.01F * (float)var7 * 0.01F);
+                        */
+                        this.AddExhaustionWithoutVisualFeedback(0.01F * (float)var7 * 0.01F);
+                        // END FCMOD
                     }
                 }
             }
@@ -1828,6 +1978,17 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             }
         }
 
+        // FCMOD: Code added (client only)
+        if ( par1ItemStack.itemID == FCBetterThanWolves.fcItemFishingRodBaited.itemID && fishEntity != null )
+        {
+        	var3 = ((FCItemFishingRodBaited)FCBetterThanWolves.fcItemFishingRodBaited).GetCastIcon();
+        }
+        else if ( isUsingItem() && getItemInUse().itemID == FCBetterThanWolves.fcItemCompositeBow.itemID )
+        {
+        	var3 = ((FCItemCompositeBow)FCBetterThanWolves.fcItemCompositeBow).getDrawIcon( getItemInUseDuration() );
+        }
+        // END FCMOD
+
         return var3;
     }
 
@@ -1905,6 +2066,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             if (!this.worldObj.isRemote)
             {
+            	// FCMOD: Code added        	
+            	par1 *= GetArmorExhaustionModifier();
+        		// END FCMOD
                 this.foodStats.addExhaustion(par1);
             }
         }
@@ -1920,6 +2084,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
     public boolean canEat(boolean par1)
     {
+    	// FCMOD: Code added to prevent player from eating while having the hunger effect
+        if ( isPotionActive( Potion.hunger ) )
+        {
+        	return false;
+        }
+    	// END FCMOD
         return (par1 || this.foodStats.needFood()) && !this.capabilities.disableDamage;
     }
 
@@ -1974,7 +2144,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 {
                     ItemStack var6 = this.getCurrentEquippedItem();
 
+                    // FCMOD: Code change
+                    /*
                     if (var6.canHarvestBlock(var5) || var6.getStrVsBlock(var5) > 1.0F)
+                    */
+                    if (var6.canHarvestBlock(worldObj, var5, par1, par2, par3) || var6.getStrVsBlock(worldObj, var5, par1, par2, par3) > 1.0F)
+                	// END FCMOD
                     {
                         return true;
                     }
@@ -1987,6 +2162,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
     public boolean canPlayerEdit(int par1, int par2, int par3, int par4, ItemStack par5ItemStack)
     {
+    	// FCMOD: Code added to prevent the player from placing blocks while in mid air
+    	if ( !capabilities.isCreativeMode && !onGround && !inWater && !isOnLadder() && ridingEntity == null && !handleLavaMovement() )
+    	{
+    		return false;
+    	}
+    	// END FCMOD
+    	
         return this.capabilities.allowEdit ? true : (par5ItemStack != null ? par5ItemStack.func_82835_x() : false);
     }
 
@@ -2183,4 +2365,1072 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     {
         return ScorePlayerTeam.func_96667_a(this.getTeam(), this.username);
     }
+
+    // FCMOD: Added New
+    public ChunkCoordinates m_HardcoreSpawnChunk;
+    
+    public long m_lTimeOfLastSpawnAssignment = 0;
+    public long m_lTimeOfLastDimensionSwitch = 0;
+    public long m_lRespawnAssignmentCooldownTimer = 0;
+    
+    public int m_iSpawnDimension = 0;
+    public int m_iTimesCraftedThisTick = 0;
+    public int m_iInGloomCounter = 0;
+    public int m_iAirRecoveryCountdown = 0;
+    public int m_iTicksSinceEmoteSound = 0;
+    
+	protected float m_fCurrentMiningSpeedModifier = 1F;	
+    
+    public static final int m_iGloomCounterBetweenStateChanges = 1200; // 1 minute
+    
+	private static final int m_iStongestMagneticPointForLocationIDataWatcherID = 22;
+	private static final int m_iStongestMagneticPointForLocationKDataWatcherID = 23;
+	private static final int m_iHasValidMagneticPointForLocationDataWatcherID = 24;
+	private static final int m_iGloomLevelDataWatcherID = 25;
+	private static final int m_iFatPenaltyLevelDataWatcherID = 26;
+	private static final int m_iHungerPenaltyLevelDataWatcherID = 27;
+	private static final int m_iHealthPenaltyLevelDataWatcherID = 28;
+	
+	private static final int m_iSpawnChunksVisualizationLocationIDataWatcherID = 29;
+	private static final int m_iSpawnChunksVisualizationLocationJDataWatcherID = 30;
+	private static final int m_iSpawnChunksVisualizationLocationKDataWatcherID = 31;
+    
+	private static final int m_iTicksBetweenEmoteSounds = 10;
+	
+	public static final float m_fExhaustionJumping = 0.2F;
+	public static final float m_fExhaustionJumpingSprinting = 1.0F;
+	
+    protected void ReadModDataFromNBT( NBTTagCompound tag )
+    {
+	    if ( tag.hasKey( "fcTimeOfLastSpawnAssignment" ) )
+	    {
+	    	m_lTimeOfLastSpawnAssignment = tag.getLong( "fcTimeOfLastSpawnAssignment" );
+	    }
+	    
+	    if ( tag.hasKey( "fcTimeOfLastDimensionSwitch" ) )
+	    {
+	    	m_lTimeOfLastDimensionSwitch = tag.getLong( "fcTimeOfLastDimensionSwitch" );
+	    }
+	    
+	    if ( tag.hasKey( "fcHCSpawnX" ) && tag.hasKey( "fcHCSpawnY" ) && tag.hasKey( "fcHCSpawnZ" ) )
+	    {
+	        m_HardcoreSpawnChunk = new ChunkCoordinates( tag.getInteger( "fcHCSpawnX" ), tag.getInteger( "fcHCSpawnY" ), tag.getInteger( "fcHCSpawnZ" ) );
+	    }
+	    
+	    if ( tag.hasKey( "fcSpawnDimension" ) )
+	    {
+	    	m_iSpawnDimension = tag.getInteger( "fcSpawnDimension" );
+	    }	    	    
+	    
+	    if ( tag.hasKey( "fcGloomLevel" ) )
+	    {
+	    	SetGloomLevel( tag.getInteger( "fcGloomLevel" ) );
+	    }
+	    
+	    if ( tag.hasKey( "fcGloomCounter" ) )
+	    {
+	    	m_iInGloomCounter = tag.getInteger( "fcGloomCounter" );
+	    }
+    }
+    
+    protected void WriteModDataToNBT( NBTTagCompound tag )
+    {
+	 	tag.setLong( "fcTimeOfLastSpawnAssignment", m_lTimeOfLastSpawnAssignment );
+	 	
+	 	tag.setLong( "fcTimeOfLastDimensionSwitch", m_lTimeOfLastDimensionSwitch );
+	    
+	    if ( m_HardcoreSpawnChunk != null )
+	    {
+	        tag.setInteger( "fcHCSpawnX", m_HardcoreSpawnChunk.posX );
+	        tag.setInteger( "fcHCSpawnY", m_HardcoreSpawnChunk.posY );
+	        tag.setInteger( "fcHCSpawnZ", m_HardcoreSpawnChunk.posZ );
+	    }
+	    
+	 	tag.setInteger( "fcSpawnDimension", m_iSpawnDimension );
+	 	
+	 	tag.setInteger( "fcGloomLevel", GetGloomLevel() );
+	 	tag.setInteger( "fcGloomCounter", m_iInGloomCounter );
+    }
+    
+    @Override
+    protected int decreaseAirSupply( int iAirSupply )
+    {
+        m_iAirRecoveryCountdown = 20;
+        
+        int iEnchantmentLevel = EnchantmentHelper.getRespiration(this);
+        
+        if ( iEnchantmentLevel > 0 && IsWearingSoulforgedHelm() )
+        {
+    		if ( this.worldObj.getWorldTime() % 100 == 0 )
+    		{
+    			worldObj.playSoundAtEntity( this, 
+            		"random.breath", 
+            		0.75F + rand.nextFloat() * 0.5F, 
+            		0.5F + rand.nextFloat() * 0.025F );
+    		}    		
+
+        	if ( rand.nextInt( ( iEnchantmentLevel * iEnchantmentLevel + 1 ) ) > 0 )
+        	{
+        		return iAirSupply;
+        	}
+        	else
+        	{
+                return iAirSupply - 1;
+        	}        	
+        }
+        else
+        {
+        	return super.decreaseAirSupply( iAirSupply );
+        }
+    }
+    
+    @Override
+    protected void RecoverAirSupply()
+    {
+    	if ( m_iAirRecoveryCountdown > 0 )
+    	{
+    		m_iAirRecoveryCountdown--;
+    		
+    	}
+    	else
+    	{
+        	int iCurrentAir = getAir();
+        	
+        	if ( iCurrentAir < 300 )
+        	{
+        		iCurrentAir += 10;
+        		
+        		if ( iCurrentAir > 300 )
+        		{
+        			iCurrentAir = 300;
+        		}
+        		setAir( iCurrentAir + 1 );
+        	}
+        	else
+        	{
+        		setAir(300);
+        	}
+    	}
+    }
+    
+	@Override
+    public boolean isOnLadder()
+    {
+		return GetHealthPenaltyLevel() < 4 && super.isOnLadder();
+    }
+	
+	@Override
+    public boolean CanJump()
+    {		
+    	return health > 4 && foodStats.getFoodLevel() > 12 && (int)foodStats.getSaturationLevel() < 18;
+    }
+	
+	@Override
+    public boolean CanSwim()
+    {		
+    	return !isWeighted() && health > 4;
+    }
+	
+	@Override
+	protected int GetWornArmorWeight()
+	{
+		int iWeight = 0;
+		
+        for ( int iSlot = 0; iSlot < inventory.armorInventory.length; iSlot++ )
+        {
+        	ItemStack tempStack = inventory.armorInventory[iSlot];
+        	
+            if ( tempStack != null )
+            {
+                iWeight += tempStack.getItem().GetWeightWhenWorn();
+            }
+        }
+        
+		return iWeight;
+	}
+	
+	public float GetArmorExhaustionModifier()
+	{
+		float fModifier = 1.0F;
+		
+		int iWeight = GetWornArmorWeight();
+		
+		if ( iWeight > 0 )
+		{
+			// set to cap at a 2 times modifier with full plate armor
+			
+			fModifier += (float)iWeight / 44F;
+		}
+		
+		return fModifier;
+	}
+	
+	
+	public boolean IsWearingFullSuitSoulforgedArmor()
+	{
+        for ( int iSlot = 0; iSlot < inventory.armorInventory.length; iSlot++ )
+        {
+            if ( inventory.armorInventory[iSlot] == null || !( inventory.armorInventory[iSlot].getItem() instanceof FCItemArmorRefined ) )
+            {
+                return false;
+            }
+        }
+        
+		return true;
+	}
+	
+    protected boolean IsWearingSoulforgedHelm()
+	{
+        return inventory.armorInventory[3] != null && 
+        	inventory.armorInventory[3].getItem().itemID == 
+    		FCBetterThanWolves.fcItemPlateHelm.itemID;
+	}
+	
+    protected boolean IsWearingSoulforgedBoots()
+	{
+        return inventory.armorInventory[0] != null && 
+        	inventory.armorInventory[0].getItem().itemID == 
+    		FCBetterThanWolves.fcItemPlateBoots.itemID;
+	}
+    
+    public boolean IsWearingEnderSpectacles()
+    {
+        return inventory.armorInventory[3] != null && 
+        	inventory.armorInventory[3].getItem().itemID == 
+    		FCBetterThanWolves.fcItemEnderSpectacles.itemID;
+    }
+    
+	@Override
+    protected void playStepSound( int i, int j, int k, int iBlockID )
+    {
+		float fHealthAndExhaustionModifier = GetHealthAndExhaustionModifier();
+		
+		if ( fHealthAndExhaustionModifier < 0.26F )
+		{
+			// play grunting along with step
+			
+			float fGruntVolume = ( 1F - fHealthAndExhaustionModifier ) * 0.75F;
+			
+			worldObj.playSoundAtEntity( this, 
+        		"random.classic_hurt", 0.5F, 
+        		1F + rand.nextFloat() * 0.1F);
+		}
+		
+		if ( IsWearingSoulforgedBoots() )
+		{
+	        int iBlockAboveID = worldObj.getBlockId( i, j + 1, k );
+	        Block blockAbove = Block.blocksList[iBlockAboveID];
+	        
+	        if ( blockAbove != null && blockAbove.IsGroundCover( ) )
+	        {
+	        	StepSound stepSound = blockAbove.stepSound;
+	            
+	            worldObj.playSoundAtEntity( this, stepSound.getStepSound(), stepSound.getVolume() * 0.3F, stepSound.getPitch() * 0.75F );
+	        }
+	        else if ( !Block.blocksList[iBlockID].blockMaterial.isLiquid() )
+	        {
+		        StepSound stepSound = Block.blocksList[iBlockID].GetStepSound( worldObj, i, j, k );    	
+
+	            worldObj.playSoundAtEntity( this, stepSound.getStepSound(), stepSound.getVolume() * 0.3F, stepSound.getPitch() * 0.5F );
+	        }
+		}
+		else
+		{
+			super.playStepSound( i, j, k, iBlockID );
+		}
+    }
+
+	@Override
+    protected float GetHealthAndExhaustionModifier()
+    {
+		float fModifier = 1.0F;
+
+		int iPenaltyLevel = GetMaximumStatusPenaltyLevel();
+		
+		if ( iPenaltyLevel >= 2 )
+		{
+			if ( iPenaltyLevel >= 3 )
+			{
+				if ( iPenaltyLevel >= 4 )
+				{
+					fModifier = 0.25F;
+				}
+				else
+				{
+					fModifier = 0.5F;
+				}
+			} 
+			else
+			{
+				fModifier = 0.75F;
+			}
+		}
+		
+    	return fModifier;
+    }
+    
+    protected float GetHealthAndExhaustionModifierWithSightlessModifier()
+    {
+		float fModifier = GetHealthAndExhaustionModifier();
+		
+		if ( GetGloomLevel() > 0 )
+		{
+			fModifier *= 0.5F;
+		}
+		
+    	return fModifier;
+    }
+    
+	@Override
+    protected float GetSwimmingHorizontalModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+	@Override
+    protected float GetLandMovementModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+	@Override
+    protected float GetLadderVerticalMovementModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }    
+    
+	protected float GetJumpingHorizontalMovementModifier()        
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+	protected void SetMiningSpeedModifier( float fModifier )
+	{
+		if ( fModifier > 1F )
+		{
+			// cap it just in case the client sends an invalid speed to the server
+			
+			fModifier = 1F;
+		}
+		
+		m_fCurrentMiningSpeedModifier = fModifier;
+	}
+	
+    protected float GetMiningSpeedModifier()
+    {
+		return m_fCurrentMiningSpeedModifier;
+    }
+    
+    protected float UpdateMiningSpeedModifier()
+    {
+    	m_fCurrentMiningSpeedModifier = GetHealthAndExhaustionModifierWithSightlessModifier();
+    	
+    	return m_fCurrentMiningSpeedModifier;
+    }
+    
+    protected float GetMeleeDamageModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+    public float GetBowPullStrengthModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+	public boolean HasStatusPenalty()
+	{
+        return getHealth() <= 10 || foodStats.getFoodLevel() <= 24 || (int)foodStats.getSaturationLevel() >= 12;
+	}
+	
+	public int GetMaximumStatusPenaltyLevel()
+	{
+		int iMaximumPenaltyLevel = GetHealthPenaltyLevel();
+		int iHungerPenaltyLevel = GetHungerPenaltyLevel();
+		
+		if ( iHungerPenaltyLevel > iMaximumPenaltyLevel )
+		{
+			iMaximumPenaltyLevel = iHungerPenaltyLevel;
+		}
+		
+		int iFatPenaltyLevel = GetFatPenaltyLevel();
+		
+		if ( iFatPenaltyLevel > iMaximumPenaltyLevel )
+		{
+			iMaximumPenaltyLevel = iFatPenaltyLevel;
+		}
+		
+		return iMaximumPenaltyLevel;
+	}
+	
+    protected boolean IsCarryingBlastingOil()
+    {	
+    	return inventory.hasItem( FCBetterThanWolves.fcItemBlastingOil.itemID );
+    }
+    
+	protected void DetonateCarriedBlastingOil()
+	{
+		if ( !worldObj.isRemote )
+		{
+	    	int iHellfireCount = FCUtilsInventory.CountItemsInInventory( inventory, FCBetterThanWolves.fcItemHellfireDust.itemID, -1 );
+	    	
+	    	float fExplosionSize = ( iHellfireCount * 10.0F ) / 64.0F;
+	    	
+	    	fExplosionSize += ( FCUtilsInventory.CountItemsInInventory( inventory, Item.gunpowder.itemID, -1 ) * 10.0F ) / 64.0F;
+	    	
+	    	fExplosionSize += ( FCUtilsInventory.CountItemsInInventory( inventory, FCBetterThanWolves.fcItemBlastingOil.itemID, -1 ) * 10.0F ) / 64.0F;
+	    	
+	    	int iTNTCount = FCUtilsInventory.CountItemsInInventory( inventory, Block.tnt.blockID, -1 );
+	    	
+	    	if ( iTNTCount > 0 )
+	    	{
+	    		if ( fExplosionSize < 4.0F )
+	    		{
+	    			fExplosionSize = 4.0F;
+	    		}
+	    		
+	        	fExplosionSize += FCUtilsInventory.CountItemsInInventory( inventory, Block.tnt.blockID, -1 );
+	    	}
+	    	
+	    	if ( fExplosionSize < 1.5F )
+	    	{
+	    		fExplosionSize = 1.5F;
+	    	}
+	    	else if ( fExplosionSize > 10.0F )
+	    	{
+	    		fExplosionSize = 10.0F;
+	    	}
+	    	
+	    	FCUtilsInventory.ClearInventoryContents( inventory );
+	    	
+			health = 0;
+			
+			onDeath( DamageSource.generic );
+			
+	        worldObj.createExplosion( null, posX, posY, posZ, fExplosionSize, true );
+		}		
+	}
+	
+	@Override
+    protected void dropHead()
+    {
+        EntityItem skullEntity = entityDropItem( new ItemStack( Item.skull.itemID, 1, 3 ), 0.0F );
+        
+        if ( skullEntity != null )
+        {
+        	// client
+        	ItemStack stack = skullEntity.getEntityItem();
+        	// server
+        	//ItemStack stack = skullEntity.func_92059_d();
+        	
+            NBTTagCompound tag = stack.getTagCompound();
+
+            if ( tag == null)
+            {
+                tag = new NBTTagCompound();
+                
+                stack.setTagCompound( tag );
+            }
+
+            tag.setString( "SkullOwner", username );
+        }
+    }
+    
+    public boolean HasValidMagneticPointForLocation()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHasValidMagneticPointForLocationDataWatcherID ) > 0;
+    }
+    
+    public int GetStongestMagneticPointForLocationI()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iStongestMagneticPointForLocationIDataWatcherID );
+    }
+    
+    public int GetStongestMagneticPointForLocationK()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iStongestMagneticPointForLocationKDataWatcherID );
+    }
+    
+    public void SetHasValidMagneticPointForLocation( boolean bValid )
+    {
+    	byte bValidByte = 0;
+    	
+    	if ( bValid )
+    	{
+    		bValidByte = 1;
+    	}
+    	
+        dataWatcher.updateObject( m_iHasValidMagneticPointForLocationDataWatcherID, Byte.valueOf( bValidByte ) );
+    }
+    
+    public void SetStongestMagneticPointForLocationI( int iLocationI )
+    {
+        dataWatcher.updateObject( m_iStongestMagneticPointForLocationIDataWatcherID, Integer.valueOf( iLocationI ) );
+    }
+    
+    public void SetStongestMagneticPointForLocationK( int iLocationK )
+    {
+        dataWatcher.updateObject( m_iStongestMagneticPointForLocationKDataWatcherID, Integer.valueOf( iLocationK ) );
+    }
+    
+    public int GetGloomLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iGloomLevelDataWatcherID );
+    }
+    
+    public void SetGloomLevel( int iGloomLevel )
+    {
+        dataWatcher.updateObject( m_iGloomLevelDataWatcherID, Byte.valueOf( (byte)iGloomLevel ) );
+    }
+    
+    public int GetFatPenaltyLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iFatPenaltyLevelDataWatcherID );
+    }
+    
+    public void SetFatPenaltyLevel( int iPenaltyLevel )
+    {
+        dataWatcher.updateObject( m_iFatPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
+    }
+    
+    public int GetHungerPenaltyLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHungerPenaltyLevelDataWatcherID );
+    }
+    
+    public void SetHungerPenaltyLevel( int iPenaltyLevel )
+    {
+        dataWatcher.updateObject( m_iHungerPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
+    }
+    
+    public int GetHealthPenaltyLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHealthPenaltyLevelDataWatcherID );
+    }
+    
+    public void SetHealthPenaltyLevel( int iPenaltyLevel )
+    {
+        dataWatcher.updateObject( m_iHealthPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
+    }
+    
+    public int GetSpawnChunksVisualizationLocationI()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationIDataWatcherID );
+    }
+    
+    public int GetSpawnChunksVisualizationLocationJ()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationJDataWatcherID );
+    }
+    
+    public int GetSpawnChunksVisualizationLocationK()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationKDataWatcherID );
+    }
+    
+    public void SetSpawnChunksVisualization( int iLocationI, int iLocationJ, int iLocationK )
+    {
+        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationIDataWatcherID, 
+        	Integer.valueOf( iLocationI ) );
+        
+        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationJDataWatcherID, 
+        	Integer.valueOf( iLocationJ ) );
+        
+        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationKDataWatcherID, 
+        	Integer.valueOf( iLocationK ) );
+    }
+    
+    public boolean HasRespawnCoordinates()
+    {
+    	return spawnChunk != null;
+    }
+    
+    /*
+     * returns zero if a valid spawn location is found
+     * 1 = invalid forced spawn location
+     * 2 = missing beacon
+     * 3 = Beacon is out of range
+     * 4 = Area around beacon is obstructed
+     */
+    public int GetValidatedRespawnCoordinates( World newWorld, ChunkCoordinates respawnLocation )
+    {
+    	int iReturnValue = 0;
+    	
+    	int iOldDimension = dimension;
+    	int iNewDimension = m_iSpawnDimension;
+    	
+        IChunkProvider chunkProvider = newWorld.getChunkProvider();
+        
+        ChunkCoordinates validatedCoords = null;
+        
+        chunkProvider.loadChunk( spawnChunk.posX - 4 >> 4, spawnChunk.posZ - 4 >> 4 );
+        chunkProvider.loadChunk( spawnChunk.posX + 4 >> 4, spawnChunk.posZ - 4 >> 4 );
+        chunkProvider.loadChunk( spawnChunk.posX - 4 >> 4, spawnChunk.posZ + 4 >> 4 );
+        chunkProvider.loadChunk( spawnChunk.posX + 4 >> 4, spawnChunk.posZ + 4 >> 4 );
+
+        if ( spawnForced )
+        {
+            Material targetMaterial = newWorld.getBlockMaterial( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ );
+            Material aboveTargetMaterial = newWorld.getBlockMaterial( spawnChunk.posX, spawnChunk.posY + 1, spawnChunk.posZ );
+            
+            boolean bValidTarget = !targetMaterial.isSolid() && !targetMaterial.isLiquid();
+            boolean bValidAboveTarget = !aboveTargetMaterial.isSolid() && !aboveTargetMaterial.isLiquid();
+            
+            if ( IsValidRespawnLocation( newWorld, spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ ) )
+            {
+            	validatedCoords = spawnChunk;
+            }
+            else
+            {
+            	iReturnValue = 1;
+            }
+        }
+        else
+        {        
+    		iReturnValue = 2;
+    		
+	        if ( newWorld.getBlockId( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ ) == Block.beacon.blockID )
+	        {
+	        	FCTileEntityBeacon beaconEnt = (FCTileEntityBeacon)newWorld.getBlockTileEntity( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ );
+	        	
+	        	if ( beaconEnt != null )
+	        	{
+	        		int iBeaconEffect = beaconEnt.getPrimaryEffect();
+	        		
+	        		if ( iBeaconEffect == FCTileEntityBeacon.m_iEffectIDSpawnPoint )
+	        		{
+	        			int iBeaconPowerLevel = beaconEnt.getLevels();
+	        		
+	        			if ( iBeaconPowerLevel > 0 )
+	        			{
+	        				iReturnValue = 3;
+	        				
+		        			if ( iBeaconPowerLevel >= 4 || iOldDimension == iNewDimension )
+		        			{
+		        				boolean bInRange = true;
+		        				
+		        				if ( iBeaconPowerLevel < 3 )
+		        				{
+		        					int iMaxRange = 160;
+		        					
+		        					if ( iBeaconPowerLevel == 2 )
+		        					{
+		        						iMaxRange = 2000;
+		        					}
+		        					
+		        					int iDeltaX = Math.abs( (int)posX - spawnChunk.posX );
+		        					
+		        					if ( iDeltaX > iMaxRange )
+		        					{
+		        						bInRange = false;
+		        					}
+		        					else
+		        					{
+			        					int iDeltaZ = Math.abs( (int)posZ - spawnChunk.posZ );
+			        					
+			        					if ( iDeltaZ > iMaxRange )
+			        					{
+			        						bInRange = false;
+			        					}
+		        					}
+		        				}
+		        				
+		        				if ( bInRange )
+		        				{	        				
+		        					validatedCoords = GetRandomValidSpawnAroundBeaconLocation( newWorld, spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ, iBeaconPowerLevel );
+		        					
+		        					if ( validatedCoords != null )
+		        					{
+		        						iReturnValue = 0;
+		        						beaconEnt.m_bPlayerRespawnedAtBeacon = true;
+		        					}
+		        					else
+		        					{
+		        						iReturnValue = 4;
+		        					}
+		        				}
+		        			}
+	        			}
+	        		}
+	        	}
+	        }
+	        
+	        if ( validatedCoords != null )
+	        {
+	        	respawnLocation.posX = validatedCoords.posX;
+	        	respawnLocation.posY = validatedCoords.posY;
+	        	respawnLocation.posZ = validatedCoords.posZ;
+	        }
+        }
+        
+        return iReturnValue;
+    }
+    
+    private boolean IsValidRespawnLocation( World world, int i, int j, int k )
+    {
+        Material targetMaterial = world.getBlockMaterial( i, j, k );
+        Material aboveTargetMaterial = world.getBlockMaterial( i, j + 1, k );
+        
+        boolean bValidTarget = !targetMaterial.isSolid() && !targetMaterial.isLiquid();
+        boolean bValidAboveTarget = !aboveTargetMaterial.isSolid() && !aboveTargetMaterial.isLiquid();
+        
+        return bValidTarget && bValidAboveTarget;
+	}
+    
+    private ChunkCoordinates GetRandomValidSpawnAroundBeaconLocation( World world, int i, int j, int k, int iBeaconLevel )
+    {
+    	for ( int iAttempt = 0; iAttempt < 20; iAttempt++ )
+    	{
+    		int iDistance = rand.nextInt( iBeaconLevel ) + 1;    		
+    		
+    		// generate a random point around the edge at the specified distance
+    		
+    		int iPrimaryOffset = rand.nextInt( 2 ) * iDistance;
+    		
+			if ( rand.nextInt( 2 ) == 0 )
+			{
+				iPrimaryOffset = -iPrimaryOffset;
+			}
+			
+    		int iSecondaryOffset = rand.nextInt( iBeaconLevel * 2 + 1 ) - iBeaconLevel;
+    		
+    		int iXOffset = iPrimaryOffset; 
+			int iYOffset = -( iDistance - 1 );
+    		int iZOffset = iSecondaryOffset;
+    		
+			if ( rand.nextInt( 2 ) == 0 )
+			{
+	    		iXOffset = iSecondaryOffset;
+	    		iZOffset = iPrimaryOffset;
+			}
+			
+			int iISpawn = i + iXOffset;
+			int iJSpawn = j + iYOffset;
+			int iKSpawn = k + iZOffset;
+			
+        	if ( world.doesBlockHaveSolidTopSurface( iISpawn, iJSpawn - 1, iKSpawn ) && IsValidRespawnLocation( world, iISpawn, iJSpawn, iKSpawn ) )
+        	{
+                return new ChunkCoordinates( iISpawn, iJSpawn, iKSpawn );
+            }
+    	}
+    	
+        return null;
+    }
+
+    // overloaded vanilla function with added dimension param
+    public void setSpawnChunk( ChunkCoordinates coords, boolean bForced, int iDimension )
+    {
+        if ( coords != null )
+        {
+            spawnChunk = new ChunkCoordinates(coords);
+            spawnForced = bForced;
+            m_iSpawnDimension = iDimension;
+        }
+        else
+        {
+            spawnChunk = null;
+            spawnForced = false;
+            m_iSpawnDimension = 0;            
+        }        
+    }
+    
+	public void AddRawChatMessage( String message )
+	{
+	}
+	
+	boolean IsCurrentToolEffectiveOnBlock( Block targetBlock, int i, int j, int k )
+	{
+        float var2 = 1.0F;
+
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+            return currentItemStack.getItem().IsEfficientVsBlock( currentItemStack, worldObj, targetBlock, i, j, k );
+        }
+
+		return false;
+	}
+    
+    public boolean canHarvestBlock( Block par1Block, int i, int j, int k )
+    {
+        return this.inventory.canHarvestBlock( worldObj, par1Block, i, j, k );
+    }
+    
+    public boolean AddStackToCurrentHeldStackIfEmpty( ItemStack stack )
+    {
+    	if ( getCurrentEquippedItem() == null )
+    	{
+    		inventory.setInventorySlotContents( inventory.currentItem, stack.copy() );
+    		
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    
+    protected void UpdateModStatusVariables()
+    {
+    	UpdateGloomState();
+    	
+    	UpdateHungerPenaltyLevel();
+    	
+    	UpdateFatPenaltyLevel();
+    	
+    	UpdateHealthPenaltyLevel();
+    }
+
+    protected void UpdateGloomState() {}
+    
+	protected void UpdateHungerPenaltyLevel() {}
+	
+    protected void UpdateFatPenaltyLevel() {}
+	
+	protected void UpdateHealthPenaltyLevel() {}
+	
+	protected void OnBlockedDamage( DamageSource source, int iDamage )
+	{
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+        	currentItemStack.damageItem( 1, this );
+        }
+	}
+	
+    @Override
+    public double getMountedYOffset()
+    {
+        return (double)height * 0.025D;
+    }
+    
+    public void AddExhaustionWithoutVisualFeedback( float fAmount )
+    {
+        addExhaustion( fAmount );
+    }
+    
+    public void AddHarvestBlockExhaustion( int iBlockID, int iBlockI, int iBlockJ, int iBlockK, int iBlockMetadata )
+    {
+    	float fExhaustionConsumed = 0.025F; // default exhaustion amount
+    	
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+        	fExhaustionConsumed = currentItemStack.getItem().GetExhaustionOnUsedToHarvestBlock( iBlockID, worldObj, iBlockI, iBlockJ, iBlockK, iBlockMetadata );
+        }
+    	
+    	if ( fExhaustionConsumed > 0F )
+    	{
+    		addExhaustion( fExhaustionConsumed );
+    	}
+    }
+    
+    protected void OnZeroDamageAttack()
+    {
+    }
+    
+    protected boolean IsPlayerHoldingSail()
+    {
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+    		return currentItemStack.itemID == FCBetterThanWolves.fcItemWindMillBlade.itemID;
+        }
+        
+        return false;
+    }
+    
+    @Override
+	public boolean AppliesConstantForceWhenRidingBoat()
+	{
+		return IsPlayerHoldingSail();
+	}
+	
+    @Override
+	public double MovementModifierWhenRidingBoat()
+	{
+        double dModifier = 0.35D;
+        
+        if ( IsPlayerHoldingSail() )
+        {
+			dModifier = 1.0D;
+    	}
+        
+		return dModifier;
+	}
+
+    @Override
+    public void unmountEntity( Entity riddenEntity )
+    {
+        double dUnmountX = posX;
+        double dUnmountY = posY;
+        double dUnmountZ = posZ;
+
+        if (riddenEntity != null)
+        {
+            dUnmountX = riddenEntity.posX;
+            dUnmountY = riddenEntity.boundingBox.minY + (double)riddenEntity.height;
+            dUnmountZ = riddenEntity.posZ;
+        }
+        
+        double dLookOffsetX = -MathHelper.cos( ( rotationYaw - 90 ) * (float)Math.PI / 180.0F );
+        double dLookOffsetZ = -MathHelper.sin( ( rotationYaw - 90 ) * (float)Math.PI / 180.0F );
+        
+        int iMaxSuitability = 0;
+        
+        for ( double dTempLookOffset = 2.0D; dTempLookOffset > 0.1D; dTempLookOffset -= 0.5D )
+        {
+        	double dTempXOffset = dLookOffsetX * dTempLookOffset;
+        	double dTempZOffset = dLookOffsetZ * dTempLookOffset;
+        	
+        	int iTempSuitability = GetDismountLocationSuitability( dTempXOffset, dTempZOffset );
+        	
+        	if (  iTempSuitability > iMaxSuitability )
+        	{
+                dUnmountX = posX + dTempXOffset;
+                dUnmountY = posY + 1.0D;
+                dUnmountZ = posZ + dTempZOffset;
+                
+                iMaxSuitability = iTempSuitability;
+        	}
+        }
+        
+        if ( iMaxSuitability <= 0 )
+        {
+	        for ( double dTempXOffset = -1.5D; dTempXOffset < 2.0D; ++dTempXOffset )
+	        {
+	            for ( double dTempZOffset = -1.5D; dTempZOffset < 2.0D; ++dTempZOffset )
+	            {
+	            	int iTempSuitability = GetDismountLocationSuitability( dTempXOffset, dTempZOffset );
+	            	
+	            	if (  iTempSuitability > iMaxSuitability )
+	            	{
+	                    dUnmountX = posX + dTempXOffset;
+	                    dUnmountY = posY + 1.0D;
+	                    dUnmountZ = posZ + dTempZOffset;
+	                    
+	                    iMaxSuitability = iTempSuitability;
+	            	}
+	            }
+	        }
+        }
+
+        setLocationAndAngles(dUnmountX, dUnmountY, dUnmountZ, this.rotationYaw, this.rotationPitch);
+    }
+    
+    private boolean IsSolidBlockToDismountOn( int i, int j, int k )
+    {
+    	return worldObj.doesBlockHaveSolidTopSurface( i , j, k )  || worldObj.getBlockMaterial( i, j, k ) == Material.ice;    
+	}
+    
+    /**
+     * Returns a value of zero or higher, with larger numbers indicating greater suitability
+     */
+    private int GetDismountLocationSuitability( double dPosOffsetX, double dPosOffsetZ )
+    {
+    	int i = MathHelper.floor_double( posX + dPosOffsetX );
+    	int j = MathHelper.floor_double( posY ); 
+    	int k = MathHelper.floor_double( posZ + dPosOffsetZ );
+    	
+        AxisAlignedBB dTempBoundingBox = boundingBox.getOffsetBoundingBox( dPosOffsetX, 1.0D, dPosOffsetZ );
+
+        if ( worldObj.getCollidingBlockBounds( dTempBoundingBox ).isEmpty() )
+        {
+	        if ( IsSolidBlockToDismountOn( i, j, k ) )
+	        {
+	            return 3;
+	        }
+	        else if ( IsSolidBlockToDismountOn( i, j - 1, k ) )
+	        {
+	            return 2;
+	            
+	        }
+	        else if ( worldObj.getBlockMaterial( i, j - 1, k ) == Material.water )
+	        {
+	        	return 1;
+	        }
+        }
+        
+        return 0;
+    }
+    
+    public void AddExhaustionForJump()
+    {
+	    if ( isSprinting() )
+	    {
+			addExhaustion( m_fExhaustionJumpingSprinting );
+	    }
+	    else
+	    {
+			addExhaustion( m_fExhaustionJumping );
+	    }
+    }
+    
+    public void SetItemInUseCount( int iCount )
+    {
+        itemInUseCount = iCount;
+    }
+
+    @Override
+    public boolean GetCanBeHeadCrabbed( boolean bSquidInWater )
+    {
+    	return isEntityAlive() && !capabilities.disableDamage && 
+    		riddenByEntity == null && ridingEntity == null;
+    }
+    
+    @Override
+    public boolean IsValidOngoingAttackTargetForSquid()
+    {
+    	return isEntityAlive();
+    }
+    
+    @Override
+	public boolean IsImmuneToHeadCrabDamage()
+	{
+		return IsWearingSoulforgedHelm();
+	}
+    
+    public boolean IsLocalPlayerAndHittingBlock()
+    {
+    	return false;
+    }
+	
+    @Override
+    public void MountEntityRemote( Entity entityToMount )
+    {
+    	// Fix described in MC-1291 for players dissapearing after riding boats in SMP
+    	// Bypasses toggle type behavior of mounting and dismounting if multiple packets
+    	// are received for a player.
+    	
+    	if ( ridingEntity != entityToMount )
+    	{
+    		super.mountEntity( entityToMount );
+    	}
+    }
+
+    public boolean CanDrink()
+    {
+        return !isPotionActive( Potion.hunger );
+    }
+    
+    public void OnCantConsume()
+    {
+    	if ( !worldObj.isRemote && m_iTicksSinceEmoteSound >= m_iTicksBetweenEmoteSounds )    		
+    	{    		
+            worldObj.playAuxSFX( FCBetterThanWolves.m_iEatFailAuxFXID,           
+            	MathHelper.floor_double( posX ), 
+            	MathHelper.floor_double( posY ), 
+            	MathHelper.floor_double( posZ ), 0 );    
+            
+            m_iTicksSinceEmoteSound = 0;
+    	}
+    }
+    
+    static public boolean InstallationIntegrityTestPlayer()
+    {
+    	return true;
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityPlayerMP.java b/minecraft/net/minecraft/src/EntityPlayerMP.java
index 4eef6fe..dbb052e 100644
--- a/minecraft/net/minecraft/src/EntityPlayerMP.java
+++ b/minecraft/net/minecraft/src/EntityPlayerMP.java
@@ -33,6 +33,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     public double managedPosZ;
 
     /** LinkedList that holds the loaded chunks. */
+    /**
+     * FCNOTE: Deprecated list used by vanilla PlayerInstance and PlayerManager to track watched
+     * chunks
+     */
     public final List loadedChunks = new LinkedList();
 
     /** entities added to this list will  be packet29'd to the player */
@@ -188,6 +192,8 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
             this.playerNetServerHandler.sendPacketToPlayer(new Packet29DestroyEntity(var2));
         }
 
+        // FCMOD: Changed
+        /*
         if (!this.loadedChunks.isEmpty())
         {
             ArrayList var6 = new ArrayList();
@@ -209,23 +215,30 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
             if (!var6.isEmpty())
             {
                 this.playerNetServerHandler.sendPacketToPlayer(new Packet56MapChunks(var6));
-                Iterator var10 = var8.iterator();
+                Iterator var11 = var8.iterator();
 
-                while (var10.hasNext())
+                while (var11.hasNext())
                 {
-                    TileEntity var5 = (TileEntity)var10.next();
+                    TileEntity var5 = (TileEntity)var11.next();
                     this.sendTileEntityToPlayer(var5);
                 }
 
-                var10 = var6.iterator();
+                var11 = var6.iterator();
 
-                while (var10.hasNext())
+                while (var11.hasNext())
                 {
-                    Chunk var11 = (Chunk)var10.next();
-                    this.getServerForPlayer().getEntityTracker().func_85172_a(this, var11);
+                    Chunk var10 = (Chunk)var11.next();
+                    this.getServerForPlayer().getEntityTracker().func_85172_a(this, var10);
                 }
             }
         }
+        */
+        SendChunksToClient();
+        // END FCMOD
+
+        // FCMOD: Code Added
+        ModSpecificOnUpdate();
+        // END FCMOD
     }
 
     public void setEntityHealth(int par1)
@@ -262,12 +275,21 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
                 }
             }
 
+        	// FCMOD: Code changed to relay changes in food saturation
+        	/*
             if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry)
+        	*/
+        	if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry ||
+        		m_iLastFoodSaturation != (int)( foodStats.getSaturationLevel() * 8F ) )
+    		// END FCMOD
             {
                 this.playerNetServerHandler.sendPacketToPlayer(new Packet8UpdateHealth(this.getHealth(), this.foodStats.getFoodLevel(), this.foodStats.getSaturationLevel()));
                 this.lastHealth = this.getHealth();
                 this.lastFoodLevel = this.foodStats.getFoodLevel();
                 this.wasHungry = this.foodStats.getSaturationLevel() == 0.0F;
+            	// FCMOD: Code added
+            	m_iLastFoodSaturation = (int)( foodStats.getSaturationLevel() * 8F );
+            	// END FCMOD
             }
 
             if (this.experienceTotal != this.lastExperience)
@@ -297,6 +319,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
             this.inventory.dropAllItems();
         }
 
+        // FCMOD: Code added
+        CustomModDrops( par1DamageSource );
+        // END FCMOD
+
         Collection var2 = this.worldObj.getScoreboard().func_96520_a(ScoreObjectiveCriteria.field_96642_c);
         Iterator var3 = var2.iterator();
 
@@ -405,7 +431,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     /**
      * called from onUpdate for all tileEntity in specific chunks
      */
+    // FCMOD: Changed (server only) to match name on client
+    //private void getTileEntityInfo(TileEntity par1TileEntity)
     private void sendTileEntityToPlayer(TileEntity par1TileEntity)
+    // END FCMOD
     {
         if (par1TileEntity != null)
         {
@@ -491,7 +520,7 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     {
         this.currentWindowId = this.currentWindowId % 100 + 1;
     }
-
+    
     /**
      * Displays the crafting GUI for a workbench.
      */
@@ -499,7 +528,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     {
         this.incrementWindowID();
         this.playerNetServerHandler.sendPacketToPlayer(new Packet100OpenWindow(this.currentWindowId, 1, "Crafting", 9, true));
-        this.openContainer = new ContainerWorkbench(this.inventory, this.worldObj, par1, par2, par3);
+        // FCMOD: Changed
+        //this.openContainer = new ContainerWorkbench(this.inventory, this.worldObj, par1, par2, par3);
+        openContainer = new FCContainerWorkbench( inventory, worldObj, par1, par2, par3 );
+        // END FCMOD
         this.openContainer.windowId = this.currentWindowId;
         this.openContainer.addCraftingToCrafters(this);
     }
@@ -613,9 +645,16 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
         this.incrementWindowID();
         this.openContainer = new ContainerMerchant(this.inventory, par1IMerchant, this.worldObj);
         this.openContainer.windowId = this.currentWindowId;
+        // FCMOD: Code moved slightly later to avoid init order problems
+        /*
         this.openContainer.addCraftingToCrafters(this);
+        */
+        // END FCMOD
         InventoryMerchant var3 = ((ContainerMerchant)this.openContainer).getMerchantInventory();
         this.playerNetServerHandler.sendPacketToPlayer(new Packet100OpenWindow(this.currentWindowId, 6, par2Str == null ? "" : par2Str, var3.getSizeInventory(), par2Str != null));
+        // FCMOD: Code moved from above to avoid init order problems
+        this.openContainer.addCraftingToCrafters(this);
+        // END FCMOD
         MerchantRecipeList var4 = par1IMerchant.getRecipes(this);
 
         if (var4 != null)
@@ -923,4 +962,560 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     {
         return new ChunkCoordinates(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + 0.5D), MathHelper.floor_double(this.posZ));
     }
+
+    // FCMOD: Added
+    public LinkedList<ChunkCoordIntPair> m_chunksToBeSentToClient = 
+    	new LinkedList<ChunkCoordIntPair>();
+    
+    private int m_iLastFoodSaturation = -99999999;
+	private int m_iExhaustionWithTimeCounter = 0;
+	
+	private static final int m_iExhaustionWithTimePeriod = 600; // once per 30 seconds
+	private static final float m_fExhaustionWithTimeAmount = 0.5F; // set with above to begin starving to death after 160 minutes if you're fully obese, losing 1 hunger every 4 minutes	
+    
+    private static final float m_fMinimumGloomBiteChance = 0.01F; 
+    private static final float m_fMaximumGloomBiteChance = 0.05F; // 1/second
+    
+	private static final int m_iDelayBetweenZeroDamageAttackSounds = 20; 
+	private long m_lTimeOfLastZeroDamageAttackSound = 0;
+	
+    @Override
+    protected void CheckForHeadDrop( DamageSource source, int iLootingModifier )
+    {
+	    Entity sourceEntity = source.getEntity();        
+	    int iHeadChance = this.rand.nextInt(200);        
+	    
+        iHeadChance -= iLootingModifier;
+    	
+	    if ( sourceEntity instanceof EntityPlayer)
+	    {
+	    	if ( ((EntityPlayer)sourceEntity).getHeldItem() != null && 
+	    		((EntityPlayer)sourceEntity).getHeldItem().getItem().itemID == FCBetterThanWolves.fcItemBattleAxe.itemID )
+	    	{
+	    		// 100% chance of decapitation with Battle Axe in PvP
+	    		
+	    		iHeadChance = 0;
+	    	}
+	    }
+	    else if ( source == FCDamageSourceCustom.m_DamageSourceChoppingBlock )
+	    {
+			iHeadChance = 0;
+	    }
+	    
+	    if ( iHeadChance < 5 )
+	    {
+	        dropHead();
+	    }
+    }
+    
+    private void CustomModDrops( DamageSource source )
+    {
+	    Entity sourceEntity = source.getEntity();        
+        int iLootingModifier = GetAmbientLootingModifier();
+
+        if ( sourceEntity instanceof EntityPlayer )
+        {
+            int iPlayerLootingModifier = EnchantmentHelper.getLootingModifier((EntityLiving)sourceEntity);
+            
+            if ( iPlayerLootingModifier > iLootingModifier )
+            {
+            	iLootingModifier = iPlayerLootingModifier;
+            }
+        }
+        
+        DropMysteryMeat( iLootingModifier );
+        
+        CheckForHeadDrop( source, iLootingModifier );
+    }
+    
+    private void DropMysteryMeat( int iLootingModifier )
+    {
+        if ( !HasHeadCrabbedSquid() )
+        {
+	    	// only drop mystery meat periodically to prevent people killing themselves repeatedly for food.
+	    	// With HC Spawn enabled, it only happens when the player will be moved to a new spawn location.
+	    	
+			long lOverworldTime = MinecraftServer.getServer().worldServers[0].getWorldTime();
+			
+			if ( m_lTimeOfLastSpawnAssignment == 0 || m_lTimeOfLastSpawnAssignment > lOverworldTime || 
+				lOverworldTime - m_lTimeOfLastSpawnAssignment >= FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
+			{
+				int iDropItemID = FCBetterThanWolves.fcItemRawMysteryMeat.itemID;
+				
+				if ( isBurning() )
+				{
+					iDropItemID = FCBetterThanWolves.fcItemMeatBurned.itemID;
+				}
+		    	
+		        int iFat = ( (int)foodStats.getSaturationLevel() ) / 2;
+		        
+		        int iNumDropped = 1 + iFat;
+		
+		        for ( int iTempCount = 0; iTempCount < iNumDropped; ++iTempCount )
+		        {        	
+		            dropItem( iDropItemID, 1 );
+		        }
+			}
+        }
+    }
+    
+    private void ModSpecificOnUpdate()
+    {
+        UpdateExhaustionWithTime();
+        
+        UpdateHealthAndHungerEffects();
+        
+        UpdateMagneticInfluences();
+        
+        UpdateSpawnChunksVisualization();
+        
+    	NotifyBlockWalkedOn();
+    }
+    
+	private void UpdateMagneticInfluences()
+	{
+		if ( ( worldObj.getTotalWorldTime() + entityId ) % 40 != 0 )
+		{
+			// stagger these updates as they can be performance intensive
+			 
+			return;
+		}
+		 
+		FCMagneticPoint strongestPoint = null;
+		double dStrongestFieldStrength = 0.0D;
+		 
+	    if ( worldObj.provider.isSurfaceWorld() )
+	    {
+	    	ChunkCoordinates spawnPos = worldObj.getSpawnPoint();
+	    	 
+	    	strongestPoint = new FCMagneticPoint( spawnPos.posX, 0, spawnPos.posZ, 2 );
+	    	 
+	    	dStrongestFieldStrength = strongestPoint.GetFieldStrengthRelativeToPosition( posX, posZ );
+	    	 
+	        Iterator pointIterator = worldObj.GetMagneticPointList().m_MagneticPoints.iterator();
+	         
+	        while ( pointIterator.hasNext() )
+	        {
+	        	FCMagneticPoint tempPoint = (FCMagneticPoint)pointIterator.next();
+	        	 
+	        	double dTempFieldStrength = tempPoint.GetFieldStrengthRelativeToPosition( posX, posZ );
+	        	 
+	        	if ( dTempFieldStrength > dStrongestFieldStrength )
+	        	{
+	        		strongestPoint = tempPoint;
+	        		dStrongestFieldStrength = dTempFieldStrength;
+	        	}
+	        }
+	    }
+	    else
+	    {
+	        Iterator pointIterator = worldObj.GetMagneticPointList().m_MagneticPoints.iterator();
+	         
+	        while ( pointIterator.hasNext() )
+	        {
+	        	FCMagneticPoint tempPoint = (FCMagneticPoint)pointIterator.next();
+	        	 
+	        	double dTempFieldStrength = tempPoint.GetFieldStrengthRelativeToPositionWithBackgroundNoise( posX, posZ );
+	        	 
+	        	if ( dTempFieldStrength > dStrongestFieldStrength )
+	        	{
+	        		strongestPoint = tempPoint;
+	        		dStrongestFieldStrength = dTempFieldStrength;
+	        	}
+	        }
+	    }         
+	     
+	    if ( strongestPoint != null )
+	    {
+	    	SetHasValidMagneticPointForLocation( true );
+	    	SetStongestMagneticPointForLocationI( strongestPoint.m_iIPos );
+	    	SetStongestMagneticPointForLocationK( strongestPoint.m_iKPos );
+	    }
+	    else
+	    {
+	    	SetHasValidMagneticPointForLocation( false );
+	    }
+	}
+	
+	private void UpdateSpawnChunksVisualization()
+	{
+		if ( worldObj.provider.dimensionId == 0 && ( IsWearingEnderSpectacles() || 
+			isPotionActive( FCBetterThanWolves.potionTrueSight ) ) )
+		{
+			SetSpawnChunksVisualization( worldObj.worldInfo.getSpawnX(),
+				worldObj.worldInfo.getSpawnY(), worldObj.worldInfo.getSpawnZ() );
+		}
+		else
+		{
+			SetSpawnChunksVisualization( 0, 0, 0 );
+		}
+	}
+	
+    private void UpdateExhaustionWithTime()
+    {
+    	m_iExhaustionWithTimeCounter++;
+    	
+    	if ( m_iExhaustionWithTimeCounter >= m_iExhaustionWithTimePeriod )
+    	{
+            if ( !capabilities.disableDamage ) // disable hunger drain in creative
+            {
+            	foodStats.addExhaustion( m_fExhaustionWithTimeAmount );
+            }
+            
+    		m_iExhaustionWithTimeCounter = 0;
+    	}
+    }
+    
+    private void UpdateHealthAndHungerEffects()
+    {
+    	if ( !isDead && ( worldObj.getTotalWorldTime() + (long)entityId ) % 80L == 0L )
+    	{
+    		if ( foodStats.getFoodLevel() <= 0 && foodStats.getSaturationLevel() <= 0F )
+    		{
+                addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
+    		}
+    		
+    		if ( health <= 2 )
+    		{
+                addPotionEffect( new PotionEffect( Potion.blindness.getId(), 180, 0, true ) );                            
+    		}
+    	}
+    }
+    
+    @Override
+    protected void UpdateGloomState()
+    {
+    	if ( !isDead )
+    	{
+    		if ( IsInGloom() )
+    		{
+    			m_iInGloomCounter++;
+    			
+    			if ( GetGloomLevel() == 0 || ( m_iInGloomCounter > m_iGloomCounterBetweenStateChanges && GetGloomLevel() < 3 ) )
+    			{
+    				SetGloomLevel( GetGloomLevel() + 1 );
+    				
+    				m_iInGloomCounter = 0;
+    			}
+    			
+    			if ( GetGloomLevel() >= 3 )
+    			{
+    		    	if ( ( worldObj.getTotalWorldTime() + (long)entityId ) % 80L == 0L )
+    		    	{
+		                addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
+    		    	}
+    		    	
+    		    	// gloom bites
+    		    	
+    	    		float fCounterProgress = (float)m_iInGloomCounter / (float)m_iGloomCounterBetweenStateChanges;
+    	    		
+    	    		if ( fCounterProgress > 1.0F )
+    	    		{
+    	    			fCounterProgress = 1.0F;
+    	    		}
+
+            		float fGloomBiteChance = m_fMinimumGloomBiteChance + ( m_fMaximumGloomBiteChance - m_fMinimumGloomBiteChance ) * fCounterProgress;        		
+    	    		
+            		if ( rand.nextFloat() < fGloomBiteChance )
+            		{
+            			if ( attackEntityFrom( FCDamageSourceCustom.m_DamageSourceGloom, 1 ) )
+            			{            			
+	            			if ( health <= 0 )
+	            			{
+	            	        	worldObj.playAuxSFX( FCBetterThanWolves.m_iBurpSoundAuxFXID, 
+	            	        		MathHelper.floor_double( posX ), MathHelper.floor_double( posY ), MathHelper.floor_double( posZ ), 0 );
+	            			}
+            			}
+            		}
+		    	}
+    		}
+    		else
+    		{
+        		SetGloomLevel( 0 );
+        		
+        		m_iInGloomCounter = 0;
+    		}   		    		
+    	}
+    }
+
+    @Override
+    protected void UpdateFatPenaltyLevel()
+    {
+        int iFat = (int)foodStats.getSaturationLevel();
+    	int iFatLevel = 4;
+        
+        if ( iFat < 12 )
+        {
+        	iFatLevel = 0;
+        }
+        else if ( iFat < 14 )
+        {
+        	iFatLevel = 1;
+        }
+        else if ( iFat < 16 )
+        {
+        	iFatLevel = 2;
+        }
+        else if ( iFat < 18 )
+        {
+        	iFatLevel = 3;
+        }
+    	
+    	SetFatPenaltyLevel( iFatLevel );
+    }
+	
+    @Override
+	protected void UpdateHungerPenaltyLevel()
+	{
+        int iHunger = foodStats.getFoodLevel();
+        int iPenaltyLevel = 5;
+        
+        if ( iHunger > 24 )
+        {
+        	iPenaltyLevel = 0;
+        }
+        else if ( iHunger > 18 )
+        {
+        	iPenaltyLevel = 1;
+        }
+        else if ( iHunger > 12 )
+        {
+        	iPenaltyLevel = 2;
+        }
+        else if ( iHunger > 6 )
+        {
+        	iPenaltyLevel = 3;
+        }
+        else if ( iHunger > 0 || foodStats.getSaturationLevel() > 0F )
+        {
+        	iPenaltyLevel = 4;
+        }
+        
+        SetHungerPenaltyLevel( iPenaltyLevel );
+	}
+	
+    @Override
+	protected void UpdateHealthPenaltyLevel()
+	{
+		int iHealth = getHealth();
+        int iPenaltyLevel = 5;
+        
+        if ( iHealth > 10 )
+        {
+        	iPenaltyLevel = 0;
+        }
+        else if ( iHealth > 8 )
+        {
+        	iPenaltyLevel = 1;
+        }
+        else if ( iHealth > 6 )
+        {
+        	iPenaltyLevel = 2;
+        }
+        else if ( iHealth > 4 )
+        {
+        	iPenaltyLevel = 3;
+        }
+        else if ( iHealth > 2 )
+        {
+        	iPenaltyLevel = 4;
+        }
+        
+        SetHealthPenaltyLevel( iPenaltyLevel );
+	}
+	
+    private boolean IsInGloom()
+    {
+        if ( !capabilities.disableDamage ) // disable darkness effects in creative
+        {
+	        if ( !isPotionActive( Potion.nightVision ) && worldObj.provider.dimensionId == 0 )
+	        {
+		        int i = MathHelper.floor_double( posX );
+		        int j = MathHelper.floor_double( posY - yOffset );
+		        int k = MathHelper.floor_double( posZ );
+		        
+		        int iOldSkylightSubtracted = worldObj.skylightSubtracted;
+		        
+		        float fSunBrightness = worldObj.ComputeOverworldSunBrightnessWithMoonPhases();
+		        
+		        if ( fSunBrightness < 0.02D )
+		        {
+		        	// world is in gloom, no skylight at all
+		        	worldObj.skylightSubtracted = 15;
+		        }
+		        else
+		        {
+		        	worldObj.skylightSubtracted = (int)( ( 1F - fSunBrightness ) * 11.9F );
+		        }
+
+		        float fBlockInLightValue = worldObj.getLightBrightness( i, j, k );
+		        
+		        float fBlockAboveLightValue = worldObj.getLightBrightness( i, j + 1, k );
+		        
+		        if ( fBlockAboveLightValue > fBlockInLightValue )
+		        {
+		        	fBlockInLightValue = fBlockAboveLightValue;
+		        }
+		        
+		        worldObj.skylightSubtracted = iOldSkylightSubtracted;
+		        
+		    	return fBlockInLightValue < 0.001F;
+	        }
+        }
+        
+        return false;
+    }
+    
+	@Override    
+	public void AddRawChatMessage( String message )
+	{
+		playerNetServerHandler.sendPacket( new Packet3Chat( message ) );
+	}
+
+	@Override
+    protected void OnZeroDamageAttack()
+    {
+		long lCurrentTime = worldObj.getWorldTime();
+		
+		if ( lCurrentTime > m_lTimeOfLastZeroDamageAttackSound + m_iDelayBetweenZeroDamageAttackSounds )
+		{
+			worldObj.playSoundAtEntity( this, 
+	    		"random.classic_hurt", 1.0F +  rand.nextFloat() * 0.25F, 
+	    		getSoundPitch() * 1.20F + rand.nextFloat() * 0.1F);
+			
+			m_lTimeOfLastZeroDamageAttackSound = lCurrentTime;
+		}
+    }
+	
+	@Override
+    public void OnStruckByLightning( FCEntityLightningBolt boltEntity )
+    {
+        if ( !capabilities.disableDamage )
+        {
+            dealFireDamage( 12 );
+            
+            setFire( 8 );
+
+        	FlingAwayFromEntity( boltEntity, 2D );
+    		
+    		worldObj.playSoundAtEntity( this, 
+        		"random.classic_hurt", 1.0F +  rand.nextFloat() * 0.25F, 
+        		getSoundPitch() * 1.20F + rand.nextFloat() * 0.1F);
+    		
+            addPotionEffect( new PotionEffect( Potion.blindness.getId(), 90, 0, true ) );
+            
+            addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
+        }
+    }
+	
+    public int IncrementAndGetWindowID()
+    {
+        this.currentWindowId = this.currentWindowId % 100 + 1;
+        
+        return currentWindowId;
+    }
+    
+    private void NotifyBlockWalkedOn()
+    {
+        if ( onGround )
+        {
+        	int iGroundI = MathHelper.floor_double( posX );
+        	int iGroundJ = MathHelper.floor_double( posY - 0.03D - (double)yOffset ); // same calc used for step sound
+        	int iGroundK = MathHelper.floor_double( posZ );
+        	
+        	Block blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+
+        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+        	{
+        		float fHalfWidth = width / 2F;
+        		
+        		// block we are standing on directly is air or has no collision box.  Check the horizontal extents of our box for a movement modifier
+
+        		int iCenterGroundI = iGroundI;
+        		
+        		iGroundI = MathHelper.floor_double( posX + fHalfWidth );	        		
+	        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+	        	
+	        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+	        	{
+	        		iGroundI = MathHelper.floor_double( posX - fHalfWidth );
+		        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+		        	
+		        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+		        	{
+		        		iGroundI = iCenterGroundI;
+		        		
+		        		iGroundK = MathHelper.floor_double( posZ + fHalfWidth );
+			        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+			        	
+			        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+			        	{
+			        		iGroundK = MathHelper.floor_double( posZ - fHalfWidth );
+				        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];					        	
+			        	}
+		        	}
+	        	}	        	
+        	}
+        	
+        	if ( blockOn != null )
+        	{
+        		blockOn.OnPlayerWalksOnBlock( worldObj, iGroundI, iGroundJ, iGroundK, this );        		
+        	}
+        }        
+    }
+    
+    public void SendChunksToClient()
+    {
+        if ( !m_chunksToBeSentToClient.isEmpty() )
+        {
+            Iterator<ChunkCoordIntPair> coordIterator = m_chunksToBeSentToClient.iterator();
+            
+            ArrayList<Chunk> chunksToSend = new ArrayList<Chunk>();
+            ArrayList<TileEntity> tileEntitiesToSend = new ArrayList<TileEntity>();
+
+            while ( coordIterator.hasNext() && chunksToSend.size() < 5 )
+            {
+                ChunkCoordIntPair tempCoord = coordIterator.next();
+                coordIterator.remove();
+
+                if ( tempCoord != null && worldObj.chunkExists( 
+                	tempCoord.chunkXPos, tempCoord.chunkZPos ) )
+                {
+                    chunksToSend.add( worldObj.getChunkFromChunkCoords(
+                    	tempCoord.chunkXPos, tempCoord.chunkZPos ) );
+                    
+                    tileEntitiesToSend.addAll( getServerForPlayer().getAllTileEntityInBox(
+                    	tempCoord.chunkXPos * 16, 0, tempCoord.chunkZPos * 16, 
+                    	tempCoord.chunkXPos * 16 + 16, 256, tempCoord.chunkZPos * 16 + 16));
+                }
+            }
+
+            if ( !chunksToSend.isEmpty() )
+            {
+	        	FCUtilsWorld.SendPacketToPlayer( playerNetServerHandler, 
+	        		new Packet56MapChunks( chunksToSend ) );
+	        	
+                Iterator<TileEntity> tileIterator = tileEntitiesToSend.iterator();
+
+                while ( tileIterator.hasNext() )
+                {
+                    TileEntity tempTile = (TileEntity)tileIterator.next();
+                    
+                    sendTileEntityToPlayer( tempTile );
+                }
+
+                Iterator<Chunk> chunkIterator = chunksToSend.iterator();
+
+                while ( chunkIterator.hasNext() )
+                {
+                    Chunk var10 = chunkIterator.next();
+                    
+                    // the following call checks for entities in the chunk, and starts the player
+                    // watching them for updates
+                    getServerForPlayer().getEntityTracker().func_85172_a( this, var10 );
+                }
+            }
+        }
+    }
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityPlayerSP.java b/minecraft/net/minecraft/src/EntityPlayerSP.java
index e203918..cd1de83 100644
--- a/minecraft/net/minecraft/src/EntityPlayerSP.java
+++ b/minecraft/net/minecraft/src/EntityPlayerSP.java
@@ -38,7 +38,10 @@ public class EntityPlayerSP extends EntityPlayer
 
         if (par3Session != null && par3Session.username != null && par3Session.username.length() > 0)
         {
-            this.skinUrl = "http://skins.minecraft.net/MinecraftSkins/" + StringUtils.stripControlCodes(par3Session.username) + ".png";
+        	// FCMOD: Changed, client only        	
+            //this.skinUrl = "http://skins.minecraft.net/MinecraftSkins/" + StringUtils.stripControlCodes(par3Session.username) + ".png";
+            this.skinUrl = FCBetterThanWolves.fcPlayerSkinURL + StringUtils.stripControlCodes(par3Session.username) + ".png";
+            // END FCMOD
         }
 
         this.username = par3Session.username;
@@ -180,7 +183,12 @@ public class EntityPlayerSP extends EntityPlayer
             this.pushOutOfBlocks(this.posX - (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ - (double)this.width * 0.35D);
             this.pushOutOfBlocks(this.posX + (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ - (double)this.width * 0.35D);
             this.pushOutOfBlocks(this.posX + (double)this.width * 0.35D, this.boundingBox.minY + 0.5D, this.posZ + (double)this.width * 0.35D);
+            // FCMOD: Code change so that sprinting takes into account hunger, health, and fat
+            /*
             boolean var4 = (float)this.getFoodStats().getFoodLevel() > 6.0F || this.capabilities.allowFlying;
+            */
+            boolean var4 = !HasStatusPenalty() || this.capabilities.allowFlying;
+            // END FCMOD
 
             if (this.onGround && !var3 && this.movementInput.moveForward >= var2 && !this.isSprinting() && var4 && !this.isUsingItem() && !this.isPotionActive(Potion.blindness))
             {
@@ -238,7 +246,7 @@ public class EntityPlayerSP extends EntityPlayer
             {
                 this.capabilities.isFlying = false;
                 this.sendPlayerAbilities();
-            }
+            }            
         }
     }
 
@@ -254,9 +262,22 @@ public class EntityPlayerSP extends EntityPlayer
             var1 *= 1.1F;
         }
 
+        // FCMOD: Changed the following so the view doesn't zoom in and out based on walking on different material types
+        /*
         var1 *= (this.landMovementFactor * this.getSpeedModifier() / this.speedOnGround + 1.0F) / 2.0F;
-
+        */
+        var1 *= (this.landMovementFactor * this.getFOVSpeedModifier() / this.speedOnGround + 1.0F) / 2.0F;
+        
+        var1 *= UpdateGloomFOVMultiplier();
+        // END FCMOD
+
+        // FCMOD: Changed the following to provide FOV change on composite bow
+		/*
         if (this.isUsingItem() && this.getItemInUse().itemID == Item.bow.itemID)
+        */
+        if ( isUsingItem() && ( getItemInUse().itemID == Item.bow.itemID ||
+    		getItemInUse().itemID == FCBetterThanWolves.fcItemCompositeBow.itemID ) )        	
+    	// END FCMOD
         {
             int var2 = this.getItemInUseDuration();
             float var3 = (float)var2 / 20.0F;
@@ -278,7 +299,10 @@ public class EntityPlayerSP extends EntityPlayer
 
     public void updateCloak()
     {
-        this.cloakUrl = "http://skins.minecraft.net/MinecraftCloaks/" + StringUtils.stripControlCodes(this.username) + ".png";
+    	// FCMOD: Changed, client only        	
+        //this.cloakUrl = "http://skins.minecraft.net/MinecraftCloaks/" + StringUtils.stripControlCodes(this.username) + ".png";
+        this.cloakUrl = FCBetterThanWolves.fcPlayerCloakURL + StringUtils.stripControlCodes(this.username) + ".png";
+        // END FCMOD
     }
 
     /**
@@ -320,6 +344,12 @@ public class EntityPlayerSP extends EntityPlayer
         {
             this.mc.displayGuiScreen(new GuiScreenBook(this, par1ItemStack, true));
         }
+        // FCMOD: Code added
+        else if ( var2 == FCBetterThanWolves.fcItemAncientProphecy )
+        {
+            mc.displayGuiScreen( new GuiScreenBook( this, par1ItemStack, false ) );
+        }
+        // END FCMOD
     }
 
     /**
@@ -345,7 +375,10 @@ public class EntityPlayerSP extends EntityPlayer
      */
     public void displayGUIWorkbench(int par1, int par2, int par3)
     {
-        this.mc.displayGuiScreen(new GuiCrafting(this.inventory, this.worldObj, par1, par2, par3));
+    	// FCMOD: Changed (client only)    	
+        //this.mc.displayGuiScreen(new GuiCrafting(this.inventory, this.worldObj, par1, par2, par3));
+        this.mc.displayGuiScreen(new FCClientGuiCraftingWorkbench(this.inventory, this.worldObj, par1, par2, par3));
+        // END FCMOD
     }
 
     public void displayGUIEnchantment(int par1, int par2, int par3, String par4Str)
@@ -617,4 +650,183 @@ public class EntityPlayerSP extends EntityPlayer
     {
         this.worldObj.playSound(this.posX, this.posY - (double)this.yOffset, this.posZ, par1Str, par2, par3, false);
     }
+    
+    // FCMOD: Added (client only)
+    private static final float m_fMinimumGloomCaveSoundChance = 0.01F; // 1/5 seconds 
+    private static final float m_fMaximumGloomCaveSoundChance = 0.05F; // 1/second
+    private static final float m_fMinimumGloomCaveSoundVolume = 0.1F; 
+    private static final float m_fMaximumGloomCaveSoundVolume = 4.0F;
+    
+    private static final float m_fMinimumGloomGrowlSoundChance = 0.01F; // 1/5 seconds 
+    private static final float m_fMaximumGloomGrowlSoundChance = 0.05F; // 1/second
+    private static final float m_fMinimumGloomGrowlSoundVolume = 0.1F; 
+    private static final float m_fMaximumGloomGrowlSoundVolume = 4.0F;
+    
+    private static final float m_fMaximumGloomFOVMultiplier = 1.5F;
+    private static final float m_fGloomFOVMultiplierTimeForTransitionIn = 10.0F; // in seconds
+    private static final float m_fGloomFOVMultiplierTimeForTransitionOut = 2.0F; // in seconds
+    private static final float m_fGloomFOVMultiplierDeltaInPerTick = ( ( m_fMaximumGloomFOVMultiplier - 1.0F ) / 20F ) / m_fGloomFOVMultiplierTimeForTransitionIn; 
+    private static final float m_fGloomFOVMultiplierDeltaOutPerTick = ( ( m_fMaximumGloomFOVMultiplier - 1.0F ) / 20F ) / m_fGloomFOVMultiplierTimeForTransitionOut; 
+    
+    private float m_fCurrentGloomFOVMultiplier = 1F;
+    
+    private int m_iPreviousGloomLevel = 0;    
+    
+    public boolean m_bExhaustionAddedSinceLastGuiUpdate = false;
+    
+    @Override
+    public void addExhaustion( float fAmount )
+    {
+        if ( !capabilities.disableDamage )
+        {
+        	m_bExhaustionAddedSinceLastGuiUpdate = true;
+        }
+        
+        super.addExhaustion( fAmount );
+    }
+
+    @Override
+    public void AddExhaustionWithoutVisualFeedback( float fAmount )
+    {
+        super.addExhaustion( fAmount );
+    }
+    
+    private float getFOVSpeedModifier()
+    {
+    	// copy of original "getSpeedModifier()" code from EntityLiving to avoid view zooming in and out 
+    	// based on the material type you're walking on
+    	
+        float var1 = 1.0F;
+
+        /*
+        if (this.isPotionActive(Potion.moveSpeed))
+        {
+            var1 *= 1.0F + 0.2F * (float)(this.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1);
+        }
+        */
+
+        if (this.isPotionActive(Potion.moveSlowdown))
+        {
+            var1 *= 1.0F - 0.15F * (float)(this.getActivePotionEffect(Potion.moveSlowdown).getAmplifier() + 1);
+        }
+
+        return var1;
+    }
+    
+    private float UpdateGloomFOVMultiplier()
+    {
+    	int iGloomLevel = GetGloomLevel();
+    	
+    	if ( iGloomLevel == 0 )
+    	{
+    		m_fCurrentGloomFOVMultiplier -= m_fGloomFOVMultiplierDeltaOutPerTick;
+    		
+    		if ( m_fCurrentGloomFOVMultiplier < 1F )
+    		{
+    			m_fCurrentGloomFOVMultiplier = 1F;
+    		}
+    	}
+    	else
+    	{
+    		m_fCurrentGloomFOVMultiplier += m_fGloomFOVMultiplierDeltaInPerTick;
+    		
+    		if ( m_fCurrentGloomFOVMultiplier > m_fMaximumGloomFOVMultiplier )
+    		{
+    			m_fCurrentGloomFOVMultiplier = m_fMaximumGloomFOVMultiplier;
+    		}
+    	}
+    	
+    	return m_fCurrentGloomFOVMultiplier;
+    }
+    
+    @Override
+    protected void UpdateGloomState()
+    {
+    	int iGloomLevel = GetGloomLevel();
+
+		if ( m_iPreviousGloomLevel != GetGloomLevel() )
+		{
+			m_iInGloomCounter = 0;
+	    	m_iPreviousGloomLevel = iGloomLevel;
+	    	
+	    	if ( iGloomLevel == 3 )
+	    	{
+                playSound( "mob.endermen.stare", 1.0F, 1.0F );
+	    	}
+		}			
+    	
+    	if ( iGloomLevel > 0 )
+    	{
+    		m_iInGloomCounter++;
+    		
+    		float fCounterProgress = (float)m_iInGloomCounter / (float)m_iGloomCounterBetweenStateChanges;
+    		
+    		if ( fCounterProgress > 1.0F )
+    		{
+    			fCounterProgress = 1.0F;
+    		}
+
+    		// general cave sounds
+    		
+    		float fCaveSoundChance = m_fMaximumGloomCaveSoundChance;
+    		float fCaveSoundVolume = m_fMaximumGloomCaveSoundVolume;
+    		
+    		if ( iGloomLevel > 1 )
+    		{
+    			// growls
+    			
+    			float fGrowlSoundChance = m_fMaximumGloomGrowlSoundChance;
+    			float fGrowlSoundVolume = m_fMaximumGloomGrowlSoundVolume;
+
+    			if ( iGloomLevel > 2 )
+    			{
+    				// insert effects here for when the player is getting bit
+    			}
+    			else
+    			{
+    				fGrowlSoundChance = m_fMinimumGloomGrowlSoundChance + ( m_fMaximumGloomGrowlSoundChance - m_fMinimumGloomGrowlSoundChance ) * fCounterProgress;
+    				fGrowlSoundVolume = m_fMinimumGloomGrowlSoundVolume + ( m_fMaximumGloomGrowlSoundVolume - m_fMinimumGloomGrowlSoundVolume ) * fCounterProgress;
+    			}
+	    		
+	    		if ( rand.nextFloat() < fGrowlSoundChance )
+	    		{
+	    	        PlaySoundInRandomDirection( "mob.wolf.growl", fGrowlSoundVolume, ( rand.nextFloat() - rand.nextFloat()) * 0.05F + 0.55F, 5D );
+	    		}
+    		}
+    		else
+    		{
+        		fCaveSoundChance = m_fMinimumGloomCaveSoundChance + ( m_fMaximumGloomCaveSoundChance - m_fMinimumGloomCaveSoundChance ) * fCounterProgress;        		
+        		fCaveSoundVolume = m_fMinimumGloomCaveSoundVolume + ( m_fMaximumGloomCaveSoundVolume - m_fMinimumGloomCaveSoundVolume ) * fCounterProgress;        		
+    		}
+    		
+    		if ( rand.nextFloat() < fCaveSoundChance )
+    		{
+                PlaySoundInRandomDirection( "ambient.cave.cave", fCaveSoundVolume, 0.5F + this.rand.nextFloat(), 5D );
+    		}    		
+    	}
+    }
+    
+    public void PlaySoundInRandomDirection( String sSoundName, float fVolume, float fPitch, double dDistance )
+    {
+    	double dXPos = posX;
+    	double dYPos = posY;
+    	double dZPos = posZ;
+    	
+    	double dRandomYaw = rand.nextDouble();
+    	
+        double dXOffset = (double)-MathHelper.sin( (float)( dRandomYaw * 360D  ) ) * dDistance; 
+        double dZOffset = (double)MathHelper.cos( (float)( dRandomYaw * 360D ) ) * dDistance;
+        
+        dXPos += dXOffset;
+        dZPos += dZOffset;
+        
+        worldObj.playSound( dXPos, dYPos, dZPos, sSoundName, fVolume, fPitch, false );
+    }
+    
+    @Override
+    public boolean IsLocalPlayerAndHittingBlock()
+    {
+    	return mc.playerController.IsHittingBlock();
+    }	
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityPortalFX.java b/minecraft/net/minecraft/src/EntityPortalFX.java
index 5eb0faf..d2a1d86 100644
--- a/minecraft/net/minecraft/src/EntityPortalFX.java
+++ b/minecraft/net/minecraft/src/EntityPortalFX.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
+
 public class EntityPortalFX extends EntityFX
 {
     private float portalParticleScale;
@@ -19,11 +21,12 @@ public class EntityPortalFX extends EntityFX
         float var14 = this.rand.nextFloat() * 0.6F + 0.4F;
         this.portalParticleScale = this.particleScale = this.rand.nextFloat() * 0.2F + 0.5F;
         this.particleRed = this.particleGreen = this.particleBlue = 1.0F * var14;
-        this.particleGreen *= 0.3F;
-        this.particleRed *= 0.9F;
+        this.particleGreen *= ColorizeEntity.portalColor[1];
+        this.particleRed *= ColorizeEntity.portalColor[0];
         this.particleMaxAge = (int)(Math.random() * 10.0D) + 40;
         this.noClip = true;
         this.setParticleTextureIndex((int)(Math.random() * 8.0D));
+        this.particleBlue = ColorizeEntity.portalColor[2];
     }
 
     public void renderParticle(Tessellator par1Tessellator, float par2, float par3, float par4, float par5, float par6, float par7)
diff --git a/minecraft/net/minecraft/src/EntityRainFX.java b/minecraft/net/minecraft/src/EntityRainFX.java
index 44cd285..3dcebba 100644
--- a/minecraft/net/minecraft/src/EntityRainFX.java
+++ b/minecraft/net/minecraft/src/EntityRainFX.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntityRainFX extends EntityFX
 {
     public EntityRainFX(World par1World, double par2, double par4, double par6)
@@ -8,9 +11,20 @@ public class EntityRainFX extends EntityFX
         this.motionX *= 0.30000001192092896D;
         this.motionY = (double)((float)Math.random() * 0.2F + 0.1F);
         this.motionZ *= 0.30000001192092896D;
-        this.particleRed = 1.0F;
-        this.particleGreen = 1.0F;
-        this.particleBlue = 1.0F;
+        
+        if (ColorizeBlock.computeWaterColor(false, (int)this.posX, (int)this.posY, (int)this.posZ))
+        {
+            this.particleRed = Colorizer.setColor[0];
+            this.particleGreen = Colorizer.setColor[1];
+            this.particleBlue = Colorizer.setColor[2];
+        }
+        else
+        {
+            this.particleRed = 0.2F;
+            this.particleGreen = 0.3F;
+            this.particleBlue = 1.0F;
+        }
+        
         this.setParticleTextureIndex(19 + this.rand.nextInt(4));
         this.setSize(0.01F, 0.01F);
         this.particleGravity = 0.06F;
diff --git a/minecraft/net/minecraft/src/EntityReddustFX.java b/minecraft/net/minecraft/src/EntityReddustFX.java
index 5b470e3..541e6f8 100644
--- a/minecraft/net/minecraft/src/EntityReddustFX.java
+++ b/minecraft/net/minecraft/src/EntityReddustFX.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntityReddustFX extends EntityFX
 {
     float reddustParticleScale;
@@ -19,6 +22,13 @@ public class EntityReddustFX extends EntityFX
         if (par9 == 0.0F)
         {
             par9 = 1.0F;
+            
+            if (ColorizeBlock.computeRedstoneWireColor(15))
+            {
+                par9 = Colorizer.setColor[0];
+                par10 = Colorizer.setColor[1];
+                par11 = Colorizer.setColor[2];
+            }
         }
 
         float var12 = (float)Math.random() * 0.4F + 0.6F;
diff --git a/minecraft/net/minecraft/src/EntityRenderer.java b/minecraft/net/minecraft/src/EntityRenderer.java
index 3ae09a8..2bc8fc8 100644
--- a/minecraft/net/minecraft/src/EntityRenderer.java
+++ b/minecraft/net/minecraft/src/EntityRenderer.java
@@ -1,5 +1,10 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.cc.Colorizer;
+import com.prupe.mcpatcher.cc.Lightmap;
+import com.prupe.mcpatcher.renderpass.RenderPass;
+
 import java.awt.image.BufferedImage;
 import java.nio.FloatBuffer;
 import java.util.List;
@@ -88,8 +93,15 @@ public class EntityRenderer
 
     /** FOV multiplier temp */
     private float fovMultiplierTemp;
+    
+    // FCMOD: Changed (client only) the name of this variable for clarity
+    /*
     private float field_82831_U;
     private float field_82832_V;
+    */
+    private float fWitherEffectIntensity;
+    private float fPreviousWithEffectIntensity;
+    // END FCMOD
 
     /** Cloud fog mode */
     private boolean cloudFog = false;
@@ -109,7 +121,7 @@ public class EntityRenderer
     private boolean lightmapUpdateNeeded = false;
 
     /** Torch flicker X */
-    float torchFlickerX = 0.0F;
+    public float torchFlickerX = 0.0F;
 
     /** Torch flicker DX */
     float torchFlickerDX = 0.0F;
@@ -202,22 +214,23 @@ public class EntityRenderer
         ++this.rendererUpdateCount;
         this.itemRenderer.updateEquippedItem();
         this.addRainParticles();
-        this.field_82832_V = this.field_82831_U;
+        this.fPreviousWithEffectIntensity = this.fWitherEffectIntensity;
 
+        // FCNOTE: The follwing test is basically "if the wither is present"
         if (BossStatus.field_82825_d)
         {
-            this.field_82831_U += 0.05F;
+            this.fWitherEffectIntensity += 0.05F;
 
-            if (this.field_82831_U > 1.0F)
+            if (this.fWitherEffectIntensity > 1.0F)
             {
-                this.field_82831_U = 1.0F;
+                this.fWitherEffectIntensity = 1.0F;
             }
 
             BossStatus.field_82825_d = false;
         }
-        else if (this.field_82831_U > 0.0F)
+        else if (this.fWitherEffectIntensity > 0.0F)
         {
-            this.field_82831_U -= 0.0125F;
+            this.fWitherEffectIntensity -= 0.0125F;
         }
     }
 
@@ -232,14 +245,30 @@ public class EntityRenderer
             {
                 this.mc.pointedEntityLiving = null;
                 double var2 = (double)this.mc.playerController.getBlockReachDistance();
+                // FCMOD: Changed (client only) to limit snow ray-trace tests to this call
+                /*
                 this.mc.objectMouseOver = this.mc.renderViewEntity.rayTrace(var2, par1);
+                */
+                this.mc.objectMouseOver = this.mc.renderViewEntity.MouseOverCustomRayTrace(var2, par1);
+                // END FCMOD
+                
                 double var4 = var2;
                 Vec3 var6 = this.mc.renderViewEntity.getPosition(par1);
 
                 if (this.mc.playerController.extendedReach())
                 {
+                	// FCMOD: Changed (client only) to fix weird reach problems in 
+                	//creative mode between blocks and entities
+        			/*
                     var2 = 6.0D;
                     var4 = 6.0D;
+					*/
+		        	if ( var4 > 6D )
+		        	{
+		        		var4 = 6D;
+		        	}
+		        	var2 = var4;
+		        	// END FCMOD
                 }
                 else
                 {
@@ -735,7 +764,11 @@ public class EntityRenderer
     {
         WorldClient var2 = this.mc.theWorld;
 
-        if (var2 != null)
+        if (Lightmap.computeLightmap(this, var2, this.lightmapColors, par1))
+        {
+            this.mc.renderEngine.createTextureFromBytes(this.lightmapColors, 16, 16, this.lightmapTexture);
+        }
+        else if (var2 != null)
         {
             for (int var3 = 0; var3 < 256; ++var3)
             {
@@ -760,9 +793,9 @@ public class EntityRenderer
                 var15 = var15 * 0.96F + 0.03F;
                 float var16;
 
-                if (this.field_82831_U > 0.0F)
+                if (this.fWitherEffectIntensity > 0.0F)
                 {
-                    var16 = this.field_82832_V + (this.field_82831_U - this.field_82832_V) * par1;
+                    var16 = this.fPreviousWithEffectIntensity + (this.fWitherEffectIntensity - this.fPreviousWithEffectIntensity) * par1;
                     var13 = var13 * (1.0F - var16) + var13 * 0.7F * var16;
                     var14 = var14 * (1.0F - var16) + var14 * 0.6F * var16;
                     var15 = var15 * (1.0F - var16) + var15 * 0.6F * var16;
@@ -793,8 +826,12 @@ public class EntityRenderer
                     }
 
                     var13 = var13 * (1.0F - var16) + var13 * var17 * var16;
+                    // FCMOD: Removed (client only) to only modify red with night vision
+                    /*
                     var14 = var14 * (1.0F - var16) + var14 * var17 * var16;
                     var15 = var15 * (1.0F - var16) + var15 * var17 * var16;
+                    */
+                    // END FCMOD
                 }
 
                 if (var13 > 1.0F)
@@ -855,7 +892,7 @@ public class EntityRenderer
                 {
                     var15 = 0.0F;
                 }
-
+                
                 short var20 = 255;
                 int var21 = (int)(var13 * 255.0F);
                 int var22 = (int)(var14 * 255.0F);
@@ -873,6 +910,12 @@ public class EntityRenderer
     private float getNightVisionBrightness(EntityPlayer par1EntityPlayer, float par2)
     {
         int var3 = par1EntityPlayer.getActivePotionEffect(Potion.nightVision).getDuration();
+        // FCMOD: Added (client only) to prevent constant flashing with beacon version 
+        if ( par1EntityPlayer.getActivePotionEffect(Potion.nightVision).getIsAmbient() )
+        {
+        	var3 = 400;
+        }
+        // END FCMOD
         return var3 > 200 ? 1.0F : 0.7F + MathHelper.sin(((float)var3 - par2) * (float)Math.PI * 0.2F) * 0.3F;
     }
 
@@ -885,7 +928,12 @@ public class EntityRenderer
 
         if (this.lightmapUpdateNeeded)
         {
+        	// FCMOD: Changed (client only)
+        	/*
             this.updateLightmap(par1);
+            */
+        	ModUpdateLightmap(par1);
+        	// END FCMOD
         }
 
         this.mc.mcProfiler.endSection();
@@ -967,6 +1015,13 @@ public class EntityRenderer
                 {
                     this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var16, var17);
                 }
+                // FCMOD: Added (client only) to display stuff like ender spectacle effects 
+                // even if the GUI is turned off
+                else
+                {
+                	mc.ingameGUI.RenderGameOverlayWithGuiDisabled(par1, this.mc.currentScreen != null, var16, var17);
+                }
+                // END FCMOD
 
                 this.mc.mcProfiler.endSection();
             }
@@ -1013,7 +1068,12 @@ public class EntityRenderer
 
         if (this.lightmapUpdateNeeded)
         {
+        	// FCMOD: Changed (client only)
+        	/*
             this.updateLightmap(par1);
+            */
+        	ModUpdateLightmap(par1);
+        	// END FCMOD
         }
 
         GL11.glEnable(GL11.GL_CULL_FACE);
@@ -1071,7 +1131,7 @@ public class EntityRenderer
             GL11.glEnable(GL11.GL_FOG);
             this.setupFog(1, par1);
 
-            if (this.mc.gameSettings.ambientOcclusion != 0)
+            if (RenderPass.setAmbientOcclusion(this.mc.gameSettings.ambientOcclusion != 0))
             {
                 GL11.glShadeModel(GL11.GL_SMOOTH);
             }
@@ -1108,6 +1168,7 @@ public class EntityRenderer
             RenderHelper.disableStandardItemLighting();
             this.mc.mcProfiler.endStartSection("terrain");
             var5.sortAndRender(var4, 0, (double)par1);
+            var5.sortAndRender(var4, 4, (double)par1);
             GL11.glShadeModel(GL11.GL_FLAT);
             EntityPlayer var17;
 
@@ -1149,7 +1210,7 @@ public class EntityRenderer
             {
                 this.mc.mcProfiler.endStartSection("water");
 
-                if (this.mc.gameSettings.ambientOcclusion != 0)
+                if (RenderPass.setAmbientOcclusion(this.mc.gameSettings.ambientOcclusion != 0))
                 {
                     GL11.glShadeModel(GL11.GL_SMOOTH);
                 }
@@ -1186,6 +1247,8 @@ public class EntityRenderer
                 var5.sortAndRender(var4, 1, (double)par1);
             }
 
+            var5.sortAndRender(var4, 5, (double)par1);
+            this.renderRainSnow(par1);
             GL11.glDepthMask(true);
             GL11.glEnable(GL11.GL_CULL_FACE);
             GL11.glDisable(GL11.GL_BLEND);
@@ -1254,6 +1317,11 @@ public class EntityRenderer
     private void addRainParticles()
     {
         float var1 = this.mc.theWorld.getRainStrength(1.0F);
+        
+        // FCMOD: Added (client only) to reduce rain particles when it's not stormy
+        var1 *= 0.1F;
+        var1 += mc.theWorld.thunderingStrength * 0.9F;
+        // END FCMOD
 
         if (!this.mc.gameSettings.fancyGraphics)
         {
@@ -1292,7 +1360,11 @@ public class EntityRenderer
                 int var20 = var3.getBlockId(var17, var19 - 1, var18);
                 BiomeGenBase var21 = var3.getBiomeGenForCoords(var17, var18);
 
-                if (var19 <= var5 + var7 && var19 >= var5 - var7 && var21.canSpawnLightningBolt() && var21.getFloatTemperature() >= 0.2F)
+                // FCMOD: Changed (client only) for clarity
+                //if (var19 <= var5 + var7 && var19 >= var5 - var7 && var21.canSpawnLightningBolt() && var21.getFloatTemperature() >= 0.2F)
+                if ( var19 <= var5 + var7 && var19 >= var5 - var7 && 
+                	var21.CanRainInBiome() && var21.getFloatTemperature() >= 0.2F )
+            	// END FCMOD
                 {
                     float var22 = this.random.nextFloat();
                     float var23 = this.random.nextFloat();
@@ -1326,11 +1398,21 @@ public class EntityRenderer
 
                 if (var10 > var2.posY + 1.0D && var3.getPrecipitationHeight(MathHelper.floor_double(var2.posX), MathHelper.floor_double(var2.posZ)) > MathHelper.floor_double(var2.posY))
                 {
+                	// FCMOD: Changed (client only) to make intensity of sound dependent on storm strength
+                	/*
                     this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.1F, 0.5F, false);
+                    */
+                    this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.1F * var1, 0.5F, false);
+                    // END FCMOD
                 }
                 else
                 {
+                	// FCMOD: Changed (client only) to make intensity of sound dependent on storm strength
+                	/*
                     this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.2F, 1.0F, false);
+                    */
+                    this.mc.theWorld.playSound(var8, var10, var12, "ambient.weather.rain", 0.2F * var1, 1.0F, false);
+                    // END FCMOD
                 }
             }
         }
@@ -1342,6 +1424,10 @@ public class EntityRenderer
     protected void renderRainSnow(float par1)
     {
         float var2 = this.mc.theWorld.getRainStrength(par1);
+        // FCMOD: Added (client only) to reduce rain particles when it's not stormy
+        var2 *= 0.5F;
+        var2 += mc.theWorld.thunderingStrength * 0.5F;
+        // END FCMOD
 
         if (var2 > 0.0F)
         {
@@ -1409,7 +1495,10 @@ public class EntityRenderer
                     float var24 = this.rainYCoords[var22] * 0.5F;
                     BiomeGenBase var25 = var42.getBiomeGenForCoords(var21, var20);
 
-                    if (var25.canSpawnLightningBolt() || var25.getEnableSnow())
+                    // FCMOD: Changed (client only) for clarity
+                    //if (var25.canSpawnLightningBolt() || var25.getEnableSnow())
+                    if ( var25.CanRainInBiome() || var25.getEnableSnow() )
+                	// END FCMOD
                     {
                         int var26 = var42.getPrecipitationHeight(var21, var20);
                         int var27 = var44 - var16;
@@ -1437,8 +1526,8 @@ public class EntityRenderer
                         {
                             this.random.setSeed((long)(var21 * var21 * 3121 + var21 * 45238971 ^ var20 * var20 * 418711 + var20 * 13761));
                             float var31 = var25.getFloatTemperature();
-                            float var32;
                             double var35;
+                            float var32;
 
                             if (var42.getWorldChunkManager().getTemperatureAtHeight(var31, var26) >= 0.15F)
                             {
@@ -1612,12 +1701,26 @@ public class EntityRenderer
             this.fogColorRed = 0.02F;
             this.fogColorGreen = 0.02F;
             this.fogColorBlue = 0.2F;
+            
+            if (ColorizeWorld.computeUnderwaterColor())
+            {
+                this.fogColorRed = Colorizer.setColor[0];
+                this.fogColorGreen = Colorizer.setColor[1];
+                this.fogColorBlue = Colorizer.setColor[2];
+            }
         }
         else if (var21 != 0 && Block.blocksList[var21].blockMaterial == Material.lava)
         {
             this.fogColorRed = 0.6F;
             this.fogColorGreen = 0.1F;
             this.fogColorBlue = 0.0F;
+            
+            if (ColorizeWorld.computeUnderlavaColor())
+            {
+                this.fogColorRed = Colorizer.setColor[0];
+                this.fogColorGreen = Colorizer.setColor[1];
+                this.fogColorBlue = Colorizer.setColor[2];
+            }
         }
 
         float var22 = this.fogColor2 + (this.fogColor1 - this.fogColor2) * par1;
@@ -1639,6 +1742,12 @@ public class EntityRenderer
                 var14 = 0.0D;
             }
         }
+        // FCMOD: Added (client only)
+        else if ( mc.gameSettings.thirdPersonView == 0 && var3.HasHeadCrabbedSquid() )
+        {
+        	var14 = 0.2D;
+        }
+        // END FCMOD
 
         if (var14 < 1.0D)
         {
@@ -1655,9 +1764,9 @@ public class EntityRenderer
 
         float var23;
 
-        if (this.field_82831_U > 0.0F)
+        if (this.fWitherEffectIntensity > 0.0F)
         {
-            var23 = this.field_82832_V + (this.field_82831_U - this.field_82832_V) * par1;
+            var23 = this.fPreviousWithEffectIntensity + (this.fWitherEffectIntensity - this.fPreviousWithEffectIntensity) * par1;
             this.fogColorRed = this.fogColorRed * (1.0F - var23) + this.fogColorRed * 0.7F * var23;
             this.fogColorGreen = this.fogColorGreen * (1.0F - var23) + this.fogColorGreen * 0.6F * var23;
             this.fogColorBlue = this.fogColorBlue * (1.0F - var23) + this.fogColorBlue * 0.6F * var23;
@@ -1681,8 +1790,12 @@ public class EntityRenderer
             }
 
             this.fogColorRed = this.fogColorRed * (1.0F - var23) + this.fogColorRed * var17 * var23;
+            // FCMOD: Removed (client only) to only affect red with night vision
+            /*
             this.fogColorGreen = this.fogColorGreen * (1.0F - var23) + this.fogColorGreen * var17 * var23;
             this.fogColorBlue = this.fogColorBlue * (1.0F - var23) + this.fogColorBlue * var17 * var23;
+            */
+            // END FCMOD
         }
 
         if (this.mc.gameSettings.anaglyph)
@@ -1762,6 +1875,30 @@ public class EntityRenderer
                     GL11.glFogi(34138, 34139);
                 }
             }
+            // FCMOD: Added (client only)
+            else if ( mc.gameSettings.thirdPersonView == 0 && var3.HasHeadCrabbedSquid() )
+            {
+                var6 = 0.45F;
+
+                GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
+
+                if (par1 < 0)
+                {
+                    GL11.glFogf(GL11.GL_FOG_START, 0.0F);
+                    GL11.glFogf(GL11.GL_FOG_END, var6 * 0.8F);
+                }
+                else
+                {
+                    GL11.glFogf(GL11.GL_FOG_START, 0.0F);
+                    GL11.glFogf(GL11.GL_FOG_END, var6);
+                }
+
+                if (GLContext.getCapabilities().GL_NV_fog_distance)
+                {
+                    GL11.glFogi(34138, 34139);
+                }
+            }
+            // END FCMOD            
             else
             {
                 float var8;
@@ -1923,4 +2060,223 @@ public class EntityRenderer
     {
         return par0EntityRenderer.mc;
     }
+    
+    // FCMOD: Added (client only)
+    private static final float m_fMaximumSunBrightnessDelta = 0.001F;
+    
+    private float m_fPreviousSunBrightness = -1F;
+    
+    private void ModUpdateLightmap( float fPartialTicks )
+    {
+        WorldClient world = mc.theWorld;
+        
+        if ( world != null )
+        {
+            if ( world.provider.dimensionId == 0 )
+            {
+            	// isolating the overworld for gloom effects
+            	
+            	ModUpdateLightmapOverworld( world, fPartialTicks );
+            	
+            	return;
+            }
+            else
+            {
+                m_fPreviousSunBrightness = -1F;
+                
+            	updateLightmap( fPartialTicks );
+            }
+        }
+    }
+    
+	private void ModUpdateLightmapOverworld( WorldClient world, float fPartialTicks )
+	{
+    	// copy of updateLightmap() to modify for moon phases and to refactor it to make it easier to understand and work with.
+
+    	float fCurrentSunBrightness = world.ComputeOverworldSunBrightnessWithMoonPhases();
+    	
+    	if ( m_fPreviousSunBrightness > -0.01F )
+    	{
+    		if ( Math.abs( fCurrentSunBrightness - m_fPreviousSunBrightness ) > m_fMaximumSunBrightnessDelta )
+    		{
+    			if ( fCurrentSunBrightness > m_fPreviousSunBrightness )
+    			{
+    				fCurrentSunBrightness = m_fPreviousSunBrightness + m_fMaximumSunBrightnessDelta;
+    			}
+    			else
+    			{
+    				fCurrentSunBrightness = m_fPreviousSunBrightness - m_fMaximumSunBrightnessDelta;
+    			}	
+    		}
+    	}
+    	
+    	m_fPreviousSunBrightness = fCurrentSunBrightness;
+    	
+        float fModifiedSunBrightness = fCurrentSunBrightness;
+        
+        boolean bPlayerHasNightVision = mc.thePlayer.isPotionActive( Potion.nightVision );
+    	
+        for ( int iTempMapIndex = 0; iTempMapIndex < 256; ++iTempMapIndex )
+        {
+            float fRedIntensity;
+            float fGreenIntensity;
+            float fBlueIntensity;
+
+            float fTorchBrightnessForIndex = world.provider.lightBrightnessTable[iTempMapIndex % 16] * ( torchFlickerX * 0.1F + 1.5F );
+            
+            float fGreenTorchBrightness = fTorchBrightnessForIndex * ( ( fTorchBrightnessForIndex * 0.6F + 0.4F ) * 0.6F + 0.4F );
+            float fBlueTorchBrightness = fTorchBrightnessForIndex * ( fTorchBrightnessForIndex * fTorchBrightnessForIndex * 0.6F + 0.4F );
+
+            float fSunBrightnessForIndex = world.provider.lightBrightnessTable[iTempMapIndex / 16] * fModifiedSunBrightness;
+            
+            if ( world.lastLightningBolt > 0 )
+            {
+                fSunBrightnessForIndex = world.provider.lightBrightnessTable[iTempMapIndex / 16];
+            }
+
+            float fRedSunBrightness = fSunBrightnessForIndex * ( fCurrentSunBrightness * 0.65F + 0.35F );
+            float fGreenSunBrightness = fRedSunBrightness;                
+            
+            fRedIntensity = fRedSunBrightness + fTorchBrightnessForIndex;
+            fGreenIntensity = fGreenSunBrightness + fGreenTorchBrightness;
+            fBlueIntensity = fSunBrightnessForIndex + fBlueTorchBrightness;
+            
+            if ( fWitherEffectIntensity > 0.0F )
+            {
+            	// this all seems to be related to darkening the sky around the wither.  The above test is true if the player is near, or has recently been near, 
+            	// the wither, with what appears to be a fade-in/out transition on the effect
+
+                float fCurrentWitherEffectIntensity = fPreviousWithEffectIntensity + ( fWitherEffectIntensity - fPreviousWithEffectIntensity ) * fPartialTicks;
+                
+                fRedIntensity = fRedIntensity * (1.0F - fCurrentWitherEffectIntensity) + fRedIntensity * 0.7F * fCurrentWitherEffectIntensity;
+                fGreenIntensity = fGreenIntensity * (1.0F - fCurrentWitherEffectIntensity) + fGreenIntensity * 0.6F * fCurrentWitherEffectIntensity;
+                fBlueIntensity = fBlueIntensity * (1.0F - fCurrentWitherEffectIntensity) + fBlueIntensity * 0.6F * fCurrentWitherEffectIntensity;
+            }
+            
+            float fMinimumBrightness = fSunBrightnessForIndex + fTorchBrightnessForIndex;
+            
+            fMinimumBrightness *= fMinimumBrightness;
+            
+            if ( fMinimumBrightness > 0.03F )
+            {
+            	fMinimumBrightness = 0.03F;
+            }
+
+            if ( bPlayerHasNightVision )
+            {
+            	fRedIntensity = fRedIntensity * 0.96F + 0.03F;
+            	
+            	// Note: this portion has been modified from stock to only modify red with night vision
+                float fNightVisionBrightness = getNightVisionBrightness( mc.thePlayer, fPartialTicks );
+                
+                float var17 = 1.0F / fRedIntensity;
+
+                if (var17 > 1.0F / fGreenIntensity)
+                {
+                    var17 = 1.0F / fGreenIntensity;
+                }
+
+                if (var17 > 1.0F / fBlueIntensity)
+                {
+                    var17 = 1.0F / fBlueIntensity;
+                }
+
+                fRedIntensity = fRedIntensity * (1.0F - fNightVisionBrightness) + fRedIntensity * var17 * fNightVisionBrightness;
+            }
+
+            float fMinimumBrightnessMultiplier = 1F - fMinimumBrightness;
+            
+        	fRedIntensity = fRedIntensity * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fGreenIntensity = fGreenIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fBlueIntensity = fBlueIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;            
+
+            if (fRedIntensity > 1.0F)
+            {
+                fRedIntensity = 1.0F;
+            }
+
+            if (fGreenIntensity > 1.0F)
+            {
+                fGreenIntensity = 1.0F;
+            }
+
+            if (fBlueIntensity > 1.0F)
+            {
+                fBlueIntensity = 1.0F;
+            }
+
+            float fGammaSetting = mc.gameSettings.gammaSetting;
+            
+            float fRedModifier = 1.0F - fRedIntensity;
+            float fGreenModifier = 1.0F - fGreenIntensity;
+            float fBlueModifier = 1.0F - fBlueIntensity;
+            
+            fRedModifier = 1.0F - fRedModifier * fRedModifier * fRedModifier * fRedModifier;
+            fGreenModifier = 1.0F - fGreenModifier * fGreenModifier * fGreenModifier * fGreenModifier;
+            fBlueModifier = 1.0F - fBlueModifier * fBlueModifier * fBlueModifier * fBlueModifier;
+            
+            fRedIntensity = fRedIntensity * (1.0F - fGammaSetting) + fRedModifier * fGammaSetting;
+            fGreenIntensity = fGreenIntensity * (1.0F - fGammaSetting) + fGreenModifier * fGammaSetting;
+            fBlueIntensity = fBlueIntensity * (1.0F - fGammaSetting) + fBlueModifier * fGammaSetting;
+            
+        	//fRedIntensity = fRedIntensity * 0.96F + 0.03F;
+        	//fGreenIntensity = fGreenIntensity * 0.96F + 0.03F;
+        	//fBlueIntensity = fBlueIntensity * 0.96F + 0.03F;
+
+        	fRedIntensity = fRedIntensity * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fGreenIntensity = fGreenIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;
+        	fBlueIntensity = fBlueIntensity  * fMinimumBrightnessMultiplier + fMinimumBrightness;            
+        	
+            if (fRedIntensity > 1.0F)
+            {
+                fRedIntensity = 1.0F;
+            }
+
+            if (fGreenIntensity > 1.0F)
+            {
+                fGreenIntensity = 1.0F;
+            }
+
+            if (fBlueIntensity > 1.0F)
+            {
+                fBlueIntensity = 1.0F;
+            }
+
+            if (fRedIntensity < 0.0F)
+            {
+                fRedIntensity = 0.0F;
+            }
+
+            if (fGreenIntensity < 0.0F)
+            {
+                fGreenIntensity = 0.0F;
+            }
+
+            if (fBlueIntensity < 0.0F)
+            {
+                fBlueIntensity = 0.0F;
+            }
+            
+            short sFinalAlpha = 255;
+            
+            int iFinalRed = (int)(fRedIntensity * 255.0F);
+            int iFinalGreen = (int)(fGreenIntensity * 255.0F);
+            int iFinalBlue = (int)(fBlueIntensity * 255.0F);
+            
+            lightmapColors[iTempMapIndex] = sFinalAlpha << 24 | iFinalRed << 16 | iFinalGreen << 8 | iFinalBlue;
+        }
+
+        mc.renderEngine.createTextureFromBytes( lightmapColors, 16, 16, lightmapTexture );
+	}
+	
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }    
+    // END FCMOD
+    
+    public float getNightVisionStrength(float var1)
+    {
+        return this.mc.thePlayer.isPotionActive(Potion.nightVision) ? this.getNightVisionBrightness(this.mc.thePlayer, var1) : 0.0F;
+    }
 }
diff --git a/minecraft/net/minecraft/src/EntitySheep.java b/minecraft/net/minecraft/src/EntitySheep.java
index 2d2bfd4..7bfdce0 100644
--- a/minecraft/net/minecraft/src/EntitySheep.java
+++ b/minecraft/net/minecraft/src/EntitySheep.java
@@ -1,5 +1,9 @@
+// FCMOD: Class changes deprecated 07/23/2018
+
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
 import java.util.Random;
 
 public class EntitySheep extends EntityAnimal
@@ -96,7 +100,7 @@ public class EntitySheep extends EntityAnimal
      */
     protected int getDropItemId()
     {
-        return Block.cloth.blockID;
+    	return Block.cloth.blockID;
     }
 
     public void handleHealthUpdate(byte par1)
diff --git a/minecraft/net/minecraft/src/EntitySilverfish.java b/minecraft/net/minecraft/src/EntitySilverfish.java
index c2c10b0..a46e4e1 100644
--- a/minecraft/net/minecraft/src/EntitySilverfish.java
+++ b/minecraft/net/minecraft/src/EntitySilverfish.java
@@ -177,7 +177,16 @@ public class EntitySilverfish extends EntityMob
 
                 if (BlockSilverfish.getPosingIdByMetadata(var5))
                 {
+                	// FCMOD: Code change
+                	/*
                     this.worldObj.setBlock(var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9], Block.silverfish.blockID, BlockSilverfish.getMetadataForBlockType(var5), 3);
+                    */
+                	int iNewBlockMetadata = FCBlockSilverfish.GetMetadataConversionOnInfest( var5, 
+                		worldObj.getBlockMetadata( var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9] ) );
+                	
+                    worldObj.setBlock(var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9], 
+                    	Block.silverfish.blockID, iNewBlockMetadata, 3);
+                	// END FCMOD
                     this.spawnExplosionParticle();
                     this.setDead();
                 }
@@ -241,4 +250,34 @@ public class EntitySilverfish extends EntityMob
     {
         return EnumCreatureAttribute.ARTHROPOD;
     }
+    
+    // FCMOD: Code added
+    @Override
+    protected void dropFewItems( boolean bKilledByPlayer, int iLootingModifier )
+    {
+    	if ( worldObj.provider.dimensionId == 1 )
+    	{
+	        int iDropChance = this.rand.nextInt( 5 ) - 3 + iLootingModifier;
+	
+	        if ( iDropChance > 0 )
+	        {
+	            dropItem( Item.clay.itemID, 1 );
+	        }
+    	}
+    }
+    
+    @Override
+    public void CheckForScrollDrop()
+    {    	
+    	if ( worldObj.provider.dimensionId == 1 )
+    	{
+	    	if ( rand.nextInt( 1000 ) == 0 )
+	    	{
+	    		ItemStack itemstack = new ItemStack( FCBetterThanWolves.fcItemArcaneScroll, 1, Enchantment.efficiency.effectId );
+	            
+	            entityDropItem(itemstack, 0.0F);
+	    	}
+    	}
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntitySkeleton.java b/minecraft/net/minecraft/src/EntitySkeleton.java
index f38b81f..d594612 100644
--- a/minecraft/net/minecraft/src/EntitySkeleton.java
+++ b/minecraft/net/minecraft/src/EntitySkeleton.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/26/2018
+
 package net.minecraft.src;
 
 import java.util.Calendar;
diff --git a/minecraft/net/minecraft/src/EntitySlime.java b/minecraft/net/minecraft/src/EntitySlime.java
index f061439..cd2f7d4 100644
--- a/minecraft/net/minecraft/src/EntitySlime.java
+++ b/minecraft/net/minecraft/src/EntitySlime.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/24/2018
+
 package net.minecraft.src;
 
 public class EntitySlime extends EntityLiving implements IMob
@@ -18,7 +20,7 @@ public class EntitySlime extends EntityLiving implements IMob
         int var2 = 1 << this.rand.nextInt(3);
         this.yOffset = 0.0F;
         this.slimeJumpDelay = this.rand.nextInt(20) + 10;
-        this.setSlimeSize(var2);
+        this.setSlimeSize(var2);        
     }
 
     protected void entityInit()
@@ -147,7 +149,7 @@ public class EntitySlime extends EntityLiving implements IMob
         if (this.onGround && this.slimeJumpDelay-- <= 0)
         {
             this.slimeJumpDelay = this.getJumpDelay();
-
+            
             if (var1 != null)
             {
                 this.slimeJumpDelay /= 3;
@@ -205,8 +207,8 @@ public class EntitySlime extends EntityLiving implements IMob
 
             for (int var3 = 0; var3 < var2; ++var3)
             {
-                float var4 = ((float)(var3 % 2) - 0.5F) * (float)var1 / 4.0F;
-                float var5 = ((float)(var3 / 2) - 0.5F) * (float)var1 / 4.0F;
+                float var4 = ((float)(var3 % 2) - 0.5F) * (float)var1 / 40.0F;
+                float var5 = ((float)(var3 / 2) - 0.5F) * (float)var1 / 40.0F;
                 EntitySlime var6 = this.createInstance();
                 var6.setSlimeSize(var1 / 2);
                 var6.setLocationAndAngles(this.posX + (double)var4, this.posY + 0.5D, this.posZ + (double)var5, this.rand.nextFloat() * 360.0F, 0.0F);
diff --git a/minecraft/net/minecraft/src/EntitySnowman.java b/minecraft/net/minecraft/src/EntitySnowman.java
index b077510..aa5465b 100644
--- a/minecraft/net/minecraft/src/EntitySnowman.java
+++ b/minecraft/net/minecraft/src/EntitySnowman.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 12/27/2018
+
 package net.minecraft.src;
 
 public class EntitySnowman extends EntityGolem implements IRangedAttackMob
diff --git a/minecraft/net/minecraft/src/EntitySpider.java b/minecraft/net/minecraft/src/EntitySpider.java
index 194b7d3..c8b5d96 100644
--- a/minecraft/net/minecraft/src/EntitySpider.java
+++ b/minecraft/net/minecraft/src/EntitySpider.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntitySpider extends EntityMob
@@ -223,5 +225,5 @@ public class EntitySpider extends EntityMob
             this.worldObj.spawnEntityInWorld(var1);
             var1.mountEntity(this);
         }
-    }
+    }    
 }
diff --git a/minecraft/net/minecraft/src/EntitySplashFX.java b/minecraft/net/minecraft/src/EntitySplashFX.java
index 3fddb67..a8ed7bb 100644
--- a/minecraft/net/minecraft/src/EntitySplashFX.java
+++ b/minecraft/net/minecraft/src/EntitySplashFX.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntitySplashFX extends EntityRainFX
 {
     public EntitySplashFX(World par1World, double par2, double par4, double par6, double par8, double par10, double par12)
@@ -14,5 +17,12 @@ public class EntitySplashFX extends EntityRainFX
             this.motionY = par10 + 0.1D;
             this.motionZ = par12;
         }
+        
+        if (ColorizeBlock.computeWaterColor(false, (int)this.posX, (int)this.posY, (int)this.posZ))
+        {
+            this.particleRed = Colorizer.setColor[0];
+            this.particleGreen = Colorizer.setColor[1];
+            this.particleBlue = Colorizer.setColor[2];
+        }
     }
 }
diff --git a/minecraft/net/minecraft/src/EntitySquid.java b/minecraft/net/minecraft/src/EntitySquid.java
index 8bf2c2b..5bbd82b 100644
--- a/minecraft/net/minecraft/src/EntitySquid.java
+++ b/minecraft/net/minecraft/src/EntitySquid.java
@@ -5,7 +5,7 @@ public class EntitySquid extends EntityWaterMob
     public float squidPitch = 0.0F;
     public float prevSquidPitch = 0.0F;
     public float squidYaw = 0.0F;
-    public float prevSquidYaw = 0.0F;
+    public float prevSquidYaw = 0.0F;    
     public float field_70867_h = 0.0F;
     public float field_70868_i = 0.0F;
 
@@ -13,7 +13,7 @@ public class EntitySquid extends EntityWaterMob
     public float tentacleAngle = 0.0F;
 
     /** the last calculated angle of the tentacles in radians */
-    public float prevTentacleAngle = 0.0F;
+    public float prevTentacleAngle = 0.0F;    
     private float randomMotionSpeed = 0.0F;
     private float field_70864_bA = 0.0F;
     private float field_70871_bB = 0.0F;
@@ -109,7 +109,7 @@ public class EntitySquid extends EntityWaterMob
         this.field_70868_i = this.field_70867_h;
         this.prevTentacleAngle = this.tentacleAngle;
         this.field_70867_h += this.field_70864_bA;
-
+        
         if (this.field_70867_h > ((float)Math.PI * 2F))
         {
             this.field_70867_h -= ((float)Math.PI * 2F);
@@ -119,7 +119,7 @@ public class EntitySquid extends EntityWaterMob
                 this.field_70864_bA = 1.0F / (this.rand.nextFloat() + 1.0F) * 0.2F;
             }
         }
-
+        
         if (this.isInWater())
         {
             float var1;
@@ -157,7 +157,7 @@ public class EntitySquid extends EntityWaterMob
             this.renderYawOffset += (-((float)Math.atan2(this.motionX, this.motionZ)) * 180.0F / (float)Math.PI - this.renderYawOffset) * 0.1F;
             this.rotationYaw = this.renderYawOffset;
             this.squidYaw += (float)Math.PI * this.field_70871_bB * 1.5F;
-            this.squidPitch += (-((float)Math.atan2((double)var1, this.motionY)) * 180.0F / (float)Math.PI - this.squidPitch) * 0.1F;
+            this.squidPitch += (-((float)Math.atan2((double)var1, this.motionY)) * 180.0F / (float)Math.PI - this.squidPitch) * 0.1F;            
         }
         else
         {
diff --git a/minecraft/net/minecraft/src/EntitySuspendFX.java b/minecraft/net/minecraft/src/EntitySuspendFX.java
index 912235d..3bfaaa6 100644
--- a/minecraft/net/minecraft/src/EntitySuspendFX.java
+++ b/minecraft/net/minecraft/src/EntitySuspendFX.java
@@ -1,13 +1,17 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public class EntitySuspendFX extends EntityFX
 {
     public EntitySuspendFX(World par1World, double par2, double par4, double par6, double par8, double par10, double par12)
     {
         super(par1World, par2, par4 - 0.125D, par6, par8, par10, par12);
-        this.particleRed = 0.4F;
-        this.particleGreen = 0.4F;
-        this.particleBlue = 0.7F;
+        ColorizeEntity.computeSuspendColor(6710962, (int)par2, (int)par4, (int)par6);
+        this.particleRed = Colorizer.setColor[0];
+        this.particleGreen = Colorizer.setColor[1];
+        this.particleBlue = Colorizer.setColor[2];
         this.setParticleTextureIndex(0);
         this.setSize(0.01F, 0.01F);
         this.particleScale *= this.rand.nextFloat() * 0.6F + 0.2F;
diff --git a/minecraft/net/minecraft/src/EntityTameable.java b/minecraft/net/minecraft/src/EntityTameable.java
index ea084ed..c56b5a7 100644
--- a/minecraft/net/minecraft/src/EntityTameable.java
+++ b/minecraft/net/minecraft/src/EntityTameable.java
@@ -147,4 +147,17 @@ public abstract class EntityTameable extends EntityAnimal
     {
         return this.aiSit;
     }
+
+    // FCMOD: Code Added
+    @Override
+    public boolean IsSecondaryTargetForSquid()
+    {
+    	return false;
+    }
+    
+    public boolean IsAITryingToSit()
+    {
+    	return aiSit.IsTryingToSit();
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityThrowable.java b/minecraft/net/minecraft/src/EntityThrowable.java
index 946beaf..abf547e 100644
--- a/minecraft/net/minecraft/src/EntityThrowable.java
+++ b/minecraft/net/minecraft/src/EntityThrowable.java
@@ -161,7 +161,12 @@ public abstract class EntityThrowable extends Entity implements IProjectile
 
         Vec3 var16 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
         Vec3 var2 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
+        // FCMOD: Code change to ignore transparent type blocks like tall grass
+        /*
         MovingObjectPosition var3 = this.worldObj.rayTraceBlocks(var16, var2);
+        */
+        MovingObjectPosition var3 = this.worldObj.rayTraceBlocks_do_do(var16, var2, false, true);
+        // END FCMOD
         var16 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
         var2 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
 
@@ -333,4 +338,11 @@ public abstract class EntityThrowable extends Entity implements IProjectile
 
         return this.thrower;
     }
+    
+    // FCMOD: Code added
+    protected void SetThrower( EntityLiving throwerParam )
+    {
+    	thrower = throwerParam;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityTracker.java b/minecraft/net/minecraft/src/EntityTracker.java
index 92621e5..e4a9fc1 100644
--- a/minecraft/net/minecraft/src/EntityTracker.java
+++ b/minecraft/net/minecraft/src/EntityTracker.java
@@ -44,6 +44,17 @@ public class EntityTracker
                 }
             }
         }
+        // FCMOD: Code added
+        else if ( par1Entity instanceof FCIEntityPacketHandler )
+        {
+        	FCIEntityPacketHandler fcEntity = (FCIEntityPacketHandler)par1Entity;
+        	
+        	// client
+            addEntityToTracker( par1Entity, fcEntity.GetTrackerViewDistance(), fcEntity.GetTrackerUpdateFrequency(), fcEntity.GetTrackMotion() );
+            // server
+            //trackEntity( par1Entity, fcEntity.GetTrackerViewDistance(), fcEntity.GetTrackerUpdateFrequency(), fcEntity.GetTrackMotion() );
+        }
+        // END FCMOD
         else if (par1Entity instanceof EntityFishHook)
         {
             this.addEntityToTracker(par1Entity, 64, 5, true);
@@ -100,15 +111,24 @@ public class EntityTracker
         {
             this.addEntityToTracker(par1Entity, 80, 3, true);
         }
-        else if (par1Entity instanceof EntitySquid)
+        // FCMOD: Changed
+        //else if (par1Entity instanceof EntitySquid)
+        else if ( par1Entity instanceof FCEntitySquid )
+    	// END FCMOD
         {
             this.addEntityToTracker(par1Entity, 64, 3, true);
         }
-        else if (par1Entity instanceof EntityWither)
+        // FCMOD: Changed
+        //else if (par1Entity instanceof EntityWither)
+        else if ( par1Entity instanceof FCEntityWither )
+    	// END FCMOD
         {
             this.addEntityToTracker(par1Entity, 80, 3, false);
         }
-        else if (par1Entity instanceof EntityBat)
+        // FCMOD: Changed
+        //else if (par1Entity instanceof EntityBat)
+        else if ( par1Entity instanceof FCEntityBat )
+    	// END FCMOD
         {
             this.addEntityToTracker(par1Entity, 80, 3, false);
         }
diff --git a/minecraft/net/minecraft/src/EntityTrackerEntry.java b/minecraft/net/minecraft/src/EntityTrackerEntry.java
index bb4b5eb..f964ea6 100644
--- a/minecraft/net/minecraft/src/EntityTrackerEntry.java
+++ b/minecraft/net/minecraft/src/EntityTrackerEntry.java
@@ -99,7 +99,12 @@ public class EntityTrackerEntry
             if (var24 != null && var24.getItem() instanceof ItemMap)
             {
                 MapData var26 = Item.map.getMapData(var24, this.myEntity.worldObj);
+                // FCMOD: Code change to send map data to all visible players rather than tracked ones
+                /*
                 Iterator var29 = par1List.iterator();
+                */
+                Iterator var29 = trackingPlayers.iterator();
+                // END FCMOD
 
                 while (var29.hasNext())
                 {
@@ -109,21 +114,27 @@ public class EntityTrackerEntry
 
                     if (var31.playerNetServerHandler.packetSize() <= 5)
                     {
+                    	// FCMOD: Code added so that players only receive data on their own position
+                    	var26.func_82568_a( var30 );
+                    	// END FCMOD
                         Packet var32 = Item.map.createMapDataPacket(var24, this.myEntity.worldObj, var31);
 
                         if (var32 != null)
                         {
                             var31.playerNetServerHandler.sendPacketToPlayer(var32);
                         }
+                    	// FCMOD: Code added so that players only receive data on their own position
+                    	var26.playersVisibleOnMap.clear();
+                    	// END FCMOD
                     }
                 }
             }
 
-            DataWatcher var27 = this.myEntity.getDataWatcher();
+            DataWatcher var28 = this.myEntity.getDataWatcher();
 
-            if (var27.hasChanges())
+            if (var28.hasChanges())
             {
-                this.sendPacketToAllAssociatedPlayers(new Packet40EntityMetadata(this.myEntity.entityId, var27, false));
+                this.sendPacketToAllAssociatedPlayers(new Packet40EntityMetadata(this.myEntity.entityId, var28, false));
             }
         }
         else if (this.ticks % this.updateFrequency == 0 || this.myEntity.isAirBorne || this.myEntity.getDataWatcher().hasChanges())
@@ -230,11 +241,11 @@ public class EntityTrackerEntry
                 this.lastScaledXPosition = this.myEntity.myEntitySize.multiplyBy32AndRound(this.myEntity.posX);
                 this.lastScaledYPosition = MathHelper.floor_double(this.myEntity.posY * 32.0D);
                 this.lastScaledZPosition = this.myEntity.myEntitySize.multiplyBy32AndRound(this.myEntity.posZ);
-                DataWatcher var28 = this.myEntity.getDataWatcher();
+                DataWatcher var27 = this.myEntity.getDataWatcher();
 
-                if (var28.hasChanges())
+                if (var27.hasChanges())
                 {
-                    this.sendPacketToAllAssociatedPlayers(new Packet40EntityMetadata(this.myEntity.entityId, var28, false));
+                    this.sendPacketToAllAssociatedPlayers(new Packet40EntityMetadata(this.myEntity.entityId, var27, false));
                 }
 
                 this.ridingEntity = true;
@@ -319,8 +330,12 @@ public class EntityTrackerEntry
 
             if (var2 >= (double)(-this.blocksDistanceThreshold) && var2 <= (double)this.blocksDistanceThreshold && var4 >= (double)(-this.blocksDistanceThreshold) && var4 <= (double)this.blocksDistanceThreshold)
             {
-                if (!this.trackingPlayers.contains(par1EntityPlayerMP) && (this.isPlayerWatchingThisChunk(par1EntityPlayerMP) || this.myEntity.field_98038_p))
-                {
+            	// client
+            	if ((!this.trackingPlayers.contains(par1EntityPlayerMP) && (this.isPlayerWatchingThisChunk(par1EntityPlayerMP) || this.myEntity.field_98038_p))
+                        || (Math.abs(par1EntityPlayerMP.posX - this.myEntity.posX) > 120 || Math.abs(par1EntityPlayerMP.posZ - this.myEntity.posZ) > 120)) {
+            	// server
+            	//if ((!this.trackingPlayers.contains(par1EntityPlayerMP) && (this.isPlayerWatchingThisChunk(par1EntityPlayerMP) || this.trackedEntity.field_98038_p))
+                //		|| (Math.abs(par1EntityPlayerMP.posX - this.trackedEntity.posX) > 120 || Math.abs(par1EntityPlayerMP.posZ - this.trackedEntity.posZ) > 120)) {
                     this.trackingPlayers.add(par1EntityPlayerMP);
                     Packet var6 = this.getPacketForThisEntity();
                     par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(var6);
@@ -359,9 +374,9 @@ public class EntityTrackerEntry
 
                     if (this.myEntity instanceof EntityPlayer)
                     {
-                        EntityPlayer var10 = (EntityPlayer)this.myEntity;
+                        EntityPlayer var11 = (EntityPlayer)this.myEntity;
 
-                        if (var10.isPlayerSleeping())
+                        if (var11.isPlayerSleeping())
                         {
                             par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet17Sleep(this.myEntity, 0, MathHelper.floor_double(this.myEntity.posX), MathHelper.floor_double(this.myEntity.posY), MathHelper.floor_double(this.myEntity.posZ)));
                         }
@@ -369,8 +384,8 @@ public class EntityTrackerEntry
 
                     if (this.myEntity instanceof EntityLiving)
                     {
-                        EntityLiving var11 = (EntityLiving)this.myEntity;
-                        Iterator var12 = var11.getActivePotionEffects().iterator();
+                        EntityLiving var10 = (EntityLiving)this.myEntity;
+                        Iterator var12 = var10.getActivePotionEffects().iterator();
 
                         while (var12.hasNext())
                         {
@@ -390,7 +405,15 @@ public class EntityTrackerEntry
 
     private boolean isPlayerWatchingThisChunk(EntityPlayerMP par1EntityPlayerMP)
     {
-        return par1EntityPlayerMP.getServerForPlayer().getPlayerManager().isPlayerWatchingChunk(par1EntityPlayerMP, this.myEntity.chunkCoordX, this.myEntity.chunkCoordZ);
+    	// FCMOD: Changed    	
+        //return par1EntityPlayerMP.getServerForPlayer().getPlayerManager().isPlayerWatchingChunk(par1EntityPlayerMP, this.myEntity.chunkCoordX, this.myEntity.chunkCoordZ);
+        return par1EntityPlayerMP.getServerForPlayer().
+        	GetChunkTracker().IsChunkWatchedByPlayerAndSentToClient(
+        	// client 
+        	par1EntityPlayerMP, this.myEntity.chunkCoordX, this.myEntity.chunkCoordZ);
+        	// server
+			//par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);        
+        // END FCMOD
     }
 
     public void sendEventsToPlayers(List par1List)
@@ -408,6 +431,21 @@ public class EntityTrackerEntry
             this.myEntity.worldObj.getWorldLogAgent().logWarning("Fetching addPacket for removed entity");
         }
 
+        // FCMOD: Code added.  This is at the top of all the following code due to some mod entities inheriting from the ones below
+        // client
+        if ( myEntity instanceof FCIEntityPacketHandler )
+    	// server
+        //if ( trackedEntity instanceof FCIEntityPacketHandler )        	
+        {
+        	// client
+        	FCIEntityPacketHandler packetHandler = (FCIEntityPacketHandler)myEntity;
+        	// server
+        	//FCIEntityPacketHandler packetHandler = (FCIEntityPacketHandler)trackedEntity;
+        	
+    		return packetHandler.GetSpawnPacketForThisEntity();
+        }
+        // END FCMOD
+        
         if (this.myEntity instanceof EntityItem)
         {
             return new Packet23VehicleSpawn(this.myEntity, 2, 1);
diff --git a/minecraft/net/minecraft/src/EntityVillager.java b/minecraft/net/minecraft/src/EntityVillager.java
index c5a74c7..d6b96f3 100644
--- a/minecraft/net/minecraft/src/EntityVillager.java
+++ b/minecraft/net/minecraft/src/EntityVillager.java
@@ -1,3 +1,5 @@
+// FCMOD: Note that in the server version of this file, I've renamed functions to match the client
+
 package net.minecraft.src;
 
 import java.util.Collections;
@@ -17,28 +19,25 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
     private EntityPlayer buyingPlayer;
 
     /** Initialises the MerchantRecipeList.java */
-    private MerchantRecipeList buyingList;
+    // FCMOD: Changed
+    //private MerchantRecipeList buyingList;
+    protected MerchantRecipeList buyingList;
+    // END FCMOD
+    
     private int timeUntilReset;
 
     /** addDefaultEquipmentAndRecipies is called if this is true */
     private boolean needsInitilization;
+    
     private int wealth;
 
     /** Last player to trade with this villager, used for aggressivity. */
     private String lastBuyingPlayer;
+    
     private boolean field_82190_bM;
     private float field_82191_bN;
 
-    /**
-     * a villagers recipe list is intialized off this list ; the 2 params are min/max amount they will trade for 1
-     * emerald
-     */
     private static final Map villagerStockList = new HashMap();
-
-    /**
-     * Selling list of Blacksmith items. negative numbers mean 1 emerald for n items, positive numbers are n emeralds
-     * for 1 item
-     */
     private static final Map blacksmithSellingList = new HashMap();
 
     public EntityVillager(World par1World)
@@ -231,7 +230,7 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
             case 1:
                 return "/mob/villager/librarian.png";
 
-            case 2:
+            case 2:            	
                 return "/mob/villager/priest.png";
 
             case 3:
@@ -492,6 +491,7 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
                 addBlacksmithItem(var2, Item.expBottle.itemID, this.rand, this.func_82188_j(0.2F));
                 addBlacksmithItem(var2, Item.redstone.itemID, this.rand, this.func_82188_j(0.4F));
                 addBlacksmithItem(var2, Block.glowStone.blockID, this.rand, this.func_82188_j(0.3F));
+            	
                 int[] var3 = new int[] {Item.swordIron.itemID, Item.swordDiamond.itemID, Item.plateIron.itemID, Item.plateDiamond.itemID, Item.axeIron.itemID, Item.axeDiamond.itemID, Item.pickaxeIron.itemID, Item.pickaxeDiamond.itemID};
                 int[] var4 = var3;
                 int var5 = var3.length;
@@ -623,7 +623,7 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
             par0MerchantRecipeList.add(new MerchantRecipe(var5, var6));
         }
     }
-
+    
     private static int getRandomCountForBlacksmithItem(int par0, Random par1Random)
     {
         Tuple var2 = (Tuple)blacksmithSellingList.get(Integer.valueOf(par0));
@@ -756,4 +756,21 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
         blacksmithSellingList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(7), Integer.valueOf(11)));
         blacksmithSellingList.put(Integer.valueOf(Item.arrow.itemID), new Tuple(Integer.valueOf(-12), Integer.valueOf(-8)));
     }
+    
+    // FCMOD: Added to satisfy IMerchant
+    public int GetCurrentTradeLevel() 
+    {
+    	return 0;
+    }
+    
+    public int GetCurrentTradeXP()
+    {
+    	return 0;
+    }
+    
+    public int GetCurrentTradeMaxXP()
+    {
+    	return 0;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityWaterMob.java b/minecraft/net/minecraft/src/EntityWaterMob.java
index 1073d02..ec8672a 100644
--- a/minecraft/net/minecraft/src/EntityWaterMob.java
+++ b/minecraft/net/minecraft/src/EntityWaterMob.java
@@ -52,7 +52,12 @@ public abstract class EntityWaterMob extends EntityCreature implements IAnimals
         int var1 = this.getAir();
         super.onEntityUpdate();
 
+        // FCMOD: Change to be more forgiving on whether the squid is in water or not 
+        /*
         if (this.isEntityAlive() && !this.isInsideOfMaterial(Material.water))
+        */
+        if (this.isEntityAlive() && !inWater)
+        // END FCMOD
         {
             --var1;
             this.setAir(var1);
diff --git a/minecraft/net/minecraft/src/EntityWitch.java b/minecraft/net/minecraft/src/EntityWitch.java
index 595fcd8..b845107 100644
--- a/minecraft/net/minecraft/src/EntityWitch.java
+++ b/minecraft/net/minecraft/src/EntityWitch.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/23/2018
+
 package net.minecraft.src;
 
 import java.util.Iterator;
diff --git a/minecraft/net/minecraft/src/EntityWither.java b/minecraft/net/minecraft/src/EntityWither.java
index f4c0b34..7a0d076 100644
--- a/minecraft/net/minecraft/src/EntityWither.java
+++ b/minecraft/net/minecraft/src/EntityWither.java
@@ -248,7 +248,11 @@ public class EntityWither extends EntityMob implements IBossDisplayData, IRanged
                 {
                     this.field_82223_h[var1 - 1] = this.ticksExisted + 10 + this.rand.nextInt(10);
 
+                    // FCMOD: Code removed so that skulls launch on easy difficulty
+                    /*
                     if (this.worldObj.difficultySetting >= 2)
+                    */
+                    // END FCMOD
                     {
                         int var10001 = var1 - 1;
                         int var10003 = this.field_82224_i[var1 - 1];
@@ -332,28 +336,34 @@ public class EntityWither extends EntityMob implements IBossDisplayData, IRanged
                     var1 = MathHelper.floor_double(this.posY);
                     var12 = MathHelper.floor_double(this.posX);
                     int var15 = MathHelper.floor_double(this.posZ);
-                    boolean var17 = false;
+                    boolean var18 = false;
 
-                    for (int var18 = -1; var18 <= 1; ++var18)
+                    for (int var17 = -1; var17 <= 1; ++var17)
                     {
                         for (int var19 = -1; var19 <= 1; ++var19)
                         {
                             for (int var7 = 0; var7 <= 3; ++var7)
                             {
-                                int var20 = var12 + var18;
+                                int var20 = var12 + var17;
                                 int var9 = var1 + var7;
                                 int var10 = var15 + var19;
                                 int var11 = this.worldObj.getBlockId(var20, var9, var10);
 
+                                // FCMOD: Change
+                                /*
                                 if (var11 > 0 && var11 != Block.bedrock.blockID && var11 != Block.endPortal.blockID && var11 != Block.endPortalFrame.blockID)
+                                */                                	
+                                if (var11 > 0 && var11 != Block.bedrock.blockID && var11 != Block.endPortal.blockID && var11 != Block.endPortalFrame.blockID &&
+                                	var11 != FCBetterThanWolves.fcSoulforgedSteelBlock.blockID )
+                            	// END FCMOD
                                 {
-                                    var17 = this.worldObj.destroyBlock(var20, var9, var10, true) || var17;
+                                    var18 = this.worldObj.destroyBlock(var20, var9, var10, true) || var18;
                                 }
                             }
                         }
                     }
 
-                    if (var17)
+                    if (var18)
                     {
                         this.worldObj.playAuxSFXAtEntity((EntityPlayer)null, 1012, (int)this.posX, (int)this.posY, (int)this.posZ, 0);
                     }
@@ -450,7 +460,10 @@ public class EntityWither extends EntityMob implements IBossDisplayData, IRanged
         double var15 = par2 - var9;
         double var17 = par4 - var11;
         double var19 = par6 - var13;
-        EntityWitherSkull var21 = new EntityWitherSkull(this.worldObj, this, var15, var17, var19);
+        // FCMOD: Changed
+        //EntityWitherSkull var21 = new EntityWitherSkull(this.worldObj, this, var15, var17, var19);
+        FCEntityWitherSkull var21 = new FCEntityWitherSkull(this.worldObj, this, var15, var17, var19);
+        // END FCMOD
 
         if (par8)
         {
diff --git a/minecraft/net/minecraft/src/EntityWitherSkull.java b/minecraft/net/minecraft/src/EntityWitherSkull.java
index ed05af9..a3ee8ce 100644
--- a/minecraft/net/minecraft/src/EntityWitherSkull.java
+++ b/minecraft/net/minecraft/src/EntityWitherSkull.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 10/20/2018
+
 package net.minecraft.src;
 
 public class EntityWitherSkull extends EntityFireball
diff --git a/minecraft/net/minecraft/src/EntityWolf.java b/minecraft/net/minecraft/src/EntityWolf.java
index 7a4cac3..b2580b7 100644
--- a/minecraft/net/minecraft/src/EntityWolf.java
+++ b/minecraft/net/minecraft/src/EntityWolf.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/10/2018
+
 package net.minecraft.src;
 
 public class EntityWolf extends EntityTameable
diff --git a/minecraft/net/minecraft/src/EntityXPOrb.java b/minecraft/net/minecraft/src/EntityXPOrb.java
index 736be9a..ebc47ce 100644
--- a/minecraft/net/minecraft/src/EntityXPOrb.java
+++ b/minecraft/net/minecraft/src/EntityXPOrb.java
@@ -2,6 +2,10 @@ package net.minecraft.src;
 
 public class EntityXPOrb extends Entity
 {
+    // FCMOD: Code added
+    public boolean m_bNotPlayerOwned = false;
+    // END FCMOD
+    
     /**
      * A constantly increasing value that RenderXPOrb uses to control the colour shifting (Green / yellow)
      */
@@ -15,7 +19,12 @@ public class EntityXPOrb extends Entity
     private int xpOrbHealth = 5;
 
     /** This is how much XP this orb has. */
+    // FCMOD: Changed to public
+	/*
     private int xpValue;
+	*/
+    public int xpValue;
+    // END FCMOD
 
     /** The closest EntityPlayer to this orb. */
     private EntityPlayer closestPlayer;
@@ -23,10 +32,23 @@ public class EntityXPOrb extends Entity
     /** Threshold color for tracking players */
     private int xpTargetColor;
 
+    // FCMOD: Method added
+    public EntityXPOrb(World par1World, double par2, double par4, double par6, int par8, boolean bNotPlayerOwned )
+    {
+    	this( par1World, par2, par4, par6, par8 );
+        m_bNotPlayerOwned = bNotPlayerOwned;
+    }
+    // END FCMOD
+
     public EntityXPOrb(World par1World, double par2, double par4, double par6, int par8)
     {
         super(par1World);
+        // FCMOD: Line changed so XP orbs will fit through tight spaces (set to same size as items)
+		/*
         this.setSize(0.5F, 0.5F);
+		*/
+        setSize(0.25F, 0.25F);
+        // END FCMOD
         this.yOffset = this.height / 2.0F;
         this.setPosition(par2, par4, par6);
         this.rotationYaw = (float)(Math.random() * 360.0D);
@@ -106,13 +128,23 @@ public class EntityXPOrb extends Entity
             this.playSound("random.fizz", 0.4F, 2.0F + this.rand.nextFloat() * 0.4F);
         }
 
-        this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+        // FCMOD: Changed to reduce discrepancies between client and server by 
+        // pusing only on server
+        //this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+        if ( !worldObj.isRemote )
+        {
+            pushOutOfBlocks( posX, ( boundingBox.minY + boundingBox.maxY) / 2D, posZ );
+        }
+    	// END FCMOD
         double var1 = 8.0D;
 
         if (this.xpTargetColor < this.xpColor - 20 + this.entityId % 100)
         {
             if (this.closestPlayer == null || this.closestPlayer.getDistanceSqToEntity(this) > var1 * var1)
             {
+				// FCMOD: Added
+		        if ( !m_bNotPlayerOwned )
+	        	// END FCMOD
                 this.closestPlayer = this.worldObj.getClosestPlayerToEntity(this, var1);
             }
 
@@ -124,11 +156,21 @@ public class EntityXPOrb extends Entity
             double var3 = (this.closestPlayer.posX - this.posX) / var1;
             double var5 = (this.closestPlayer.posY + (double)this.closestPlayer.getEyeHeight() - this.posY) / var1;
             double var7 = (this.closestPlayer.posZ - this.posZ) / var1;
+            // FCMOD: Code Changed for optimization
+            /*
             double var9 = Math.sqrt(var3 * var3 + var5 * var5 + var7 * var7);
             double var11 = 1.0D - var9;
 
             if (var11 > 0.0D)
             {
+            */
+            double dDistanceSq = var3 * var3 + var5 * var5 + var7 * var7;
+
+            if (dDistanceSq < 1.0D)
+            {
+                double var9 = Math.sqrt( dDistanceSq );
+                double var11 = 1.0D - var9;
+            // 	END FCMOD
                 var11 *= var11;
                 this.motionX += var3 / var9 * var11 * 0.1D;
                 this.motionY += var5 / var9 * var11 * 0.1D;
@@ -216,6 +258,9 @@ public class EntityXPOrb extends Entity
         par1NBTTagCompound.setShort("Health", (short)((byte)this.xpOrbHealth));
         par1NBTTagCompound.setShort("Age", (short)this.xpOrbAge);
         par1NBTTagCompound.setShort("Value", (short)this.xpValue);
+        // FCMOD: Code added        
+        par1NBTTagCompound.setBoolean("m_bNotPlayerOwned", m_bNotPlayerOwned);
+        // END FCMOD
     }
 
     /**
@@ -226,6 +271,12 @@ public class EntityXPOrb extends Entity
         this.xpOrbHealth = par1NBTTagCompound.getShort("Health") & 255;
         this.xpOrbAge = par1NBTTagCompound.getShort("Age");
         this.xpValue = par1NBTTagCompound.getShort("Value");
+        // FCMOD: Code added        
+        if ( par1NBTTagCompound.hasKey( "m_bNotPlayerOwned" ) )
+        {
+        	m_bNotPlayerOwned = par1NBTTagCompound.getBoolean( "m_bNotPlayerOwned" );
+        }
+        // END FCMOD
     }
 
     /**
@@ -233,6 +284,12 @@ public class EntityXPOrb extends Entity
      */
     public void onCollideWithPlayer(EntityPlayer par1EntityPlayer)
     {
+        // FCMOD: Code added
+    	if ( m_bNotPlayerOwned )
+    	{
+    		return;
+    	}
+    	// END FCMOD
         if (!this.worldObj.isRemote)
         {
             if (this.field_70532_c == 0 && par1EntityPlayer.xpCooldown == 0)
@@ -278,4 +335,42 @@ public class EntityXPOrb extends Entity
     {
         return false;
     }
+    
+    // FCMOD: inherited function added so that blocks like Hoppers get collision events with items on top.  
+    // Copy of code from Entity.java, changes marked with FCMOD.
+    @Override
+    protected void doBlockCollisions()
+    {
+        int i = MathHelper.floor_double(boundingBox.minX + 0.001D);
+        // FCMOD: code change
+        /*
+        int j = MathHelper.floor_double(boundingBox.minY + 0.001D);
+        */
+        int j = MathHelper.floor_double(boundingBox.minY - 0.01D);
+        // END FCMOD
+        int k = MathHelper.floor_double(boundingBox.minZ + 0.001D);
+        int l = MathHelper.floor_double(boundingBox.maxX - 0.001D);
+        int i1 = MathHelper.floor_double(boundingBox.maxY - 0.001D);
+        int j1 = MathHelper.floor_double(boundingBox.maxZ - 0.001D);
+
+        if (worldObj.checkChunksExist(i, j, k, l, i1, j1))
+        {
+            for (int k1 = i; k1 <= l; k1++)
+            {
+                for (int l1 = j; l1 <= i1; l1++)
+                {
+                    for (int i2 = k; i2 <= j1; i2++)
+                    {
+                        int j2 = worldObj.getBlockId(k1, l1, i2);
+
+                        if (j2 > 0)
+                        {
+                            Block.blocksList[j2].onEntityCollidedWithBlock(worldObj, k1, l1, i2, this);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EntityZombie.java b/minecraft/net/minecraft/src/EntityZombie.java
index a2dfab3..b7c01fb 100644
--- a/minecraft/net/minecraft/src/EntityZombie.java
+++ b/minecraft/net/minecraft/src/EntityZombie.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 import java.util.Calendar;
@@ -8,7 +10,7 @@ public class EntityZombie extends EntityMob
      * Ticker used to determine the time remaining for this zombie to convert into a villager when cured.
      */
     private int conversionTime = 0;
-
+    
     public EntityZombie(World par1World)
     {
         super(par1World);
@@ -291,7 +293,7 @@ public class EntityZombie extends EntityMob
             else
             {
                 this.setCurrentItemOrArmor(0, new ItemStack(Item.shovelIron));
-            }
+            }            
         }
     }
 
@@ -312,7 +314,7 @@ public class EntityZombie extends EntityMob
             par1NBTTagCompound.setBoolean("IsVillager", true);
         }
 
-        par1NBTTagCompound.setInteger("ConversionTime", this.isConverting() ? this.conversionTime : -1);
+        par1NBTTagCompound.setInteger("ConversionTime", this.isConverting() ? this.conversionTime : -1);        
     }
 
     /**
@@ -357,7 +359,7 @@ public class EntityZombie extends EntityMob
             this.worldObj.removeEntity(par1EntityLiving);
             var2.initCreature();
             var2.setVillager(true);
-
+            
             if (par1EntityLiving.isChild())
             {
                 var2.setChild(true);
@@ -515,5 +517,5 @@ public class EntityZombie extends EntityMob
         }
 
         return var1;
-    }
+    }    
 }
diff --git a/minecraft/net/minecraft/src/EnumAction.java b/minecraft/net/minecraft/src/EnumAction.java
index 1ea0780..3caa80d 100644
--- a/minecraft/net/minecraft/src/EnumAction.java
+++ b/minecraft/net/minecraft/src/EnumAction.java
@@ -6,5 +6,9 @@ public enum EnumAction
     eat,
     drink,
     block,
-    bow;
+    // FCMOD: Changed
+    //bow;
+    bow,
+    miscUse;
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/EnumArmorMaterial.java b/minecraft/net/minecraft/src/EnumArmorMaterial.java
index 9376b3d..20060c4 100644
--- a/minecraft/net/minecraft/src/EnumArmorMaterial.java
+++ b/minecraft/net/minecraft/src/EnumArmorMaterial.java
@@ -2,9 +2,16 @@ package net.minecraft.src;
 
 public enum EnumArmorMaterial
 {
+	// FCMOD: Change to increase durability of armors, and change iron enchantibility to equal diamond
+	/*
     CLOTH(5, new int[]{1, 3, 2, 1}, 15),
     CHAIN(15, new int[]{2, 5, 4, 1}, 12),
     IRON(15, new int[]{2, 6, 5, 2}, 9),
+    */
+    CLOTH(10, new int[]{1, 3, 2, 1}, 15),
+    CHAIN(20, new int[]{2, 5, 4, 1}, 12),
+    IRON(20, new int[]{2, 6, 5, 2}, 10),
+    // END FCMOD
     GOLD(7, new int[]{2, 5, 3, 1}, 25),
     DIAMOND(33, new int[]{3, 8, 6, 3}, 10);
 
diff --git a/minecraft/net/minecraft/src/EnumCreatureType.java b/minecraft/net/minecraft/src/EnumCreatureType.java
index c8ceaee..a8f16a3 100644
--- a/minecraft/net/minecraft/src/EnumCreatureType.java
+++ b/minecraft/net/minecraft/src/EnumCreatureType.java
@@ -2,7 +2,11 @@ package net.minecraft.src;
 
 public enum EnumCreatureType
 {
-    monster(IMob.class, 70, Material.air, false, false),
+	// FCMOD: Changed to increase mob cap to compensate for rectangular instead of spherical despawn
+	// volume causing decreased mob density	
+    //monster(IMob.class, 70, Material.air, false, false),
+    monster( IMob.class, 90, Material.air, false, false ),
+	// END FCMOD
     creature(EntityAnimal.class, 10, Material.air, true, true),
     ambient(EntityAmbientCreature.class, 15, Material.air, true, false),
     waterCreature(EntityWaterMob.class, 5, Material.water, true, false);
diff --git a/minecraft/net/minecraft/src/EnumToolMaterial.java b/minecraft/net/minecraft/src/EnumToolMaterial.java
index f11667c..9ded21b 100644
--- a/minecraft/net/minecraft/src/EnumToolMaterial.java
+++ b/minecraft/net/minecraft/src/EnumToolMaterial.java
@@ -2,11 +2,24 @@ package net.minecraft.src;
 
 public enum EnumToolMaterial
 {
+	// FCMOD: Change to rebalance value of early game tools and value of iron
+	/*
     WOOD(0, 59, 2.0F, 0, 15),
     STONE(1, 131, 4.0F, 1, 5),
     IRON(2, 250, 6.0F, 2, 14),
     EMERALD(3, 1561, 8.0F, 3, 10),
     GOLD(0, 32, 12.0F, 0, 22);
+    */
+	// FCNOTE: Min efficiency is slightly greater than 1 due to > 1 test elsewhere in the code, 
+	// There's one such test in EntityPlayer.getCurrentPlayerStrVsBlock() but I'm not sure 
+	// it's the only one I was referring to in this comment when first written    
+	WOOD( 0, 10, 1.01F, 0, 0, 20, 2 ),  // no vanilla enchant of wood
+    STONE( 1, 50, 1.01F, 1, 5, 10, 1 ), 
+    IRON( 2, 500, 6F, 2, 14, 25, 2 ),
+    EMERALD( 3, 1561, 8F, 3, 14, 30, 2 ),
+    GOLD( 0, 32, 12F, 0, 22, 30, 3 ),
+    SOULFORGED_STEEL( 4, 2250, 12F, 4, 0, 30, 4 );
+    // END FCMOD
 
     /**
      * The level of material this tool can harvest (3 = DIAMOND, 2 = IRON, 1 = STONE, 0 = IRON/GOLD)
@@ -29,6 +42,8 @@ public enum EnumToolMaterial
     /** Defines the natural enchantability factor of the material. */
     private final int enchantability;
 
+    // FCMOD: Changed
+    /*
     private EnumToolMaterial(int par3, int par4, float par5, int par6, int par7)
     {
         this.harvestLevel = par3;
@@ -37,6 +52,20 @@ public enum EnumToolMaterial
         this.damageVsEntity = par6;
         this.enchantability = par7;
     }
+    */
+    private EnumToolMaterial( int iHarvestLevel, int iMaxUses, float fEffeciency, int iWeaponDamage, 
+    	int iEnchantability, int iInfernalMaxEnchantmentCost, int iInfernalMaxNumEnchants )
+    {
+        harvestLevel = iHarvestLevel;
+        maxUses = iMaxUses;
+        efficiencyOnProperMaterial = fEffeciency;
+        damageVsEntity = iWeaponDamage;
+        enchantability = iEnchantability;
+        
+        m_iInfernalMaxEnchantmentCost = iInfernalMaxEnchantmentCost;
+        m_iInfernalMaxNumEnchants = iInfernalMaxNumEnchants;
+    }    
+    // END FCMOD
 
     /**
      * The number of uses this material allows. (wood = 59, stone = 131, iron = 250, diamond = 1561, gold = 32)
@@ -86,4 +115,19 @@ public enum EnumToolMaterial
     {
         return this == WOOD ? Block.planks.blockID : (this == STONE ? Block.cobblestone.blockID : (this == GOLD ? Item.ingotGold.itemID : (this == IRON ? Item.ingotIron.itemID : (this == EMERALD ? Item.diamond.itemID : 0))));
     }
+    
+    // FCMOD: Added New
+    private final int m_iInfernalMaxEnchantmentCost;
+    private final int m_iInfernalMaxNumEnchants;
+    
+    public int GetInfernalMaxEnchantmentCost()
+    {
+    	return m_iInfernalMaxEnchantmentCost;
+    }
+    
+    public int GetInfernalMaxNumEnchants()
+    {
+    	return m_iInfernalMaxNumEnchants;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/Explosion.java b/minecraft/net/minecraft/src/Explosion.java
index 5bfa5fe..a42e6bb 100644
--- a/minecraft/net/minecraft/src/Explosion.java
+++ b/minecraft/net/minecraft/src/Explosion.java
@@ -23,11 +23,15 @@ public class Explosion
     public double explosionZ;
     public Entity exploder;
     public float explosionSize;
-
+    
     /** A list of ChunkPositions of blocks affected by this explosion */
     public List affectedBlockPositions = new ArrayList();
     private Map field_77288_k = new HashMap();
 
+    // FCMOD: Added
+    public boolean m_bSuppressFX = false;
+    // END FCMOD
+
     public Explosion(World par1World, Entity par2Entity, double par3, double par5, double par7, float par9)
     {
         this.worldObj = par1World;
@@ -82,7 +86,14 @@ public class Explosion
                             if (var25 > 0)
                             {
                                 Block var26 = Block.blocksList[var25];
+                                
+                                // FCMOD: Changed
+                                /*
                                 float var27 = this.exploder != null ? this.exploder.func_82146_a(this, this.worldObj, var22, var23, var24, var26) : var26.getExplosionResistance(this.exploder);
+                                */
+                                float var27 = this.exploder != null ? this.exploder.func_82146_a(this, this.worldObj, var22, var23, var24, var26) : 
+                                	var26.getExplosionResistance(this.exploder, worldObj, var22, var23, var24);
+                                // END FCMOD
                                 var14 -= (var27 + 0.3F) * var21;
                             }
 
@@ -121,15 +132,15 @@ public class Explosion
                 var15 = var32.posX - this.explosionX;
                 var17 = var32.posY + (double)var32.getEyeHeight() - this.explosionY;
                 var19 = var32.posZ - this.explosionZ;
-                double var33 = (double)MathHelper.sqrt_double(var15 * var15 + var17 * var17 + var19 * var19);
+                double var34 = (double)MathHelper.sqrt_double(var15 * var15 + var17 * var17 + var19 * var19);
 
-                if (var33 != 0.0D)
+                if (var34 != 0.0D)
                 {
-                    var15 /= var33;
-                    var17 /= var33;
-                    var19 /= var33;
-                    double var34 = (double)this.worldObj.getBlockDensity(var31, var32.boundingBox);
-                    double var35 = (1.0D - var13) * var34;
+                    var15 /= var34;
+                    var17 /= var34;
+                    var19 /= var34;
+                    double var33 = (double)this.worldObj.getBlockDensity(var31, var32.boundingBox);
+                    double var35 = (1.0D - var13) * var33;
                     var32.attackEntityFrom(DamageSource.setExplosionSource(this), (int)((var35 * var35 + var35) / 2.0D * 8.0D * (double)this.explosionSize + 1.0D));
                     double var36 = EnchantmentProtection.func_92092_a(var32, var35);
                     var32.motionX += var15 * var36;
@@ -152,6 +163,10 @@ public class Explosion
      */
     public void doExplosionB(boolean par1)
     {
+    	// FCMOD: Added
+    	if ( !m_bSuppressFX )
+    	{
+    	// END FCMOD
         this.worldObj.playSoundEffect(this.explosionX, this.explosionY, this.explosionZ, "random.explode", 4.0F, (1.0F + (this.worldObj.rand.nextFloat() - this.worldObj.rand.nextFloat()) * 0.2F) * 0.7F);
 
         if (this.explosionSize >= 2.0F && this.isSmoking)
@@ -162,6 +177,9 @@ public class Explosion
         {
             this.worldObj.spawnParticle("largeexplode", this.explosionX, this.explosionY, this.explosionZ, 1.0D, 0.0D, 0.0D);
         }
+    	// FCMOD: Added
+    	}
+    	// END FCMOD
 
         Iterator var2;
         ChunkPosition var3;
@@ -205,15 +223,26 @@ public class Explosion
 
                 if (var7 > 0)
                 {
-                    Block var24 = Block.blocksList[var7];
+                    Block var25 = Block.blocksList[var7];
 
-                    if (var24.canDropFromExplosion(this))
+                    // FCMOD: Changed
+                    /*
+                    if (var25.canDropFromExplosion(this))
                     {
-                        var24.dropBlockAsItemWithChance(this.worldObj, var4, var5, var6, this.worldObj.getBlockMetadata(var4, var5, var6), 1.0F / this.explosionSize, 0);
+                        var25.dropBlockAsItemWithChance(this.worldObj, var4, var5, var6, this.worldObj.getBlockMetadata(var4, var5, var6), 1.0F / this.explosionSize, 0);
                     }
+                    */
+                    var25.DropItemsOnDestroyedByExplosion( worldObj, var4, var5, var6, this );
+                    // END FCMOD
 
+                    // FCMOD: Changed to rearrange order so that blocks can still access their metadata when notified of an explosion
+                    /*
+                    this.worldObj.setBlock(var4, var5, var6, 0, 0, 3);
+                    var25.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
+                    */
+                    var25.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
                     this.worldObj.setBlock(var4, var5, var6, 0, 0, 3);
-                    var24.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
+                    // END FCMOD
                 }
             }
         }
@@ -225,18 +254,33 @@ public class Explosion
             while (var2.hasNext())
             {
                 var3 = (ChunkPosition)var2.next();
+                
+                // FCMOD: Changed
+                /*
                 var4 = var3.x;
                 var5 = var3.y;
                 var6 = var3.z;
                 var7 = this.worldObj.getBlockId(var4, var5, var6);
-                int var25 = this.worldObj.getBlockId(var4, var5 - 1, var6);
+                int var24 = this.worldObj.getBlockId(var4, var5 - 1, var6);
 
-                if (var7 == 0 && Block.opaqueCubeLookup[var25] && this.explosionRNG.nextInt(3) == 0)
+                if (var7 == 0 && Block.opaqueCubeLookup[var24] && this.explosionRNG.nextInt(3) == 0)
                 {
                     this.worldObj.setBlock(var4, var5, var6, Block.fire.blockID);
                 }
+                */
+                if ( explosionRNG.nextInt( 3 ) == 0 && 
+                	FCBlockFire.CanFireReplaceBlock( worldObj, var3.x, var3.y, var3.z ) && 
+                	Block.fire.canPlaceBlockAt( worldObj, var3.x, var3.y, var3.z ) )
+                {
+                    this.worldObj.setBlock( var3.x, var3.y, var3.z, Block.fire.blockID );
+                }
+                // END FCMOD
             }
         }
+        
+        // FCMOD: Added
+        PerformSecondaryExplosions();
+        // END FCMOD
     }
 
     public Map func_77277_b()
@@ -248,4 +292,41 @@ public class Explosion
     {
         return this.exploder == null ? null : (this.exploder instanceof EntityTNTPrimed ? ((EntityTNTPrimed)this.exploder).getTntPlacedBy() : (this.exploder instanceof EntityLiving ? (EntityLiving)this.exploder : null));
     }
+    
+    // FCMOD: Added
+    public List m_SecondaryExplosionList = null;
+    
+    public void AddSecondaryExplosionNoFX( double dPosX, double dPosY, double dPosZ, 
+    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
+    {
+    	if ( m_SecondaryExplosionList == null )
+    	{
+    		m_SecondaryExplosionList = new ArrayList();
+    	}
+    	
+        Explosion explosion = new Explosion( worldObj, null, dPosX, dPosY, dPosZ, fExplosionSize );
+        
+        explosion.isFlaming = bCreatesFlames;
+        explosion.isSmoking = bDestroysBlocks;
+        explosion.m_bSuppressFX = true;
+        
+        m_SecondaryExplosionList.add( explosion );
+    }
+    
+    private void PerformSecondaryExplosions()
+    {
+    	if ( m_SecondaryExplosionList != null )
+    	{
+    		Iterator tempIterator = m_SecondaryExplosionList.iterator();
+    		
+            while ( tempIterator.hasNext() )
+            {
+                Explosion tempExplosion = (Explosion)tempIterator.next();
+                
+                tempExplosion.doExplosionA();
+                tempExplosion.doExplosionB( false ); // false tells individual block destruction effects not to play
+            }
+    	}
+    }    
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/FontRenderer.java b/minecraft/net/minecraft/src/FontRenderer.java
index 6bba4bc..87255ea 100644
--- a/minecraft/net/minecraft/src/FontRenderer.java
+++ b/minecraft/net/minecraft/src/FontRenderer.java
@@ -1,5 +1,9 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.hd.FontUtils;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mal.resource.TexturePackAPI;
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 import java.io.InputStream;
@@ -8,7 +12,6 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import javax.imageio.ImageIO;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 
@@ -31,7 +34,7 @@ public class FontRenderer
      * drop shadows.
      */
     private int[] colorCode = new int[32];
-    private final String fontTextureName;
+    private String fontTextureName;
 
     /** The RenderEngine used to load and setup glyph textures. */
     private final RenderEngine renderEngine;
@@ -85,6 +88,12 @@ public class FontRenderer
      * Set if the "m" style (strikethrough) is active in currently rendering string
      */
     private boolean strikethroughStyle = false;
+    
+    public float[] charWidthf;
+    private String defaultFont;
+    private String hdFont;
+    public boolean isHD;
+    public float fontAdj;
 
     FontRenderer()
     {
@@ -135,6 +144,8 @@ public class FontRenderer
 
     public void readFontData()
     {
+    	this.fontTextureName = FakeResourceLocation.unwrap(FontUtils.getFontName(this, FakeResourceLocation.wrap(this.fontTextureName), 1.0F));
+        String var1 = this.fontTextureName;
         this.readGlyphSizes();
         this.readFontTexture(this.fontTextureName);
     }
@@ -145,9 +156,9 @@ public class FontRenderer
 
         try
         {
-            var2 = ImageIO.read(RenderEngine.class.getResourceAsStream(par1Str));
+        	var2 = TexturePackAPI.getImage(FakeResourceLocation.wrap(par1Str));
         }
-        catch (IOException var15)
+        catch (Exception var15)
         {
             throw new RuntimeException(var15);
         }
@@ -199,6 +210,8 @@ public class FontRenderer
                 break;
             }
         }
+        
+        this.charWidthf = FontUtils.computeCharWidthsf(this, FakeResourceLocation.wrap(this.fontTextureName), var2, var5, this.charWidth);
     }
 
     private void readGlyphSizes()
@@ -219,7 +232,7 @@ public class FontRenderer
      */
     private float renderCharAtPos(int par1, char par2, boolean par3)
     {
-        return par2 == 32 ? 4.0F : (par1 > 0 && !this.unicodeFlag ? this.renderDefaultChar(par1 + 32, par3) : this.renderUnicodeChar(par2, par3));
+    	return par2 == 32 ? this.charWidthf[32] : (par1 > 0 && !this.unicodeFlag ? this.renderDefaultChar(par1 + 32, par3) : this.renderUnicodeChar(par2, par3));
     }
 
     /**
@@ -242,7 +255,7 @@ public class FontRenderer
         GL11.glTexCoord2f((var3 + var6) / 128.0F, (var4 + 7.99F) / 128.0F);
         GL11.glVertex3f(this.posX + var6 - var5, this.posY + 7.99F, 0.0F);
         GL11.glEnd();
-        return (float)this.charWidth[par1];
+        return FontUtils.getCharWidthf(this, this.charWidth, par1);
     }
 
     /**
@@ -458,7 +471,7 @@ public class FontRenderer
                         var5 += 16;
                     }
 
-                    var6 = this.colorCode[var5];
+                    var6 = ColorizeWorld.colorizeText(this.colorCode[var5], var5);
                     this.textColor = var6;
                     GL11.glColor4f((float)(var6 >> 16) / 255.0F, (float)(var6 >> 8 & 255) / 255.0F, (float)(var6 & 255) / 255.0F, this.alpha);
                 }
@@ -608,6 +621,8 @@ public class FontRenderer
         }
         else
         {
+        	par4 = ColorizeWorld.colorizeText(par4);
+        	
             if ((par4 & -67108864) == 0)
             {
                 par4 |= -16777216;
@@ -635,7 +650,11 @@ public class FontRenderer
      */
     public int getStringWidth(String par1Str)
     {
-        if (par1Str == null)
+    	if (this.isHD)
+        {
+            return (int)FontUtils.getStringWidthf(this, par1Str);
+        }
+        else if (par1Str == null)
         {
             return 0;
         }
@@ -1019,4 +1038,24 @@ public class FontRenderer
     {
         return this.bidiFlag;
     }
+    
+    public FakeResourceLocation getDefaultFont()
+    {
+        return FakeResourceLocation.wrap(this.defaultFont);
+    }
+
+    public void setDefaultFont(FakeResourceLocation var1)
+    {
+        this.defaultFont = FakeResourceLocation.unwrap(var1);
+    }
+
+    public FakeResourceLocation getHDFont()
+    {
+        return FakeResourceLocation.wrap(this.hdFont);
+    }
+
+    public void setHDFont(FakeResourceLocation var1)
+    {
+        this.hdFont = FakeResourceLocation.unwrap(var1);
+    }
 }
diff --git a/minecraft/net/minecraft/src/FoodStats.java b/minecraft/net/minecraft/src/FoodStats.java
index e0db982..cb67183 100644
--- a/minecraft/net/minecraft/src/FoodStats.java
+++ b/minecraft/net/minecraft/src/FoodStats.java
@@ -3,38 +3,65 @@ package net.minecraft.src;
 public class FoodStats
 {
     /** The player's food level. */
+	// FCMOD: Code change to increase food meter resolution
+	/*
     private int foodLevel = 20;
+    */
+    private int foodLevel = 60;
+    // END FCMOD
 
     /** The player's food saturation. */
+    // FCMOD: Code change so that player spawns with zero fat
+    /*
     private float foodSaturationLevel = 5.0F;
+    */
+    private float foodSaturationLevel = 0F;
+    // END FCMOD
 
     /** The player's food exhaustion. */
     private float foodExhaustionLevel;
 
     /** The player's food timer value. */
     private int foodTimer = 0;
+    
+	// FCMOD: Code change to increase food meter resolution
+	/*
     private int prevFoodLevel = 20;
+    */
+    private int prevFoodLevel = 60;
+    // END FCMOD
 
     /**
      * Args: int foodLevel, float foodSaturationModifier
      */
+    // FCMOD: Code removed and replaced later by custom function
+    /*
     public void addStats(int par1, float par2)
     {
         this.foodLevel = Math.min(par1 + this.foodLevel, 20);
         this.foodSaturationLevel = Math.min(this.foodSaturationLevel + (float)par1 * par2 * 2.0F, (float)this.foodLevel);
     }
+	*/
+	// END FCMOD
 
     /**
      * Eat some food.
      */
     public void addStats(ItemFood par1ItemFood)
     {
+    	// FCMOD: Code change
+    	/*
         this.addStats(par1ItemFood.getHealAmount(), par1ItemFood.getSaturationModifier());
+        */
+        this.addStats(par1ItemFood.GetHungerRestored(), par1ItemFood.getSaturationModifier());
+        // END FCMOD
     }
 
     /**
      * Handles the food game logic.
      */
+    // FCMOD: Code removed and replaced later by custom function
+    /*
     public void onUpdate(EntityPlayer par1EntityPlayer)
     {
         int var2 = par1EntityPlayer.worldObj.difficultySetting;
@@ -83,6 +110,8 @@ public class FoodStats
             this.foodTimer = 0;
         }
     }
+	*/
+	// END FCMOD
 
     /**
      * Reads food stats from an NBT object.
@@ -95,6 +124,26 @@ public class FoodStats
             this.foodTimer = par1NBTTagCompound.getInteger("foodTickTimer");
             this.foodSaturationLevel = par1NBTTagCompound.getFloat("foodSaturationLevel");
             this.foodExhaustionLevel = par1NBTTagCompound.getFloat("foodExhaustionLevel");
+            
+            // FCMOD: Code added
+            if ( !par1NBTTagCompound.hasKey("fcFoodLevelAdjusted"))
+            {
+            	foodLevel = foodLevel * 3;
+            	foodSaturationLevel = 0F;
+            }
+            
+            // sanity check the values as apparently they can get fucked up when importing from vanilla
+            
+            if ( foodLevel > 60 || foodLevel < 0 )
+            {
+            	foodLevel = 60;
+            }
+            
+            if ( foodSaturationLevel > 20F || foodSaturationLevel < 0F )
+            {
+            	foodSaturationLevel = 20F;
+            }
+            // END FCMOD
         }
     }
 
@@ -107,6 +156,10 @@ public class FoodStats
         par1NBTTagCompound.setInteger("foodTickTimer", this.foodTimer);
         par1NBTTagCompound.setFloat("foodSaturationLevel", this.foodSaturationLevel);
         par1NBTTagCompound.setFloat("foodExhaustionLevel", this.foodExhaustionLevel);
+        
+        // FCMOD: Code added
+        par1NBTTagCompound.setBoolean( "fcFoodLevelAdjusted", true );
+        // END FCMOD
     }
 
     /**
@@ -127,7 +180,12 @@ public class FoodStats
      */
     public boolean needFood()
     {
+    	// FCMOD: Code changed
+    	/*
         return this.foodLevel < 20;
+        */
+        return this.foodLevel < 60;    	
+        // END FCMOD
     }
 
     /**
@@ -135,7 +193,7 @@ public class FoodStats
      */
     public void addExhaustion(float par1)
     {
-        this.foodExhaustionLevel = Math.min(this.foodExhaustionLevel + par1, 40.0F);
+        this.foodExhaustionLevel = Math.min(this.foodExhaustionLevel + par1, 40.0F);        
     }
 
     /**
@@ -155,4 +213,99 @@ public class FoodStats
     {
         this.foodSaturationLevel = par1;
     }
+    
+    // FCMOD: Added New
+    /**
+     * Note that iFoodGain is one third regular hunger gained, with 6 units being a full pip
+     */
+    public void addStats( int iFoodGain, float fFatMultiplier )
+    {
+    	int iPreviousFoodLevel = foodLevel;
+    	
+        foodLevel = Math.min( iFoodGain + foodLevel, 60);
+        
+        int iExcessFood = iFoodGain - ( foodLevel - iPreviousFoodLevel );
+        
+        if ( iExcessFood > 0 )
+        {
+        	// divide by 3 due to increased resolution
+        	
+            foodSaturationLevel = Math.min( foodSaturationLevel + (float)iExcessFood * fFatMultiplier / 3F, 20F );
+        }
+    }
+    
+    public void onUpdate( EntityPlayer player )
+    {
+    	// only called on server
+    	
+        int iDifficulty = player.worldObj.difficultySetting;
+        
+        prevFoodLevel = foodLevel;
+        
+        if ( iDifficulty > 0 )
+        {
+	        // burn hunger
+	        
+	        while ( foodLevel > 0 && foodExhaustionLevel >= 1.33F && !ShouldBurnFatBeforeHunger() )
+	        {
+	            foodExhaustionLevel -= 1.33F;
+	            
+	            foodLevel = Math.max( foodLevel - 1, 0 );
+	        }
+	        
+	    	// burn fat
+	    	
+	        while ( foodExhaustionLevel >= 0.5F && ShouldBurnFatBeforeHunger() )
+	        {
+	    		foodExhaustionLevel -= 0.5F;
+	    		
+	            foodSaturationLevel = Math.max( foodSaturationLevel - 0.125F, 0F );
+	        }
+        }
+        else
+        {
+        	foodExhaustionLevel = 0F;
+        }
+
+        if ( foodLevel > 24 && player.shouldHeal() )
+        {
+            ++foodTimer;
+
+            if ( foodTimer >= 600 ) // once every 30 seconds
+            {
+                player.heal( 1 );
+                foodTimer = 0;
+            }
+        }
+        else if ( foodLevel <= 0 && foodSaturationLevel <= 0.01F )
+        {
+            ++foodTimer;
+
+            if ( foodTimer >= 80 )
+            {
+            	if ( iDifficulty > 0 )
+            	{
+            		player.attackEntityFrom( DamageSource.starve, 1 );
+            	}
+
+                foodTimer = 0;
+            }
+
+            // reset the exhaustion level so that it doesn't stack up while the player is starving
+            
+            foodExhaustionLevel = 0F;
+        }
+        else
+        {
+            foodTimer = 0;
+        }
+    }
+    
+    private boolean ShouldBurnFatBeforeHunger()
+    {
+    	// only burn fat when the corresponding hunger pip is completely depleted
+    	
+    	return foodSaturationLevel > (float)( ( foodLevel + 5 ) / 6 ) * 2F;    	
+    }    
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/FurnaceRecipes.java b/minecraft/net/minecraft/src/FurnaceRecipes.java
index 9f6e65d..9027f07 100644
--- a/minecraft/net/minecraft/src/FurnaceRecipes.java
+++ b/minecraft/net/minecraft/src/FurnaceRecipes.java
@@ -45,11 +45,15 @@ public class FurnaceRecipes
     /**
      * Adds a smelting recipe.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public void addSmelting(int par1, ItemStack par2ItemStack, float par3)
     {
         this.smeltingList.put(Integer.valueOf(par1), par2ItemStack);
         this.experienceList.put(Integer.valueOf(par2ItemStack.itemID), Float.valueOf(par3));
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the smelting result of an item.
@@ -68,4 +72,32 @@ public class FurnaceRecipes
     {
         return this.experienceList.containsKey(Integer.valueOf(par1)) ? ((Float)this.experienceList.get(Integer.valueOf(par1))).floatValue() : 0.0F;
     }
+    
+    // FCMOD: Code added
+    private Map m_CookTimeBinaryShiftMap = new HashMap();
+    
+    public void addSmelting( int iInputItemID, ItemStack outputStack, float fExperience )
+    {
+    	addSmelting( iInputItemID, outputStack, fExperience, 0 );
+    }
+    
+    public void addSmelting( int iInputItemID, ItemStack outputStack, float fExperience, int iCookTimeBinaryShift )
+    {
+        smeltingList.put( Integer.valueOf( iInputItemID ), outputStack );
+        
+        experienceList.put( Integer.valueOf( outputStack.itemID ), Float.valueOf( fExperience ) );
+        
+        m_CookTimeBinaryShiftMap.put( Integer.valueOf( iInputItemID ), Integer.valueOf( iCookTimeBinaryShift ) );
+    }
+    
+    public int GetCookTimeBinaryShift( int iItemID )
+    {
+    	if ( m_CookTimeBinaryShiftMap.containsKey( Integer.valueOf( iItemID ) ) )
+    	{
+    		return ((Integer)m_CookTimeBinaryShiftMap.get( Integer.valueOf( iItemID ) ) ).intValue();
+    	}
+    	
+    	return 0;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/GameSettings.java b/minecraft/net/minecraft/src/GameSettings.java
index e1967b0..d03287b 100644
--- a/minecraft/net/minecraft/src/GameSettings.java
+++ b/minecraft/net/minecraft/src/GameSettings.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.Config;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
@@ -145,7 +146,7 @@ public class GameSettings
         this.particleSetting = 0;
         this.language = "en_US";
         this.mc = par1Minecraft;
-        this.optionsFile = new File(par2File, "options.txt");
+        this.optionsFile = Config.getOptionsTxt(par2File, "options.txt");
         this.loadOptions();
     }
 
@@ -328,6 +329,12 @@ public class GameSettings
         if (par1EnumOptions == EnumOptions.DIFFICULTY)
         {
             this.difficulty = this.difficulty + par2 & 3;
+            // FCMOD: Code added to eliminate peaceful & easy (client only)
+            if ( difficulty < 2 )
+            {
+            	difficulty = 2;
+            }
+            // END FCMOD
         }
 
         if (par1EnumOptions == EnumOptions.GRAPHICS)
@@ -585,6 +592,12 @@ public class GameSettings
                     if (var3[0].equals("difficulty"))
                     {
                         this.difficulty = Integer.parseInt(var3[1]);
+                        // FCMOD: Code added to remove peaceful and easy (client only)
+                        if ( difficulty < 2 )
+                        {
+                        	difficulty = 2;
+                        }
+                        // END FCMOD
                     }
 
                     if (var3[0].equals("fancyGraphics"))
diff --git a/minecraft/net/minecraft/src/GuiContainer.java b/minecraft/net/minecraft/src/GuiContainer.java
index 59ef8f5..94d5583 100644
--- a/minecraft/net/minecraft/src/GuiContainer.java
+++ b/minecraft/net/minecraft/src/GuiContainer.java
@@ -109,16 +109,16 @@ public abstract class GuiContainer extends GuiScreen
 
         for (int var13 = 0; var13 < this.inventorySlots.inventorySlots.size(); ++var13)
         {
-            Slot var15 = (Slot)this.inventorySlots.inventorySlots.get(var13);
-            this.drawSlotInventory(var15);
+            Slot var14 = (Slot)this.inventorySlots.inventorySlots.get(var13);
+            this.drawSlotInventory(var14);
 
-            if (this.isMouseOverSlot(var15, par1, par2))
+            if (this.isMouseOverSlot(var14, par1, par2))
             {
-                this.theSlot = var15;
+                this.theSlot = var14;
                 GL11.glDisable(GL11.GL_LIGHTING);
                 GL11.glDisable(GL11.GL_DEPTH_TEST);
-                int var8 = var15.xDisplayPosition;
-                var9 = var15.yDisplayPosition;
+                int var8 = var14.xDisplayPosition;
+                var9 = var14.yDisplayPosition;
                 this.drawGradientRect(var8, var9, var8 + 16, var9 + 16, -2130706433, -2130706433);
                 GL11.glEnable(GL11.GL_LIGHTING);
                 GL11.glEnable(GL11.GL_DEPTH_TEST);
@@ -126,12 +126,12 @@ public abstract class GuiContainer extends GuiScreen
         }
 
         this.drawGuiContainerForegroundLayer(par1, par2);
-        InventoryPlayer var14 = this.mc.thePlayer.inventory;
-        ItemStack var16 = this.draggedStack == null ? var14.getItemStack() : this.draggedStack;
+        InventoryPlayer var15 = this.mc.thePlayer.inventory;
+        ItemStack var16 = this.draggedStack == null ? var15.getItemStack() : this.draggedStack;
 
         if (var16 != null)
         {
-            byte var17 = 8;
+            byte var18 = 8;
             var9 = this.draggedStack == null ? 8 : 16;
             String var10 = null;
 
@@ -151,29 +151,29 @@ public abstract class GuiContainer extends GuiScreen
                 }
             }
 
-            this.drawItemStack(var16, par1 - var4 - var17, par2 - var5 - var9, var10);
+            this.drawItemStack(var16, par1 - var4 - var18, par2 - var5 - var9, var10);
         }
 
         if (this.returningStack != null)
         {
-            float var18 = (float)(Minecraft.getSystemTime() - this.returningStackTime) / 100.0F;
+            float var17 = (float)(Minecraft.getSystemTime() - this.returningStackTime) / 100.0F;
 
-            if (var18 >= 1.0F)
+            if (var17 >= 1.0F)
             {
-                var18 = 1.0F;
+                var17 = 1.0F;
                 this.returningStack = null;
             }
 
             var9 = this.returningStackDestSlot.xDisplayPosition - this.field_85049_r;
             int var20 = this.returningStackDestSlot.yDisplayPosition - this.field_85048_s;
-            int var11 = this.field_85049_r + (int)((float)var9 * var18);
-            int var12 = this.field_85048_s + (int)((float)var20 * var18);
+            int var11 = this.field_85049_r + (int)((float)var9 * var17);
+            int var12 = this.field_85048_s + (int)((float)var20 * var17);
             this.drawItemStack(this.returningStack, var11, var12, (String)null);
         }
 
         GL11.glPopMatrix();
 
-        if (var14.getItemStack() == null && this.theSlot != null && this.theSlot.getHasStack())
+        if (var15.getItemStack() == null && this.theSlot != null && this.theSlot.getHasStack())
         {
             ItemStack var19 = this.theSlot.getStack();
             this.drawItemStackTooltip(var19, par1, par2);
@@ -386,14 +386,22 @@ public abstract class GuiContainer extends GuiScreen
             }
 
             GL11.glEnable(GL11.GL_DEPTH_TEST);
-            itemRenderer.renderItemAndEffectIntoGUI(this.fontRenderer, this.mc.renderEngine, var4, var2, var3);
+            
+            // FCMOD: Changed (client only)
+            //itemRenderer.renderItemAndEffectIntoGUI(this.fontRenderer, this.mc.renderEngine, var4, var2, var3);
+            if ( !DrawSlotSpecialItems( par1Slot, var4 ) )
+            {
+                itemRenderer.renderItemAndEffectIntoGUI(this.fontRenderer, this.mc.renderEngine, var4, var2, var3);
+            }
+            // END FCMOD
+            
             itemRenderer.renderItemOverlayIntoGUI(this.fontRenderer, this.mc.renderEngine, var4, var2, var3, var8);
         }
 
         itemRenderer.zLevel = 0.0F;
         this.zLevel = 0.0F;
     }
-
+    
     private void func_94066_g()
     {
         ItemStack var1 = this.mc.thePlayer.inventory.getItemStack();
@@ -772,6 +780,7 @@ public abstract class GuiContainer extends GuiScreen
             par2 = par1Slot.slotNumber;
         }
 
+        // FCNOTE: par2 is slotnumber, par3 is hotkey num, par4 2 when this is called by checkHotbarKeys()
         this.mc.playerController.windowClick(this.inventorySlots.windowId, par2, par3, par4, this.mc.thePlayer);
     }
 
@@ -811,6 +820,7 @@ public abstract class GuiContainer extends GuiScreen
             {
                 if (par1 == 2 + var2)
                 {
+                	// FCNOTE: 2 in the last param is a command code for hotswapping items
                     this.handleMouseClick(this.theSlot, this.theSlot.slotNumber, var2, 2);
                     return true;
                 }
@@ -851,4 +861,58 @@ public abstract class GuiContainer extends GuiScreen
             this.mc.thePlayer.closeScreen();
         }
     }
+    
+    // FCMOD: Added (client only)
+    private boolean DrawSlotSpecialItems( Slot slot, ItemStack stack )
+    {
+    	if ( stack != null )
+    	{
+    		int iItemID = stack.getItem().itemID;
+    		
+	    	if ( !IsPlayerInventorySlot( slot ) )
+	    	{
+		        if ( iItemID == Item.pocketSundial.itemID )
+		        {
+		        	TextureClock.m_clockTexture.UpdateInert();
+		        	
+		        	itemRenderer.renderItemAndEffectIntoGUI( fontRenderer, mc.renderEngine, stack, slot.xDisplayPosition, slot.yDisplayPosition );
+		
+		        	TextureClock.m_clockTexture.updateAnimation();
+		        	
+		        	return true;
+		        }
+	    	}
+	    	else
+	    	{
+		        if ( iItemID == Item.compass.itemID )
+		        {
+		        	TextureCompass.compassTexture.UpdateActive();
+		        	
+		        	itemRenderer.renderItemAndEffectIntoGUI( fontRenderer, mc.renderEngine, stack, slot.xDisplayPosition, slot.yDisplayPosition );
+		
+		        	TextureCompass.compassTexture.UpdateInert();
+		        	
+		        	return true;
+		        }
+	    	}
+    	}
+        
+        return false;
+    }
+    
+    private boolean IsPlayerInventorySlot( Slot slot )
+    {
+    	if ( mc.thePlayer.inventory == slot.inventory )
+    	{
+    		return true;
+    	}
+    	
+    	return false;
+    }
+
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/GuiIngame.java b/minecraft/net/minecraft/src/GuiIngame.java
index f68572c..0be841b 100644
--- a/minecraft/net/minecraft/src/GuiIngame.java
+++ b/minecraft/net/minecraft/src/GuiIngame.java
@@ -69,6 +69,10 @@ public class GuiIngame extends Gui
             this.renderPumpkinBlur(var6, var7);
         }
 
+        // FCMOD: Added (client only)
+        RenderModSpecificPlayerSightEffects();
+        // END FCMOD
+
         if (!this.mc.thePlayer.isPotionActive(Potion.confusion))
         {
             float var10 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * par1;
@@ -82,17 +86,17 @@ public class GuiIngame extends Gui
         boolean var11;
         int var12;
         int var13;
-        int var16;
         int var17;
+        int var16;
         int var18;
         int var20;
-        int var22;
         int var23;
+        int var22;
         int var24;
-        int var26;
         byte var27;
+        int var26;
         int var47;
-        int var52;
+        int var50;
 
         if (!this.mc.playerController.enableEverythingIsScrewedUpMode())
         {
@@ -158,8 +162,8 @@ public class GuiIngame extends Gui
 
                 this.mc.mcProfiler.endStartSection("healthArmor");
                 int var25;
-                int var28;
                 int var29;
+                int var28;
 
                 for (var25 = 0; var25 < 10; ++var25)
                 {
@@ -249,16 +253,18 @@ public class GuiIngame extends Gui
 
                 this.mc.mcProfiler.endStartSection("food");
 
+                // FCMOD: Changed to add more detail to hunger display (client only)
+                /*
                 for (var25 = 0; var25 < 10; ++var25)
                 {
                     var26 = var47;
-                    var52 = 16;
-                    byte var53 = 0;
+                    var50 = 16;
+                    byte var51 = 0;
 
                     if (this.mc.thePlayer.isPotionActive(Potion.hunger))
                     {
-                        var52 += 36;
-                        var53 = 13;
+                        var50 += 36;
+                        var51 = 13;
                     }
 
                     if (this.mc.thePlayer.getFoodStats().getSaturationLevel() <= 0.0F && this.updateCounter % (var16 * 3 + 1) == 0)
@@ -268,45 +274,55 @@ public class GuiIngame extends Gui
 
                     if (var14)
                     {
-                        var53 = 1;
+                        var51 = 1;
                     }
 
                     var29 = var19 - var25 * 8 - 9;
-                    this.drawTexturedModalRect(var29, var26, 16 + var53 * 9, 27, 9, 9);
+                    this.drawTexturedModalRect(var29, var26, 16 + var51 * 9, 27, 9, 9);
 
                     if (var14)
                     {
                         if (var25 * 2 + 1 < var17)
                         {
-                            this.drawTexturedModalRect(var29, var26, var52 + 54, 27, 9, 9);
+                            this.drawTexturedModalRect(var29, var26, var50 + 54, 27, 9, 9);
                         }
 
                         if (var25 * 2 + 1 == var17)
                         {
-                            this.drawTexturedModalRect(var29, var26, var52 + 63, 27, 9, 9);
+                            this.drawTexturedModalRect(var29, var26, var50 + 63, 27, 9, 9);
                         }
                     }
 
                     if (var25 * 2 + 1 < var16)
                     {
-                        this.drawTexturedModalRect(var29, var26, var52 + 36, 27, 9, 9);
+                        this.drawTexturedModalRect(var29, var26, var50 + 36, 27, 9, 9);
                     }
 
                     if (var25 * 2 + 1 == var16)
                     {
-                        this.drawTexturedModalRect(var29, var26, var52 + 45, 27, 9, 9);
+                        this.drawTexturedModalRect(var29, var26, var50 + 45, 27, 9, 9);
                     }
                 }
+                */
+                DrawFoodOverlay( var19, var47 );
+                
+                int iSightlessTextOffset = -8;
+                // END FCMOD
 
                 this.mc.mcProfiler.endStartSection("air");
 
+                // FCMOD: Change to display air gauge during recovery (client only)
+                /*
                 if (this.mc.thePlayer.isInsideOfMaterial(Material.water))
+                */
+                if (this.mc.thePlayer.isInsideOfMaterial(Material.water) || mc.thePlayer.getAir() < 300 )
+            	// END FCMOD 
                 {
                     var25 = this.mc.thePlayer.getAir();
                     var26 = MathHelper.ceiling_double_int((double)(var25 - 2) * 10.0D / 300.0D);
-                    var52 = MathHelper.ceiling_double_int((double)var25 * 10.0D / 300.0D) - var26;
+                    var50 = MathHelper.ceiling_double_int((double)var25 * 10.0D / 300.0D) - var26;
 
-                    for (var28 = 0; var28 < var26 + var52; ++var28)
+                    for (var28 = 0; var28 < var26 + var50; ++var28)
                     {
                         if (var28 < var26)
                         {
@@ -318,6 +334,14 @@ public class GuiIngame extends Gui
                         }
                     }
                 }
+                // FCMOD: Added (client only)
+                else if ( !DrawPenaltyText( var19, var22 ) )
+                {                	
+                	iSightlessTextOffset = 0;
+                }
+                
+                DrawSightlessText( var19, var22 + iSightlessTextOffset );
+                // END FCMOD
 
                 this.mc.mcProfiler.endSection();
             }
@@ -361,8 +385,8 @@ public class GuiIngame extends Gui
             this.mc.mcProfiler.endSection();
         }
 
-        int var36;
-        int var40;
+        int var38;
+        int var37;
 
         if (this.mc.playerController.func_78763_f() && this.mc.thePlayer.experienceLevel > 0)
         {
@@ -370,13 +394,13 @@ public class GuiIngame extends Gui
             var11 = false;
             var12 = var11 ? 16777215 : 8453920;
             String var34 = "" + this.mc.thePlayer.experienceLevel;
-            var36 = (var6 - var8.getStringWidth(var34)) / 2;
-            var40 = var7 - 31 - 4;
-            var8.drawString(var34, var36 + 1, var40, 0);
-            var8.drawString(var34, var36 - 1, var40, 0);
-            var8.drawString(var34, var36, var40 + 1, 0);
-            var8.drawString(var34, var36, var40 - 1, 0);
-            var8.drawString(var34, var36, var40, var12);
+            var38 = (var6 - var8.getStringWidth(var34)) / 2;
+            var37 = var7 - 31 - 4;
+            var8.drawString(var34, var38 + 1, var37, 0);
+            var8.drawString(var34, var38 - 1, var37, 0);
+            var8.drawString(var34, var38, var37 + 1, 0);
+            var8.drawString(var34, var38, var37 - 1, 0);
+            var8.drawString(var34, var38, var37, var12);
             this.mc.mcProfiler.endSection();
         }
 
@@ -397,19 +421,19 @@ public class GuiIngame extends Gui
                     var13 += 14;
                 }
 
-                var36 = (int)((float)this.remainingHighlightTicks * 256.0F / 10.0F);
+                var38 = (int)((float)this.remainingHighlightTicks * 256.0F / 10.0F);
 
-                if (var36 > 255)
+                if (var38 > 255)
                 {
-                    var36 = 255;
+                    var38 = 255;
                 }
 
-                if (var36 > 0)
+                if (var38 > 0)
                 {
                     GL11.glPushMatrix();
                     GL11.glEnable(GL11.GL_BLEND);
                     GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
-                    var8.drawStringWithShadow(var35, var12, var13, 16777215 + (var36 << 24));
+                    var8.drawStringWithShadow(var35, var12, var13, 16777215 + (var38 << 24));
                     GL11.glDisable(GL11.GL_BLEND);
                     GL11.glPopMatrix();
                 }
@@ -446,14 +470,16 @@ public class GuiIngame extends Gui
             var8.drawStringWithShadow(this.mc.getEntityDebug(), 2, 22, 16777215);
             var8.drawStringWithShadow(this.mc.debugInfoEntities(), 2, 32, 16777215);
             var8.drawStringWithShadow(this.mc.getWorldProviderName(), 2, 42, 16777215);
-            long var39 = Runtime.getRuntime().maxMemory();
-            long var37 = Runtime.getRuntime().totalMemory();
-            long var41 = Runtime.getRuntime().freeMemory();
-            long var44 = var37 - var41;
-            String var45 = "Used memory: " + var44 * 100L / var39 + "% (" + var44 / 1024L / 1024L + "MB) of " + var39 / 1024L / 1024L + "MB";
-            this.drawString(var8, var45, var6 - var8.getStringWidth(var45) - 2, 2, 14737632);
-            var45 = "Allocated memory: " + var37 * 100L / var39 + "% (" + var37 / 1024L / 1024L + "MB)";
-            this.drawString(var8, var45, var6 - var8.getStringWidth(var45) - 2, 12, 14737632);
+            long var36 = Runtime.getRuntime().maxMemory();
+            long var40 = Runtime.getRuntime().totalMemory();
+            long var43 = Runtime.getRuntime().freeMemory();
+            long var44 = var40 - var43;
+            String var46 = "Used memory: " + var44 * 100L / var36 + "% (" + var44 / 1024L / 1024L + "MB) of " + var36 / 1024L / 1024L + "MB";
+            this.drawString(var8, var46, var6 - var8.getStringWidth(var46) - 2, 2, 14737632);
+            var46 = "Allocated memory: " + var40 * 100L / var36 + "% (" + var40 / 1024L / 1024L + "MB)";
+            this.drawString(var8, var46, var6 - var8.getStringWidth(var46) - 2, 12, 14737632);
+            // FCMOD: Removed (client only)
+            /*
             var47 = MathHelper.floor_double(this.mc.thePlayer.posX);
             var22 = MathHelper.floor_double(this.mc.thePlayer.posY);
             var23 = MathHelper.floor_double(this.mc.thePlayer.posZ);
@@ -465,11 +491,16 @@ public class GuiIngame extends Gui
 
             if (this.mc.theWorld != null && this.mc.theWorld.blockExists(var47, var22, var23))
             {
-                Chunk var50 = this.mc.theWorld.getChunkFromBlockCoords(var47, var23);
-                this.drawString(var8, "lc: " + (var50.getTopFilledSegment() + 15) + " b: " + var50.getBiomeGenForWorldCoords(var47 & 15, var23 & 15, this.mc.theWorld.getWorldChunkManager()).biomeName + " bl: " + var50.getSavedLightValue(EnumSkyBlock.Block, var47 & 15, var22, var23 & 15) + " sl: " + var50.getSavedLightValue(EnumSkyBlock.Sky, var47 & 15, var22, var23 & 15) + " rl: " + var50.getBlockLightValue(var47 & 15, var22, var23 & 15, 0), 2, 96, 14737632);
+                Chunk var52 = this.mc.theWorld.getChunkFromBlockCoords(var47, var23);
+                this.drawString(var8, "lc: " + (var52.getTopFilledSegment() + 15) + " b: " + var52.getBiomeGenForWorldCoords(var47 & 15, var23 & 15, this.mc.theWorld.getWorldChunkManager()).biomeName + " bl: " + var52.getSavedLightValue(EnumSkyBlock.Block, var47 & 15, var22, var23 & 15) + " sl: " + var52.getSavedLightValue(EnumSkyBlock.Sky, var47 & 15, var22, var23 & 15) + " rl: " + var52.getBlockLightValue(var47 & 15, var22, var23 & 15, 0), 2, 96, 14737632);
             }
 
             this.drawString(var8, String.format("ws: %.3f, fs: %.3f, g: %b, fl: %d", new Object[] {Float.valueOf(this.mc.thePlayer.capabilities.getWalkSpeed()), Float.valueOf(this.mc.thePlayer.capabilities.getFlySpeed()), Boolean.valueOf(this.mc.thePlayer.onGround), Integer.valueOf(this.mc.theWorld.getHeightValue(var47, var23))}), 2, 104, 14737632);
+            */
+            // END FCMOD
+            // FCMOD: Added (client only)
+            RenderModDebugOverlay();
+            // END FCMOD
             GL11.glPopMatrix();
             this.mc.mcProfiler.endSection();
         }
@@ -527,12 +558,12 @@ public class GuiIngame extends Gui
         if (this.mc.gameSettings.keyBindPlayerList.pressed && (!this.mc.isIntegratedServerRunning() || this.mc.thePlayer.sendQueue.playerInfoList.size() > 1 || var42 != null))
         {
             this.mc.mcProfiler.startSection("playerList");
-            NetClientHandler var38 = this.mc.thePlayer.sendQueue;
-            List var43 = var38.playerInfoList;
-            var36 = var38.currentServerMaxPlayers;
-            var40 = var36;
+            NetClientHandler var39 = this.mc.thePlayer.sendQueue;
+            List var41 = var39.playerInfoList;
+            var38 = var39.currentServerMaxPlayers;
+            var37 = var38;
 
-            for (var16 = 1; var40 > 20; var40 = (var36 + var16 - 1) / var16)
+            for (var16 = 1; var37 > 20; var37 = (var38 + var16 - 1) / var16)
             {
                 ++var16;
             }
@@ -545,59 +576,59 @@ public class GuiIngame extends Gui
             }
 
             var18 = (var6 - var16 * var17) / 2;
-            byte var46 = 10;
-            drawRect(var18 - 1, var46 - 1, var18 + var17 * var16, var46 + 9 * var40, Integer.MIN_VALUE);
+            byte var45 = 10;
+            drawRect(var18 - 1, var45 - 1, var18 + var17 * var16, var45 + 9 * var37, Integer.MIN_VALUE);
 
-            for (var20 = 0; var20 < var36; ++var20)
+            for (var20 = 0; var20 < var38; ++var20)
             {
                 var47 = var18 + var20 % var16 * var17;
-                var22 = var46 + var20 / var16 * 9;
+                var22 = var45 + var20 / var16 * 9;
                 drawRect(var47, var22, var47 + var17 - 1, var22 + 8, 553648127);
                 GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
                 GL11.glEnable(GL11.GL_ALPHA_TEST);
 
-                if (var20 < var43.size())
+                if (var20 < var41.size())
                 {
-                    GuiPlayerInfo var48 = (GuiPlayerInfo)var43.get(var20);
-                    ScorePlayerTeam var49 = this.mc.theWorld.getScoreboard().getPlayersTeam(var48.name);
-                    String var51 = ScorePlayerTeam.func_96667_a(var49, var48.name);
-                    var8.drawStringWithShadow(var51, var47, var22, 16777215);
+                    GuiPlayerInfo var49 = (GuiPlayerInfo)var41.get(var20);
+                    ScorePlayerTeam var48 = this.mc.theWorld.getScoreboard().getPlayersTeam(var49.name);
+                    String var53 = ScorePlayerTeam.func_96667_a(var48, var49.name);
+                    var8.drawStringWithShadow(var53, var47, var22, 16777215);
 
                     if (var42 != null)
                     {
-                        var26 = var47 + var8.getStringWidth(var51) + 5;
-                        var52 = var47 + var17 - 12 - 5;
+                        var26 = var47 + var8.getStringWidth(var53) + 5;
+                        var50 = var47 + var17 - 12 - 5;
 
-                        if (var52 - var26 > 5)
+                        if (var50 - var26 > 5)
                         {
-                            Score var55 = var42.getScoreboard().func_96529_a(var48.name, var42);
-                            String var57 = EnumChatFormatting.YELLOW + "" + var55.func_96652_c();
-                            var8.drawStringWithShadow(var57, var52 - var8.getStringWidth(var57), var22, 16777215);
+                            Score var56 = var42.getScoreboard().func_96529_a(var49.name, var42);
+                            String var57 = EnumChatFormatting.YELLOW + "" + var56.func_96652_c();
+                            var8.drawStringWithShadow(var57, var50 - var8.getStringWidth(var57), var22, 16777215);
                         }
                     }
 
                     GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
                     this.mc.renderEngine.bindTexture("/gui/icons.png");
-                    byte var54 = 0;
-                    boolean var56 = false;
+                    byte var55 = 0;
+                    boolean var54 = false;
 
-                    if (var48.responseTime < 0)
+                    if (var49.responseTime < 0)
                     {
                         var27 = 5;
                     }
-                    else if (var48.responseTime < 150)
+                    else if (var49.responseTime < 150)
                     {
                         var27 = 0;
                     }
-                    else if (var48.responseTime < 300)
+                    else if (var49.responseTime < 300)
                     {
                         var27 = 1;
                     }
-                    else if (var48.responseTime < 600)
+                    else if (var49.responseTime < 600)
                     {
                         var27 = 2;
                     }
-                    else if (var48.responseTime < 1000)
+                    else if (var49.responseTime < 1000)
                     {
                         var27 = 3;
                     }
@@ -607,7 +638,7 @@ public class GuiIngame extends Gui
                     }
 
                     this.zLevel += 100.0F;
-                    this.drawTexturedModalRect(var47 + var17 - 12, var22, 0 + var54 * 10, 176 + var27 * 8, 10, 8);
+                    this.drawTexturedModalRect(var47 + var17 - 12, var22, 0 + var55 * 10, 176 + var27 * 8, 10, 8);
                     this.zLevel -= 100.0F;
                 }
             }
@@ -637,8 +668,8 @@ public class GuiIngame extends Gui
 
             int var22 = var6.size() * par4FontRenderer.FONT_HEIGHT;
             int var23 = par2 / 2 + var22 / 3;
-            byte var24 = 3;
-            int var25 = par3 - var7 - var24;
+            byte var25 = 3;
+            int var24 = par3 - var7 - var25;
             int var12 = 0;
             Iterator var13 = var6.iterator();
 
@@ -650,17 +681,17 @@ public class GuiIngame extends Gui
                 String var16 = ScorePlayerTeam.func_96667_a(var15, var14.func_96653_e());
                 String var17 = EnumChatFormatting.RED + "" + var14.func_96652_c();
                 int var19 = var23 - var12 * par4FontRenderer.FONT_HEIGHT;
-                int var20 = par3 - var24 + 2;
-                drawRect(var25 - 2, var19, var20, var19 + par4FontRenderer.FONT_HEIGHT, 1342177280);
-                par4FontRenderer.drawString(var16, var25, var19, 553648127);
+                int var20 = par3 - var25 + 2;
+                drawRect(var24 - 2, var19, var20, var19 + par4FontRenderer.FONT_HEIGHT, 1342177280);
+                par4FontRenderer.drawString(var16, var24, var19, 553648127);
                 par4FontRenderer.drawString(var17, var20 - par4FontRenderer.getStringWidth(var17), var19, 553648127);
 
                 if (var12 == var6.size())
                 {
                     String var21 = par1ScoreObjective.getDisplayName();
-                    drawRect(var25 - 2, var19 - par4FontRenderer.FONT_HEIGHT - 1, var20, var19 - 1, 1610612736);
-                    drawRect(var25 - 2, var19 - 1, var20, var19, 1342177280);
-                    par4FontRenderer.drawString(var21, var25 + var7 / 2 - par4FontRenderer.getStringWidth(var21) / 2, var19 - par4FontRenderer.FONT_HEIGHT, 553648127);
+                    drawRect(var24 - 2, var19 - par4FontRenderer.FONT_HEIGHT - 1, var20, var19 - 1, 1610612736);
+                    drawRect(var24 - 2, var19 - 1, var20, var19, 1342177280);
+                    par4FontRenderer.drawString(var21, var24 + var7 / 2 - par4FontRenderer.getStringWidth(var21) / 2, var19 - par4FontRenderer.FONT_HEIGHT, 553648127);
                 }
             }
         }
@@ -809,8 +840,24 @@ public class GuiIngame extends Gui
                 GL11.glTranslatef((float)(-(par2 + 8)), (float)(-(par3 + 12)), 0.0F);
             }
 
+            // FCMOD: Added (client only)
+    		int iItemID = var5.getItem().itemID;
+    		
+	        if ( iItemID == Item.compass.itemID )
+	        {
+	        	TextureCompass.compassTexture.UpdateActive();
+	        }
+            // END FCMOD
+	        
             itemRenderer.renderItemAndEffectIntoGUI(this.mc.fontRenderer, this.mc.renderEngine, var5, par2, par3);
 
+            // FCMOD: Added (client only)
+	        if ( iItemID == Item.compass.itemID )
+	        {
+	        	TextureCompass.compassTexture.UpdateInert();
+	        }
+            // END FCMOD
+	        
             if (var6 > 0.0F)
             {
                 GL11.glPopMatrix();
@@ -875,4 +922,627 @@ public class GuiIngame extends Gui
     {
         return this.updateCounter;
     }
+
+    // FCMOD: Added New (client only)
+	static final int m_iTrueSightRange = 10;
+	
+    private int m_iFoodLevelOnLastGUIUpdate = 0;
+    private float m_fFatOnLastGUIUpdate = 0F;
+    
+    public void RenderModDebugOverlay()
+    {
+    	AddChunkBoundaryDisplay( 64 );
+    	
+    	//AddMovementSpeedDisplay( 74 );
+    	
+    	//AddCurrentBiomeDisplay( 74 );
+    	
+    	AddLoadedChunksOnServerDisplay( 84 );        
+    }
+    
+    private void AddChunkBoundaryDisplay( int iYPos )
+    {
+        FontRenderer fontRenderer = mc.fontRenderer;
+        
+        int chunkX = MathHelper.floor_double(mc.thePlayer.posX) % 16;
+        
+        if ( chunkX < 0 )
+        {
+        	chunkX = 16 + chunkX;
+        }
+        
+        int iDistToChunkBndryX = chunkX;
+        
+        if ( 15 - chunkX < chunkX )
+        {
+        	iDistToChunkBndryX = 15 - chunkX;
+        }
+        
+        int chunkZ = MathHelper.floor_double(mc.thePlayer.posZ) % 16;
+        
+        if ( chunkZ < 0 )
+        {
+        	chunkZ = 16 + chunkZ;
+        }
+        
+        int iDistToChunkBndryZ = chunkZ;
+        
+        if ( 15 - chunkZ < chunkZ )
+        {
+        	iDistToChunkBndryZ = 15 - chunkZ;
+        }
+        
+        int iDistToChunkBndry = iDistToChunkBndryX;
+        
+        if ( iDistToChunkBndryZ < iDistToChunkBndryX )
+        {
+        	iDistToChunkBndry = iDistToChunkBndryZ;
+        }
+        
+        drawString(fontRenderer, String.format("Dist To Chnk Bndry: %d", new Object[]
+			{
+			     Integer.valueOf( iDistToChunkBndry )
+			}), 2, iYPos, 0xe0e0e0);
+    }
+    
+    private void AddCurrentBiomeDisplay( int iYPos )
+    {
+        FontRenderer fontRenderer = mc.fontRenderer;        
+        EntityPlayer player = mc.thePlayer;
+        
+        String sBiomeDescriptor;        
+        
+        BiomeGenBase biomeGen = player.worldObj.getBiomeGenForCoords( MathHelper.floor_double( player.posX ),
+        	MathHelper.floor_double( player.posZ ) );        
+        
+        if ( biomeGen != null )
+        {
+        	sBiomeDescriptor = biomeGen.getClass().getName(); 
+        }
+        else
+        {
+        	sBiomeDescriptor = "unknown";
+        }
+        
+        drawString( fontRenderer, "Biome: " + sBiomeDescriptor, 2, iYPos, 0xe0e0e0 );
+        
+    }
+    
+    private void AddMovementSpeedDisplay( int iYPos )
+    {
+        FontRenderer fontRenderer = mc.fontRenderer;
+        
+        double playerSpeed = Math.sqrt( ( mc.thePlayer.motionX * mc.thePlayer.motionX ) + ( mc.thePlayer.motionZ * mc.thePlayer.motionZ ) );
+        
+        
+        String sPlayerSpeedString = String.format("Player Speed: %.5f", new Object[] {
+    		Double.valueOf(playerSpeed) } ); 
+        	
+        drawString(fontRenderer, sPlayerSpeedString , 2, iYPos, 0xe0e0e0);
+                                                                                
+        double riddenSpeed = 0D;
+        
+        if ( mc.thePlayer.ridingEntity != null )
+        {
+        	riddenSpeed = Math.sqrt( ( mc.thePlayer.ridingEntity.motionX * mc.thePlayer.ridingEntity.motionX ) + ( mc.thePlayer.ridingEntity.motionZ * mc.thePlayer.ridingEntity.motionZ ) );
+        }
+        
+        
+        String sRiddenSpeedString = String.format("Ridden Speed: %.5f", new Object[] {
+    		Double.valueOf(riddenSpeed) } );
+        
+        ScaledResolution resolution = new ScaledResolution( mc.gameSettings, 
+        	mc.displayWidth, mc.displayHeight );
+        
+        int iXPos = 12 + fontRenderer.getStringWidth( sPlayerSpeedString );
+        
+        drawString(fontRenderer, String.format("Ridden Speed: %.5f", new Object[]
+			{
+        		Double.valueOf(riddenSpeed)
+			}), iXPos, iYPos, 0xe0e0e0);
+    }
+    
+    private void AddLoadedChunksOnServerDisplay( int iYPos )
+    {
+        if ( net.minecraft.server.MinecraftServer.getServer() != null )
+        {
+            FontRenderer fontrenderer = mc.fontRenderer;
+            
+        	if ( net.minecraft.server.MinecraftServer.getServer().worldServers[0] != null )
+        	{
+	            IChunkProvider provider = 
+	            	net.minecraft.server.MinecraftServer.getServer().worldServers[0].getChunkProvider();
+	            
+	            drawString( fontrenderer, "Overworld " + provider.makeString(), 2, 84, 0xe0e0e0 );
+        	}
+        	
+        	if ( net.minecraft.server.MinecraftServer.getServer().worldServers[1] != null )
+        	{
+	            IChunkProvider provider = 
+	            	net.minecraft.server.MinecraftServer.getServer().worldServers[1].getChunkProvider();
+	            
+	            drawString( fontrenderer, "Nether " + provider.makeString(), 2, 94, 0xe0e0e0 );
+        	}
+        	
+        	if ( net.minecraft.server.MinecraftServer.getServer().worldServers[2] != null )
+        	{
+	            IChunkProvider provider = 
+	            	net.minecraft.server.MinecraftServer.getServer().worldServers[2].getChunkProvider();
+	            
+	            drawString( fontrenderer, "End " + provider.makeString(), 2, 104, 0xe0e0e0 );
+        	}
+        }
+    }
+    
+    private void renderEnderSpectaclesBlur()
+    {
+        ScaledResolution resolution = new ScaledResolution( mc.gameSettings, 
+        	mc.displayWidth, mc.displayHeight);
+        
+        int iScreenWidth = resolution.getScaledWidth();
+        int iScreenHeight = resolution.getScaledHeight();
+        
+        GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GL11.glDepthMask(false);
+        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        GL11.glDisable(GL11.GL_ALPHA_TEST);
+        mc.renderEngine.bindTexture("%blur%/btwmodtex/spectaclesblur.png");
+        Tessellator tessellator = Tessellator.instance;
+        tessellator.startDrawingQuads();
+        tessellator.addVertexWithUV(0.0D, iScreenHeight, -90D, 0.0D, 1.0D);
+        tessellator.addVertexWithUV(iScreenWidth, iScreenHeight, -90D, 1.0D, 1.0D);
+        tessellator.addVertexWithUV(iScreenWidth, 0.0D, -90D, 1.0D, 0.0D);
+        tessellator.addVertexWithUV(0.0D, 0.0D, -90D, 0.0D, 0.0D);
+        tessellator.draw();
+        GL11.glDepthMask(true);
+        GL11.glEnable(GL11.GL_DEPTH_TEST);
+        GL11.glEnable(GL11.GL_ALPHA_TEST);
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);        
+    }
+    
+    public void RenderGameOverlayWithGuiDisabled(float fSmoothCameraPartialTicks, boolean bScreenActive, int iMouseX, int iMouseY )
+    {
+    	// Renders anything that has a gameplay effect when the player has the GUI turned off
+    	
+        ScaledResolution resolution = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight);
+        int iScreenWidth = resolution.getScaledWidth();
+        int iScreenHeight = resolution.getScaledHeight();
+        FontRenderer fontRenderer = this.mc.fontRenderer;
+        
+        mc.entityRenderer.setupOverlayRendering();
+        GL11.glEnable(GL11.GL_BLEND);
+
+        if (Minecraft.isFancyGraphicsEnabled())
+        {
+            this.renderVignette(this.mc.thePlayer.getBrightness(fSmoothCameraPartialTicks), iScreenWidth, iScreenHeight);
+        }
+        else
+        {
+            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+        }
+
+        ItemStack var9 = this.mc.thePlayer.inventory.armorItemInSlot(3);
+
+        if (this.mc.gameSettings.thirdPersonView == 0 && var9 != null && var9.itemID == Block.pumpkin.blockID)
+        {
+            this.renderPumpkinBlur(iScreenWidth, iScreenHeight);
+        }
+
+        RenderModSpecificPlayerSightEffects();
+
+        if (!this.mc.thePlayer.isPotionActive(Potion.confusion))
+        {
+            float var10 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * fSmoothCameraPartialTicks;
+
+            if (var10 > 0.0F)
+            {
+                this.renderPortalOverlay(var10, iScreenWidth, iScreenHeight);
+            }
+        }
+
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        GL11.glDisable(GL11.GL_LIGHTING);
+        GL11.glEnable(GL11.GL_ALPHA_TEST);
+    }
+    
+    private void RenderModSpecificPlayerSightEffects()
+    {
+        if ( mc.gameSettings.thirdPersonView == 0 )
+        {
+		    if ( mc.thePlayer.IsWearingEnderSpectacles() )
+		    {
+		        renderEnderSpectaclesBlur();
+		        
+		        AddTrueSightParticles();
+		        
+		    	// Decided against this as it may trivialize base measurement too much.
+		        //AddSpawnChunksParticles();
+		    }
+		    else if ( mc.thePlayer.isPotionActive( FCBetterThanWolves.potionTrueSight ) )
+		    {
+		        AddTrueSightParticles();
+		        
+		        AddSpawnChunksParticles();
+		    }
+        }
+    }
+    
+    private void AddTrueSightParticles()
+    {
+        // create particles where mobs can spawn
+        
+        if ( !mc.isGamePaused )
+        {
+            EntityPlayer player = mc.thePlayer;
+            World world = mc.theWorld;
+            int iParticleSetting = mc.gameSettings.particleSetting;
+            
+			int iPlayerI = MathHelper.floor_double( player.posX );
+			int iPlayerJ = MathHelper.floor_double( player.posY );
+			int iPlayerK = MathHelper.floor_double( player.posZ );
+			
+			for ( int iTempI = iPlayerI - m_iTrueSightRange; iTempI <= iPlayerI + m_iTrueSightRange; iTempI++ )
+			{
+				for ( int iTempJ = iPlayerJ - m_iTrueSightRange; iTempJ <= iPlayerJ + m_iTrueSightRange; iTempJ++ )
+				{
+					for ( int iTempK = iPlayerK - m_iTrueSightRange; iTempK <= iPlayerK + m_iTrueSightRange; iTempK++ )
+					{
+						if ( FCUtilsWorld.CanMobsSpawnHere( world, iTempI, iTempJ, iTempK ) )
+						{
+							double dVerticalOffset = 0D;
+							
+							Block blockBelow = Block.blocksList[world.getBlockId( 
+								iTempI, iTempJ - 1, iTempK )];
+							
+							if ( blockBelow != null )
+							{
+								dVerticalOffset = blockBelow.MobSpawnOnVerticalOffset( 
+									world, iTempI, iTempJ - 1, iTempK );
+							}
+							
+							if ( rand.nextInt( 12 ) <= ( 2 - iParticleSetting ) )
+							{
+								double particleX = (double)iTempI + rand.nextDouble();
+								
+								double particleY = (double)iTempJ + dVerticalOffset + 
+									rand.nextDouble() * 0.25D;
+								
+								double particleZ = (double)iTempK + rand.nextDouble();
+								
+								SpawnTrueSightParticle( world, particleX, particleY, particleZ );								
+							}
+						}
+					}
+				}
+			}
+        }        
+    }
+    
+    private void SpawnTrueSightParticle( World world, double dXPos, double dYPos, double dZPos )
+    {
+        EntityFX particleEntity = new EntitySpellParticleFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        
+        particleEntity.setRBGColorF( 0F, 0F, 0F );
+        
+        mc.effectRenderer.addEffect( (EntityFX)particleEntity );
+    }
+    
+    private void AddSpawnChunksParticles()
+    {
+        World world = mc.theWorld;
+        EntityPlayer player = mc.thePlayer;
+        
+        if ( !mc.isGamePaused && player.GetSpawnChunksVisualizationLocationJ() != 0 &&
+        	world.provider.dimensionId == 0 ) // is overworld
+        {   
+        	// Note that world.GetClampedViewDistanceInChunks() is not accurate on the client
+        	// and will always be 10, regardless of view-distance parameter on dedicated server
+        	int iViewDistanceChunks = world.GetClampedViewDistanceInChunks();
+        	
+        	int iFirstPassRange = ( iViewDistanceChunks + 2 ) * 16; // player has to be within these bounds
+        	
+            int iPlayerX = MathHelper.floor_double( player.posX );            
+            int iDeltaPosX = iPlayerX - player.GetSpawnChunksVisualizationLocationI();
+            
+            if ( iDeltaPosX >= -iFirstPassRange && iDeltaPosX <= iFirstPassRange )
+            {
+                int iPlayerZ = MathHelper.floor_double( player.posZ );            
+                int iDeltaPosZ = iPlayerZ - player.GetSpawnChunksVisualizationLocationK();
+                
+                if ( iDeltaPosZ >= -iFirstPassRange && iDeltaPosZ <= iFirstPassRange )
+                {
+                    int iParticleSetting = mc.gameSettings.particleSetting;
+                    
+                	int iNumParticles = 200 - ( iParticleSetting * 100 );
+                	
+                	for ( int iTempCount = 0; iTempCount < iNumParticles; iTempCount++ )
+                	{
+						double particleY = player.posY -(double)m_iTrueSightRange + 
+							( rand.nextDouble() * (double)m_iTrueSightRange * 2D );
+						
+						if ( particleY > 0D && particleY <= 256D )
+						{
+							double particleX = player.posX -(double)m_iTrueSightRange + 
+							( rand.nextDouble() * (double)m_iTrueSightRange * 2D );
+						
+							double particleZ = player.posZ -(double)m_iTrueSightRange + 
+							( rand.nextDouble() * (double)m_iTrueSightRange * 2D );
+						
+					    	int iSpawnChunkX = player.GetSpawnChunksVisualizationLocationI() >> 4;
+	            			int iSpawnChunkZ = player.GetSpawnChunksVisualizationLocationK() >> 4;
+	                	
+							if ( IsPosInSpawnChunkZone( particleX, particleY, particleZ,
+								iSpawnChunkX, iSpawnChunkZ, iViewDistanceChunks ) )
+							{
+								if ( IsPosInSpawnChunkZone( particleX, particleY, particleZ,
+									iSpawnChunkX, iSpawnChunkZ, iViewDistanceChunks - 2 ) )
+								{
+									if ( IsPosInSpawnBlock( player, particleX, particleY, particleZ ) )
+									{
+										SpawnSpawnPointParticle( world, particleX, particleY, particleZ );
+									}
+									else
+									{
+										SpawnSpawnChunkInnerParticle( world, particleX, particleY, particleZ );
+									}
+								}
+								else
+								{
+									SpawnSpawnChunkOuterParticle( world, particleX, particleY, particleZ );
+								}
+							}
+                		}
+                	}
+                }
+            }
+        }
+    }    
+    
+    private void SpawnSpawnChunkOuterParticle( World world, double dXPos, double dYPos, double dZPos )
+    {
+        EntityFX particleEntity = new EntityPortalFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        
+        particleEntity.setRBGColorF( 0F, 0F, 0.5F );
+        particleEntity.setAlphaF(0.5F);
+        
+        mc.effectRenderer.addEffect( (EntityFX)particleEntity );
+    }
+    
+    private void SpawnSpawnChunkInnerParticle( World world, double dXPos, double dYPos, double dZPos )
+    {
+        EntityFX particleEntity = new EntityCritFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        
+        particleEntity.setRBGColorF( 0.5F, 0F, 0.5F );
+        particleEntity.setAlphaF(0.25F);
+        
+        mc.effectRenderer.addEffect( (EntityFX)particleEntity );
+    }
+    
+    private void SpawnSpawnPointParticle( World world, double dXPos, double dYPos, double dZPos )
+    {
+        //EntityFX particleEntity = new EntityAuraFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        //EntityFX particleEntity = new EntityCritFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        //EntityFX particleEntity = new EntityPortalFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        EntityFX particleEntity = new EntityEnchantmentTableParticleFX( world, dXPos, dYPos, dZPos, 0.0D, 0.0D, 0.0D);
+        
+        particleEntity.setRBGColorF( 0.75F, 0F, 0F );
+        particleEntity.setAlphaF(0.5F);
+        
+        mc.effectRenderer.addEffect( (EntityFX)particleEntity );
+    }
+    
+    public boolean IsPosInSpawnChunkZone( double posX, double posY, double posZ, 
+    	int iSpawnChunkX, int iSpawnChunkZ, int iChunkRange )
+    {
+    	int iPosChunkX = MathHelper.floor_double( posX / 16D );
+    	int iDeltaX = iPosChunkX - iSpawnChunkX;  
+    	
+    	if ( iDeltaX >= -iChunkRange && iDeltaX <= iChunkRange )
+    	{    	
+    		int iPosChunkZ = MathHelper.floor_double( posZ / 16D );
+        	int iDeltaZ = iPosChunkZ - iSpawnChunkZ;  
+    		
+        	if ( iDeltaZ >= -iChunkRange && iDeltaZ <= iChunkRange )
+        	{
+        		return true;
+        	}
+    	}
+    	
+    	return false;
+    }
+    
+    public boolean IsPosInSpawnBlock( EntityPlayer player, double posX, double posY, double posZ )
+    {
+    	int iDeltaX = MathHelper.floor_double( posX ) - player.GetSpawnChunksVisualizationLocationI();
+    	
+    	if ( iDeltaX >= -1 && iDeltaX <= 1 )
+    	{
+    		int iDeltaZ = MathHelper.floor_double( posZ ) - player.GetSpawnChunksVisualizationLocationK();
+    		
+        	if ( iDeltaZ >= -1 && iDeltaZ <= 1 )
+        	{
+        		return true;
+        	}
+    	}
+    	
+    	return false;
+    }
+    
+    private int m_iFoodOverlayShakeCounter = 0;
+    
+    private void DrawFoodOverlay( int iScreenX, int iScreenY )
+    {
+        FoodStats stats = mc.thePlayer.getFoodStats();
+        
+        int iHungerPenalty = mc.thePlayer.GetHungerPenaltyLevel();
+        
+        int iFoodLevel = stats.getFoodLevel();
+        float fSaturationLevel = stats.getSaturationLevel();
+        int iSaturationPips = (int)( ( stats.getSaturationLevel() + 0.124F ) * 4F );
+        
+        int iFullHungerPips = iFoodLevel / 6;
+        
+        if ( mc.thePlayer.m_bExhaustionAddedSinceLastGuiUpdate )
+        {
+        	m_iFoodOverlayShakeCounter = 20;
+        	
+        	mc.thePlayer.m_bExhaustionAddedSinceLastGuiUpdate = false;
+        }
+        else if ( m_iFoodOverlayShakeCounter > 0 )
+        {
+        	m_iFoodOverlayShakeCounter--;
+        }
+        
+        for ( int iTempCount = 0; iTempCount < 10; ++iTempCount )
+        {
+            int iShankScreenY = iScreenY;
+            int iShankTextureOffsetX = 16;
+            byte iBackgroundTextureOffsetX = 0;
+
+            if ( mc.thePlayer.isPotionActive( Potion.hunger ) )
+            {
+                iShankTextureOffsetX += 36;
+                iBackgroundTextureOffsetX = 13;
+            }
+            else if ( iTempCount < iSaturationPips >> 3 )
+            {
+            	iBackgroundTextureOffsetX = 1;
+            }
+
+            if ( iHungerPenalty > 0 && updateCounter % ( iFoodLevel * 5 + 1 ) == 0 )
+            {
+                iShankScreenY = iScreenY + (this.rand.nextInt(3) - 1);
+            }
+            else if ( m_iFoodOverlayShakeCounter > 0 )
+            {
+            	int iShakeAmount = /*rand.nextInt( 2 ) +*/ 1;
+            	
+            	if ( rand.nextInt( 2 ) == 0 )
+            	{
+            		iShakeAmount = -iShakeAmount;
+            	}
+            	
+                iShankScreenY = iScreenY + iShakeAmount;
+            }
+
+            int iShankScreenX = iScreenX - iTempCount * 8 - 9;
+            
+            drawTexturedModalRect( iShankScreenX, iShankScreenY, 16 + iBackgroundTextureOffsetX * 9, 27, 9, 9 );
+            
+            if ( iTempCount == iSaturationPips >> 3 )
+            {
+            	if ( !mc.thePlayer.isPotionActive( Potion.hunger ) )
+            	{
+	            	int iPartialPips = iSaturationPips % 8;
+	            	
+	            	if ( iPartialPips != 0 )
+	            	{
+		            	// draw partial pips
+		            	
+		                drawTexturedModalRect( iShankScreenX + 8 - iPartialPips, iShankScreenY, 25 + 8 - iPartialPips, 27, 1 + iPartialPips, 9 );
+	            	}
+            	}
+            }
+
+            if ( iTempCount < iFullHungerPips )
+            {
+                drawTexturedModalRect( iShankScreenX, iShankScreenY, iShankTextureOffsetX + 36, 27, 9, 9);
+            }
+            else if ( iTempCount == iFullHungerPips )
+            {
+            	int iPartialPips = iFoodLevel % 6;
+            	
+            	if ( iPartialPips != 0 )
+            	{
+            		drawTexturedModalRect( iShankScreenX + 7 - iPartialPips, iShankScreenY, iShankTextureOffsetX + 36 + 7 - iPartialPips, 27, 3 + iPartialPips, 9);
+            	}
+            }
+        }        
+    }
+    
+    public static final String[] sHealthPenaltyDescriptions = new String[] { "Invalid", "Hurt", "Injured", "Wounded", "Crippled", "Dying" };
+    public static final String[] sHungerPenaltyDescriptions = new String[] { "Invalid", "Peckish", "Hungry", "Famished", "Starving", "Dying" };
+    public static final String[] sFatPenaltyDescriptions = new String[] { "Invalid", "Plump", "Chubby", "Fat", "Obese", "Invalid" };
+    
+	private boolean DrawPenaltyText( int iScreenX, int iScreenY )
+	{
+		if ( mc.thePlayer.isDead )
+		{
+			return false;
+		}
+		
+        FontRenderer rednerer = this.mc.fontRenderer;
+        String sPenaltyString = null;
+        
+        int iHealthPenalty = mc.thePlayer.GetHealthPenaltyLevel();
+        int iHungerPenalty = mc.thePlayer.GetHungerPenaltyLevel();
+        int iFatPenalty = mc.thePlayer.GetFatPenaltyLevel();
+        
+        if ( iHealthPenalty > 0 && iHealthPenalty >= iHungerPenalty && iHealthPenalty >= iFatPenalty )
+        {
+        	sPenaltyString = sHealthPenaltyDescriptions[iHealthPenalty];
+        }
+        else if ( iHungerPenalty > 0 && iHungerPenalty >= iFatPenalty )
+        {
+        	sPenaltyString = sHungerPenaltyDescriptions[iHungerPenalty];
+        }
+        else if ( iFatPenalty > 0 )
+        {
+        	sPenaltyString = sFatPenaltyDescriptions[iFatPenalty];
+        }        
+        
+        if ( sPenaltyString != null )
+        {
+            int iStringWidth = rednerer.getStringWidth( sPenaltyString );
+
+            rednerer.drawStringWithShadow( sPenaltyString, iScreenX - iStringWidth , iScreenY, 0XFFFFFF );
+            
+            return true;
+        }        
+        
+        return false;
+	}
+	
+	private void DrawSightlessText( int iScreenX, int iScreenY )
+	{
+        int iGloomLevel = mc.thePlayer.GetGloomLevel();
+        
+        if ( mc.thePlayer.GetGloomLevel() > 0 && !mc.thePlayer.isDead )
+        {
+            FontRenderer rednerer = this.mc.fontRenderer;
+            String sPenaltyString = null;
+            
+        	switch ( iGloomLevel )
+        	{
+        		case 2:
+        			
+	            	sPenaltyString = "Dread";
+	            	
+	            	break;
+	            	
+        		case 3:
+        			
+	            	sPenaltyString = "Terror";
+	            	
+	            	break;
+	            	
+	        	default:
+	        		
+	            	sPenaltyString = "Gloom";
+	            	
+	            	break;
+        	}
+        	
+            int iStringWidth = rednerer.getStringWidth( sPenaltyString );
+
+            rednerer.drawStringWithShadow( sPenaltyString, iScreenX - iStringWidth , iScreenY, 0XFFFFFF );
+        }
+	}
+	
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/GuiInventory.java b/minecraft/net/minecraft/src/GuiInventory.java
index 0830482..b2ebe99 100644
--- a/minecraft/net/minecraft/src/GuiInventory.java
+++ b/minecraft/net/minecraft/src/GuiInventory.java
@@ -57,6 +57,10 @@ public class GuiInventory extends InventoryEffectRenderer
     protected void drawGuiContainerForegroundLayer(int par1, int par2)
     {
         this.fontRenderer.drawString(StatCollector.translateToLocal("container.crafting"), 86, 16, 4210752);
+        
+        // FCMOD: Added (client only)
+        DrawSecondaryOutputIndicator();
+        // END FCMOD
     }
 
     /**
@@ -129,4 +133,29 @@ public class GuiInventory extends InventoryEffectRenderer
             this.mc.displayGuiScreen(new GuiStats(this, this.mc.statFileWriter));
         }
     }
+    // FCMOD: Added (client only)
+    private void DrawSecondaryOutputIndicator()
+    {
+    	if ( !mc.playerController.isInCreativeMode() )
+    	{
+	    	FCContainerPlayer container = (FCContainerPlayer)mc.thePlayer.inventoryContainer;
+	    	
+	    	if ( container != null )
+	    	{
+		        IRecipe recipe = CraftingManager.getInstance().FindMatchingRecipe(
+		        	container.craftMatrix, mc.theWorld );
+		        
+		        if ( recipe != null && recipe.HasSecondaryOutput() )
+		        {
+			        Slot outputSlot = (Slot)container.inventorySlots.get( 0 );
+			        
+			        int iDisplayX = outputSlot.xDisplayPosition + 20;
+			        int iDisplayY = outputSlot.yDisplayPosition + 5;
+			        
+			        FCClientUtilsRender.DrawSecondaryCraftingOutputIndicator( mc, iDisplayX, iDisplayY );
+		        }
+	    	}
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/GuiMainMenu.java b/minecraft/net/minecraft/src/GuiMainMenu.java
index 2eab63c..326d90b 100644
--- a/minecraft/net/minecraft/src/GuiMainMenu.java
+++ b/minecraft/net/minecraft/src/GuiMainMenu.java
@@ -530,7 +530,7 @@ public class GuiMainMenu extends GuiScreen
         GL11.glScalef(var8, var8, var8);
         this.drawCenteredString(this.fontRenderer, this.splashText, 0, -8, 16776960);
         GL11.glPopMatrix();
-        String var9 = "Minecraft 1.5.2";
+        String var9 = "Better Than Wolves CE V" + FCBetterThanWolves.fcVersionString;
 
         if (this.mc.isDemo())
         {
diff --git a/minecraft/net/minecraft/src/GuiMerchant.java b/minecraft/net/minecraft/src/GuiMerchant.java
index 0f3df69..14393a8 100644
--- a/minecraft/net/minecraft/src/GuiMerchant.java
+++ b/minecraft/net/minecraft/src/GuiMerchant.java
@@ -13,12 +13,20 @@ public class GuiMerchant extends GuiContainer
     private GuiButtonMerchant previousRecipeButtonIndex;
     private int currentRecipeIndex = 0;
     private String field_94082_v;
+    
+    // FCMOD: Added
+    private int iCurrentNumValidRecipes = 0;
+    private int iValidRecipesScrollOffset = 0;
+    // END FCMOD
 
     public GuiMerchant(InventoryPlayer par1, IMerchant par2, World par3World, String par4)
     {
         super(new ContainerMerchant(par1, par2, par3World));
         this.theIMerchant = par2;
         this.field_94082_v = par4 != null && par4.length() >= 1 ? par4 : StatCollector.translateToLocal("entity.Villager.name");
+        // FCMOD: Added
+        ySize = 239;
+        // END FCMOD
     }
 
     /**
@@ -29,8 +37,16 @@ public class GuiMerchant extends GuiContainer
         super.initGui();
         int var1 = (this.width - this.xSize) / 2;
         int var2 = (this.height - this.ySize) / 2;
+        // FCMOD: Changed
+        /*
         this.buttonList.add(this.nextRecipeButtonIndex = new GuiButtonMerchant(1, var1 + 120 + 27, var2 + 24 - 1, true));
         this.buttonList.add(this.previousRecipeButtonIndex = new GuiButtonMerchant(2, var1 + 36 - 19, var2 + 24 - 1, false));
+        */
+        this.buttonList.add(this.nextRecipeButtonIndex = new GuiButtonMerchant(1, var1 + 144, var2 + 118, true));
+        this.buttonList.add(this.previousRecipeButtonIndex = new GuiButtonMerchant(2, var1 + 34 - 14, var2 + 118, false));
+        this.nextRecipeButtonIndex.drawButton = false;
+        this.previousRecipeButtonIndex.drawButton = false;
+        // END FCMOD
         this.nextRecipeButtonIndex.enabled = false;
         this.previousRecipeButtonIndex.enabled = false;
     }
@@ -47,6 +63,8 @@ public class GuiMerchant extends GuiContainer
     /**
      * Called from the main game loop to update the screen.
      */
+    // FCMOD: Removed
+    /*
     public void updateScreen()
     {
         super.updateScreen();
@@ -58,22 +76,38 @@ public class GuiMerchant extends GuiContainer
             this.previousRecipeButtonIndex.enabled = this.currentRecipeIndex > 0;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Fired when a control is clicked. This is the equivalent of ActionListener.actionPerformed(ActionEvent e).
      */
+    // FCMOD: Removed
+    /*
     protected void actionPerformed(GuiButton par1GuiButton)
     {
         boolean var2 = false;
 
         if (par1GuiButton == this.nextRecipeButtonIndex)
         {
-            ++this.currentRecipeIndex;
+            ++this.currentRecipeIndex;            
+            // FCMOD: Sanity check added due to reported crash
+            if ( currentRecipeIndex > theIMerchant.getRecipes(this.mc.thePlayer).size() - 1 )
+            {
+            	currentRecipeIndex = theIMerchant.getRecipes(this.mc.thePlayer).size() - 1; 
+            }
+            // END FCMOD
             var2 = true;
         }
         else if (par1GuiButton == this.previousRecipeButtonIndex)
         {
             --this.currentRecipeIndex;
+            // FCMOD: Sanity check added due to reported crash
+            if ( currentRecipeIndex < 0 )
+            {
+            	currentRecipeIndex = 0;
+            }
+            // END FCMOD
             var2 = true;
         }
 
@@ -94,6 +128,8 @@ public class GuiMerchant extends GuiContainer
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Draw the background layer for the GuiContainer (everything behind the items)
@@ -101,7 +137,12 @@ public class GuiMerchant extends GuiContainer
     protected void drawGuiContainerBackgroundLayer(float par1, int par2, int par3)
     {
         GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        // FCMOD: Change
+        /*
         this.mc.renderEngine.bindTexture("/gui/trading.png");
+        */
+        mc.renderEngine.bindTexture( "/btwmodtex/fcguitrading.png" );
+        // END FCMOD
         int var4 = (this.width - this.xSize) / 2;
         int var5 = (this.height - this.ySize) / 2;
         this.drawTexturedModalRect(var4, var5, 0, 0, this.xSize, this.ySize);
@@ -114,18 +155,29 @@ public class GuiMerchant extends GuiContainer
 
             if (var8.func_82784_g())
             {
+                // FCMOD: Change
+                /*
                 this.mc.renderEngine.bindTexture("/gui/trading.png");
+                */
+                mc.renderEngine.bindTexture( "/btwmodtex/fcguitrading.png" );
+            	// END FCMOD
                 GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
                 GL11.glDisable(GL11.GL_LIGHTING);
                 this.drawTexturedModalRect(this.guiLeft + 83, this.guiTop + 21, 212, 0, 28, 21);
                 this.drawTexturedModalRect(this.guiLeft + 83, this.guiTop + 51, 212, 0, 28, 21);
             }
         }
+        
+        // FCMOD: Added
+        DrawXPDisplay();        
+        // END FCMOD
     }
 
     /**
      * Draws the screen and all the components in it.
      */
+    // FCMOD: Removed and replaced later
+    /*
     public void drawScreen(int par1, int par2, float par3)
     {
         super.drawScreen(par1, par2, par3);
@@ -180,6 +232,8 @@ public class GuiMerchant extends GuiContainer
             RenderHelper.enableStandardItemLighting();
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Gets the Instance of IMerchant interface.
@@ -188,4 +242,360 @@ public class GuiMerchant extends GuiContainer
     {
         return this.theIMerchant;
     }
-}
+    
+    // FCMOD: Added    
+    public void drawScreen( int iMouseX, int iMouseY, float fMysteryVariable )
+    {
+        super.drawScreen( iMouseX, iMouseY, fMysteryVariable );
+        
+        MerchantRecipeList recipeList = theIMerchant.getRecipes( mc.thePlayer );
+    	ContainerMerchant associatedContainer = GetAssociatedContainerMerchant();
+    	
+        if ( recipeList != null && !recipeList.isEmpty() && associatedContainer != null )
+        {
+            int iGuiX = (this.width - this.xSize) / 2;
+            int iGuiY = (this.height - this.ySize) / 2;
+            
+            GL11.glPushMatrix();
+            RenderHelper.enableGUIStandardItemLighting();
+            GL11.glDisable(GL11.GL_LIGHTING);
+            GL11.glEnable(GL12.GL_RESCALE_NORMAL);
+            GL11.glEnable(GL11.GL_COLOR_MATERIAL);
+            
+            int iNumRecipes = recipeList.size();
+            
+            if ( iNumRecipes > 8 )
+            {
+            	// gui can display a max of 8 recipes
+            	
+            	iNumRecipes = 8;
+            }
+            
+            ItemStack tooltipStack = null;
+            
+            int iOffsetY = 18;            
+            
+            for ( int iTempRecipeIndex = 0; iTempRecipeIndex < iNumRecipes; iTempRecipeIndex++ )
+            {
+                int iOffsetX = 8;
+                
+            	if ( iTempRecipeIndex % 2 == 1 )
+            	{
+                    iOffsetX = 8 + ( 18 * 5 );
+            	}
+            	/*
+            	else if ( iTempRecipeIndex == iNumRecipes - 1 )
+            	{
+            		// last item in an odd row, so center it
+            		
+                    iOffsetX = 8 + ( ( 18 * 5 ) - ( 9 + 36 ) );
+            	}
+            	*/
+            	
+	            MerchantRecipe tempRecipe = (MerchantRecipe)recipeList.get( iTempRecipeIndex );
+	            
+	            GL11.glEnable(GL11.GL_LIGHTING);
+	            
+	            ItemStack inputStack1 = tempRecipe.getItemToBuy();
+	            ItemStack inputStack2 = tempRecipe.getSecondItemToBuy();
+	            ItemStack outputStack = tempRecipe.getItemToSell();
+	            
+	            itemRenderer.zLevel = 100.0F;
+	            
+	            itemRenderer.renderItemAndEffectIntoGUI( fontRenderer, mc.renderEngine, inputStack1, iGuiX + iOffsetX, iGuiY + iOffsetY );
+	            itemRenderer.renderItemOverlayIntoGUI( fontRenderer, mc.renderEngine, inputStack1, iGuiX + iOffsetX, iGuiY + iOffsetY );
+	
+	            if (inputStack2 != null)
+	            {
+	                itemRenderer.renderItemAndEffectIntoGUI( fontRenderer, mc.renderEngine, inputStack2, iGuiX + iOffsetX + 18, iGuiY + iOffsetY );
+	                itemRenderer.renderItemOverlayIntoGUI( fontRenderer, mc.renderEngine, inputStack2, iGuiX + iOffsetX + 18, iGuiY + iOffsetY );
+	            }
+	
+	            itemRenderer.renderItemAndEffectIntoGUI( fontRenderer, mc.renderEngine, outputStack, iGuiX + iOffsetX + 54, iGuiY + iOffsetY );
+	            itemRenderer.renderItemOverlayIntoGUI( fontRenderer, mc.renderEngine, outputStack, iGuiX + iOffsetX + 54, iGuiY + iOffsetY );
+	            
+	            itemRenderer.zLevel = 0.0F;
+	            
+	            GL11.glDisable(GL11.GL_LIGHTING);
+	
+	            // draw arrow between input and output on active trades
+	            
+	            mc.renderEngine.bindTexture( "/btwmodtex/fcguitrading.png" );
+	            
+	            GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+	            
+	            if ( !tempRecipe.func_82784_g() ) // whether the recipe is expired
+	            {
+	                drawTexturedModalRect( iGuiX + iOffsetX + 36, iGuiY + iOffsetY, 176, 38, 16, 16 );
+	                
+	        		String sXPString = null;
+	    			
+	        		if ( tempRecipe.m_iTradeLevel < 0 )
+	        		{
+	        			if ( -( tempRecipe.m_iTradeLevel ) == associatedContainer.m_iAssociatedVillagerTradeLevel )
+	        			{
+	        				sXPString = "++";
+	        			}
+	        		}
+	        		else if ( tempRecipe.m_iTradeLevel == associatedContainer.m_iAssociatedVillagerTradeLevel && tempRecipe.m_iTradeLevel < 5 )
+	        		{
+	        			sXPString = "+";    			
+	        		}
+	        		
+	        		if ( sXPString != null )
+	        		{
+	                    int iLevelScreenX = iGuiX + iOffsetX + 45 - ( mc.fontRenderer.getStringWidth( sXPString ) / 2 );            
+	                    int iLevelScreenY = iGuiY + iOffsetY + 5;
+	                    
+	                    // black (0) outline of text
+	                    
+	                    mc.fontRenderer.drawString( sXPString, iLevelScreenX + 1, iLevelScreenY, 0 );            
+	                    mc.fontRenderer.drawString( sXPString, iLevelScreenX - 1, iLevelScreenY, 0 );
+	                    
+	                    mc.fontRenderer.drawString( sXPString, iLevelScreenX, iLevelScreenY + 1, 0 );
+	                    mc.fontRenderer.drawString( sXPString, iLevelScreenX, iLevelScreenY - 1, 0 );
+	                    
+	                    // text itself in the same color as vanilla xp display (8453920)
+	                    
+	                    mc.fontRenderer.drawString( sXPString, iLevelScreenX, iLevelScreenY, 8453920 );            
+	        		}
+	            }
+	            else
+	            {	                
+	                drawTexturedModalRect( iGuiX + iOffsetX + 36, iGuiY + iOffsetY, 191, 38, 16, 16 );
+	            }
+                
+	            if ( isPointInRegion( iOffsetX, iOffsetY, 16, 16, iMouseX, iMouseY ) )
+	            {
+	            	tooltipStack = inputStack1;
+	            }
+	            else if (inputStack2 != null && this.isPointInRegion( iOffsetX + 18, iOffsetY, 16, 16, iMouseX, iMouseY))
+	            {
+	            	tooltipStack = inputStack2;
+	            }
+	            else if ( isPointInRegion( iOffsetX + 53, iOffsetY, 16, 16, iMouseX, iMouseY ) )
+	            {
+	            	tooltipStack = outputStack;
+	            }	
+	            
+	            if ( iTempRecipeIndex % 2 == 1 )
+	            {
+	            	iOffsetY += 18;
+	            }
+            }
+            
+            if ( tooltipStack != null )
+            {
+            	// have to do this at the end so that recipes don't overlap it
+            	
+                drawItemStackTooltip( tooltipStack, iMouseX, iMouseY );
+            }
+            
+            GL11.glPopMatrix();
+            GL11.glEnable(GL11.GL_LIGHTING);
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            RenderHelper.enableStandardItemLighting();
+        }
+    }
+    
+    ContainerMerchant GetAssociatedContainerMerchant()
+    {
+    	if ( inventorySlots != null && inventorySlots instanceof ContainerMerchant )
+    	{
+    		return (ContainerMerchant)inventorySlots;
+    	}
+    	
+    	return null;
+    }
+    
+    private void DrawXPDisplay()
+    {
+    	ContainerMerchant associatedContainer = GetAssociatedContainerMerchant();
+    	
+    	if ( associatedContainer != null && associatedContainer.m_iAssociatedVillagerTradeLevel > 0 )
+    	{
+            mc.renderEngine.bindTexture( "/btwmodtex/fcguitrading.png" );
+            
+	        int xPos = ( width - xSize ) / 2;
+	        int yPos = ( height - ySize ) / 2;
+
+	        if ( associatedContainer.m_iAssociatedVillagerTradeMaxXP > 0 )
+	        {
+	        	int iXPBarIconWidth = 151;
+	        	float fXPBarScale = ( (float)associatedContainer.m_iAssociatedVillagerTradeXP / (float)associatedContainer.m_iAssociatedVillagerTradeMaxXP );
+	        	
+		        if ( associatedContainer.m_iAssociatedVillagerTradeLevel >= 5 )
+		        {
+		        	fXPBarScale = 1F;
+		        }
+		        
+		        int iScaledIconWidth = (int)( fXPBarScale * (float)iXPBarIconWidth );		        
+
+		        if ( iScaledIconWidth > 0 )
+		        {
+			        drawTexturedModalRect( xPos + 12,									// screen x pos 
+			        		yPos + 99, 													// screen y pos
+			        		0, 															// bitmap source x
+			        		251, 														// bitmap source y
+			        		iScaledIconWidth,											// width
+			        		5 );														// height
+		        }
+	        }
+	        
+	        // draw the experience level
+	        
+            String sLevelString = "" + associatedContainer.m_iAssociatedVillagerTradeLevel;
+            
+	        if ( associatedContainer.m_iAssociatedVillagerTradeLevel >= 5 )
+	        {
+	        	sLevelString = "Max";
+	        }
+	        
+            int iLevelScreenX = xPos + 88 - ( mc.fontRenderer.getStringWidth( sLevelString ) / 2 );            
+            int iLevelScreenY = yPos + 93;
+            
+            // black (0) outline of text
+            
+            mc.fontRenderer.drawString( sLevelString, iLevelScreenX + 1, iLevelScreenY, 0 );            
+            mc.fontRenderer.drawString( sLevelString, iLevelScreenX - 1, iLevelScreenY, 0 );
+            
+            mc.fontRenderer.drawString( sLevelString, iLevelScreenX, iLevelScreenY + 1, 0 );
+            mc.fontRenderer.drawString( sLevelString, iLevelScreenX, iLevelScreenY - 1, 0 );
+            
+            // text itself in the same color as vanilla xp display (8453920)
+            
+            mc.fontRenderer.drawString( sLevelString, iLevelScreenX, iLevelScreenY, 8453920 );
+    	}
+    }
+    
+	private int IsEmeraldOnlyBuyTrade( MerchantRecipe recipe )
+	{
+		// returns a value greater than zero (the cost in emeralds) if this is a straight purchase trade
+		
+		if ( recipe.getSecondItemToBuy() == null )
+		{
+			ItemStack firstItem = recipe.getItemToBuy();
+			
+			if ( firstItem != null && firstItem.itemID == Item.emerald.itemID )
+			{
+				return firstItem.stackSize;
+			}
+		}
+		
+		return 0;
+	}
+	
+    public void updateScreen()
+    {
+    	super.updateScreen();
+    	
+    	int iOldCurrentRecipe = currentRecipeIndex;
+    	
+        MerchantRecipeList recipeList = theIMerchant.getRecipes( mc.thePlayer );
+    	ContainerMerchant associatedContainer = GetAssociatedContainerMerchant();   	
+
+	    iCurrentNumValidRecipes = 0;
+    	
+        if ( recipeList != null && !recipeList.isEmpty() && associatedContainer != null )
+        {    
+        	InventoryMerchant merchantInventory = associatedContainer.getMerchantInventory();
+        	
+            ItemStack playerStack1 = merchantInventory.getStackInSlot( 0 );
+            ItemStack playerStack2 = merchantInventory.getStackInSlot( 1 );
+            
+            if ( playerStack1 != null || playerStack2 != null )
+            {
+	            int iNumRecipes = recipeList.size();
+	            
+	            for ( int iTempRecipeIndex = 0; iTempRecipeIndex < iNumRecipes; iTempRecipeIndex++ )
+	            {
+	            	if ( ( playerStack1 != null && recipeList.canRecipeBeUsed( playerStack1, playerStack2, iTempRecipeIndex ) != null ) ||
+	            		( playerStack2 != null && recipeList.canRecipeBeUsed( playerStack2, playerStack1, iTempRecipeIndex ) != null ) )
+	            	{
+            		    iCurrentNumValidRecipes++;
+            		    
+			            MerchantRecipe tempRecipe = (MerchantRecipe)recipeList.get( iTempRecipeIndex );
+			            
+	            		int iTempEmeraldTrade = IsEmeraldOnlyBuyTrade( tempRecipe );
+	            		
+	            		if ( iTempEmeraldTrade > 0 )
+	            		{
+	            			// we keep scanning through these until we find the highest value one the player's offer can purchase
+	            			
+	            			if ( iCurrentNumValidRecipes <= iValidRecipesScrollOffset + 1 )
+	            			{
+	            				currentRecipeIndex = iTempRecipeIndex;
+	            			}
+	            		}
+	            		else
+	            		{	            		
+	            		    iValidRecipesScrollOffset = 0;
+	            		    
+		            		currentRecipeIndex = iTempRecipeIndex;
+		            		
+		            		break;
+	            		}
+	            	}
+	            }
+	            
+	            if ( iOldCurrentRecipe != currentRecipeIndex )
+	            {
+	            	associatedContainer.setCurrentRecipeIndex(currentRecipeIndex);
+	                ByteArrayOutputStream var3 = new ByteArrayOutputStream();
+	                DataOutputStream var4 = new DataOutputStream(var3);
+	
+	                try
+	                {
+	                    var4.writeInt(this.currentRecipeIndex);
+	                    this.mc.getNetHandler().addToSendQueue(new Packet250CustomPayload("MC|TrSel", var3.toByteArray()));
+	                }
+	                catch (Exception var6)
+	                {
+	                    var6.printStackTrace();
+	                }
+	            }
+            }
+        }
+        
+        if ( iCurrentNumValidRecipes <= 0 || iValidRecipesScrollOffset >= iCurrentNumValidRecipes )
+        {
+		    iValidRecipesScrollOffset = 0;
+        }
+        
+        if ( iCurrentNumValidRecipes > 1 )
+        {
+        	nextRecipeButtonIndex.drawButton = true;
+        	previousRecipeButtonIndex.drawButton = true;
+        	
+	        nextRecipeButtonIndex.enabled = iValidRecipesScrollOffset < iCurrentNumValidRecipes - 1;
+	        previousRecipeButtonIndex.enabled = iValidRecipesScrollOffset > 0;
+        }
+        else
+        {
+        	nextRecipeButtonIndex.drawButton = false;
+        	previousRecipeButtonIndex.drawButton = false;
+        	
+	        nextRecipeButtonIndex.enabled = false;
+	        previousRecipeButtonIndex.enabled = false;
+        }
+    }
+    
+    protected void actionPerformed( GuiButton button )
+    {
+        if ( button == this.nextRecipeButtonIndex )
+        {
+        	if ( iValidRecipesScrollOffset < iCurrentNumValidRecipes - 1 )
+        	{
+        		iValidRecipesScrollOffset++;
+        	}
+        }
+        else if ( button == this.previousRecipeButtonIndex )
+        {
+        	if ( iValidRecipesScrollOffset > 0 )
+        	{
+        		iValidRecipesScrollOffset--;
+        	}
+        }
+    }
+    // END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/GuiSlotStatsItem.java b/minecraft/net/minecraft/src/GuiSlotStatsItem.java
index b0c4736..1fa8de5 100644
--- a/minecraft/net/minecraft/src/GuiSlotStatsItem.java
+++ b/minecraft/net/minecraft/src/GuiSlotStatsItem.java
@@ -79,7 +79,21 @@ class GuiSlotStatsItem extends GuiSlotStats
     {
         StatCrafting var6 = this.func_77257_d(par1);
         int var7 = var6.getItemID();
+        // FCMOD: Code change
+        /*
         GuiStats.drawItemSprite(this.slotGuiStats, par2 + 40, par3, var7);
+        */
+        if ( var7 == Item.pocketSundial.itemID )
+        {
+        	TextureClock.m_clockTexture.UpdateInert();
+            GuiStats.drawItemSprite(this.slotGuiStats, par2 + 40, par3, var7);
+        	TextureClock.m_clockTexture.updateAnimation();        	
+        }
+        else
+        {
+            GuiStats.drawItemSprite(this.slotGuiStats, par2 + 40, par3, var7);
+        }
+        // END FCMOD
         this.func_77260_a((StatCrafting)StatList.objectBreakStats[var7], par2 + 115, par3, par1 % 2 == 0);
         this.func_77260_a((StatCrafting)StatList.objectCraftStats[var7], par2 + 165, par3, par1 % 2 == 0);
         this.func_77260_a(var6, par2 + 215, par3, par1 % 2 == 0);
diff --git a/minecraft/net/minecraft/src/HttpUtilRunnable.java b/minecraft/net/minecraft/src/HttpUtilRunnable.java
index e6bdef1..d878b4b 100644
--- a/minecraft/net/minecraft/src/HttpUtilRunnable.java
+++ b/minecraft/net/minecraft/src/HttpUtilRunnable.java
@@ -49,101 +49,105 @@ final class HttpUtilRunnable implements Runnable
 
         try
         {
-            byte[] var4 = new byte[4096];
-            URL var5 = new URL(this.sourceURL);
-            var1 = var5.openConnection();
-            float var6 = 0.0F;
-            float var7 = (float)this.field_76177_c.entrySet().size();
-            Iterator var8 = this.field_76177_c.entrySet().iterator();
-
-            while (var8.hasNext())
-            {
-                Entry var9 = (Entry)var8.next();
-                var1.setRequestProperty((String)var9.getKey(), (String)var9.getValue());
-
-                if (this.feedbackHook != null)
-                {
-                    this.feedbackHook.setLoadingProgress((int)(++var6 / var7 * 100.0F));
-                }
-            }
-
-            var2 = var1.getInputStream();
-            var7 = (float)var1.getContentLength();
-            int var28 = var1.getContentLength();
-
-            if (this.feedbackHook != null)
-            {
-                this.feedbackHook.resetProgresAndWorkingMessage(String.format("Downloading file (%.2f MB)...", new Object[] {Float.valueOf(var7 / 1000.0F / 1000.0F)}));
-            }
-
-            if (this.destinationFile.exists())
+            try
             {
-                long var29 = this.destinationFile.length();
-
-                if (var29 == (long)var28)
+            	byte[] var4 = new byte[4096];
+                URL var5 = new URL(this.sourceURL);
+                var1 = var5.openConnection();
+                float var6 = 0.0F;
+                float var7 = (float)this.field_76177_c.entrySet().size();
+                Iterator var8 = this.field_76177_c.entrySet().iterator();
+
+                while (var8.hasNext())
                 {
-                    this.downloadSuccess.onSuccess(this.destinationFile);
+                	Entry var9 = (Entry)var8.next();
+                    var1.setRequestProperty((String)var9.getKey(), (String)var9.getValue());
 
                     if (this.feedbackHook != null)
                     {
-                        this.feedbackHook.onNoMoreProgress();
+                    	this.feedbackHook.setLoadingProgress((int)(++var6 / var7 * 100.0F));
                     }
-
-                    return;
                 }
 
-                System.out.println("Deleting " + this.destinationFile + " as it does not match what we currently have (" + var28 + " vs our " + var29 + ").");
-                this.destinationFile.delete();
-            }
-
-            var3 = new DataOutputStream(new FileOutputStream(this.destinationFile));
+                var2 = var1.getInputStream();
+                var7 = (float)var1.getContentLength();
+                int var28 = var1.getContentLength();
 
-            if (this.maxFileSize > 0 && var7 > (float)this.maxFileSize)
-            {
                 if (this.feedbackHook != null)
                 {
-                    this.feedbackHook.onNoMoreProgress();
+                	this.feedbackHook.resetProgresAndWorkingMessage(String.format("Downloading file (%.2f MB)...", new Object[] {Float.valueOf(var7 / 1000.0F / 1000.0F)}));
                 }
 
-                throw new IOException("Filesize is bigger than maximum allowed (file is " + var6 + ", limit is " + this.maxFileSize + ")");
-            }
+                if (this.destinationFile.exists())
+                {
+                    long var29 = this.destinationFile.length();
 
-            boolean var30 = false;
-            int var31;
+                    if (var29 == (long)var28)
+                    {
+                        this.downloadSuccess.onSuccess(this.destinationFile);
 
-            while ((var31 = var2.read(var4)) >= 0)
-            {
-                var6 += (float)var31;
+                        if (this.feedbackHook != null)
+                        {
+                            this.feedbackHook.onNoMoreProgress();
+                        }
 
-                if (this.feedbackHook != null)
-                {
-                    this.feedbackHook.setLoadingProgress((int)(var6 / var7 * 100.0F));
+                        return;
+                    }
+
+                    System.out.println("Deleting " + this.destinationFile + " as it does not match what we currently have (" + var28 + " vs our " + var29 + ").");
+                    this.destinationFile.delete();
                 }
 
-                if (this.maxFileSize > 0 && var6 > (float)this.maxFileSize)
+                var3 = new DataOutputStream(new FileOutputStream(this.destinationFile));
+
+                if (this.maxFileSize > 0 && var7 > (float)this.maxFileSize)
                 {
                     if (this.feedbackHook != null)
                     {
                         this.feedbackHook.onNoMoreProgress();
                     }
 
-                    throw new IOException("Filesize was bigger than maximum allowed (got >= " + var6 + ", limit was " + this.maxFileSize + ")");
+                    throw new IOException("Filesize is bigger than maximum allowed (file is " + var6 + ", limit is " + this.maxFileSize + ")");
                 }
 
-                var3.write(var4, 0, var31);
-            }
+                boolean var30 = false;
+                int var31;
 
-            this.downloadSuccess.onSuccess(this.destinationFile);
+                while ((var31 = var2.read(var4)) >= 0)
+                {
+                    var6 += (float)var31;
 
-            if (this.feedbackHook != null)
+                    if (this.feedbackHook != null)
+                    {
+                        this.feedbackHook.setLoadingProgress((int)(var6 / var7 * 100.0F));
+                    }
+
+                    if (this.maxFileSize > 0 && var6 > (float)this.maxFileSize)
+                    {
+                        if (this.feedbackHook != null)
+                        {
+                            this.feedbackHook.onNoMoreProgress();
+                        }
+
+                        throw new IOException("Filesize was bigger than maximum allowed (got >= " + var6 + ", limit was " + this.maxFileSize + ")");
+                    }
+
+                    var3.write(var4, 0, var31);
+                }
+
+                this.downloadSuccess.onSuccess(this.destinationFile);
+
+                if (this.feedbackHook != null)
+                {
+                    this.feedbackHook.onNoMoreProgress();
+                    return;
+                }
+            }
+            catch (Throwable var26)
             {
-                this.feedbackHook.onNoMoreProgress();
+            	var26.printStackTrace();
             }
         }
-        catch (Throwable var26)
-        {
-            var26.printStackTrace();
-        }
         finally
         {
             try
diff --git a/minecraft/net/minecraft/src/IMerchant.java b/minecraft/net/minecraft/src/IMerchant.java
index c9ea287..b900046 100644
--- a/minecraft/net/minecraft/src/IMerchant.java
+++ b/minecraft/net/minecraft/src/IMerchant.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 10/02/2018
+
 package net.minecraft.src;
 
 public interface IMerchant
@@ -11,4 +13,10 @@ public interface IMerchant
     void setRecipes(MerchantRecipeList var1);
 
     void useRecipe(MerchantRecipe var1);
+
+    // FCMOD: Added
+    public int GetCurrentTradeLevel(); 
+    public int GetCurrentTradeXP();
+    public int GetCurrentTradeMaxXP();
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/IRecipe.java b/minecraft/net/minecraft/src/IRecipe.java
index 0dc59af..1688e92 100644
--- a/minecraft/net/minecraft/src/IRecipe.java
+++ b/minecraft/net/minecraft/src/IRecipe.java
@@ -18,4 +18,14 @@ public interface IRecipe
     int getRecipeSize();
 
     ItemStack getRecipeOutput();
+    
+    // FCMOD: Added
+    public abstract boolean matches( IRecipe recipe );
+    
+    // NOTE: That secondary output is manually flagged rather than maintaining an internal 
+    // list of outputs because of SlotCrafting having no idea what recipe is being produced when 
+    // the output is collected.  It would be a mess of base class edits to change this.
+    
+    public abstract boolean HasSecondaryOutput();
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ISaveHandler.java b/minecraft/net/minecraft/src/ISaveHandler.java
index 8cf0b80..7ee4c3d 100644
--- a/minecraft/net/minecraft/src/ISaveHandler.java
+++ b/minecraft/net/minecraft/src/ISaveHandler.java
@@ -48,4 +48,10 @@ public interface ISaveHandler
      * Returns the name of the directory where world information is saved.
      */
     String getWorldDirectoryName();
+
+    // FCMOD: Added
+    public void LoadModSpecificData( WorldServer world );
+    
+    public void SaveModSpecificData( WorldServer world );
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/IconRegister.java b/minecraft/net/minecraft/src/IconRegister.java
index cbca42c..66ffe9a 100644
--- a/minecraft/net/minecraft/src/IconRegister.java
+++ b/minecraft/net/minecraft/src/IconRegister.java
@@ -3,4 +3,8 @@ package net.minecraft.src;
 public interface IconRegister
 {
     Icon registerIcon(String var1);
+    
+    // FCMOD: Code added (client only)
+    public Icon registerIcon( String sName, TextureStitched textureHandler );
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/IntegratedServer.java b/minecraft/net/minecraft/src/IntegratedServer.java
index 7aea2f1..54b569d 100644
--- a/minecraft/net/minecraft/src/IntegratedServer.java
+++ b/minecraft/net/minecraft/src/IntegratedServer.java
@@ -2,6 +2,8 @@ package net.minecraft.src;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Iterator;
+
 import net.minecraft.client.Minecraft;
 import net.minecraft.server.MinecraftServer;
 
@@ -123,6 +125,38 @@ public class IntegratedServer extends MinecraftServer
         {
             super.tick();
         }
+        // FCMOD: Added (client only)
+        else
+        {
+        	// this keeps terrain loading and being transmitted to the client even if the game is paused
+        	
+            for ( int iTempWorldIndex = 0; iTempWorldIndex < worldServers.length; iTempWorldIndex++ )
+            {
+                if ( iTempWorldIndex == 0 || getAllowNether() )
+                {
+                    WorldServer tempWorldServer = worldServers[iTempWorldIndex];
+                    
+                    if ( !tempWorldServer.playerEntities.isEmpty() )
+                    {
+                        Iterator playerIterator = tempWorldServer.playerEntities.iterator();
+                        
+                        while ( playerIterator.hasNext() )
+                        {
+                        	EntityPlayer tempPlayer = (EntityPlayer)playerIterator.next();
+                        	
+                        	// sanity check
+                        	if ( tempPlayer instanceof EntityPlayerMP )
+                        	{
+                        		EntityPlayerMP tempPlayerMP = (EntityPlayerMP)tempPlayer;
+	                        	
+	                        	tempPlayerMP.SendChunksToClient();
+                        	}
+                        }
+                    }
+                }
+            }
+        }
+        // END FCMOD
     }
 
     public boolean canStructuresSpawn()
diff --git a/minecraft/net/minecraft/src/InventoryMerchant.java b/minecraft/net/minecraft/src/InventoryMerchant.java
index 7acc2b2..3b65784 100644
--- a/minecraft/net/minecraft/src/InventoryMerchant.java
+++ b/minecraft/net/minecraft/src/InventoryMerchant.java
@@ -228,6 +228,10 @@ public class InventoryMerchant implements IInventory
                 }
             }
         }
+        
+        // FCMOD: Code added
+        ResetRecipeAndSlotsModProcessing();
+        // END FCMOD
     }
 
     public MerchantRecipe getCurrentRecipe()
@@ -240,4 +244,37 @@ public class InventoryMerchant implements IInventory
         this.currentRecipeIndex = par1;
         this.resetRecipeAndSlots();
     }
+    
+    // FCMOD: Code added
+    private void ResetRecipeAndSlotsModProcessing()
+    {
+    	ItemStack outputStack = theInventory[2];
+    	
+		if ( outputStack != null && outputStack.itemID == FCBetterThanWolves.fcItemAncientProphecy.itemID )
+		{
+			ItemStack manuscriptStack = theInventory[0];
+			
+			if ( manuscriptStack.itemID != Item.enchantedBook.itemID )
+			{
+				manuscriptStack = theInventory[1];
+			}
+			
+			int iEnchantmentID = -1;
+			
+			NBTTagList enchantmentTagList = Item.enchantedBook.func_92110_g( manuscriptStack );
+			
+			if ( enchantmentTagList != null && enchantmentTagList.tagCount() > 0 )
+			{
+                short iTempID = ((NBTTagCompound)enchantmentTagList.tagAt( 0 ) ).getShort("id");
+
+                if (Enchantment.enchantmentsList[iTempID] != null)
+                {
+                	iEnchantmentID = iTempID;                	
+                }
+			}
+			
+			((FCItemAncientProphecy)FCBetterThanWolves.fcItemAncientProphecy).InitializeProphecyDataFromEnchantmentID( outputStack, iEnchantmentID );
+		}
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/InventoryPlayer.java b/minecraft/net/minecraft/src/InventoryPlayer.java
index 5fd88f8..84cfbb6 100644
--- a/minecraft/net/minecraft/src/InventoryPlayer.java
+++ b/minecraft/net/minecraft/src/InventoryPlayer.java
@@ -507,13 +507,23 @@ public class InventoryPlayer implements IInventory
     /**
      * Gets the strength of the current item (tool) against the specified block, 1.0f if not holding anything.
      */
+    // FCMOD: Code change
+    /*
     public float getStrVsBlock(Block par1Block)
+    */
+    public float getStrVsBlock( World world, Block par1Block, int i, int j, int k )
+    // END FCMOD
     {
         float var2 = 1.0F;
 
         if (this.mainInventory[this.currentItem] != null)
         {
+            // FCMOD: Code change
+            /*
             var2 *= this.mainInventory[this.currentItem].getStrVsBlock(par1Block);
+            */
+            var2 *= this.mainInventory[this.currentItem].getStrVsBlock( world, par1Block, i, j, k );
+        	// END FCMOD
         }
 
         return var2;
@@ -644,7 +654,12 @@ public class InventoryPlayer implements IInventory
     /**
      * Returns whether the current item (tool) can harvest from the specified block (actually get a result).
      */
+    // FCMOD: Code change
+    /*
     public boolean canHarvestBlock(Block par1Block)
+    */
+    public boolean canHarvestBlock(World world, Block par1Block, int i, int j, int k)
+    // END FCMOD
     {
         if (par1Block.blockMaterial.isToolNotRequired())
         {
@@ -653,7 +668,12 @@ public class InventoryPlayer implements IInventory
         else
         {
             ItemStack var2 = this.getStackInSlot(this.currentItem);
+            // FCMOD: Code change
+            /*
             return var2 != null ? var2.canHarvestBlock(par1Block) : false;
+            */
+            return var2 != null ? var2.canHarvestBlock(world, par1Block, i, j, k) : false;
+            // END FCMOD
         }
     }
 
diff --git a/minecraft/net/minecraft/src/Item.java b/minecraft/net/minecraft/src/Item.java
index 7e7329b..dac3895 100644
--- a/minecraft/net/minecraft/src/Item.java
+++ b/minecraft/net/minecraft/src/Item.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cit.CITUtils;
 import java.util.List;
 import java.util.Random;
 
@@ -12,183 +13,187 @@ public class Item
 
     /** A 32000 elements Item array. */
     public static Item[] itemsList = new Item[32000];
-    public static Item shovelIron = (new ItemSpade(0, EnumToolMaterial.IRON)).setUnlocalizedName("shovelIron");
-    public static Item pickaxeIron = (new ItemPickaxe(1, EnumToolMaterial.IRON)).setUnlocalizedName("pickaxeIron");
-    public static Item axeIron = (new ItemAxe(2, EnumToolMaterial.IRON)).setUnlocalizedName("hatchetIron");
-    public static Item flintAndSteel = (new ItemFlintAndSteel(3)).setUnlocalizedName("flintAndSteel");
-    public static Item appleRed = (new ItemFood(4, 4, 0.3F, false)).setUnlocalizedName("apple");
-    public static ItemBow bow = (ItemBow)(new ItemBow(5)).setUnlocalizedName("bow");
-    public static Item arrow = (new Item(6)).setUnlocalizedName("arrow").setCreativeTab(CreativeTabs.tabCombat);
-    public static Item coal = (new ItemCoal(7)).setUnlocalizedName("coal");
-    public static Item diamond = (new Item(8)).setUnlocalizedName("diamond").setCreativeTab(CreativeTabs.tabMaterials);
+    
+    public static final int m_iFilterable_NoProperties = 0;
+    public static final int m_iFilterable_SolidBlock = 1;
+    public static final int m_iFilterable_Small = 2;
+    public static final int m_iFilterable_Narrow = 4;
+    public static final int m_iFilterable_Fine = 8;
+    public static final int m_iFilterable_Thin = 16;
+    
+    public static Item shovelIron = ( new FCItemShovel( 0, EnumToolMaterial.IRON ) ).setUnlocalizedName( "shovelIron" );
+    public static Item pickaxeIron = ( new FCItemPickaxe( 1, EnumToolMaterial.IRON ) ).setUnlocalizedName( "pickaxeIron" );
+    public static Item axeIron = ( new FCItemAxe( 2, EnumToolMaterial.IRON ) ).setUnlocalizedName( "hatchetIron" );
+    public static Item flintAndSteel = ( new FCItemFlintAndSteel( 3 ) ).setUnlocalizedName( "flintAndSteel" );
+    public static Item appleRed = ( new ItemFood( 4, 1, 0F, false ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "apple" );
+    public static ItemBow bow = new FCItemBow( 5 );
+    public static Item arrow = new FCItemArrow( 6 );
+    public static Item coal = ( new ItemCoal( 7 ) ).SetIncineratedInCrucible().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.COAL ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "coal" );
+    public static Item diamond = ( new Item( 8 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "diamond" ).setCreativeTab( CreativeTabs.tabMaterials );
     public static Item ingotIron = (new Item(9)).setUnlocalizedName("ingotIron").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item ingotGold = (new Item(10)).setUnlocalizedName("ingotGold").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item swordIron = (new ItemSword(11, EnumToolMaterial.IRON)).setUnlocalizedName("swordIron");
-    public static Item swordWood = (new ItemSword(12, EnumToolMaterial.WOOD)).setUnlocalizedName("swordWood");
-    public static Item shovelWood = (new ItemSpade(13, EnumToolMaterial.WOOD)).setUnlocalizedName("shovelWood");
-    public static Item pickaxeWood = (new ItemPickaxe(14, EnumToolMaterial.WOOD)).setUnlocalizedName("pickaxeWood");
-    public static Item axeWood = (new ItemAxe(15, EnumToolMaterial.WOOD)).setUnlocalizedName("hatchetWood");
-    public static Item swordStone = (new ItemSword(16, EnumToolMaterial.STONE)).setUnlocalizedName("swordStone");
-    public static Item shovelStone = (new ItemSpade(17, EnumToolMaterial.STONE)).setUnlocalizedName("shovelStone");
-    public static Item pickaxeStone = (new ItemPickaxe(18, EnumToolMaterial.STONE)).setUnlocalizedName("pickaxeStone");
-    public static Item axeStone = (new ItemAxe(19, EnumToolMaterial.STONE)).setUnlocalizedName("hatchetStone");
-    public static Item swordDiamond = (new ItemSword(20, EnumToolMaterial.EMERALD)).setUnlocalizedName("swordDiamond");
-    public static Item shovelDiamond = (new ItemSpade(21, EnumToolMaterial.EMERALD)).setUnlocalizedName("shovelDiamond");
-    public static Item pickaxeDiamond = (new ItemPickaxe(22, EnumToolMaterial.EMERALD)).setUnlocalizedName("pickaxeDiamond");
-    public static Item axeDiamond = (new ItemAxe(23, EnumToolMaterial.EMERALD)).setUnlocalizedName("hatchetDiamond");
-    public static Item stick = (new Item(24)).setFull3D().setUnlocalizedName("stick").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bowlEmpty = (new Item(25)).setUnlocalizedName("bowl").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bowlSoup = (new ItemSoup(26, 6)).setUnlocalizedName("mushroomStew");
-    public static Item swordGold = (new ItemSword(27, EnumToolMaterial.GOLD)).setUnlocalizedName("swordGold");
-    public static Item shovelGold = (new ItemSpade(28, EnumToolMaterial.GOLD)).setUnlocalizedName("shovelGold");
-    public static Item pickaxeGold = (new ItemPickaxe(29, EnumToolMaterial.GOLD)).setUnlocalizedName("pickaxeGold");
-    public static Item axeGold = (new ItemAxe(30, EnumToolMaterial.GOLD)).setUnlocalizedName("hatchetGold");
-    public static Item silk = (new ItemReed(31, Block.tripWire)).setUnlocalizedName("string").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item feather = (new Item(32)).setUnlocalizedName("feather").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item gunpowder = (new Item(33)).setUnlocalizedName("sulphur").setPotionEffect(PotionHelper.gunpowderEffect).setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item hoeWood = (new ItemHoe(34, EnumToolMaterial.WOOD)).setUnlocalizedName("hoeWood");
-    public static Item hoeStone = (new ItemHoe(35, EnumToolMaterial.STONE)).setUnlocalizedName("hoeStone");
-    public static Item hoeIron = (new ItemHoe(36, EnumToolMaterial.IRON)).setUnlocalizedName("hoeIron");
-    public static Item hoeDiamond = (new ItemHoe(37, EnumToolMaterial.EMERALD)).setUnlocalizedName("hoeDiamond");
-    public static Item hoeGold = (new ItemHoe(38, EnumToolMaterial.GOLD)).setUnlocalizedName("hoeGold");
-    public static Item seeds = (new ItemSeeds(39, Block.crops.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds");
-    public static Item wheat = (new Item(40)).setUnlocalizedName("wheat").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bread = (new ItemFood(41, 5, 0.6F, false)).setUnlocalizedName("bread");
-    public static ItemArmor helmetLeather = (ItemArmor)(new ItemArmor(42, EnumArmorMaterial.CLOTH, 0, 0)).setUnlocalizedName("helmetCloth");
-    public static ItemArmor plateLeather = (ItemArmor)(new ItemArmor(43, EnumArmorMaterial.CLOTH, 0, 1)).setUnlocalizedName("chestplateCloth");
-    public static ItemArmor legsLeather = (ItemArmor)(new ItemArmor(44, EnumArmorMaterial.CLOTH, 0, 2)).setUnlocalizedName("leggingsCloth");
-    public static ItemArmor bootsLeather = (ItemArmor)(new ItemArmor(45, EnumArmorMaterial.CLOTH, 0, 3)).setUnlocalizedName("bootsCloth");
-    public static ItemArmor helmetChain = (ItemArmor)(new ItemArmor(46, EnumArmorMaterial.CHAIN, 1, 0)).setUnlocalizedName("helmetChain");
-    public static ItemArmor plateChain = (ItemArmor)(new ItemArmor(47, EnumArmorMaterial.CHAIN, 1, 1)).setUnlocalizedName("chestplateChain");
-    public static ItemArmor legsChain = (ItemArmor)(new ItemArmor(48, EnumArmorMaterial.CHAIN, 1, 2)).setUnlocalizedName("leggingsChain");
-    public static ItemArmor bootsChain = (ItemArmor)(new ItemArmor(49, EnumArmorMaterial.CHAIN, 1, 3)).setUnlocalizedName("bootsChain");
-    public static ItemArmor helmetIron = (ItemArmor)(new ItemArmor(50, EnumArmorMaterial.IRON, 2, 0)).setUnlocalizedName("helmetIron");
-    public static ItemArmor plateIron = (ItemArmor)(new ItemArmor(51, EnumArmorMaterial.IRON, 2, 1)).setUnlocalizedName("chestplateIron");
-    public static ItemArmor legsIron = (ItemArmor)(new ItemArmor(52, EnumArmorMaterial.IRON, 2, 2)).setUnlocalizedName("leggingsIron");
-    public static ItemArmor bootsIron = (ItemArmor)(new ItemArmor(53, EnumArmorMaterial.IRON, 2, 3)).setUnlocalizedName("bootsIron");
-    public static ItemArmor helmetDiamond = (ItemArmor)(new ItemArmor(54, EnumArmorMaterial.DIAMOND, 3, 0)).setUnlocalizedName("helmetDiamond");
-    public static ItemArmor plateDiamond = (ItemArmor)(new ItemArmor(55, EnumArmorMaterial.DIAMOND, 3, 1)).setUnlocalizedName("chestplateDiamond");
-    public static ItemArmor legsDiamond = (ItemArmor)(new ItemArmor(56, EnumArmorMaterial.DIAMOND, 3, 2)).setUnlocalizedName("leggingsDiamond");
-    public static ItemArmor bootsDiamond = (ItemArmor)(new ItemArmor(57, EnumArmorMaterial.DIAMOND, 3, 3)).setUnlocalizedName("bootsDiamond");
-    public static ItemArmor helmetGold = (ItemArmor)(new ItemArmor(58, EnumArmorMaterial.GOLD, 4, 0)).setUnlocalizedName("helmetGold");
-    public static ItemArmor plateGold = (ItemArmor)(new ItemArmor(59, EnumArmorMaterial.GOLD, 4, 1)).setUnlocalizedName("chestplateGold");
-    public static ItemArmor legsGold = (ItemArmor)(new ItemArmor(60, EnumArmorMaterial.GOLD, 4, 2)).setUnlocalizedName("leggingsGold");
-    public static ItemArmor bootsGold = (ItemArmor)(new ItemArmor(61, EnumArmorMaterial.GOLD, 4, 3)).setUnlocalizedName("bootsGold");
-    public static Item flint = (new Item(62)).setUnlocalizedName("flint").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item porkRaw = (new ItemFood(63, 3, 0.3F, true)).setUnlocalizedName("porkchopRaw");
-    public static Item porkCooked = (new ItemFood(64, 8, 0.8F, true)).setUnlocalizedName("porkchopCooked");
-    public static Item painting = (new ItemHangingEntity(65, EntityPainting.class)).setUnlocalizedName("painting");
-    public static Item appleGold = (new ItemAppleGold(66, 4, 1.2F, false)).setAlwaysEdible().setPotionEffect(Potion.regeneration.id, 5, 0, 1.0F).setUnlocalizedName("appleGold");
-    public static Item sign = (new ItemSign(67)).setUnlocalizedName("sign");
-    public static Item doorWood = (new ItemDoor(68, Material.wood)).setUnlocalizedName("doorWood");
-    public static Item bucketEmpty = (new ItemBucket(69, 0)).setUnlocalizedName("bucket").setMaxStackSize(16);
-    public static Item bucketWater = (new ItemBucket(70, Block.waterMoving.blockID)).setUnlocalizedName("bucketWater").setContainerItem(bucketEmpty);
-    public static Item bucketLava = (new ItemBucket(71, Block.lavaMoving.blockID)).setUnlocalizedName("bucketLava").setContainerItem(bucketEmpty);
-    public static Item minecartEmpty = (new ItemMinecart(72, 0)).setUnlocalizedName("minecart");
-    public static Item saddle = (new ItemSaddle(73)).setUnlocalizedName("saddle");
+    public static Item swordIron = ( new FCItemSword( 11, EnumToolMaterial.IRON ) ).setUnlocalizedName( "swordIron" );
+    public static Item swordWood = ( new FCItemSword( 12, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "swordWood" );
+    public static Item shovelWood = ( new FCItemShovel( 13, EnumToolMaterial.WOOD ) ).SetDamageVsEntity( 2 ).setUnlocalizedName( "shovelWood" );
+    public static Item pickaxeWood = ( new FCItemPickaxe( 14, EnumToolMaterial.WOOD, 1 ) ).setUnlocalizedName( "pickaxeWood" );
+    public static Item axeWood = ( new FCItemAxe( 15, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "hatchetWood" );
+    public static Item swordStone = ( new FCItemSword( 16, EnumToolMaterial.STONE ) ).setUnlocalizedName( "swordStone" );	    
+    public static Item shovelStone = new FCItemShovelStone( 17 );
+    public static Item pickaxeStone = ( new FCItemPickaxe( 18, EnumToolMaterial.STONE ) ).setUnlocalizedName( "pickaxeStone" );
+    public static Item axeStone = ( new FCItemAxe( 19, EnumToolMaterial.STONE ) ).setUnlocalizedName( "hatchetStone" );
+    public static Item swordDiamond = ( new FCItemSword( 20, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "swordDiamond" );	    
+    public static Item shovelDiamond = ( new FCItemShovel( 21, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "shovelDiamond" );
+    public static Item pickaxeDiamond = ( new FCItemPickaxe( 22, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "pickaxeDiamond" );	    
+    public static Item axeDiamond = ( new FCItemAxe( 23, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "hatchetDiamond" );
+    public static Item stick = new FCItemShaft( 24 );    
+    public static Item bowlEmpty = ( new Item( 25 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "bowl" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item bowlSoup = ( new FCItemMushroomSoup( 26, 3 ) ).setUnlocalizedName( "mushroomStew" );
+    public static Item swordGold = ( new FCItemSword( 27, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "swordGold" );
+    public static Item shovelGold = ( new FCItemShovel( 28, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "shovelGold" );
+    public static Item pickaxeGold = ( new FCItemPickaxe( 29, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "pickaxeGold" );	    
+    public static Item axeGold = ( new FCItemAxe( 30, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "hatchetGold" );
+    public static Item silk = ( new Item( 31 ) ).SetBuoyant().SetBellowsBlowDistance( 2 ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "string" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item feather = ( new Item( 32 ) ).SetBuoyant().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "feather" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item gunpowder = ( new Item( 33 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "sulphur" ).setPotionEffect( PotionHelper.gunpowderEffect ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item hoeWood = ( new FCItemHoe( 34, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "hoeWood" );
+    public static Item hoeStone = ( new FCItemHoe( 35, EnumToolMaterial.STONE ) ).setUnlocalizedName( "hoeStone" );
+    public static Item hoeIron = ( new FCItemHoe( 36, EnumToolMaterial.IRON ) ).setUnlocalizedName( "hoeIron" );
+    public static Item hoeDiamond = ( new FCItemHoe( 37, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "hoeDiamond" );
+    public static Item hoeGold = ( new FCItemHoe( 38, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "hoeGold" );
+    public static Item seeds = ( new FCItemSeeds( 39, Block.crops.blockID ) ).SetAsBasicChickenFood().setUnlocalizedName( "seeds" ).setCreativeTab( null );
+    public static Item wheat = new FCItemWheatLegacy( 40 );
+    public static Item bread = ( new ItemFood( 41, 3, 0.25F, false ) ).setUnlocalizedName( "bread" );
+    public static ItemArmor helmetLeather = (ItemArmor)( new FCItemArmorLeather( 42, 0 ) ).setUnlocalizedName( "helmetCloth" );
+    public static ItemArmor plateLeather = (ItemArmor)( new FCItemArmorLeather( 43, 1 ) ).setUnlocalizedName( "chestplateCloth" );
+    public static ItemArmor legsLeather = (ItemArmor)( new FCItemArmorLeather( 44, 2 ) ).setUnlocalizedName( "leggingsCloth" );
+    public static ItemArmor bootsLeather = (ItemArmor)( new FCItemArmorLeather( 45, 3 ) ).setUnlocalizedName( "bootsCloth" );    
+    public static ItemArmor helmetChain = (ItemArmor)( new FCItemArmorChain( 46, 0, 3 ) ).setUnlocalizedName( "helmetChain" );
+    public static ItemArmor plateChain = (ItemArmor)( new FCItemArmorChain( 47, 1, 4 ) ).setUnlocalizedName( "chestplateChain" );
+    public static ItemArmor legsChain = (ItemArmor)( new FCItemArmorChain( 48, 2, 4 ) ).setUnlocalizedName( "leggingsChain" );
+    public static ItemArmor bootsChain = (ItemArmor)( new FCItemArmorChain( 49, 3, 2 ) ).setUnlocalizedName( "bootsChain" );
+    public static ItemArmor helmetIron = (ItemArmor)( new FCItemArmorIron( 50, 0, 5 ) ).setUnlocalizedName( "helmetIron" );
+    public static ItemArmor plateIron = (ItemArmor)( new FCItemArmorIron( 51, 1, 8 ) ).setUnlocalizedName( "chestplateIron" );
+    public static ItemArmor legsIron = (ItemArmor)( new FCItemArmorIron( 52, 2, 7 ) ).setUnlocalizedName( "leggingsIron" );
+    public static ItemArmor bootsIron = (ItemArmor)( new FCItemArmorIron( 53, 3, 4 ) ).setUnlocalizedName( "bootsIron" );
+    public static ItemArmor helmetDiamond = (ItemArmor)( new FCItemArmorDiamond( 54, 0, 5 ) ).setUnlocalizedName( "helmetDiamond" );
+    public static ItemArmor plateDiamond = (ItemArmor)( new FCItemArmorDiamond( 55, 1, 8 ) ).setUnlocalizedName( "chestplateDiamond" );
+    public static ItemArmor legsDiamond = (ItemArmor)( new FCItemArmorDiamond( 56, 2, 7 ) ).setUnlocalizedName( "leggingsDiamond" );
+    public static ItemArmor bootsDiamond = (ItemArmor)( new FCItemArmorDiamond( 57, 3, 4 ) ).setUnlocalizedName( "bootsDiamond" );
+    public static ItemArmor helmetGold = (ItemArmor)( new FCItemArmorGold( 58, 0, 5 ) ).setUnlocalizedName( "helmetGold" );
+    public static ItemArmor plateGold = (ItemArmor)( new FCItemArmorGold( 59, 1, 8 ) ).setUnlocalizedName( "chestplateGold" );
+    public static ItemArmor legsGold = (ItemArmor)( new FCItemArmorGold( 60, 2, 7 ) ).setUnlocalizedName( "leggingsGold" );
+    public static ItemArmor bootsGold = (ItemArmor)( new FCItemArmorGold( 61, 3, 4 ) ).setUnlocalizedName( "bootsGold" );
+    public static Item flint = new FCItemFlint( 62 );
+    public static Item porkRaw = ( new FCItemFood( 63, FCItemFood.m_iPorkChopRawHungerHealed, FCItemFood.m_fPorkChopSaturationModifier, true, "porkchopRaw", true ) ).SetStandardFoodPoisoningEffect();    
+    public static Item porkCooked = ( new ItemFood( 64, FCItemFood.m_iPorkChopCookedHungerHealed, FCItemFood.m_fPorkChopSaturationModifier, true ) ).setUnlocalizedName( "porkchopCooked" );    
+    public static Item painting = ( new ItemHangingEntity( 65, EntityPainting.class ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "painting" );
+    public static Item appleGold = ( new ItemAppleGold( 66, 1, 0F, false ) ).setAlwaysEdible().setPotionEffect( Potion.regeneration.id, 5, 0, 1F ).SetNonBuoyant().SetNotIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "appleGold" );
+    public static Item sign = new FCItemSign( 67 );
+    public static Item doorWood = new FCItemDoorWood( 68 );	    
+    public static Item bucketEmpty = new FCItemBucketEmpty( 69 );
+    public static Item bucketWater = new FCItemBucketWater( 70 );
+    public static Item bucketLava = new FCItemBucketLava( 71 );
+    public static Item minecartEmpty = ( new FCItemMinecart( 72, 0 ) ).setUnlocalizedName( "minecart" );
+    public static Item saddle = ( new ItemSaddle( 73 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "saddle" );
     public static Item doorIron = (new ItemDoor(74, Material.iron)).setUnlocalizedName("doorIron");
-    public static Item redstone = (new ItemRedstone(75)).setUnlocalizedName("redstone").setPotionEffect(PotionHelper.redstoneEffect);
-    public static Item snowball = (new ItemSnowball(76)).setUnlocalizedName("snowball");
-    public static Item boat = (new ItemBoat(77)).setUnlocalizedName("boat");
-    public static Item leather = (new Item(78)).setUnlocalizedName("leather").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bucketMilk = (new ItemBucketMilk(79)).setUnlocalizedName("milk").setContainerItem(bucketEmpty);
-    public static Item brick = (new Item(80)).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item clay = (new Item(81)).setUnlocalizedName("clay").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item reed = (new ItemReed(82, Block.reed)).setUnlocalizedName("reeds").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item paper = (new Item(83)).setUnlocalizedName("paper").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item book = (new ItemBook(84)).setUnlocalizedName("book").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item slimeBall = (new Item(85)).setUnlocalizedName("slimeball").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item minecartCrate = (new ItemMinecart(86, 1)).setUnlocalizedName("minecartChest");
-    public static Item minecartPowered = (new ItemMinecart(87, 2)).setUnlocalizedName("minecartFurnace");
-    public static Item egg = (new ItemEgg(88)).setUnlocalizedName("egg");
+    public static Item redstone = new FCItemRedstone( 75 );
+    public static Item snowball = new FCItemSnowball( 76 );
+    public static Item boat = new FCItemBoat( 77 );
+    public static Item leather = ( new Item( 78 ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Thin ).setUnlocalizedName( "leather" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item bucketMilk = new FCItemBucketMilk( 79 );    	
+    public static Item brick = new FCItemBrick( 80 );
+    public static Item clay = new FCItemClay( 81 );
+    public static Item reed = ( new ItemReed( 82, Block.reed ) ).SetBuoyant().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Narrow ).setUnlocalizedName( "reeds" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item paper = ( new Item( 83 ) ).SetBuoyant().SetBellowsBlowDistance( 3 ).SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "paper" ).setCreativeTab( CreativeTabs.tabMisc );
+    public static Item book = new FCItemBook( 84 );
+    public static Item slimeBall = new FCItemSlimeball( 85 );
+    public static Item minecartCrate = ( new FCItemMinecart( 86, 1 ) ).setUnlocalizedName( "minecartChest" );
+    public static Item minecartPowered = ( new FCItemMinecart( 87, 2 ) ).setUnlocalizedName( "minecartFurnace" );
+    public static Item egg = new FCItemEgg( 88 );
     public static Item compass = (new Item(89)).setUnlocalizedName("compass").setCreativeTab(CreativeTabs.tabTools);
-    public static ItemFishingRod fishingRod = (ItemFishingRod)(new ItemFishingRod(90)).setUnlocalizedName("fishingRod");
+    public static ItemFishingRod fishingRod = new FCItemFishingRod( 90 );
     public static Item pocketSundial = (new Item(91)).setUnlocalizedName("clock").setCreativeTab(CreativeTabs.tabTools);
-    public static Item lightStoneDust = (new Item(92)).setUnlocalizedName("yellowDust").setPotionEffect(PotionHelper.glowstoneEffect).setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item fishRaw = (new ItemFood(93, 2, 0.3F, false)).setUnlocalizedName("fishRaw");
-    public static Item fishCooked = (new ItemFood(94, 5, 0.6F, false)).setUnlocalizedName("fishCooked");
-    public static Item dyePowder = (new ItemDye(95)).setUnlocalizedName("dyePowder");
-    public static Item bone = (new Item(96)).setUnlocalizedName("bone").setFull3D().setCreativeTab(CreativeTabs.tabMisc);
-    public static Item sugar = (new Item(97)).setUnlocalizedName("sugar").setPotionEffect(PotionHelper.sugarEffect).setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item cake = (new ItemReed(98, Block.cake)).setMaxStackSize(1).setUnlocalizedName("cake").setCreativeTab(CreativeTabs.tabFood);
-    public static Item bed = (new ItemBed(99)).setMaxStackSize(1).setUnlocalizedName("bed");
-    public static Item redstoneRepeater = (new ItemReed(100, Block.redstoneRepeaterIdle)).setUnlocalizedName("diode").setCreativeTab(CreativeTabs.tabRedstone);
-    public static Item cookie = (new ItemFood(101, 2, 0.1F, false)).setUnlocalizedName("cookie");
-    public static ItemMap map = (ItemMap)(new ItemMap(102)).setUnlocalizedName("map");
-
-    /**
-     * Item introduced on 1.7 version, is a shear to cut leaves (you can keep the block) or get wool from sheeps.
-     */
-    public static ItemShears shears = (ItemShears)(new ItemShears(103)).setUnlocalizedName("shears");
-    public static Item melon = (new ItemFood(104, 2, 0.3F, false)).setUnlocalizedName("melon");
-    public static Item pumpkinSeeds = (new ItemSeeds(105, Block.pumpkinStem.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds_pumpkin");
-    public static Item melonSeeds = (new ItemSeeds(106, Block.melonStem.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds_melon");
-    public static Item beefRaw = (new ItemFood(107, 3, 0.3F, true)).setUnlocalizedName("beefRaw");
-    public static Item beefCooked = (new ItemFood(108, 8, 0.8F, true)).setUnlocalizedName("beefCooked");
-    public static Item chickenRaw = (new ItemFood(109, 2, 0.3F, true)).setPotionEffect(Potion.hunger.id, 30, 0, 0.3F).setUnlocalizedName("chickenRaw");
-    public static Item chickenCooked = (new ItemFood(110, 6, 0.6F, true)).setUnlocalizedName("chickenCooked");
-    public static Item rottenFlesh = (new ItemFood(111, 4, 0.1F, true)).setPotionEffect(Potion.hunger.id, 30, 0, 0.8F).setUnlocalizedName("rottenFlesh");
-    public static Item enderPearl = (new ItemEnderPearl(112)).setUnlocalizedName("enderPearl");
-    public static Item blazeRod = (new Item(113)).setUnlocalizedName("blazeRod").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item ghastTear = (new Item(114)).setUnlocalizedName("ghastTear").setPotionEffect(PotionHelper.ghastTearEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item goldNugget = (new Item(115)).setUnlocalizedName("goldNugget").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item netherStalkSeeds = (new ItemSeeds(116, Block.netherStalk.blockID, Block.slowSand.blockID)).setUnlocalizedName("netherStalkSeeds").setPotionEffect("+4");
-    public static ItemPotion potion = (ItemPotion)(new ItemPotion(117)).setUnlocalizedName("potion");
-    public static Item glassBottle = (new ItemGlassBottle(118)).setUnlocalizedName("glassBottle");
-    public static Item spiderEye = (new ItemFood(119, 2, 0.8F, false)).setPotionEffect(Potion.poison.id, 5, 0, 1.0F).setUnlocalizedName("spiderEye").setPotionEffect(PotionHelper.spiderEyeEffect);
-    public static Item fermentedSpiderEye = (new Item(120)).setUnlocalizedName("fermentedSpiderEye").setPotionEffect(PotionHelper.fermentedSpiderEyeEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item blazePowder = (new Item(121)).setUnlocalizedName("blazePowder").setPotionEffect(PotionHelper.blazePowderEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item magmaCream = (new Item(122)).setUnlocalizedName("magmaCream").setPotionEffect(PotionHelper.magmaCreamEffect).setCreativeTab(CreativeTabs.tabBrewing);
+    public static Item lightStoneDust = ( new Item( 92 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "yellowDust" ).setCreativeTab( CreativeTabs.tabMaterials );    
+    public static Item fishRaw = ( new FCItemFood( 93, FCItemFood.m_iFishRawHungerHealed, FCItemFood.m_fFishSaturationModifier, false, "fishRaw" ) ).SetStandardFoodPoisoningEffect();
+    public static Item fishCooked = ( new ItemFood( 94, FCItemFood.m_iFishCookedHungerHealed, FCItemFood.m_fFishSaturationModifier, false ) ).setUnlocalizedName( "fishCooked" );
+    public static Item dyePowder = new FCItemDye( 95 );
+    public static Item bone = new FCItemBone( 96 );
+    public static Item sugar = ( new Item( 97 ) ).SetBuoyant().SetBellowsBlowDistance( 3 ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "sugar" ).setCreativeTab( CreativeTabs.tabMaterials );	    
+    public static Item cake = ( new ItemReed( 98, Block.cake ) ).SetBuoyant().SetIncineratedInCrucible().setMaxStackSize( 1 ).setUnlocalizedName( "cake" ).setCreativeTab( CreativeTabs.tabFood );
+    public static Item bed = ( new ItemBed( 99 ) ).SetBuoyant().SetIncineratedInCrucible().setMaxStackSize( 1 ).setUnlocalizedName( "bed" );
+    public static Item redstoneRepeater = new FCItemRedstoneRepeater( 100 );
+    public static Item cookie = ( new ItemFood( 101, 1, 1F, false ) ).setAlwaysEdible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "cookie" );
+    public static ItemMap map = new FCItemMap( 102 );
+    public static ItemShears shears = (ItemShears)( new FCItemShears( 103 ) ).setUnlocalizedName( "shears" );
+    public static Item melon = new FCItemFoodHighRes( 104, 2, 0F, false, "melon" );
+    public static Item pumpkinSeeds = ( new FCItemSeedFood( 105, 1, 0F, Block.pumpkinStem.blockID ) ).SetAsBasicChickenFood().SetBellowsBlowDistance( 2 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "seeds_pumpkin" );
+    public static Item melonSeeds = ( new FCItemSeeds( 106, Block.melonStem.blockID ) ).SetAsBasicChickenFood().setUnlocalizedName( "seeds_melon" );
+    public static Item beefRaw = ( new FCItemFood( 107, FCItemFood.m_iBeefRawHungerHealed, FCItemFood.m_fBeefSaturationModifier, true, "beefRaw", true ) ).SetStandardFoodPoisoningEffect();    
+    public static Item beefCooked = ( new ItemFood( 108, FCItemFood.m_iBeefCookedHungerHealed, FCItemFood.m_fBeefSaturationModifier, true ) ).setUnlocalizedName("beefCooked");
+    public static Item chickenRaw = ( new FCItemFood( 109, FCItemFood.m_iChickenRawHungerHealed, FCItemFood.m_fChickenSaturationModifier, true, "chickenRaw" ) ).SetStandardFoodPoisoningEffect();    
+    public static Item chickenCooked = (new ItemFood( 110, FCItemFood.m_iChickenCookedHungerHealed, FCItemFood.m_fChickenSaturationModifier, true ) ).setUnlocalizedName( "chickenCooked" );    
+    public static Item rottenFlesh = new FCItemRottenFlesh( 111 );
+    public static Item enderPearl = ( new ItemEnderPearl( 112 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "enderPearl" );
+    public static Item blazeRod = ( new Item( 113 ) ).SetFurnaceBurnTime( FCEnumFurnaceBurnTime.BLAZE_ROD ).SetFilterableProperties( m_iFilterable_Narrow ).setUnlocalizedName( "blazeRod" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item ghastTear = ( new Item( 114 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "ghastTear" ).setPotionEffect( PotionHelper.ghastTearEffect ).setCreativeTab( CreativeTabs.tabBrewing );
+    public static Item goldNugget = ( new Item( 115 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "goldNugget" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item netherStalkSeeds = ( new FCItemSeeds( 116, Block.netherStalk.blockID ) ).SetBellowsBlowDistance( 1 ).setUnlocalizedName( "netherStalkSeeds" ).setPotionEffect( "+4" );
+    public static ItemPotion potion = new FCItemPotion( 117 );
+    public static Item glassBottle = ( new FCItemGlassBottle( 118 ) ).SetBuoyant().setUnlocalizedName( "glassBottle" );
+    public static Item spiderEye = ( (new ItemFood( 119, 2, 0.8F, false ) ).setPotionEffect( Potion.poison.id, 5, 0, 1F ) ).SetNeutralBuoyant().SetFilterableProperties( m_iFilterable_Small ).setPotionEffect( PotionHelper.goldenCarrotEffect ).setUnlocalizedName( "spiderEye" );
+    public static Item fermentedSpiderEye = ( new Item( 120 ) ).SetNeutralBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "fermentedSpiderEye" ).setPotionEffect( PotionHelper.fermentedSpiderEyeEffect ).setCreativeTab( CreativeTabs.tabBrewing );
+    public static Item blazePowder = ( new Item( 121 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "blazePowder" ).setPotionEffect( PotionHelper.blazePowderEffect ).setCreativeTab( CreativeTabs.tabBrewing );
+    public static Item magmaCream = ( new Item( 122 ) ).SetNeutralBuoyant().setUnlocalizedName( "magmaCream" ).setPotionEffect( PotionHelper.magmaCreamEffect ).setCreativeTab( CreativeTabs.tabBrewing );
     public static Item brewingStand = (new ItemReed(123, Block.brewingStand)).setUnlocalizedName("brewingStand").setCreativeTab(CreativeTabs.tabBrewing);
     public static Item cauldron = (new ItemReed(124, Block.cauldron)).setUnlocalizedName("cauldron").setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item eyeOfEnder = (new ItemEnderEye(125)).setUnlocalizedName("eyeOfEnder");
-    public static Item speckledMelon = (new Item(126)).setUnlocalizedName("speckledMelon").setPotionEffect(PotionHelper.speckledMelonEffect).setCreativeTab(CreativeTabs.tabBrewing);
+    public static Item eyeOfEnder = ( new ItemEnderEye( 125 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "eyeOfEnder" );
+    public static Item speckledMelon = ( new Item( 126 ) ).setUnlocalizedName( "speckledMelon" ).setCreativeTab( CreativeTabs.tabFood );
     public static Item monsterPlacer = (new ItemMonsterPlacer(127)).setUnlocalizedName("monsterPlacer");
 
     /**
      * Bottle o' Enchanting. Drops between 1 and 3 experience orbs when thrown.
      */
     public static Item expBottle = (new ItemExpBottle(128)).setUnlocalizedName("expBottle");
-
-    /**
-     * Fire Charge. When used in a dispenser it fires a fireball similiar to a Ghast's.
-     */
-    public static Item fireballCharge = (new ItemFireball(129)).setUnlocalizedName("fireball");
-    public static Item writableBook = (new ItemWritableBook(130)).setUnlocalizedName("writingBook").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item writtenBook = (new ItemEditableBook(131)).setUnlocalizedName("writtenBook");
+    public static Item fireballCharge = new FCItemFireCharge( 129 );
+    public static Item writableBook = ( new ItemWritableBook( 130 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "writingBook" ).setCreativeTab( CreativeTabs.tabMisc );
+    public static Item writtenBook = ( new ItemEditableBook( 131 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "writtenBook" );
     public static Item emerald = (new Item(132)).setUnlocalizedName("emerald").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item itemFrame = (new ItemHangingEntity(133, EntityItemFrame.class)).setUnlocalizedName("frame");
-    public static Item flowerPot = (new ItemReed(134, Block.flowerPot)).setUnlocalizedName("flowerPot").setCreativeTab(CreativeTabs.tabDecorations);
-    public static Item carrot = (new ItemSeedFood(135, 4, 0.6F, Block.carrot.blockID, Block.tilledField.blockID)).setUnlocalizedName("carrots");
-    public static Item potato = (new ItemSeedFood(136, 1, 0.3F, Block.potato.blockID, Block.tilledField.blockID)).setUnlocalizedName("potato");
-    public static Item bakedPotato = (new ItemFood(137, 6, 0.6F, false)).setUnlocalizedName("potatoBaked");
-    public static Item poisonousPotato = (new ItemFood(138, 2, 0.3F, false)).setPotionEffect(Potion.poison.id, 5, 0, 0.6F).setUnlocalizedName("potatoPoisonous");
-    public static ItemEmptyMap emptyMap = (ItemEmptyMap)(new ItemEmptyMap(139)).setUnlocalizedName("emptyMap");
-    public static Item goldenCarrot = (new ItemFood(140, 6, 1.2F, false)).setUnlocalizedName("carrotGolden").setPotionEffect(PotionHelper.goldenCarrotEffect);
-    public static Item skull = (new ItemSkull(141)).setUnlocalizedName("skull");
-    public static Item carrotOnAStick = (new ItemCarrotOnAStick(142)).setUnlocalizedName("carrotOnAStick");
-    public static Item netherStar = (new ItemSimpleFoiled(143)).setUnlocalizedName("netherStar").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item pumpkinPie = (new ItemFood(144, 8, 0.3F, false)).setUnlocalizedName("pumpkinPie").setCreativeTab(CreativeTabs.tabFood);
+    public static Item itemFrame = ( new ItemHangingEntity( 133, EntityItemFrame.class ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "frame" );
+    public static Item flowerPot = ( new ItemReed( 134, Block.flowerPot ) ).SetBuoyant().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "flowerPot" ).setCreativeTab( CreativeTabs.tabDecorations );
+    public static Item carrot = ( new FCItemSeedFood( 135, 3, 0F, Block.carrot.blockID ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "carrots" );
+    public static Item potato = ( new FCItemSeedFood( 136, 3, 0F, Block.potato.blockID ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "potato" );
+    public static Item bakedPotato = ( new ItemFood( 137, 2, 0F, false ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "potatoBaked" );	    
+    public static Item poisonousPotato = ( new ItemFood( 138, 1, 0F, false ) ).setPotionEffect( Potion.poison.id, 5, 0, 0.6F ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "potatoPoisonous" );
+    public static ItemEmptyMap emptyMap = new FCItemEmptyMap( 139 );
+    public static Item goldenCarrot = ( new ItemFood( 140, 1, 0F, false ) ).SetNonBuoyant().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "carrotGolden" );
+    public static Item skull = ( new ItemSkull( 141 ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "skull" );
+    public static Item carrotOnAStick = new FCItemCarrotOnAStick( 142 );
+    public static Item netherStar = new FCItemNetherStar( 143 );
+    public static Item pumpkinPie = ( new ItemFood( 144, 2, 2.5F, false ) ).setAlwaysEdible().setUnlocalizedName( "pumpkinPie" ).setCreativeTab( CreativeTabs.tabFood );
     public static Item firework = (new ItemFirework(145)).setUnlocalizedName("fireworks");
     public static Item fireworkCharge = (new ItemFireworkCharge(146)).setUnlocalizedName("fireworksCharge").setCreativeTab(CreativeTabs.tabMisc);
-    public static ItemEnchantedBook enchantedBook = (ItemEnchantedBook)(new ItemEnchantedBook(147)).setMaxStackSize(1).setUnlocalizedName("enchantedBook");
-    public static Item comparator = (new ItemReed(148, Block.redstoneComparatorIdle)).setUnlocalizedName("comparator").setCreativeTab(CreativeTabs.tabRedstone);
-    public static Item netherrackBrick = (new Item(149)).setUnlocalizedName("netherbrick").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item netherQuartz = (new Item(150)).setUnlocalizedName("netherquartz").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item minecartTnt = (new ItemMinecart(151, 3)).setUnlocalizedName("minecartTnt");
-    public static Item minecartHopper = (new ItemMinecart(152, 5)).setUnlocalizedName("minecartHopper");
+    public static ItemEnchantedBook enchantedBook = (ItemEnchantedBook)( new FCItemEnchantedBook( 147 ) ).setMaxStackSize( 1 ).setUnlocalizedName( "enchantedBook" );
+    public static Item comparator = (new FCItemPlacesAsBlock(148, Block.redstoneComparatorIdle.blockID)).setUnlocalizedName("comparator").setCreativeTab(CreativeTabs.tabRedstone);
+    public static Item netherrackBrick = ( new Item(149 ) ).setUnlocalizedName( "netherbrick" );
+    public static Item netherQuartz = ( new FCItemNetherQuartz( 150 ) ).setUnlocalizedName( "netherquartz" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item minecartTnt = ( new FCItemStub( 151 ) ).setUnlocalizedName( "minecartTnt" );
+    public static Item minecartHopper = ( new FCItemStub( 152 ) ).setUnlocalizedName( "minecartHopper" );
+    // Added aliases to avoid annoying naming differences between client and server
+    public static Item tntMinecart = minecartTnt;
+    public static Item hopperMinecart = minecartHopper;
+    
     public static Item record13 = (new ItemRecord(2000, "13")).setUnlocalizedName("record");
-    public static Item recordCat = (new ItemRecord(2001, "cat")).setUnlocalizedName("record");
-    public static Item recordBlocks = (new ItemRecord(2002, "blocks")).setUnlocalizedName("record");
-    public static Item recordChirp = (new ItemRecord(2003, "chirp")).setUnlocalizedName("record");
-    public static Item recordFar = (new ItemRecord(2004, "far")).setUnlocalizedName("record");
-    public static Item recordMall = (new ItemRecord(2005, "mall")).setUnlocalizedName("record");
-    public static Item recordMellohi = (new ItemRecord(2006, "mellohi")).setUnlocalizedName("record");
-    public static Item recordStal = (new ItemRecord(2007, "stal")).setUnlocalizedName("record");
-    public static Item recordStrad = (new ItemRecord(2008, "strad")).setUnlocalizedName("record");
-    public static Item recordWard = (new ItemRecord(2009, "ward")).setUnlocalizedName("record");
-    public static Item record11 = (new ItemRecord(2010, "11")).setUnlocalizedName("record");
-    public static Item recordWait = (new ItemRecord(2011, "wait")).setUnlocalizedName("record");
+    public static Item recordCat = (new ItemRecord(2001, "cat")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordBlocks = (new ItemRecord(2002, "blocks")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordChirp = (new ItemRecord(2003, "chirp")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordFar = (new ItemRecord(2004, "far")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordMall = (new ItemRecord(2005, "mall")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordMellohi = (new ItemRecord(2006, "mellohi")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordStal = (new ItemRecord(2007, "stal")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordStrad = (new ItemRecord(2008, "strad")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordWard = (new ItemRecord(2009, "ward")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item record11 = (new ItemRecord(2010, "11")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordWait = (new ItemRecord(2011, "wait")).setUnlocalizedName("record").setCreativeTab((CreativeTabs)null);
 
     /** The ID of this item. */
     public final int itemID;
@@ -214,11 +219,17 @@ public class Item
 
     /** Icon index in the icons table. */
     protected Icon itemIcon;
+    
+    public static final boolean[] itemReplaced = new boolean[32000];
+    private Class entityClass = EntityItem.class;
 
     protected Item(int par1)
     {
         this.itemID = 256 + par1;
 
+        // FCMOD: Code added
+        if ( !m_bSuppressConflictWarnings )
+    	// END FCMOD
         if (itemsList[256 + par1] != null)
         {
             System.out.println("CONFLICT @ " + par1);
@@ -254,7 +265,7 @@ public class Item
      */
     public final Icon getIconIndex(ItemStack par1ItemStack)
     {
-        return this.getIconFromDamage(par1ItemStack.getItemDamage());
+    	return CITUtils.getIcon(this.getIconFromDamage(par1ItemStack.getItemDamage()), par1ItemStack, 0);
     }
 
     /**
@@ -270,10 +281,14 @@ public class Item
      * Returns the strength of the stack against a given block. 1.0F base, (Quality+1)*2 if correct blocktype, 1.5F if
      * sword
      */
+    // FCMOD: Removed and replaced later
+    /*
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return 1.0F;
     }
+    */
+    // END FCMOD
 
     /**
      * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
@@ -362,10 +377,14 @@ public class Item
     /**
      * Returns if the item (tool) can harvest results from the block type.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return false;
     }
+    */
+    // END FCMOD    
 
     /**
      * Called when a player right clicks an entity with an item.
@@ -491,7 +510,10 @@ public class Item
      * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and
      * update it's contents.
      */
-    public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5) {}
+    // FCMOD: Changed
+    //public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5) {}
+    public void onUpdate( ItemStack stack, World world, EntityPlayer entity, int iInventorySlot, boolean bIsHandHeldItem ) {}
+    // END FCMOD
 
     /**
      * Called when item is crafted/smelted. Used only by maps so far.
@@ -671,4 +693,514 @@ public class Item
     {
         StatList.initStats();
     }
+
+	// FCMOD: Added New
+    public static boolean m_bSuppressConflictWarnings = false;
+    
+    /**
+     * Method which replaces canPlaceItemBlockOnSide() in ItemBlock. Allows the client to prevent item usage before it is relayed
+     * to the server by returning false.  Only called on client.
+     */    
+    public boolean CanItemBeUsedByPlayer( World world, int i, int j, int k, int iFacing, EntityPlayer player, ItemStack stack )
+    {
+    	return true;    	
+    }
+    
+    public boolean DoZombiesConsume()
+    {
+    	return false;
+    }
+    
+    public boolean IsEfficientVsBlock( ItemStack stack, World world, Block block, int i, int j, int k )
+    {
+        return false;
+    }
+    
+    public boolean canHarvestBlock( ItemStack stack, World world, Block block, int i, int j, int k )
+    {
+        return false;
+    }
+    
+    public float getStrVsBlock( ItemStack stack, World world, Block block, int i, int j, int k )
+    {
+        return 1F;
+    }
+    
+    public boolean IsMultiUsePerClick()
+    {
+    	return true;
+    }
+    
+    public float GetExhaustionOnUsedToHarvestBlock( int iBlockID, World world, int i, int j, int k, int iBlockMetadata )
+    {
+    	return 0.025F; // standard default exhaustion amount
+    }
+    
+    public void InitializeStackOnGiveCommand( Random rand, ItemStack stack )
+    {
+    }
+    
+    public void UpdateUsingItem( ItemStack stack, World world, EntityPlayer player )
+    {
+    }
+    
+    public int GetItemUseWarmupDuration()
+    {
+    	return 7;
+    }
+    
+    public boolean IgnoreDamageWhenComparingDuringUse()
+    {
+    	return false;
+    }
+	
+    //------------ Addon interfacing related functionality ----------//
+
+    /**
+     * Replaces a reference to an existing block (vanilla or btw)
+     * @param id The block id to be replaced
+     * @param newClass The class of the new item
+     * @param parameters Optional additional parameters to pass to the item, not including the id.
+     */
+    public static Item replaceItem(int id, Class newClass, Object ... parameters) {
+    	if (itemReplaced[id]) {
+    		throw new RuntimeException("Multiple addons attempting to replace item " + itemsList[id]);
+    	}
+    	else {
+    		m_bSuppressConflictWarnings = true;
+    		
+    		Item newItem = null;
+    		
+    		Class[] parameterTypes = new Class[parameters.length + 1];
+    		Object[] parameterValues = new Object[parameters.length + 1];
+    		
+    		parameterTypes[0] = Integer.TYPE;
+    		parameterValues[0] = id - 256;
+    		
+    		for (int i = 0; i < parameters.length; i++) {
+    			Class<?> type = parameters[i].getClass();
+    			
+    			if (type == Integer.class) {
+    				type = Integer.TYPE;
+    			}
+    			else if (type == Boolean.class) {
+    				type = Boolean.TYPE;
+    			}
+    			else if (type == Float.class) {
+    				type = Float.TYPE;
+    			}
+    			else if (type == Double.class) {
+    				type = Double.TYPE;
+    			}
+    			else if (Block.class.isAssignableFrom(type)) {
+    				type = Block.class;
+    			}
+    			else if (Item.class.isAssignableFrom(type)) {
+    				type = Item.class;
+    			}
+    			
+    			parameterTypes[i + 1] = type;
+    			parameterValues[i + 1] = parameters[i];
+    		}
+    		
+    			try {
+					newItem = (Item) newClass.getConstructor(parameterTypes).newInstance(parameterValues);
+				} catch (InstantiationException e) {
+					throw new RuntimeException("A problem has occured attempting to instantiate replacement for " + itemsList[id]);
+				} catch (IllegalArgumentException e) {
+					throw new RuntimeException("Incompatible types passed to specified constructor for " + itemsList[id]);
+				} catch (NoSuchMethodException e) {
+					throw new RuntimeException("No appropriate constructor found for " + itemsList[id] + ". Constructors must be public to be used in replacement.");
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+    		
+    		itemReplaced[id] = true;
+    		Item original = itemsList[id];
+    		itemsList[id] = null;
+    		
+    		newItem.SetFilterableProperties(original.m_iFilterablePropertiesBitfield).SetBuoyancy(original.GetBuoyancy(0)).setCreativeTab(original.getCreativeTab());
+    		
+    		if (original.IsIncineratedInCrucible())
+    			newItem.SetIncineratedInCrucible();
+    		else
+    			newItem.SetNotIncineratedInCrucible();
+    		
+    		itemsList[id] = newItem;
+    		
+    		m_bSuppressConflictWarnings = false;
+    		
+    		return newItem;
+    	}
+    }
+
+    //----------- Animal Food related functionality -----------//
+    
+    public static final int m_iBaseHerbivoreItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 4 );
+    public static final int m_iBasePigItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 4 );
+    public static final int m_iBaseChickenItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 8 );
+
+    private int m_iHerbivoreFoodValue = 0;
+    private int m_iBirdFoodValue = 0;
+    private int m_iPigFoodValue = 0;
+    
+    public int GetHerbivoreFoodValue( int iItemDamage )
+    {
+    	return m_iHerbivoreFoodValue;
+    }
+    
+    public Item SetHerbivoreFoodValue( int iFoodValue )
+    {
+    	m_iHerbivoreFoodValue = iFoodValue;
+    	
+    	return this;
+    }
+    
+    public Item SetAsBasicHerbivoreFood()
+    {
+    	return SetHerbivoreFoodValue( m_iBaseHerbivoreItemFoodValue );
+    }
+    
+    public int GetChickenFoodValue( int iItemDamage )
+    {
+    	return m_iBirdFoodValue;
+    }
+    
+    public Item SetChickenFoodValue( int iFoodValue )
+    {
+    	m_iBirdFoodValue = iFoodValue;
+    	
+    	return this;
+    }
+    
+    public Item SetAsBasicChickenFood()
+    {
+    	return SetChickenFoodValue( m_iBaseChickenItemFoodValue );
+    }
+    
+    public int GetPigFoodValue( int iItemDamage )
+    {
+    	return m_iPigFoodValue;
+    }
+    
+    public Item SetPigFoodValue( int iFoodValue )
+    {
+    	m_iPigFoodValue = iFoodValue;
+    	
+    	return this;
+    }
+    
+    public Item SetAsBasicPigFood()
+    {
+    	return SetPigFoodValue( m_iBasePigItemFoodValue );
+    }
+    
+    public boolean IsWolfFood()
+    {
+    	return false;
+    }
+    
+    public int GetWolfHealAmount()
+    {
+    	return 0;
+    }
+    
+    //------------- Buoyancy related functionality ------------//
+    
+	private float m_fBuoyancy = -1.0F;
+	
+    public Item SetBuoyancy( float fBuoyancy )
+    {
+    	m_fBuoyancy = fBuoyancy;
+    	
+    	return this;
+    }
+    
+    public Item SetBuoyant() { return SetBuoyancy( 1F ); }
+    public Item SetNonBuoyant() { return SetBuoyancy( -1F ); }
+    public Item SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
+    
+    public float GetBuoyancy( int iItemDamage )
+    {
+    	return m_fBuoyancy;
+    }
+    
+    public int GetWeightWhenWorn()
+    {
+    	return 0;
+    }
+    
+    //------------- Bellows related functionality ------------//
+    
+	private int m_iBellowsBlowDistance = 0;
+	
+	/**
+	 * 3 = light powders or light large surface objects like paper or bat wings
+	 * 2 = seeds, dyes, fibers, chunkier powders like ground netherrack or sand, 
+	 * 	   heavier sheets like bark or wicker
+	 * 1 = fabric or wool, small leather like straps, arrows, heavier small mobsdrops like creeper 
+	 * 	   oysters, and witch wart, dirt and gravel, heavy seeds like cocoa beans and netherwart
+	 * 0 = everything else
+	 */
+    public Item SetBellowsBlowDistance( int iDistance )
+    {
+    	m_iBellowsBlowDistance = iDistance;
+    	
+    	return this;
+    }
+    
+    public int GetBellowsBlowDistance( int iItemDamage )
+    {
+    	return m_iBellowsBlowDistance;
+    }
+    
+    //------------- Enchanting related functionality ------------//
+    
+	private int m_iInfernalMaxNumEnchants = 0;
+	private int m_iInfernalMaxEnchantmentCost = 0;
+	
+    public Item SetInfernalMaxNumEnchants( int iMaxNumEnchants )
+    {
+    	m_iInfernalMaxNumEnchants = iMaxNumEnchants;
+    	
+    	return this;
+    }
+    
+    public int GetInfernalMaxNumEnchants()
+    {
+    	return m_iInfernalMaxNumEnchants;
+    }    
+    
+    public Item SetInfernalMaxEnchantmentCost( int iMaxEnchantmentCost )
+    {
+    	m_iInfernalMaxEnchantmentCost = iMaxEnchantmentCost;
+    	
+    	return this;
+    }
+    
+    public int GetInfernalMaxEnchantmentCost()
+    {
+    	return m_iInfernalMaxEnchantmentCost;
+    }
+    
+    public boolean IsEnchantmentApplicable( Enchantment enchantment )
+    {
+    	return enchantment.type == EnumEnchantmentType.all;
+    }
+    
+    //------------- Crafting related functionality ------------//    
+    
+    protected int m_iDefaultFurnaceBurnTime = 0;
+    protected boolean m_bIsInceratedInCrucible = false;
+    
+    public boolean IsConsumedInCrafting()
+    {
+    	return true;
+    }
+    
+    public boolean IsDamagedInCrafting()
+    {
+    	return false;
+    }    
+    
+    public void OnUsedInCrafting( int iItemDamage, EntityPlayer player, ItemStack outputStack )
+    {
+    	OnUsedInCrafting( player, outputStack );
+    }
+    
+    public void OnUsedInCrafting( EntityPlayer player, ItemStack outputStack )
+    {
+    }
+    
+    public void OnDamagedInCrafting( EntityPlayer player )
+    {
+    }
+    
+    public void OnBrokenInCrafting( EntityPlayer player )
+    {
+    }
+    
+    public int GetFurnaceBurnTime( int iItemDamage )
+    {
+    	return m_iDefaultFurnaceBurnTime;
+    }
+    
+    public Item SetFurnaceBurnTime( int iBurnTime )
+    {
+    	m_iDefaultFurnaceBurnTime = iBurnTime;
+    	
+    	return this;
+    }
+    
+    public Item SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
+    {
+    	SetFurnaceBurnTime( burnTime.m_iBurnTime );
+    	
+    	return this;
+    }
+    
+    public int GetCampfireBurnTime( int iItemDamage )
+    {
+    	return GetFurnaceBurnTime( iItemDamage );
+    }
+    
+    /**
+     * Used to override default activation behavior on certain blocks like accessing inventory on furnace and campfires 
+     */
+    public boolean GetCanItemStartFireOnUse( int iItemDamage )
+    {
+    	return false;
+    }    
+    
+    /**
+     * Used to override default activation behavior on certain blocks like accessing inventory on furnace and campfires 
+     */
+    public boolean GetCanItemBeSetOnFireOnUse( int iItemDamage )
+    {
+    	return false;
+    }
+    
+    public boolean GetCanBeFedDirectlyIntoCampfire( int iItemDamage )
+    {
+		return !GetCanItemBeSetOnFireOnUse( iItemDamage ) && !GetCanItemStartFireOnUse( iItemDamage ) &&
+			GetCampfireBurnTime( iItemDamage ) > 0;
+    }
+    
+    public boolean GetCanBeFedDirectlyIntoBrickOven( int iItemDamage )
+    {
+		return !GetCanItemBeSetOnFireOnUse( iItemDamage ) && !GetCanItemStartFireOnUse( iItemDamage ) &&
+			GetFurnaceBurnTime( iItemDamage ) > 0;
+    }
+    
+    public boolean IsIncineratedInCrucible()
+    {
+    	return m_bIsInceratedInCrucible;
+    }
+    
+    public Item SetIncineratedInCrucible()
+    {
+    	m_bIsInceratedInCrucible = true;
+    	
+    	return this;
+    }
+    
+    public Item SetNotIncineratedInCrucible()
+    {
+    	m_bIsInceratedInCrucible = false;
+    	
+    	return this;
+    }
+    
+    public boolean DoesConsumeContainerItemWhenCrafted( Item containerItem )
+    {
+    	return false;
+    }
+    
+    //------------- Piston Packing related functionality ------------//
+    
+    public boolean IsPistonPackable( ItemStack stack )
+    {
+    	return false;
+    }
+    
+    public int GetRequiredItemCountToPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    //------------- Hopper Filtering Functionality -----------//
+    
+    protected int m_iFilterablePropertiesBitfield = 0;
+    
+    public boolean CanItemPassIfFilter( ItemStack filteredItem )
+    {
+    	return true;
+    }
+    
+    public int GetFilterableProperties( ItemStack stack )
+    {
+    	return m_iFilterablePropertiesBitfield;
+    }
+    
+    public Item SetFilterableProperties( int iProperties )
+    {
+    	m_iFilterablePropertiesBitfield = iProperties;
+    	
+    	return this;
+    }
+    
+    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
+    {
+    	return false;
+    }
+    
+    //------------- Deprecated tool functionality ------------//
+    
+    public static void SetAllPicksToBeEffectiveVsBlock( Block block )
+    {
+    	block.SetPicksEffectiveOn( true );
+    }
+    
+    public static void SetAllAxesToBeEffectiveVsBlock( Block block )
+    {
+    	block.SetAxesEffectiveOn( true );
+    }
+    
+    public static void SetAllShovelsToBeEffectiveVsBlock( Block block )
+    {
+    	block.SetShovelsEffectiveOn( true );
+    }
+    
+    //----- Block Dispenser Related Functionality -----//
+    
+	/**
+	 * This method should return true if the item is successfully placed (in which case the BD will 
+	 * consume the corresponding item in its inventory), false otherwise.  Co-ordinates specify
+	 * the BD position.
+	 */
+	public boolean OnItemUsedByBlockDispenser( ItemStack stack, World world, 
+		int i, int j, int k, int iFacing )
+	{
+		FCBetterThanWolves.fcBlockDispenser.SpitOutItem( world, i, j, k, stack );
+		
+        world.playAuxSFX( 1000, i, j, k, 0 ); // normal pitch click							        
+        
+		return true;
+	}
+    
+    //------- Item Entity Related Functionality -------//
+    
+    public boolean hasCustomItemEntity() {
+    	return this.entityClass != EntityItem.class;
+    }
+    
+    public Class getCustomItemEntity() {
+    	return this.entityClass;
+    }
+    
+    public void setCustomItemEntity(Class entityClass) {
+    	this.entityClass = entityClass;
+    }
+    
+    public EntityItem createItemAsEntityInWorld(World world, double x, double y, double z, ItemStack stack) {
+    	return null;
+    }
+	
+	//----------- Client Side Functionality -----------//
+    
+    public Icon GetHopperFilterIcon()
+    {
+    	return null;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/ItemArmor.java b/minecraft/net/minecraft/src/ItemArmor.java
index 7984733..02aee66 100644
--- a/minecraft/net/minecraft/src/ItemArmor.java
+++ b/minecraft/net/minecraft/src/ItemArmor.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
+
 public class ItemArmor extends Item
 {
     /** Holds the 'base' maxDamage that each armorType have. */
@@ -14,7 +16,12 @@ public class ItemArmor extends Item
     public final int armorType;
 
     /** Holds the amount of damage that the armor reduces at full durability. */
+    // FCMOD: Changed to remove final
+    /*
     public final int damageReduceAmount;
+    */
+    public int damageReduceAmount;
+    // END FCMOD
 
     /**
      * Used on RenderPlayer to select the correspondent armor to be rendered on the player: 0 is cloth, 1 is chain, 2 is
@@ -37,7 +44,11 @@ public class ItemArmor extends Item
         this.setMaxDamage(par2EnumArmorMaterial.getDurability(par4));
         this.maxStackSize = 1;
         this.setCreativeTab(CreativeTabs.tabCombat);
+        // FCMOD: Code removed
+        /*
         BlockDispenser.dispenseBehaviorRegistry.putObject(this, field_96605_cw);
+        */
+        // END FCMOD
     }
 
     public int getColorFromItemStack(ItemStack par1ItemStack, int par2)
@@ -103,12 +114,12 @@ public class ItemArmor extends Item
 
             if (var2 == null)
             {
-                return 10511680;
+            	return ColorizeEntity.undyedLeatherColor;
             }
             else
             {
                 NBTTagCompound var3 = var2.getCompoundTag("display");
-                return var3 == null ? 10511680 : (var3.hasKey("color") ? var3.getInteger("color") : 10511680);
+                return var3 == null ? ColorizeEntity.undyedLeatherColor : (var3.hasKey("color") ? var3.getInteger("color") : ColorizeEntity.undyedLeatherColor);
             }
         }
     }
@@ -235,4 +246,33 @@ public class ItemArmor extends Item
     {
         return maxDamageArray;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public boolean IsEnchantmentApplicable( Enchantment enchantment )
+    {
+    	if ( enchantment.type == EnumEnchantmentType.armor )
+    	{
+    		return true;
+    	}
+    	else if ( enchantment.type == EnumEnchantmentType.armor_head )
+    	{		
+    		return armorType == 0;
+    	}		
+    	else if ( enchantment.type == EnumEnchantmentType.armor_torso )
+    	{		
+    		return armorType == 1;
+    	}		
+    	else if ( enchantment.type == EnumEnchantmentType.armor_legs )
+    	{		
+    		return armorType == 2;
+    	}		
+    	else if ( enchantment.type == EnumEnchantmentType.armor_feet )
+    	{		
+    		return armorType == 3;
+    	}
+    	
+    	return super.IsEnchantmentApplicable( enchantment );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemAxe.java b/minecraft/net/minecraft/src/ItemAxe.java
index 824f929..edf6c46 100644
--- a/minecraft/net/minecraft/src/ItemAxe.java
+++ b/minecraft/net/minecraft/src/ItemAxe.java
@@ -6,8 +6,8 @@ public class ItemAxe extends ItemTool
     private static Block[] blocksEffectiveAgainst = new Block[] {Block.planks, Block.bookShelf, Block.wood, Block.chest, Block.stoneDoubleSlab, Block.stoneSingleSlab, Block.pumpkin, Block.pumpkinLantern};
 
     protected ItemAxe(int par1, EnumToolMaterial par2EnumToolMaterial)
-    {
-        super(par1, 3, par2EnumToolMaterial, blocksEffectiveAgainst);
+    {    	
+        super(par1, 3, par2EnumToolMaterial, blocksEffectiveAgainst);        
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/ItemBlock.java b/minecraft/net/minecraft/src/ItemBlock.java
index 8f64000..dd3f67e 100644
--- a/minecraft/net/minecraft/src/ItemBlock.java
+++ b/minecraft/net/minecraft/src/ItemBlock.java
@@ -2,7 +2,10 @@ package net.minecraft.src;
 
 import java.util.List;
 
-public class ItemBlock extends Item
+// FCMOD: Changed
+//public class ItemBlock extends Item
+public class ItemBlock extends FCItemPlacesAsBlock
+// END FCMOD
 {
     /** The block ID of the Block associated with this ItemBlock */
     private int blockID;
@@ -11,7 +14,7 @@ public class ItemBlock extends Item
     public ItemBlock(int par1)
     {
         super(par1);
-        this.blockID = par1 + 256;
+        this.blockID = par1 + 256;        
     }
 
     /**
@@ -42,6 +45,8 @@ public class ItemBlock extends Item
      * Callback for item usage. If the item does something special on right clicking, he will have one of those. Return
      * True if something happen and false if it don't. This is for ITEMS, not BLOCKS
      */
+    // FCMOD: Removed and replaced in parent class
+    /*
     public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
     {
         int var11 = par3World.getBlockId(par4, par5, par6);
@@ -120,10 +125,14 @@ public class ItemBlock extends Item
             return false;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns true if the given ItemBlock can be placed on the given side of the given block position.
      */
+    // FCMOD: Removed and replaced in parent class (client only)
+    /*
     public boolean canPlaceItemBlockOnSide(World par1World, int par2, int par3, int par4, int par5, EntityPlayer par6EntityPlayer, ItemStack par7ItemStack)
     {
         int var8 = par1World.getBlockId(par2, par3, par4);
@@ -167,6 +176,8 @@ public class ItemBlock extends Item
 
         return par1World.canPlaceEntityOnSide(this.getBlockID(), par2, par3, par4, false, par5, (Entity)null, par7ItemStack);
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the unlocalized name of this item. This version accepts an ItemStack so different stacks can have
@@ -210,4 +221,150 @@ public class ItemBlock extends Item
             this.field_94588_b = par1IconRegister.registerIcon(var2);
         }
     }
+    
+    public int getColorFromItemStack(ItemStack var1, int var2)
+    {
+        Block var3 = Block.blocksList[this.blockID];
+        return var3 != null ? var3.getRenderColor(var2) : super.getColorFromItemStack(var1, var2);
+    }
+    
+    // FCMOD: Added New
+    private boolean m_bHasOldNamePrefix = false;
+    
+    @Override
+    public float GetBuoyancy( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetBuoyancy( iItemDamage );
+    }
+    
+    @Override
+    public Item SetBuoyancy( float fBuoyancy )
+    {
+    	Block.blocksList[blockID].SetBuoyancy( fBuoyancy );
+    	
+    	return super.SetBuoyancy( fBuoyancy );
+    }
+    
+    @Override
+    public boolean IsPistonPackable( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].IsPistonPackable( stack );
+    }
+    
+    @Override
+    public int GetRequiredItemCountToPistonPack( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetRequiredItemCountToPistonPack( stack );
+    }
+    
+    @Override
+    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetResultingBlockIDOnPistonPack( stack );
+    }
+    
+    @Override
+    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetResultingBlockMetadataOnPistonPack( stack );
+    }
+
+    @Override
+    public int GetFurnaceBurnTime( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetFurnaceBurnTime( iItemDamage );
+    }
+    
+    @Override
+    public Item SetFurnaceBurnTime( int iBurnTime )
+    {
+    	Block.blocksList[blockID].SetFurnaceBurnTime( iBurnTime );
+    	
+    	return super.SetFurnaceBurnTime( iBurnTime );
+    }
+    
+    @Override
+    public int GetHerbivoreFoodValue( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetHerbivoreItemFoodValue( iItemDamage );
+    }
+    
+    @Override
+    public Item SetHerbivoreFoodValue( int iFoodValue )
+    {
+    	Block.blocksList[blockID].SetHerbivoreItemFoodValue( iFoodValue );
+    	
+    	return super.SetHerbivoreFoodValue( iFoodValue );
+    }
+    
+    @Override
+    public int GetChickenFoodValue( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetChickenItemFoodValue( iItemDamage );
+    }
+    
+    @Override
+    public Item SetChickenFoodValue( int iFoodValue )
+    {
+    	Block.blocksList[blockID].SetChickenItemFoodValue( iFoodValue );
+    	
+    	return super.SetChickenFoodValue( iFoodValue );
+    }
+    
+    @Override
+    public int GetPigFoodValue( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetPigItemFoodValue( iItemDamage );
+    }
+    
+    @Override
+    public Item SetPigFoodValue( int iFoodValue )
+    {
+    	Block.blocksList[blockID].SetPigItemFoodValue( iFoodValue );
+    	
+    	return super.SetPigFoodValue( iFoodValue );
+    }
+    
+    @Override
+    public boolean IsIncineratedInCrucible()
+    {
+    	return Block.blocksList[blockID].IsIncineratedInCrucible();
+    }
+    
+    @Override
+    public FCItemPlacesAsBlock SetAssociatedBlockID( int iBlockID )
+    {
+    	blockID = iBlockID;
+    	
+    	return super.SetAssociatedBlockID( iBlockID );
+    }
+    
+    @Override
+    public boolean CanItemPassIfFilter( ItemStack filteredItem )
+    {
+    	return Block.blocksList[blockID].CanItemPassIfFilter( filteredItem );
+    }
+    
+    @Override
+    public int GetFilterableProperties( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetFilterableProperties( stack );
+    }
+    
+    @Override
+    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
+    {
+    	return Block.blocksList[blockID].CanTransformItemIfFilter( filteredItem );
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+	//----------- Client Side Functionality -----------//
+    
+    @Override
+    public Icon GetHopperFilterIcon()
+    {
+    	return Block.blocksList[blockID].GetHopperFilterIcon();
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemBucket.java b/minecraft/net/minecraft/src/ItemBucket.java
index ce41e47..63b5fc2 100644
--- a/minecraft/net/minecraft/src/ItemBucket.java
+++ b/minecraft/net/minecraft/src/ItemBucket.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/01/2018
+
 package net.minecraft.src;
 
 public class ItemBucket extends Item
diff --git a/minecraft/net/minecraft/src/ItemEnderPearl.java b/minecraft/net/minecraft/src/ItemEnderPearl.java
index 3a7a657..4acf33a 100644
--- a/minecraft/net/minecraft/src/ItemEnderPearl.java
+++ b/minecraft/net/minecraft/src/ItemEnderPearl.java
@@ -14,11 +14,7 @@ public class ItemEnderPearl extends Item
      */
     public ItemStack onItemRightClick(ItemStack par1ItemStack, World par2World, EntityPlayer par3EntityPlayer)
     {
-        if (par3EntityPlayer.capabilities.isCreativeMode)
-        {
-            return par1ItemStack;
-        }
-        else if (par3EntityPlayer.ridingEntity != null)
+        if (par3EntityPlayer.ridingEntity != null)
         {
             return par1ItemStack;
         }
@@ -35,4 +31,24 @@ public class ItemEnderPearl extends Item
             return par1ItemStack;
         }
     }
+    
+    @Override
+    public boolean IsPistonPackable(ItemStack stack) {
+    	return true;
+    }
+    
+	@Override
+    public int GetRequiredItemCountToPistonPack(ItemStack stack) {
+    	return 9;
+    }
+    
+	@Override
+    public int GetResultingBlockIDOnPistonPack(ItemStack stack) {
+    	return FCBetterThanWolves.fcAestheticOpaque.blockID;
+    }
+    
+	@Override
+    public int GetResultingBlockMetadataOnPistonPack(ItemStack stack) {
+    	return ((FCBlockAestheticOpaque) FCBetterThanWolves.fcAestheticOpaque).m_iSubtypeEnderBlock;
+    }
 }
diff --git a/minecraft/net/minecraft/src/ItemFood.java b/minecraft/net/minecraft/src/ItemFood.java
index 65029eb..a8349ff 100644
--- a/minecraft/net/minecraft/src/ItemFood.java
+++ b/minecraft/net/minecraft/src/ItemFood.java
@@ -39,6 +39,11 @@ public class ItemFood extends Item
         this.isWolfsFavoriteMeat = par4;
         this.saturationModifier = par3;
         this.setCreativeTab(CreativeTabs.tabFood);
+        // FCMOD: Added
+        maxStackSize = 16;
+        SetBuoyant();        
+        SetIncineratedInCrucible();
+        // END FCMOD
     }
 
     public ItemFood(int par1, int par2, boolean par3)
@@ -88,6 +93,12 @@ public class ItemFood extends Item
         {
             par3EntityPlayer.setItemInUse(par1ItemStack, this.getMaxItemUseDuration(par1ItemStack));
         }
+        // FCMOD: Added
+    	else
+    	{
+    		par3EntityPlayer.OnCantConsume();
+    	}
+        // END FCMOD
 
         return par1ItemStack;
     }
@@ -134,4 +145,46 @@ public class ItemFood extends Item
         this.alwaysEdible = true;
         return this;
     }
+    
+    // FCMOD: Added New    
+    private boolean m_bDoZombiesConsume = false;
+    
+    public ItemFood( int iItemID, int iHealAmount, float fSaturationModifier, boolean bWolfsFavoriteMeat, boolean bZombiesConsume )
+    {
+    	this( iItemID, iHealAmount, fSaturationModifier, bWolfsFavoriteMeat );
+    	
+    	m_bDoZombiesConsume = bZombiesConsume;
+    }
+    
+    @Override
+    public boolean DoZombiesConsume()
+    {
+    	return m_bDoZombiesConsume;
+    }
+    
+    @Override
+    public boolean IsMultiUsePerClick()
+    {
+    	return false;
+    }
+
+    @Override
+    public boolean IsWolfFood()
+    {
+    	return isWolfsFavoriteMeat();
+    }
+    
+    @Override
+    public int GetWolfHealAmount()
+    {
+    	return getHealAmount();
+    }
+    
+    public int GetHungerRestored()
+    {
+    	// multiply original values by 3 to take into account increased hunger resolution 
+    	
+    	return healAmount * 3;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemInWorldManager.java b/minecraft/net/minecraft/src/ItemInWorldManager.java
index f881046..af5db4e 100644
--- a/minecraft/net/minecraft/src/ItemInWorldManager.java
+++ b/minecraft/net/minecraft/src/ItemInWorldManager.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class ItemInWorldManager
 {
     /** The world object that this object is connected to. */
@@ -27,6 +30,9 @@ public class ItemInWorldManager
     private int posZ;
     private int field_73093_n;
     private int durabilityRemainingOnBlock;
+    // FCMOD: Added
+    private int m_iHarvestingFromFacing;
+    // END FCMOD
 
     public ItemInWorldManager(World par1World)
     {
@@ -99,7 +105,10 @@ public class ItemInWorldManager
                 if (var4 >= 1.0F)
                 {
                     this.receivedFinishDiggingPacket = false;
-                    this.tryHarvestBlock(this.posX, this.posY, this.posZ);
+                    // FCMOD: Changed
+                    //this.tryHarvestBlock(this.posX, this.posY, this.posZ);
+                    this.tryHarvestBlock(this.posX, this.posY, this.posZ, this.m_iHarvestingFromFacing);
+                    // END FCMOD
                 }
             }
         }
@@ -141,12 +150,17 @@ public class ItemInWorldManager
             {
                 if (!this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4))
                 {
-                    this.tryHarvestBlock(par1, par2, par3);
+                	// FCMOD: Changed
+                    //this.tryHarvestBlock(par1, par2, par3);
+                    this.tryHarvestBlock(par1, par2, par3, par4);
+                    // END FCMOD
                 }
             }
             else
             {
-                this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4);
+            	// FCMOD: Removed
+                //this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4);
+            	// END FCMOD
                 this.initialDamage = this.curblockDamage;
                 float var5 = 1.0F;
                 int var6 = this.theWorld.getBlockId(par1, par2, par3);
@@ -159,7 +173,10 @@ public class ItemInWorldManager
 
                 if (var6 > 0 && var5 >= 1.0F)
                 {
-                    this.tryHarvestBlock(par1, par2, par3);
+                	// FCMOD: Changed
+                    //this.tryHarvestBlock(par1, par2, par3);
+                    this.tryHarvestBlock(par1, par2, par3, par4);
+                    // END FCMOD
                 }
                 else
                 {
@@ -175,7 +192,11 @@ public class ItemInWorldManager
         }
     }
 
-    public void uncheckedTryHarvestBlock(int par1, int par2, int par3)
+	// FCMOD: Changed (function name differs between client and server ), "overloaded" function required for DemoWorldManager
+    //public void uncheckedTryHarvestBlock(int par1, int par2, int par3)
+    public void uncheckedTryHarvestBlock(int par1, int par2, int par3 ) { uncheckedTryHarvestBlock( par1, par2, par3, 1 ); }
+    public void uncheckedTryHarvestBlock(int par1, int par2, int par3, int iFromFacing)
+    // END FCMOD
     {
         if (par1 == this.partiallyDestroyedBlockX && par2 == this.partiallyDestroyedBlockY && par3 == this.partiallyDestroyedBlockZ)
         {
@@ -191,7 +212,10 @@ public class ItemInWorldManager
                 {
                     this.isDestroyingBlock = false;
                     this.theWorld.destroyBlockInWorldPartially(this.thisPlayerMP.entityId, par1, par2, par3, -1);
-                    this.tryHarvestBlock(par1, par2, par3);
+                    // FCMOD: Changed
+                    //this.tryHarvestBlock(par1, par2, par3);
+                    this.tryHarvestBlock(par1, par2, par3, iFromFacing);
+                    // END FCMOD
                 }
                 else if (!this.receivedFinishDiggingPacket)
                 {
@@ -201,6 +225,9 @@ public class ItemInWorldManager
                     this.posY = par2;
                     this.posZ = par3;
                     this.field_73093_n = this.initialDamage;
+                    // FCMOD: Added
+                    m_iHarvestingFromFacing = iFromFacing;
+                    // END FCMOD
                 }
             }
         }
@@ -233,14 +260,20 @@ public class ItemInWorldManager
         if (var4 != null && var6)
         {
             var4.onBlockDestroyedByPlayer(this.theWorld, par1, par2, par3, var5);
+            
+            // FCMOD: Panick animals when blocks are destroyed near them
+            theWorld.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( thisPlayerMP, var4, par1, par2, par3 );            
+            // END FCMOD
         }
 
         return var6;
     }
-
+    
     /**
      * Attempts to harvest a block at the given coordinate
      */
+    // FCMOD: Removed and replaced later
+    /*
     public boolean tryHarvestBlock(int par1, int par2, int par3)
     {
         if (this.gameType.isAdventure() && !this.thisPlayerMP.canCurrentToolHarvestBlock(par1, par2, par3))
@@ -282,6 +315,8 @@ public class ItemInWorldManager
             return var6;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Attempts to right-click use an item by the given EntityPlayer in the given World
@@ -368,4 +403,95 @@ public class ItemInWorldManager
     {
         this.theWorld = par1WorldServer;
     }
+    
+    // FCMOD: Added
+    
+	// "overloaded" function required for DemoWorldManager
+    public boolean tryHarvestBlock( int i, int j, int k ) { return tryHarvestBlock( i, j, k, 1 ); }
+    public boolean tryHarvestBlock( int i, int j, int k, int iFromSide )
+    {
+        if ( gameType.isAdventure() && !thisPlayerMP.canCurrentToolHarvestBlock( i, j, k ) )
+        {
+            return false;
+        }
+        else if ( isCreative() )
+        {
+            int iBlockID = theWorld.getBlockId( i, j, k );
+            int iBlockMetadata = theWorld.getBlockMetadata( i, j, k );
+            
+            theWorld.playAuxSFXAtEntity( thisPlayerMP, 2001, i, j, k, iBlockID + ( theWorld.getBlockMetadata( i, j, k ) << 12 ) );
+            
+            boolean bBlockRemoved = removeBlock( i, j, k );
+
+            FCUtilsWorld.SendPacketToPlayer( thisPlayerMP.playerNetServerHandler, new Packet53BlockChange(i, j, k, this.theWorld) );
+
+            return bBlockRemoved;
+        }
+        else
+        {
+    		return SurvivalTryHarvestBlock( i, j, k, iFromSide );
+        }
+    }
+    
+    public boolean SurvivalTryHarvestBlock( int i, int j, int k, int iFromSide )
+    {
+        int iBlockID = theWorld.getBlockId(i, j, k);
+    	Block block = Block.blocksList[iBlockID];
+    	
+    	if ( block == null )
+    	{
+    		return false;
+    	}
+    	
+        int iMetadata = theWorld.getBlockMetadata(i, j, k);
+        
+        theWorld.playAuxSFXAtEntity( thisPlayerMP, 2001, i, j, k, iBlockID + ( iMetadata << 12 ) );
+        
+        ItemStack currentStack = thisPlayerMP.getCurrentEquippedItem();
+        
+        boolean bRemovingBlock = true;
+        boolean bConvertingBlock = false;
+        
+        boolean bHarvestingBlock = thisPlayerMP.canHarvestBlock( Block.blocksList[iBlockID], i, j, k );
+        
+        if ( !bHarvestingBlock )
+        {
+        	bConvertingBlock = block.CanConvertBlock( currentStack, theWorld, i, j, k );
+        	
+        	if ( bConvertingBlock )
+        	{
+                bRemovingBlock = !( block.ConvertBlock( currentStack, theWorld, i, j, k, iFromSide ) );
+        	}
+        }
+
+        if ( bRemovingBlock )
+        {
+        	bRemovingBlock = removeBlock( i, j, k );
+
+            if ( bRemovingBlock && !bConvertingBlock )
+            {
+    	        if ( bHarvestingBlock )
+    	        {
+    	            Block.blocksList[iBlockID].harvestBlock( theWorld, thisPlayerMP, i, j, k, iMetadata );
+    	        }
+    	        else 
+    	        {
+    	        	Block.blocksList[iBlockID].OnBlockDestroyedWithImproperTool( theWorld, thisPlayerMP, i, j, k, iMetadata );
+    	        }
+            }
+        }
+
+        if ( currentStack != null )
+        {
+            currentStack.onBlockDestroyed( theWorld, iBlockID, i, j, k, thisPlayerMP );
+
+            if ( currentStack.stackSize == 0 )
+            {
+                thisPlayerMP.destroyCurrentEquippedItem();
+            }
+        }
+
+        return bRemovingBlock;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemMap.java b/minecraft/net/minecraft/src/ItemMap.java
index 6f2cd3d..409830d 100644
--- a/minecraft/net/minecraft/src/ItemMap.java
+++ b/minecraft/net/minecraft/src/ItemMap.java
@@ -66,6 +66,12 @@ public class ItemMap extends ItemMapBase
 
             MapInfo var12 = par3MapData.func_82568_a((EntityPlayer)par2Entity);
             ++var12.field_82569_d;
+            
+            // FCMOD: Changed
+            // Moved array allocation 
+            int[] var24 = new int[4096];
+            int[][] metaArray = new int[4096][16];
+            // END FCMOD
 
             for (int var13 = var9 - var11 + 1; var13 < var9 + var11; ++var13)
             {
@@ -84,7 +90,17 @@ public class ItemMap extends ItemMapBase
                             boolean var21 = var19 * var19 + var20 * var20 > (var11 - 2) * (var11 - 2);
                             int var22 = (var7 / var6 + var13 - var4 / 2) * var6;
                             int var23 = (var8 / var6 + var18 - var5 / 2) * var6;
-                            int[] var24 = new int[256];
+                            // FCMOD: Modified memory allocation
+                            //int[] var24 = new int[256];
+                            for (int i = 0; i < 4096; i++) {
+                            	var24[i] = 0;
+                            	
+                            	for (int j = 0; j < 16; j++) {
+                            		metaArray[i][j] = 0;
+                            	}
+                            }
+                            
+                            // END FCMOD
                             Chunk var25 = par1World.getChunkFromBlockCoords(var22, var23);
 
                             if (!var25.isEmpty())
@@ -122,6 +138,7 @@ public class ItemMap extends ItemMapBase
                                         {
                                             var33 = var25.getHeightValue(var31 + var26, var32 + var27) + 1;
                                             int var34 = 0;
+                                            int meta = 0;
 
                                             if (var33 > 1)
                                             {
@@ -131,6 +148,7 @@ public class ItemMap extends ItemMapBase
                                                 {
                                                     var35 = true;
                                                     var34 = var25.getBlockID(var31 + var26, var33 - 1, var32 + var27);
+                                                    meta = var25.getBlockMetadata(var31 + var26, var33 - 1, var32 + var27);
 
                                                     if (var34 == 0)
                                                     {
@@ -159,28 +177,32 @@ public class ItemMap extends ItemMapBase
                                                 {
                                                     var36 = var33 - 1;
                                                     boolean var37 = false;
-                                                    int var41;
+                                                    int var43;
 
                                                     do
                                                     {
-                                                        var41 = var25.getBlockID(var31 + var26, var36--, var32 + var27);
+                                                        var43 = var25.getBlockID(var31 + var26, var36--, var32 + var27);
                                                         ++var28;
                                                     }
-                                                    while (var36 > 0 && var41 != 0 && Block.blocksList[var41].blockMaterial.isLiquid());
+                                                    while (var36 > 0 && var43 != 0 && Block.blocksList[var43].blockMaterial.isLiquid());
                                                 }
                                             }
 
                                             var29 += (double)var33 / (double)(var6 * var6);
-                                            ++var24[var34];
+                                            var24[var34]++;
+                                            metaArray[var34][meta]++;
                                         }
                                     }
                                 }
 
                                 var28 /= var6 * var6;
-                                var31 = 0;
+                                var31 = 0; 
                                 var32 = 0;
 
-                                for (var33 = 0; var33 < 256; ++var33)
+                                // FCMOD: Change
+                                //for (var33 = 0; var33 < 256; ++var33)
+                                for (var33 = 0; var33 < 4096; ++var33)
+                                // END FCMOD
                                 {
                                     if (var24[var33] > var31)
                                     {
@@ -189,38 +211,53 @@ public class ItemMap extends ItemMapBase
                                     }
                                 }
 
-                                double var39 = (var29 - var16) * 4.0D / (double)(var6 + 4) + ((double)(var13 + var18 & 1) - 0.5D) * 0.4D;
-                                byte var40 = 1;
+                                // FCMOD: Added
+                                int greatestMeta = 0;
+                                int greatestMetaCount = 0;
+                                
+                                for (int i = 0; i < 16; i++) {
+                                	if (metaArray[var32][i] > greatestMetaCount) {
+                                		greatestMeta = i;
+                                		greatestMetaCount = metaArray[var32][i];
+                                	}
+                                }
+                                // END FCMOD
+
+                                double var40 = (var29 - var16) * 4.0D / (double)(var6 + 4) + ((double)(var13 + var18 & 1) - 0.5D) * 0.4D;
+                                byte var39 = 1;
 
-                                if (var39 > 0.6D)
+                                if (var40 > 0.6D)
                                 {
-                                    var40 = 2;
+                                    var39 = 2;
                                 }
 
-                                if (var39 < -0.6D)
+                                if (var40 < -0.6D)
                                 {
-                                    var40 = 0;
+                                    var39 = 0;
                                 }
 
                                 var36 = 0;
 
                                 if (var32 > 0)
                                 {
-                                    MapColor var42 = Block.blocksList[var32].blockMaterial.materialMapColor;
+                                	// FCMOD: Changed
+                                    //MapColor var42 = Block.blocksList[var32].blockMaterial.materialMapColor;
+                                    MapColor var42 = Block.blocksList[var32].getMapColor(greatestMeta);
+                                    // END FCMOD
 
                                     if (var42 == MapColor.waterColor)
                                     {
-                                        var39 = (double)var28 * 0.1D + (double)(var13 + var18 & 1) * 0.2D;
-                                        var40 = 1;
+                                        var40 = (double)var28 * 0.1D + (double)(var13 + var18 & 1) * 0.2D;
+                                        var39 = 1;
 
-                                        if (var39 < 0.5D)
+                                        if (var40 < 0.5D)
                                         {
-                                            var40 = 2;
+                                            var39 = 2;
                                         }
 
-                                        if (var39 > 0.9D)
+                                        if (var40 > 0.9D)
                                         {
-                                            var40 = 0;
+                                            var39 = 0;
                                         }
                                     }
 
@@ -231,10 +268,10 @@ public class ItemMap extends ItemMapBase
 
                                 if (var18 >= 0 && var19 * var19 + var20 * var20 < var11 * var11 && (!var21 || (var13 + var18 & 1) != 0))
                                 {
-                                    byte var43 = par3MapData.colors[var13 + var18 * var4];
-                                    byte var38 = (byte)(var36 * 4 + var40);
+                                    byte var41 = par3MapData.colors[var13 + var18 * var4];
+                                    byte var38 = (byte)(var36 * 4 + var39);
 
-                                    if (var43 != var38)
+                                    if (var41 != var38)
                                     {
                                         if (var14 > var18)
                                         {
@@ -266,7 +303,11 @@ public class ItemMap extends ItemMapBase
      * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and
      * update it's contents.
      */
-    public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5)
+    // FCMOD: Changed
+    //public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5)
+    @Override
+    public void onUpdate(ItemStack par1ItemStack, World par2World, EntityPlayer par3Entity, int par4, boolean par5)
+    // END FCMOD
     {
         if (!par2World.isRemote)
         {
diff --git a/minecraft/net/minecraft/src/ItemMonsterPlacer.java b/minecraft/net/minecraft/src/ItemMonsterPlacer.java
index 574a6cc..0547a8c 100644
--- a/minecraft/net/minecraft/src/ItemMonsterPlacer.java
+++ b/minecraft/net/minecraft/src/ItemMonsterPlacer.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeItem;
 import java.util.Iterator;
 import java.util.List;
 
@@ -30,7 +31,7 @@ public class ItemMonsterPlacer extends Item
     public int getColorFromItemStack(ItemStack par1ItemStack, int par2)
     {
         EntityEggInfo var3 = (EntityEggInfo)EntityList.entityEggs.get(Integer.valueOf(par1ItemStack.getItemDamage()));
-        return var3 != null ? (par2 == 0 ? var3.primaryColor : var3.secondaryColor) : 16777215;
+        return var3 != null ? (par2 == 0 ? ColorizeItem.colorizeSpawnerEgg(var3.primaryColor, par1ItemStack.getItemDamage(), par2) : ColorizeItem.colorizeSpawnerEgg(var3.secondaryColor, par1ItemStack.getItemDamage(), par2)) : ColorizeItem.colorizeSpawnerEgg(16777215, par1ItemStack.getItemDamage(), par2);
     }
 
     public boolean requiresMultipleRenderPasses()
diff --git a/minecraft/net/minecraft/src/ItemPickaxe.java b/minecraft/net/minecraft/src/ItemPickaxe.java
index 292deff..486fb61 100644
--- a/minecraft/net/minecraft/src/ItemPickaxe.java
+++ b/minecraft/net/minecraft/src/ItemPickaxe.java
@@ -25,5 +25,5 @@ public class ItemPickaxe extends ItemTool
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return par2Block != null && (par2Block.blockMaterial == Material.iron || par2Block.blockMaterial == Material.anvil || par2Block.blockMaterial == Material.rock) ? this.efficiencyOnProperMaterial : super.getStrVsBlock(par1ItemStack, par2Block);
-    }
+    }    
 }
diff --git a/minecraft/net/minecraft/src/ItemReed.java b/minecraft/net/minecraft/src/ItemReed.java
index 895a470..a3d9e86 100644
--- a/minecraft/net/minecraft/src/ItemReed.java
+++ b/minecraft/net/minecraft/src/ItemReed.java
@@ -1,20 +1,39 @@
 package net.minecraft.src;
 
-public class ItemReed extends Item
+// FCMOD: Changed to consolidate functionality in parent class
+//public class ItemReed extends Item
+public class ItemReed extends FCItemPlacesAsBlock
+// END FCMOD
 {
     /** The ID of the block the reed will spawn when used from inventory bar. */
-    private int spawnID;
+	// FCMOD: Removed
+    //private int spawnID;
+	// END FCMOD
 
     public ItemReed(int par1, Block par2Block)
     {
+    	// FCMOD: Changed
+    	/*
         super(par1);
         this.spawnID = par2Block.blockID;
+        */
+    	super( par1, par2Block.blockID );
+    	// END FCMOD
     }
+    
+    // FCMOD: Added
+    public ItemReed( int iItemID, int iBlockID )
+    {
+    	super( iItemID, iBlockID );
+    }
+    // END FCMOD
 
     /**
      * Callback for item usage. If the item does something special on right clicking, he will have one of those. Return
      * True if something happen and false if it don't. This is for ITEMS, not BLOCKS
      */
+	// FCMOD: Removed
+    /*
     public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
     {
         int var11 = par3World.getBlockId(par4, par5, par6);
@@ -87,4 +106,6 @@ public class ItemReed extends Item
             return true;
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemRenderer.java b/minecraft/net/minecraft/src/ItemRenderer.java
index f9d6f07..fccac56 100644
--- a/minecraft/net/minecraft/src/ItemRenderer.java
+++ b/minecraft/net/minecraft/src/ItemRenderer.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cit.CITUtils;
+import com.prupe.mcpatcher.mal.block.BlockAPI;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
@@ -36,14 +39,19 @@ public class ItemRenderer
     {
         GL11.glPushMatrix();
 
+        // FCMOD: Code change
+        /*
         if (par2ItemStack.getItemSpriteNumber() == 0 && Block.blocksList[par2ItemStack.itemID] != null && RenderBlocks.renderItemIn3d(Block.blocksList[par2ItemStack.itemID].getRenderType()))
+        */
+        if (par2ItemStack.getItemSpriteNumber() == 0 && Block.blocksList[par2ItemStack.itemID] != null && Block.blocksList[par2ItemStack.itemID].DoesItemRenderAsBlock( par2ItemStack.getItemDamage() ))
+    	// END FCMOD
         {
             this.mc.renderEngine.bindTexture("/terrain.png");
             this.renderBlocksInstance.renderBlockAsItem(Block.blocksList[par2ItemStack.itemID], par2ItemStack.getItemDamage(), 1.0F);
         }
         else
         {
-            Icon var4 = par1EntityLiving.getItemIcon(par2ItemStack, par3);
+        	Icon var4 = CITUtils.getIcon(par1EntityLiving.getItemIcon(par2ItemStack, par3), par2ItemStack, par3);
 
             if (var4 == null)
             {
@@ -74,9 +82,10 @@ public class ItemRenderer
             GL11.glRotatef(50.0F, 0.0F, 1.0F, 0.0F);
             GL11.glRotatef(335.0F, 0.0F, 0.0F, 1.0F);
             GL11.glTranslatef(-0.9375F, -0.0625F, 0.0F);
+            ColorizeBlock.colorizeWaterBlockGL(BlockAPI.getBlockById(par2ItemStack.itemID));
             renderItemIn2D(var5, var7, var8, var6, var9, var4.getSheetWidth(), var4.getSheetHeight(), 0.0625F);
 
-            if (par2ItemStack != null && par2ItemStack.hasEffect() && par3 == 0)
+            if (par2ItemStack != null && !CITUtils.renderEnchantmentHeld(par2ItemStack, par3) && par2ItemStack.hasEffect() && par3 == 0)
             {
                 GL11.glDepthFunc(GL11.GL_EQUAL);
                 GL11.glDisable(GL11.GL_LIGHTING);
@@ -232,16 +241,16 @@ public class ItemRenderer
         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)var8 / 1.0F, (float)var9 / 1.0F);
         GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
         float var10;
-        float var19;
         float var21;
+        float var20;
 
         if (var17 != null)
         {
             var18 = Item.itemsList[var17.itemID].getColorFromItemStack(var17, 0);
-            var19 = (float)(var18 >> 16 & 255) / 255.0F;
+            var20 = (float)(var18 >> 16 & 255) / 255.0F;
             var21 = (float)(var18 >> 8 & 255) / 255.0F;
             var10 = (float)(var18 & 255) / 255.0F;
-            GL11.glColor4f(var6 * var19, var6 * var21, var6 * var10, 1.0F);
+            GL11.glColor4f(var6 * var20, var6 * var21, var6 * var10, 1.0F);
         }
         else
         {
@@ -258,26 +267,26 @@ public class ItemRenderer
         {
             GL11.glPushMatrix();
             var7 = 0.8F;
-            var19 = var3.getSwingProgress(par1);
-            var21 = MathHelper.sin(var19 * (float)Math.PI);
-            var10 = MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI);
-            GL11.glTranslatef(-var10 * 0.4F, MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI * 2.0F) * 0.2F, -var21 * 0.2F);
-            var19 = 1.0F - var4 / 45.0F + 0.1F;
+            var20 = var3.getSwingProgress(par1);
+            var21 = MathHelper.sin(var20 * (float)Math.PI);
+            var10 = MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI);
+            GL11.glTranslatef(-var10 * 0.4F, MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI * 2.0F) * 0.2F, -var21 * 0.2F);
+            var20 = 1.0F - var4 / 45.0F + 0.1F;
 
-            if (var19 < 0.0F)
+            if (var20 < 0.0F)
             {
-                var19 = 0.0F;
+                var20 = 0.0F;
             }
 
-            if (var19 > 1.0F)
+            if (var20 > 1.0F)
             {
-                var19 = 1.0F;
+                var20 = 1.0F;
             }
 
-            var19 = -MathHelper.cos(var19 * (float)Math.PI) * 0.5F + 0.5F;
-            GL11.glTranslatef(0.0F, 0.0F * var7 - (1.0F - var2) * 1.2F - var19 * 0.5F + 0.04F, -0.9F * var7);
+            var20 = -MathHelper.cos(var20 * (float)Math.PI) * 0.5F + 0.5F;
+            GL11.glTranslatef(0.0F, 0.0F * var7 - (1.0F - var2) * 1.2F - var20 * 0.5F + 0.04F, -0.9F * var7);
             GL11.glRotatef(90.0F, 0.0F, 1.0F, 0.0F);
-            GL11.glRotatef(var19 * -85.0F, 0.0F, 0.0F, 1.0F);
+            GL11.glRotatef(var20 * -85.0F, 0.0F, 0.0F, 1.0F);
             GL11.glEnable(GL12.GL_RESCALE_NORMAL);
             GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTextureForDownloadableImage(this.mc.thePlayer.skinUrl, this.mc.thePlayer.getTexture()));
             this.mc.renderEngine.resetBoundTexture();
@@ -313,15 +322,15 @@ public class ItemRenderer
             var13 = 0.015625F;
             GL11.glScalef(var13, var13, var13);
             this.mc.renderEngine.bindTexture("/misc/mapbg.png");
-            Tessellator var27 = Tessellator.instance;
+            Tessellator var28 = Tessellator.instance;
             GL11.glNormal3f(0.0F, 0.0F, -1.0F);
-            var27.startDrawingQuads();
-            byte var28 = 7;
-            var27.addVertexWithUV((double)(0 - var28), (double)(128 + var28), 0.0D, 0.0D, 1.0D);
-            var27.addVertexWithUV((double)(128 + var28), (double)(128 + var28), 0.0D, 1.0D, 1.0D);
-            var27.addVertexWithUV((double)(128 + var28), (double)(0 - var28), 0.0D, 1.0D, 0.0D);
-            var27.addVertexWithUV((double)(0 - var28), (double)(0 - var28), 0.0D, 0.0D, 0.0D);
-            var27.draw();
+            var28.startDrawingQuads();
+            byte var27 = 7;
+            var28.addVertexWithUV((double)(0 - var27), (double)(128 + var27), 0.0D, 0.0D, 1.0D);
+            var28.addVertexWithUV((double)(128 + var27), (double)(128 + var27), 0.0D, 1.0D, 1.0D);
+            var28.addVertexWithUV((double)(128 + var27), (double)(0 - var27), 0.0D, 1.0D, 0.0D);
+            var28.addVertexWithUV((double)(0 - var27), (double)(0 - var27), 0.0D, 0.0D, 0.0D);
+            var28.draw();
             MapData var16 = Item.map.getMapData(var17, this.mc.theWorld);
 
             if (var16 != null)
@@ -338,9 +347,9 @@ public class ItemRenderer
 
             if (var3.getItemInUseCount() > 0)
             {
-                EnumAction var20 = var17.getItemUseAction();
+                EnumAction var19 = var17.getItemUseAction();
 
-                if (var20 == EnumAction.eat || var20 == EnumAction.drink)
+                if (var19 == EnumAction.eat || var19 == EnumAction.drink)
                 {
                     var21 = (float)var3.getItemInUseCount() - par1 + 1.0F;
                     var10 = 1.0F - var21 / (float)var17.getMaxItemUseDuration();
@@ -355,21 +364,56 @@ public class ItemRenderer
                     GL11.glRotatef(var12 * 10.0F, 1.0F, 0.0F, 0.0F);
                     GL11.glRotatef(var12 * 30.0F, 0.0F, 0.0F, 1.0F);
                 }
+                // FCMOD: Added
+                else if ( var19 == EnumAction.miscUse )
+                {
+                    var21 = (float)var3.getItemInUseCount() - par1 + 1.0F;
+                    
+                    var11 = var21 / (float)var17.getMaxItemUseDuration();
+                    
+                    var11 = var11 * var11 * var11;
+                    var11 = var11 * var11 * var11;
+                    var11 = var11 * var11 * var11;
+                    
+                    var12 = 1.0F - var11;
+                    
+                    // "chewing" up and down motion
+                    GL11.glTranslatef( 0.0F, MathHelper.abs(MathHelper.cos(var21 / 4.0F * (float)Math.PI) * 0.1F) * 
+                    	(( var17.getMaxItemUseDuration() - var3.getItemInUseCount() ) >= var17.getItem().GetItemUseWarmupDuration() ? 1F : 0F), 0.0F);
+                    
+                	int iItemInUseCount = MathHelper.clamp_int( 32 - ( var17.getMaxItemUseDuration() - var3.getItemInUseCount() ), 0, 32 );
+                    var21 = (float)iItemInUseCount - par1 + 1.0F;
+                    
+                    var11 = var21 / 32;
+                    
+                    var11 = var11 * var11 * var11;
+                    var11 = var11 * var11 * var11;
+                    var11 = var11 * var11 * var11;
+                    
+                    var12 = 1.0F - var11;
+                    
+                    GL11.glTranslatef(var12 * 0.6F, -var12 * 0.5F, 0.0F);
+                    
+                    GL11.glRotatef(var12 * 90.0F, 0.0F, 1.0F, 0.0F);
+                    GL11.glRotatef(var12 * 10.0F, 1.0F, 0.0F, 0.0F);
+                    GL11.glRotatef(var12 * 30.0F, 0.0F, 0.0F, 1.0F);
+                }
+            	// END FCMOD
             }
             else
             {
-                var19 = var3.getSwingProgress(par1);
-                var21 = MathHelper.sin(var19 * (float)Math.PI);
-                var10 = MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI);
-                GL11.glTranslatef(-var10 * 0.4F, MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI * 2.0F) * 0.2F, -var21 * 0.2F);
+                var20 = var3.getSwingProgress(par1);
+                var21 = MathHelper.sin(var20 * (float)Math.PI);
+                var10 = MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI);
+                GL11.glTranslatef(-var10 * 0.4F, MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI * 2.0F) * 0.2F, -var21 * 0.2F);
             }
 
             GL11.glTranslatef(0.7F * var7, -0.65F * var7 - (1.0F - var2) * 0.6F, -0.9F * var7);
             GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
             GL11.glEnable(GL12.GL_RESCALE_NORMAL);
-            var19 = var3.getSwingProgress(par1);
-            var21 = MathHelper.sin(var19 * var19 * (float)Math.PI);
-            var10 = MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI);
+            var20 = var3.getSwingProgress(par1);
+            var21 = MathHelper.sin(var20 * var20 * (float)Math.PI);
+            var10 = MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI);
             GL11.glRotatef(-var21 * 20.0F, 0.0F, 1.0F, 0.0F);
             GL11.glRotatef(-var10 * 20.0F, 0.0F, 0.0F, 1.0F);
             GL11.glRotatef(-var10 * 80.0F, 1.0F, 0.0F, 0.0F);
@@ -426,6 +470,15 @@ public class ItemRenderer
                 GL11.glRotatef(180.0F, 0.0F, 1.0F, 0.0F);
             }
 
+            // FCMOD: Added
+    		int iItemID = var17.getItem().itemID;
+    		
+	        if ( iItemID == Item.compass.itemID )
+	        {
+	        	TextureCompass.compassTexture.UpdateActive();
+	        }
+            // END FCMOD
+	        
             if (var17.getItem().requiresMultipleRenderPasses())
             {
                 this.renderItem(var3, var17, 0);
@@ -441,22 +494,29 @@ public class ItemRenderer
                 this.renderItem(var3, var17, 0);
             }
 
+            // FCMOD: Added
+	        if ( iItemID == Item.compass.itemID )
+	        {
+	        	TextureCompass.compassTexture.UpdateInert();
+	        }
+            // END FCMOD
+	        
             GL11.glPopMatrix();
         }
         else if (!var3.isInvisible())
         {
             GL11.glPushMatrix();
             var7 = 0.8F;
-            var19 = var3.getSwingProgress(par1);
-            var21 = MathHelper.sin(var19 * (float)Math.PI);
-            var10 = MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI);
-            GL11.glTranslatef(-var10 * 0.3F, MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI * 2.0F) * 0.4F, -var21 * 0.4F);
+            var20 = var3.getSwingProgress(par1);
+            var21 = MathHelper.sin(var20 * (float)Math.PI);
+            var10 = MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI);
+            GL11.glTranslatef(-var10 * 0.3F, MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI * 2.0F) * 0.4F, -var21 * 0.4F);
             GL11.glTranslatef(0.8F * var7, -0.75F * var7 - (1.0F - var2) * 0.6F, -0.9F * var7);
             GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
             GL11.glEnable(GL12.GL_RESCALE_NORMAL);
-            var19 = var3.getSwingProgress(par1);
-            var21 = MathHelper.sin(var19 * var19 * (float)Math.PI);
-            var10 = MathHelper.sin(MathHelper.sqrt_float(var19) * (float)Math.PI);
+            var20 = var3.getSwingProgress(par1);
+            var21 = MathHelper.sin(var20 * var20 * (float)Math.PI);
+            var10 = MathHelper.sin(MathHelper.sqrt_float(var20) * (float)Math.PI);
             GL11.glRotatef(var10 * 70.0F, 0.0F, 1.0F, 0.0F);
             GL11.glRotatef(-var21 * 20.0F, 0.0F, 0.0F, 1.0F);
             GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTextureForDownloadableImage(this.mc.thePlayer.skinUrl, this.mc.thePlayer.getTexture()));
@@ -647,7 +707,12 @@ public class ItemRenderer
             var3 = true;
         }
 
-        if (var2 != null && this.itemToRender != null && var2 != this.itemToRender && var2.itemID == this.itemToRender.itemID && var2.getItemDamage() == this.itemToRender.getItemDamage())
+        // FCMOD: Changed
+        //if (var2 != null && this.itemToRender != null && var2 != this.itemToRender && var2.itemID == this.itemToRender.itemID && var2.getItemDamage() == this.itemToRender.getItemDamage())
+        if (var2 != null && this.itemToRender != null && var2 != this.itemToRender && 
+        	var2.itemID == this.itemToRender.itemID && 
+        	( var2.getItemDamage() == this.itemToRender.getItemDamage() || itemToRender.getItem().IgnoreDamageWhenComparingDuringUse() ) )
+    	// END FCMOD
         {
             this.itemToRender = var2;
             var3 = true;
diff --git a/minecraft/net/minecraft/src/ItemSeeds.java b/minecraft/net/minecraft/src/ItemSeeds.java
index e7a89a8..a462ee1 100644
--- a/minecraft/net/minecraft/src/ItemSeeds.java
+++ b/minecraft/net/minecraft/src/ItemSeeds.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 02/06/2019
+
 package net.minecraft.src;
 
 public class ItemSeeds extends Item
diff --git a/minecraft/net/minecraft/src/ItemShears.java b/minecraft/net/minecraft/src/ItemShears.java
index e429b13..8d1629e 100644
--- a/minecraft/net/minecraft/src/ItemShears.java
+++ b/minecraft/net/minecraft/src/ItemShears.java
@@ -10,6 +10,8 @@ public class ItemShears extends Item
         this.setCreativeTab(CreativeTabs.tabTools);
     }
 
+    // FCMOD: Removed and replaced in child class
+    /*
     public boolean onBlockDestroyed(ItemStack par1ItemStack, World par2World, int par3, int par4, int par5, int par6, EntityLiving par7EntityLiving)
     {
         if (par3 != Block.leaves.blockID && par3 != Block.web.blockID && par3 != Block.tallGrass.blockID && par3 != Block.vine.blockID && par3 != Block.tripWire.blockID)
@@ -22,21 +24,31 @@ public class ItemShears extends Item
             return true;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns if the item (tool) can harvest results from the block type.
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return par1Block.blockID == Block.web.blockID || par1Block.blockID == Block.redstoneWire.blockID || par1Block.blockID == Block.tripWire.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the strength of the stack against a given block. 1.0F base, (Quality+1)*2 if correct blocktype, 1.5F if
      * sword
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return par2Block.blockID != Block.web.blockID && par2Block.blockID != Block.leaves.blockID ? (par2Block.blockID == Block.cloth.blockID ? 5.0F : super.getStrVsBlock(par1ItemStack, par2Block)) : 15.0F;
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemSkull.java b/minecraft/net/minecraft/src/ItemSkull.java
index c97ee71..c39a15b 100644
--- a/minecraft/net/minecraft/src/ItemSkull.java
+++ b/minecraft/net/minecraft/src/ItemSkull.java
@@ -4,8 +4,15 @@ import java.util.List;
 
 public class ItemSkull extends Item
 {
+	// FCMOD: Changed to add Infused Skull
+	/*
     private static final String[] skullTypes = new String[] {"skeleton", "wither", "zombie", "char", "creeper"};
     public static final String[] field_94587_a = new String[] {"skull_skeleton", "skull_wither", "skull_zombie", "skull_char", "skull_creeper"};
+    */
+    private static final String[] skullTypes = new String[] {"skeleton", "wither", "zombie", "char", "creeper", "infused"};
+    public static final String[] field_94587_a = new String[] {"skull_skeleton", "skull_wither", "skull_zombie", "skull_char", "skull_creeper", "fcItemSkullInfused"};
+	// END FCMOD
+    
     private Icon[] field_94586_c;
 
     public ItemSkull(int par1)
@@ -26,7 +33,11 @@ public class ItemSkull extends Item
         {
             return false;
         }
-        else if (!par3World.getBlockMaterial(par4, par5, par6).isSolid())
+        // FCMOD: Change
+        //else if (!par3World.getBlockMaterial(par4, par5, par6).isSolid())
+        else if ( !par3World.getBlockMaterial( par4, par5, par6 ).isSolid() && 
+        	!( par7 == 1 && FCUtilsWorld.DoesBlockHaveSmallCenterHardpointToFacing( par3World, par4, par5, par6, 1 ) ) )
+    	// END FCMOD
         {
             return false;
         }
@@ -67,7 +78,10 @@ public class ItemSkull extends Item
             }
             else
             {
-                par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 2);
+            	// FCMOD: Changed to notify neighbors
+                //par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 2);
+                par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 3);
+            	// END FCMOD
                 int var11 = 0;
 
                 if (par7 == 1)
diff --git a/minecraft/net/minecraft/src/ItemStack.java b/minecraft/net/minecraft/src/ItemStack.java
index f5afae7..4163798 100644
--- a/minecraft/net/minecraft/src/ItemStack.java
+++ b/minecraft/net/minecraft/src/ItemStack.java
@@ -137,10 +137,14 @@ public final class ItemStack
     /**
      * Returns the strength of the stack against a given block.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public float getStrVsBlock(Block par1Block)
     {
         return this.getItem().getStrVsBlock(this, par1Block);
     }
+    */
+    // END FCMOD
 
     /**
      * Called whenever this item stack is equipped and right clicked. Returns the new item stack to put in the position
@@ -169,7 +173,7 @@ public final class ItemStack
         {
             par1NBTTagCompound.setTag("tag", this.stackTagCompound);
         }
-
+        
         return par1NBTTagCompound;
     }
 
@@ -182,6 +186,15 @@ public final class ItemStack
         this.stackSize = par1NBTTagCompound.getByte("Count");
         this.itemDamage = par1NBTTagCompound.getShort("Damage");
 
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcDamEx" ) )
+        {
+        	// legacy support for one release where I had exended damage on wool knit representing color
+        	
+        	itemDamage = FCItemWool.GetClosestColorIndex( par1NBTTagCompound.getInteger( "fcDamEx" ) );
+        }
+        // END FCMOD
+        
         if (this.itemDamage < 0)
         {
             this.itemDamage = 0;
@@ -303,7 +316,12 @@ public final class ItemStack
             }
 
             this.itemDamage += par1;
+            // FCMOD: Code change so that items break at 0 damage, not -1
+            /*
             return this.itemDamage > this.getMaxDamage();
+            */
+            return this.itemDamage >= this.getMaxDamage();
+            // END FCMOD
         }
     }
 
@@ -372,10 +390,14 @@ public final class ItemStack
     /**
      * Checks if the itemStack object can harvest a specified block
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return Item.itemsList[this.itemID].canHarvestBlock(par1Block);
     }
+    */
+    // END FCMOD
 
     public boolean interactWith(EntityLiving par1EntityLiving)
     {
@@ -449,7 +471,10 @@ public final class ItemStack
      * Called each tick as long the ItemStack in on player inventory. Used to progress the pickup animation and update
      * maps.
      */
-    public void updateAnimation(World par1World, Entity par2Entity, int par3, boolean par4)
+    // FCMOD: Changed
+    //public void updateAnimation(World par1World, Entity par2Entity, int par3, boolean par4)
+    public void updateAnimation(World par1World, EntityPlayer par2Entity, int par3, boolean par4)
+    // END FCMOD
     {
         if (this.animationsToGo > 0)
         {
@@ -648,10 +673,14 @@ public final class ItemStack
             }
         }
 
+        // FCMOD: Removed this numerical display of item damage as an exploit (client only)
+        /*
         if (par2 && this.isItemDamaged())
         {
             var3.add("Durability: " + (this.getMaxDamage() - this.getItemDamageForDisplay()) + " / " + this.getMaxDamage());
         }
+        */
+        // END FCMOD
 
         return var3;
     }
@@ -763,4 +792,56 @@ public final class ItemStack
 
         this.stackTagCompound.setInteger("RepairCost", par1);
     }
+    
+    // FCMOD: Added
+    public boolean canHarvestBlock( World world, Block block, int i, int j, int k )
+    {
+        return Item.itemsList[this.itemID].canHarvestBlock( this, world, block, i, j, k );
+    }
+    
+    public float getStrVsBlock( World world, Block par1Block, int i, int j, int k )
+    {
+        return getItem().getStrVsBlock( this, world, par1Block, i, j, k );
+    }
+    
+    public long GetTimeOfLastUse()
+    {
+    	if ( hasTagCompound() && this.stackTagCompound.hasKey( "fcLastUse" ) ) 
+    	{
+    		return stackTagCompound.getLong( "fcLastUse" );
+    	}
+    	
+        return -1;
+    }
+    
+    public void SetTimeOfLastUse( long lTime )
+    {
+        if ( !hasTagCompound() )
+        {
+            stackTagCompound = new NBTTagCompound( "tag" );
+        }
+
+        stackTagCompound.setLong( "fcLastUse", lTime );
+    }
+    
+    public float GetAccumulatedChance( float fDefault )
+    {
+    	if ( hasTagCompound() && this.stackTagCompound.hasKey( "fcChance" ) ) 
+    	{
+    		return stackTagCompound.getFloat( "fcChance" );
+    	}
+    	
+        return fDefault;
+    }
+    
+    public void SetAccumulatedChance( float fChance )
+    {
+        if ( !hasTagCompound() )
+        {
+            stackTagCompound = new NBTTagCompound( "tag" );
+        }
+
+        stackTagCompound.setFloat( "fcChance", fChance );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ItemSword.java b/minecraft/net/minecraft/src/ItemSword.java
index f1e25dd..02bc3aa 100644
--- a/minecraft/net/minecraft/src/ItemSword.java
+++ b/minecraft/net/minecraft/src/ItemSword.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 07/05/2018
+
 package net.minecraft.src;
 
 public class ItemSword extends Item
diff --git a/minecraft/net/minecraft/src/ItemTool.java b/minecraft/net/minecraft/src/ItemTool.java
index 1146e68..9443b0a 100644
--- a/minecraft/net/minecraft/src/ItemTool.java
+++ b/minecraft/net/minecraft/src/ItemTool.java
@@ -99,5 +99,5 @@ public class ItemTool extends Item
     public boolean getIsRepairable(ItemStack par1ItemStack, ItemStack par2ItemStack)
     {
         return this.toolMaterial.getToolCraftingMaterial() == par2ItemStack.itemID ? true : super.getIsRepairable(par1ItemStack, par2ItemStack);
-    }
-}
+    }    
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/LongHashMap.java b/minecraft/net/minecraft/src/LongHashMap.java
index 3d02476..966cbb0 100644
--- a/minecraft/net/minecraft/src/LongHashMap.java
+++ b/minecraft/net/minecraft/src/LongHashMap.java
@@ -3,7 +3,17 @@ package net.minecraft.src;
 public class LongHashMap
 {
     /** the array of all elements in the hash */
-    private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[16];
+	// FCMOD: Changed so that it's most common use (loaded chunks) doesn't constantly resize 
+    //private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[16];
+
+	// 882 chunks will typical be loaded SP / 0.75, for 1176, with extra wiggle room
+	// there's only a few of these instantiated in the entire game, at 8K a piece for 2000 elements
+	// so really no need to be stingy.
+	private final int m_iDefaultSize = 2000; 
+    private final float percentUseable = 0.75F;
+	
+    private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[m_iDefaultSize];	
+	// END FCMOD
 
     /** the number of elements in the hash array */
     private transient int numHashElements;
@@ -11,12 +21,17 @@ public class LongHashMap
     /**
      * the maximum amount of elements in the hash (probably 3/4 the size due to meh hashing function)
      */
-    private int capacity = 12;
+    // FCMOD: Changed
+    //private int capacity = 12;
+    private int capacity = (int)( (float)m_iDefaultSize * percentUseable );
+    // END FCMOD
 
     /**
      * percent of the hasharray that can be used without hash colliding probably
      */
-    private final float percentUseable = 0.75F;
+    // FCMOD: Removed and replaced above due to declaration order    
+    //private final float percentUseable = 0.75F;
+    // END FCMOD
 
     /** count of times elements have been added/removed */
     private transient volatile int modCount;
@@ -26,7 +41,12 @@ public class LongHashMap
      */
     private static int getHashedKey(long par0)
     {
-        return hash((int)(par0 ^ par0 >>> 32));
+    	// FCMOD: Changed to avoid excessive collisions between what is just
+    	// XORing the X and Z values that comprise the key for chunk coords
+    	// discussion of this can be found here: https://bugs.mojang.com/browse/MC-12964
+        //return hash((int)(par0 ^ par0 >>> 32));
+        return hash( (int)( par0 ^ ( ( par0 >>> 32 ) * 31 ) ) );
+        // END FCMOD
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/MapColor.java b/minecraft/net/minecraft/src/MapColor.java
index 9618d52..2e3da2b 100644
--- a/minecraft/net/minecraft/src/MapColor.java
+++ b/minecraft/net/minecraft/src/MapColor.java
@@ -5,7 +5,10 @@ public class MapColor
     /**
      * Holds all the 16 colors used on maps, very similar of a pallete system.
      */
-    public static final MapColor[] mapColorArray = new MapColor[16];
+	// FCMod: Changed
+    //public static final MapColor[] mapColorArray = new MapColor[16];
+    public static final MapColor[] mapColorArray = new MapColor[256];
+    // END FCMOD
 
     /** The map color for Air blocks */
     public static final MapColor airColor = new MapColor(0, 0);
@@ -50,15 +53,17 @@ public class MapColor
     public static final MapColor woodColor = new MapColor(13, 6837042);
 
     /** Holds the color in RGB value that will be rendered on maps. */
-    public final int colorValue;
+    public int colorValue;
 
     /** Holds the index of the color used on map. */
     public final int colorIndex;
+    public int origColorValue;
 
     private MapColor(int par1, int par2)
     {
         this.colorIndex = par1;
         this.colorValue = par2;
+        this.origColorValue = par2;
         mapColorArray[par1] = this;
     }
 }
diff --git a/minecraft/net/minecraft/src/MapData.java b/minecraft/net/minecraft/src/MapData.java
index 953ca30..6a610fc 100644
--- a/minecraft/net/minecraft/src/MapData.java
+++ b/minecraft/net/minecraft/src/MapData.java
@@ -105,6 +105,29 @@ public class MapData extends WorldSavedData
      */
     public void updateVisiblePlayers(EntityPlayer par1EntityPlayer, ItemStack par2ItemStack)
     {
+    	// FCMOD: Added to handle maps in frames entirely independent of player held
+    	
+    	// clear the visible players every update to prevent players from receiving data about others
+    	
+        playersVisibleOnMap.clear();
+        
+        if ( par2ItemStack.isOnItemFrame() )
+        {
+        	if ( IsEntityLocationVisibleOnMap( par2ItemStack.getItemFrame() ) )
+        	{
+        		// the following code adds the "you are here" marker
+        		
+                func_82567_a( 1, par1EntityPlayer.worldObj, "frame-" + par2ItemStack.getItemFrame().entityId, 
+                	(double)par2ItemStack.getItemFrame().xPosition, (double)par2ItemStack.getItemFrame().zPosition, 
+                	(double)(par2ItemStack.getItemFrame().hangingDirection * 90 + 180 ));
+                
+        		return;
+        	}
+            
+            return;
+        }
+    	// END FCMOD
+    	
         if (!this.playersHashMap.containsKey(par1EntityPlayer))
         {
             MapInfo var3 = new MapInfo(this, par1EntityPlayer);
@@ -112,6 +135,16 @@ public class MapData extends WorldSavedData
             this.playersArrayList.add(var3);
         }
 
+        // FCMOD: Code added for custom handling of players on map, only processing the player holding it
+        if ( !par1EntityPlayer.isDead && par1EntityPlayer.inventory.hasItemStack(par2ItemStack) && IsEntityLocationVisibleOnMap( par1EntityPlayer ) &&
+        	par1EntityPlayer.dimension == dimension )
+        {
+            func_82567_a( 0, par1EntityPlayer.worldObj, par1EntityPlayer.getCommandSenderName(), par1EntityPlayer.posX, par1EntityPlayer.posZ, par1EntityPlayer.rotationYaw);
+        }
+    	// END FCMOD
+        
+        // FCMOD: Code removed
+        /*
         if (!par1EntityPlayer.inventory.hasItemStack(par2ItemStack))
         {
             this.playersVisibleOnMap.remove(par1EntityPlayer.getCommandSenderName());
@@ -139,6 +172,8 @@ public class MapData extends WorldSavedData
         {
             this.func_82567_a(1, par1EntityPlayer.worldObj, "frame-" + par2ItemStack.getItemFrame().entityId, (double)par2ItemStack.getItemFrame().xPosition, (double)par2ItemStack.getItemFrame().zPosition, (double)(par2ItemStack.getItemFrame().hangingDirection * 90));
         }
+        */
+        // END FCMOD
     }
 
     private void func_82567_a(int par1, World par2World, String par3Str, double par4, double par6, double par8)
@@ -281,4 +316,50 @@ public class MapData extends WorldSavedData
 
         return var2;
     }
+    
+    // FCMOD: Code added
+    public boolean IsEntityLocationVisibleOnMap( Entity entity )
+    {
+        int i = MathHelper.floor_double( entity.posX );
+        int j = MathHelper.floor_double( entity.posY ) + 2;
+        int k = MathHelper.floor_double( entity.posZ );
+        
+        if ( entity.dimension == dimension )
+        {
+        	return IsLocationVisibleOnMap( entity.worldObj, i, j, k );
+        }
+        
+        return false;        
+    }
+    
+    public boolean IsLocationVisibleOnMap( World world, int i, int j, int k )    
+    {
+    	// check if location is within map bounds
+    	
+        int iMapScale = 1 << this.scale;
+        float fRelativeI = (float)((double)i - (double)this.xCenter) / (float)iMapScale;
+        float fRelativeK = (float)((double)k - (double)this.zCenter) / (float)iMapScale;
+        
+        if ( Math.abs( fRelativeI ) > 64F || Math.abs( fRelativeK ) > 64F )
+        {
+        	return false;
+        }
+        
+        // check if location is above ground
+        
+    	if ( !world.canBlockSeeTheSky( i, j, k ) && !( world.getTopSolidOrLiquidBlock( i, k ) <= j )  )
+        {
+        	return false;
+        }
+        
+        Material material = world.getBlockMaterial( i, j, k );
+        
+        if ( material != null && material.isLiquid() )
+        {
+        	return false;
+        }
+        
+    	return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/MapGenNetherBridge.java b/minecraft/net/minecraft/src/MapGenNetherBridge.java
index 77a4fbf..8f7a178 100644
--- a/minecraft/net/minecraft/src/MapGenNetherBridge.java
+++ b/minecraft/net/minecraft/src/MapGenNetherBridge.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 10/01/2018
+
 package net.minecraft.src;
 
 import java.util.ArrayList;
diff --git a/minecraft/net/minecraft/src/MapGenScatteredFeature.java b/minecraft/net/minecraft/src/MapGenScatteredFeature.java
index 15e6f0a..b074bcf 100644
--- a/minecraft/net/minecraft/src/MapGenScatteredFeature.java
+++ b/minecraft/net/minecraft/src/MapGenScatteredFeature.java
@@ -26,7 +26,11 @@ public class MapGenScatteredFeature extends MapGenStructure
         this.scatteredFeatureSpawnList = new ArrayList();
         this.maxDistanceBetweenScatteredFeatures = 32;
         this.minDistanceBetweenScatteredFeatures = 8;
+        // FCMOD: Code removed
+        /*
         this.scatteredFeatureSpawnList.add(new SpawnListEntry(EntityWitch.class, 1, 1, 1));
+        */
+        // END FCMOD
     }
 
     public MapGenScatteredFeature(Map par1Map)
diff --git a/minecraft/net/minecraft/src/Material.java b/minecraft/net/minecraft/src/Material.java
index 1a7029c..e2dc98c 100644
--- a/minecraft/net/minecraft/src/Material.java
+++ b/minecraft/net/minecraft/src/Material.java
@@ -5,36 +5,68 @@ public class Material
     public static final Material air = new MaterialTransparent(MapColor.airColor);
 
     /** The material used by BlockGrass. */
-    public static final Material grass = new Material(MapColor.grassColor);
-    public static final Material ground = new Material(MapColor.dirtColor);
-    public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
+    // FCMOD: Changed
+    //public static final Material grass = new Material(MapColor.grassColor);
+    //public static final Material ground = new Material(MapColor.dirtColor);
+    //public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
+    public static final Material grass = (new Material(MapColor.grassColor)).setRequiresTool();
+    public static final Material ground = (new Material(MapColor.dirtColor)).setRequiresTool();
+    public static final Material wood = (new Material(MapColor.woodColor)).setBurning().SetMobsCantSpawnOn().SetAxesEfficientOn();
+    // END FCMOD
     public static final Material rock = (new Material(MapColor.stoneColor)).setRequiresTool();
+    // FCMOD: Changed
+    //public static final Material iron = (new Material(MapColor.ironColor)).setRequiresTool();
+    //public static final Material anvil = (new Material(MapColor.ironColor)).setRequiresTool().setImmovableMobility();
     public static final Material iron = (new Material(MapColor.ironColor)).setRequiresTool();
     public static final Material anvil = (new Material(MapColor.ironColor)).setRequiresTool().setImmovableMobility();
+    // END FCMOD
     public static final Material water = (new MaterialLiquid(MapColor.waterColor)).setNoPushMobility();
     public static final Material lava = (new MaterialLiquid(MapColor.tntColor)).setNoPushMobility();
-    public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility();
-    public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
-    public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable();
+    // FCMOD: Changed
+    //public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility();
+    //public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
+    //public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable();
+    public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility().SetAxesEfficientOn().SetAxesTreatAsVegetation();
+    public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility().SetAxesEfficientOn().SetAxesTreatAsVegetation();
+    public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable().SetAxesEfficientOn().SetAxesTreatAsVegetation();
+    // END FCMOD
     public static final Material sponge = new Material(MapColor.clothColor);
-    public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
+    // FCMOD: Changed
+    //public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
+    public static final Material cloth = (new Material(MapColor.clothColor)).setBurning().SetAxesEfficientOn();
+    // END FCMOD
     public static final Material fire = (new MaterialTransparent(MapColor.airColor)).setNoPushMobility();
-    public static final Material sand = new Material(MapColor.sandColor);
+    // FCMOD: Changed
+    //public static final Material sand = new Material(MapColor.sandColor);
+    public static final Material sand = (new Material(MapColor.sandColor)).setRequiresTool();
+    // END FCMOD
     public static final Material circuits = (new MaterialLogic(MapColor.airColor)).setNoPushMobility();
+    // FCMOD: Changed
+    //public static final Material glass = (new Material(MapColor.airColor)).setTranslucent().setAlwaysHarvested();
     public static final Material glass = (new Material(MapColor.airColor)).setTranslucent().setAlwaysHarvested();
+    // END FCMOD
     public static final Material redstoneLight = (new Material(MapColor.airColor)).setAlwaysHarvested();
+    // FCMOD: Changed
+    //public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setTranslucent();
     public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setTranslucent();
+    // END FCMOD
     public static final Material coral = (new Material(MapColor.foliageColor)).setNoPushMobility();
     public static final Material ice = (new Material(MapColor.iceColor)).setTranslucent().setAlwaysHarvested();
     public static final Material snow = (new MaterialLogic(MapColor.snowColor)).setReplaceable().setTranslucent().setRequiresTool().setNoPushMobility();
 
     /** The material for crafted snow. */
     public static final Material craftedSnow = (new Material(MapColor.snowColor)).setRequiresTool();
-    public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility();
+    // FCMOD: Changed
+    //public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility();
+    public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility().SetMobsCantSpawnOn();    
+    // END FCMOD
     public static final Material clay = new Material(MapColor.clayColor);
 
     /** pumpkin */
-    public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
+    // FCMOD: Changed
+    //public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
+    public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility().SetAxesEfficientOn();
+    // END FCMOD
     public static final Material dragonEgg = (new Material(MapColor.foliageColor)).setNoPushMobility();
 
     /** Material used for portals */
@@ -113,7 +145,10 @@ public class Material
     /**
      * Marks the material as translucent
      */
-    private Material setTranslucent()
+    // FCMOD: Changed
+    //private Material setTranslucent()
+    protected Material setTranslucent()
+    // END FCMOD
     {
         this.isTranslucent = true;
         return this;
@@ -221,4 +256,63 @@ public class Material
     {
         return this.field_85159_M;
     }
+    
+    // FCMOD: Added New
+    private boolean m_bMobsCanSpawnOn = true;
+    private boolean m_bNetherMobsCanSpawnOn = false;
+    private boolean m_bAxesEfficientOn = false;
+    private boolean m_bAxesTreatAsVegetation = false;
+    
+    public boolean GetMobsCanSpawnOn( int iDimension )
+    {
+    	if ( iDimension == -1 )
+    	{
+    		return m_bNetherMobsCanSpawnOn;
+    	}
+    	
+    	return m_bMobsCanSpawnOn;
+    }
+    
+    public Material SetMobsCantSpawnOn()
+    {
+    	m_bMobsCanSpawnOn = false;
+    	
+    	return this;
+    }
+    
+    public Material SetNetherMobsCanSpawnOn()
+    {
+    	m_bNetherMobsCanSpawnOn = true;
+    	
+    	return this;
+    }
+    
+    public boolean GetAxesEfficientOn()
+    {
+    	return m_bAxesEfficientOn;
+    }
+    
+    public Material SetAxesEfficientOn()
+    {
+    	m_bAxesEfficientOn = true;
+    	
+    	return this;
+    }
+    
+    /**
+     * If true, this material doesn't damage axes or consume hunger if the 
+     * harvesting axe is of sufficient quality 
+     */
+    public boolean GetAxesTreatAsVegetation()
+    {
+    	return m_bAxesTreatAsVegetation;    	
+    }
+    
+    public Material SetAxesTreatAsVegetation()
+    {
+    	m_bAxesTreatAsVegetation = true;
+    	
+    	return this;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/MerchantRecipe.java b/minecraft/net/minecraft/src/MerchantRecipe.java
index a86b871..5d32410 100644
--- a/minecraft/net/minecraft/src/MerchantRecipe.java
+++ b/minecraft/net/minecraft/src/MerchantRecipe.java
@@ -18,8 +18,10 @@ public class MerchantRecipe
 
     /** Maximum times this trade can be used. */
     private int maxTradeUses;
+    
+    private boolean isMandatory;
 
-    public MerchantRecipe(NBTTagCompound par1NBTTagCompound)
+	public MerchantRecipe(NBTTagCompound par1NBTTagCompound)
     {
         this.readFromTags(par1NBTTagCompound);
     }
@@ -29,7 +31,13 @@ public class MerchantRecipe
         this.itemToBuy = par1ItemStack;
         this.secondItemToBuy = par2ItemStack;
         this.itemToSell = par3ItemStack;
+        // FCMOD: Change
+        /*
         this.maxTradeUses = 7;
+        */
+        maxTradeUses = 1;
+        m_iTradeLevel = 1;
+        // END FCMOD
     }
 
     public MerchantRecipe(ItemStack par1ItemStack, ItemStack par2ItemStack)
@@ -133,8 +141,24 @@ public class MerchantRecipe
         }
         else
         {
+            // FCMOD: Change
+            /*
             this.maxTradeUses = 7;
+            */
+        	maxTradeUses = 1;
+        	// END FCMOD
         }
+        
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcTradeLevel" ) )
+        {
+            m_iTradeLevel = par1NBTTagCompound.getInteger("fcTradeLevel");
+        }
+        else
+        {
+        	m_iTradeLevel = 1;
+        }
+        // END FCMOD
     }
 
     public NBTTagCompound writeToTags()
@@ -150,6 +174,40 @@ public class MerchantRecipe
 
         var1.setInteger("uses", this.toolUses);
         var1.setInteger("maxUses", this.maxTradeUses);
+        
+        // FCMOD: Added
+        var1.setInteger( "fcTradeLevel", m_iTradeLevel );
+        // END FCMOD
+        
         return var1;
     }
-}
+    
+    // FCMOD: Added
+    public int m_iTradeLevel;    
+    
+    public MerchantRecipe( ItemStack inputStack1, ItemStack inputStack2, ItemStack outputStack, int iTradeLevel )
+    {
+        this( inputStack1, inputStack2, outputStack );
+        
+        m_iTradeLevel = iTradeLevel;
+    }
+    
+    public MerchantRecipe( ItemStack inputStack, ItemStack outputStack, int iTradeLevel )
+    {
+        this( inputStack, (ItemStack)null, outputStack, iTradeLevel );
+    }
+
+    public MerchantRecipe( ItemStack inputStack, Item outputItem, int iTradeLevel )
+    {
+        this( inputStack, new ItemStack( outputItem ), iTradeLevel );
+    }
+
+    public boolean isMandatory() {
+		return isMandatory;
+	}
+
+	public void setMandatory() {
+		this.isMandatory = true;
+	}
+    // END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/MerchantRecipeList.java b/minecraft/net/minecraft/src/MerchantRecipeList.java
index 5c1e6e0..9ab84bb 100644
--- a/minecraft/net/minecraft/src/MerchantRecipeList.java
+++ b/minecraft/net/minecraft/src/MerchantRecipeList.java
@@ -17,6 +17,8 @@ public class MerchantRecipeList extends ArrayList
     /**
      * can par1,par2 be used to in crafting recipe par3
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public MerchantRecipe canRecipeBeUsed(ItemStack par1ItemStack, ItemStack par2ItemStack, int par3)
     {
         if (par3 > 0 && par3 < this.size())
@@ -39,6 +41,8 @@ public class MerchantRecipeList extends ArrayList
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * checks if there is a recipie for the same ingredients already on the list, and replaces it. otherwise, adds it
@@ -51,10 +55,14 @@ public class MerchantRecipeList extends ArrayList
 
             if (par1MerchantRecipe.hasSameIDsAs(var3))
             {
+            	// FCMOD: Removed to avoid problems with similar items, like skulls or colored candles, replacing each other
+            	/*
                 if (par1MerchantRecipe.hasSameItemsAs(var3))
                 {
                     this.set(var2, par1MerchantRecipe);
                 }
+                */
+            	// END FCMOD
 
                 return;
             }
@@ -81,6 +89,10 @@ public class MerchantRecipeList extends ArrayList
             }
 
             par1DataOutputStream.writeBoolean(var3.func_82784_g());
+            
+            // FCMOD: Code added
+            par1DataOutputStream.writeShort( var3.m_iTradeLevel );
+            // END FCMOD
         }
     }
 
@@ -107,6 +119,12 @@ public class MerchantRecipeList extends ArrayList
             {
                 var8.func_82785_h();
             }
+            
+            // FCMOD: Code added (client only)
+            int iTradeLevel = par0DataInputStream.readShort();
+            
+            var8.m_iTradeLevel = iTradeLevel;
+            // END FCMOD
 
             var1.add(var8);
         }
@@ -139,4 +157,77 @@ public class MerchantRecipeList extends ArrayList
         var1.setTag("Recipes", var2);
         return var1;
     }
+
+    // FCMOD: Code added
+    public MerchantRecipe canRecipeBeUsed( ItemStack inputStack1, ItemStack inputStack2, int iRecipeIndex )
+    {
+        if ( iRecipeIndex >= 0 && iRecipeIndex < size() )
+        {
+            MerchantRecipe recipe = (MerchantRecipe)get(iRecipeIndex);
+            
+            if (IsStackValidForFirstSlotOfRecipe( inputStack1, recipe ) && IsStackValidForSecondSlotOfRecipe( inputStack2, recipe ) )
+            {
+            	return recipe;
+            }
+        }
+        else
+        {
+            for ( int iTempRecipeIndex = 0; iTempRecipeIndex < size(); ++iTempRecipeIndex )
+            {
+                MerchantRecipe tempRecipe = (MerchantRecipe)get( iTempRecipeIndex );
+
+                if (IsStackValidForFirstSlotOfRecipe( inputStack1, tempRecipe ) && IsStackValidForSecondSlotOfRecipe( inputStack2, tempRecipe ) )
+                {
+                	return tempRecipe;
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    private boolean IsStackValidForFirstSlotOfRecipe( ItemStack stack, MerchantRecipe recipe )
+    {
+    	if ( stack.itemID == recipe.getItemToBuy().itemID && stack.stackSize >= recipe.getItemToBuy().stackSize )
+    	{
+    		if ( recipe.getItemToBuy().getHasSubtypes() )
+    		{
+    			return stack.getItemDamage() == recipe.getItemToBuy().getItemDamage(); 
+    		}
+    		else
+    		{
+    			return true;
+    		}
+    	}
+    	
+    	return false;
+    }
+    
+    private boolean IsStackValidForSecondSlotOfRecipe( ItemStack stack, MerchantRecipe recipe )
+    {
+    	if ( recipe.hasSecondItemToBuy() )
+    	{
+    		if ( stack != null )
+    		{
+	        	if ( stack.itemID == recipe.getSecondItemToBuy().itemID && stack.stackSize >= recipe.getSecondItemToBuy().stackSize )
+	        	{
+	        		if ( recipe.getSecondItemToBuy().getHasSubtypes() )
+	        		{
+	        			return stack.getItemDamage() == recipe.getSecondItemToBuy().getItemDamage(); 
+	        		}
+	        		else
+	        		{
+	        			return true;
+	        		}
+	        	}
+    		}
+    	}
+    	else if ( stack == null )
+    	{
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/MobSpawnerBaseLogic.java b/minecraft/net/minecraft/src/MobSpawnerBaseLogic.java
index 60876e4..83f48d6 100644
--- a/minecraft/net/minecraft/src/MobSpawnerBaseLogic.java
+++ b/minecraft/net/minecraft/src/MobSpawnerBaseLogic.java
@@ -9,7 +9,7 @@ public abstract class MobSpawnerBaseLogic
     /** The delay to spawn. */
     public int spawnDelay = 20;
     private String mobID = "Pig";
-
+    
     /** List of minecart to spawn. */
     private List minecartToSpawn = null;
     private WeightedRandomMinecart randomMinecart = null;
@@ -120,6 +120,12 @@ public abstract class MobSpawnerBaseLogic
                     double var7 = (double)(this.getSpawnerY() + this.getSpawnerWorld().rand.nextInt(3) - 1);
                     double var9 = (double)this.getSpawnerZ() + (this.getSpawnerWorld().rand.nextDouble() - this.getSpawnerWorld().rand.nextDouble()) * (double)this.spawnRange;
                     EntityLiving var11 = var13 instanceof EntityLiving ? (EntityLiving)var13 : null;
+                    // FCMOD: Added
+                    if ( var11 != null )
+                    {
+                    	var11.PreInitCreature();
+                    }
+                    // END FCMOD                    
                     var13.setLocationAndAngles(var5, var7, var9, this.getSpawnerWorld().rand.nextFloat() * 360.0F, 0.0F);
 
                     if (var11 == null || var11.getCanSpawnHere())
@@ -195,7 +201,12 @@ public abstract class MobSpawnerBaseLogic
         }
         else if (par1Entity instanceof EntityLiving && par1Entity.worldObj != null)
         {
+        	// FCMOD: Code change to prevent mobs spawning with armor and weapons
+        	/*
             ((EntityLiving)par1Entity).initCreature();
+            */
+            ((EntityLiving)par1Entity).SpawnerInitCreature();
+        	// END FCMOD
             this.getSpawnerWorld().spawnEntityInWorld(par1Entity);
         }
 
diff --git a/minecraft/net/minecraft/src/ModelCow.java b/minecraft/net/minecraft/src/ModelCow.java
index 5704036..30c6158 100644
--- a/minecraft/net/minecraft/src/ModelCow.java
+++ b/minecraft/net/minecraft/src/ModelCow.java
@@ -24,4 +24,55 @@ public class ModelCow extends ModelQuadruped
         --this.leg4.rotationPointZ;
         this.field_78151_h += 2.0F;
     }
+    
+    // FCMOD: Added (client only)
+    private float m_fHeadRotation;
+    
+    public void setLivingAnimations( EntityLiving entity, float par2, float par3, 
+    	float fPartialTick )
+    {
+        super.setLivingAnimations( entity, par2, par3, fPartialTick );
+
+        FCEntityCow cow = (FCEntityCow)entity;
+        
+        head.rotationPointY = 4F + cow.GetGrazeHeadVerticalOffset( fPartialTick ) * 4F;
+        
+        m_fHeadRotation = cow.GetGrazeHeadRotation( fPartialTick );
+    }
+
+    public void setRotationAngles( float par1, float par2, float par3, 
+    	float par4, float par5, float par6, Entity entity )
+    {
+        super.setRotationAngles( par1, par2, par3, par4, par5, par6, entity );
+        
+        AdjustRotationAnglesForKickAttack( par1, par2, par3, par4, par5, par6, entity );
+        
+        head.rotateAngleX = m_fHeadRotation;
+    }
+    
+    private void AdjustRotationAnglesForKickAttack( float par1, float par2, float par3, 
+    	float par4, float par5, float par6, Entity entity)
+    {
+    	FCEntityCow cow = (FCEntityCow)entity;
+    	
+    	if ( cow != null )
+    	{
+	    	int iAttackProgressCounter = cow.m_iKickAttackInProgressCounter;
+	    	
+	    	if ( iAttackProgressCounter > 0 )
+	    	{
+	    		float fRotationFactor = 2F;
+	    		
+	    		if ( cow.m_iKickAttackLegUsed == 0 )
+	    		{
+	    			leg1.rotateAngleX = MathHelper.cos( (float)Math.PI * fRotationFactor ) * 1.4F;
+	    		}
+	    		else
+	    		{
+	    			leg2.rotateAngleX = MathHelper.cos( (float)Math.PI * fRotationFactor ) * 1.4F;
+	    		}
+	    	}
+    	}
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ModelRenderer.java b/minecraft/net/minecraft/src/ModelRenderer.java
index deedd49..db10a34 100644
--- a/minecraft/net/minecraft/src/ModelRenderer.java
+++ b/minecraft/net/minecraft/src/ModelRenderer.java
@@ -180,7 +180,7 @@ public class ModelRenderer
                     {
                         GL11.glRotatef(this.rotateAngleX * (180F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
                     }
-
+                    
                     GL11.glCallList(this.displayList);
 
                     if (this.childModels != null)
@@ -305,4 +305,104 @@ public class ModelRenderer
         this.textureHeight = (float)par2;
         return this;
     }
+    
+    // FCMOD: Code added
+    public void RenderWithScaleToBaseModel( float par1, float fScaleX, float fScaleY, float fScaleZ )
+    {
+        if (!this.isHidden)
+        {
+            if (this.showModel)
+            {
+                if (!this.compiled)
+                {
+                    this.compileDisplayList(par1);
+                }
+
+                GL11.glTranslatef(this.field_82906_o, this.field_82908_p, this.field_82907_q);
+                int var2;
+
+                if (this.rotateAngleX == 0.0F && this.rotateAngleY == 0.0F && this.rotateAngleZ == 0.0F)
+                {
+                    if (this.rotationPointX == 0.0F && this.rotationPointY == 0.0F && this.rotationPointZ == 0.0F)
+                    {
+                        GL11.glPushMatrix();
+                        
+                    	GL11.glScalef( fScaleX, fScaleY, fScaleZ );
+                    	
+                        GL11.glCallList(this.displayList);
+
+                        if (this.childModels != null)
+                        {
+                            for (var2 = 0; var2 < this.childModels.size(); ++var2)
+                            {
+                                ((ModelRenderer)this.childModels.get(var2)).render(par1);
+                            }
+                        }
+                        
+                        GL11.glPopMatrix();
+                    }
+                    else
+                    {
+                        GL11.glTranslatef(this.rotationPointX * par1, this.rotationPointY * par1, this.rotationPointZ * par1);
+                        
+                        GL11.glPushMatrix();
+                        
+                    	GL11.glScalef( fScaleX, fScaleY, fScaleZ );
+                    	
+                        GL11.glCallList(this.displayList);
+
+                        if (this.childModels != null)
+                        {
+                            for (var2 = 0; var2 < this.childModels.size(); ++var2)
+                            {
+                                ((ModelRenderer)this.childModels.get(var2)).render(par1);
+                            }
+                        }
+                        
+                        GL11.glPopMatrix();
+
+                        GL11.glTranslatef(-this.rotationPointX * par1, -this.rotationPointY * par1, -this.rotationPointZ * par1);
+                    }
+                }
+                else
+                {
+                    GL11.glPushMatrix();
+                    GL11.glTranslatef(this.rotationPointX * par1, this.rotationPointY * par1, this.rotationPointZ * par1);
+
+                    if (this.rotateAngleZ != 0.0F)
+                    {
+                        GL11.glRotatef(this.rotateAngleZ * (180F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+                    }
+
+                    if (this.rotateAngleY != 0.0F)
+                    {
+                        GL11.glRotatef(this.rotateAngleY * (180F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+                    }
+
+                    if (this.rotateAngleX != 0.0F)
+                    {
+                        GL11.glRotatef(this.rotateAngleX * (180F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
+                    }
+                    
+                	GL11.glScalef( fScaleX, fScaleY, fScaleZ );
+                	
+                    GL11.glCallList(this.displayList);
+
+                    if (this.childModels != null)
+                    {
+                        for (var2 = 0; var2 < this.childModels.size(); ++var2)
+                        {
+                            ((ModelRenderer)this.childModels.get(var2)).render(par1);
+                        }
+                    }
+
+                    GL11.glPopMatrix();
+                }
+
+                GL11.glTranslatef(-this.field_82906_o, -this.field_82908_p, -this.field_82907_q);
+            }
+        }
+    }
+    // END FCMOD
+
 }
diff --git a/minecraft/net/minecraft/src/ModelSquid.java b/minecraft/net/minecraft/src/ModelSquid.java
index 72d5f1b..de77d1d 100644
--- a/minecraft/net/minecraft/src/ModelSquid.java
+++ b/minecraft/net/minecraft/src/ModelSquid.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class ModelSquid extends ModelBase
diff --git a/minecraft/net/minecraft/src/ModelWolf.java b/minecraft/net/minecraft/src/ModelWolf.java
index 0d5256e..6bf6c33 100644
--- a/minecraft/net/minecraft/src/ModelWolf.java
+++ b/minecraft/net/minecraft/src/ModelWolf.java
@@ -27,6 +27,10 @@ public class ModelWolf extends ModelBase
 
     /** The wolf's mane */
     ModelRenderer wolfMane;
+    
+    // FCMOD: Added (client only)
+    private float m_fHeadRotation;
+    // END FCMOD
 
     public ModelWolf()
     {
@@ -107,9 +111,16 @@ public class ModelWolf extends ModelBase
      */
     public void setLivingAnimations(EntityLiving par1EntityLiving, float par2, float par3, float par4)
     {
+        // FCMOD: Changed (client only)
+        /*
         EntityWolf var5 = (EntityWolf)par1EntityLiving;
 
         if (var5.isAngry())
+        */
+        FCEntityWolf var5 = (FCEntityWolf)par1EntityLiving;
+
+        if ( var5.isAngry()|| var5.IsWildAndHostile() )
+        // END FCMOD
         {
             this.wolfTail.rotateAngleY = 0.0F;
         }
@@ -156,6 +167,12 @@ public class ModelWolf extends ModelBase
         this.wolfMane.rotateAngleZ = var5.getShakeAngle(par4, -0.08F);
         this.wolfBody.rotateAngleZ = var5.getShakeAngle(par4, -0.16F);
         this.wolfTail.rotateAngleZ = var5.getShakeAngle(par4, -0.2F);
+        
+        // FCMOD: Added (client only)
+        wolfHeadMain.rotationPointY = 13.5F + ((FCEntityWolf)par1EntityLiving).GetGrazeHeadVerticalOffset(par4) * 5.0F;
+        m_fHeadRotation = ((FCEntityWolf)par1EntityLiving).GetGrazeHeadRotation(par4);
+        wolfHeadMain.rotateAngleZ += var5.GetPossessionHeadRotation();
+        // END FCMOD
     }
 
     /**
@@ -169,5 +186,9 @@ public class ModelWolf extends ModelBase
         this.wolfHeadMain.rotateAngleX = par5 / (180F / (float)Math.PI);
         this.wolfHeadMain.rotateAngleY = par4 / (180F / (float)Math.PI);
         this.wolfTail.rotateAngleX = par3;
+        
+        // FCMOD: Added (client only)
+        wolfHeadMain.rotateAngleX = m_fHeadRotation;
+        // ENDD FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/NetClientHandler.java b/minecraft/net/minecraft/src/NetClientHandler.java
index bb563e8..6532e33 100644
--- a/minecraft/net/minecraft/src/NetClientHandler.java
+++ b/minecraft/net/minecraft/src/NetClientHandler.java
@@ -104,6 +104,10 @@ public class NetClientHandler extends NetHandler
         {
             this.netManager.wakeThreads();
         }
+        
+        // FCMOD: Added (client only)
+        UpdateTerrainLoad();
+        // END FCMOD        
     }
 
     public void handleServerAuthData(Packet253ServerAuthData par1Packet253ServerAuthData)
@@ -174,6 +178,7 @@ public class NetClientHandler extends NetHandler
         this.mc.gameSettings.sendSettingsToServer();
     }
 
+    // Misnamed - actually handles all entities
     public void handleVehicleSpawn(Packet23VehicleSpawn par1Packet23VehicleSpawn)
     {
         double var2 = (double)par1Packet23VehicleSpawn.xPosition / 32.0D;
@@ -233,7 +238,10 @@ public class NetClientHandler extends NetHandler
         }
         else if (par1Packet23VehicleSpawn.type == 66)
         {
-            var8 = new EntityWitherSkull(this.worldClient, var2, var4, var6, (double)par1Packet23VehicleSpawn.speedX / 8000.0D, (double)par1Packet23VehicleSpawn.speedY / 8000.0D, (double)par1Packet23VehicleSpawn.speedZ / 8000.0D);
+        	// FCMOD: Changed (client only)
+            //var8 = new EntityWitherSkull(this.worldClient, var2, var4, var6, (double)par1Packet23VehicleSpawn.speedX / 8000.0D, (double)par1Packet23VehicleSpawn.speedY / 8000.0D, (double)par1Packet23VehicleSpawn.speedZ / 8000.0D);
+            var8 = new FCEntityWitherSkull(this.worldClient, var2, var4, var6, (double)par1Packet23VehicleSpawn.speedX / 8000.0D, (double)par1Packet23VehicleSpawn.speedY / 8000.0D, (double)par1Packet23VehicleSpawn.speedZ / 8000.0D);
+            // END FCMOD
             par1Packet23VehicleSpawn.throwerEntityId = 0;
         }
         else if (par1Packet23VehicleSpawn.type == 62)
@@ -268,9 +276,34 @@ public class NetClientHandler extends NetHandler
         }
         else if (par1Packet23VehicleSpawn.type == 70)
         {
-            var8 = new EntityFallingSand(this.worldClient, var2, var4, var6, par1Packet23VehicleSpawn.throwerEntityId & 65535, par1Packet23VehicleSpawn.throwerEntityId >> 16);
+        	// FCMOD: Changed (client only)
+            //var8 = new EntityFallingSand(this.worldClient, var2, var4, var6, par1Packet23VehicleSpawn.throwerEntityId & 65535, par1Packet23VehicleSpawn.throwerEntityId >> 16);
+            var8 = new FCEntityFallingBlock(this.worldClient, var2, var4, var6, par1Packet23VehicleSpawn.throwerEntityId & 65535, par1Packet23VehicleSpawn.throwerEntityId >> 16);
+            // END FCMOD
             par1Packet23VehicleSpawn.throwerEntityId = 0;
         }
+        // FCMOD: Added (client only)
+        else if ( par1Packet23VehicleSpawn.type == FCEntityInfiniteArrow.GetVehicleSpawnPacketType() )
+        {
+        	var8 = new FCEntityInfiniteArrow( worldClient, var2, var4, var6 );
+        }
+        else if ( par1Packet23VehicleSpawn.type == FCEntityBroadheadArrow.GetVehicleSpawnPacketType() )
+        {
+        	var8 = new FCEntityBroadheadArrow( worldClient, var2, var4, var6 );
+        }
+        else if ( par1Packet23VehicleSpawn.type == FCEntityMovingPlatform.GetVehicleSpawnPacketType() )
+        {
+        	var8 = new FCEntityMovingPlatform( worldClient, var2, var4, var6, null );
+        }
+        else if ( par1Packet23VehicleSpawn.type == FCEntityMovingAnchor.GetVehicleSpawnPacketType() )
+        {
+        	var8 = new FCEntityMovingAnchor( worldClient, var2, var4, var6 );
+        }
+        else if ( par1Packet23VehicleSpawn.type == FCEntityRottenArrow.GetVehicleSpawnPacketType() )
+        {
+        	var8 = new FCEntityRottenArrow( worldClient, var2, var4, var6 );
+        }
+        // END FCMOD
 
         if (var8 != null)
         {
@@ -296,7 +329,12 @@ public class NetClientHandler extends NetHandler
 
             if (par1Packet23VehicleSpawn.throwerEntityId > 0)
             {
+            	// FCMOD: Changed (client only)
+            	/*
                 if (par1Packet23VehicleSpawn.type == 60)
+                */
+            	if ( var8 instanceof EntityArrow )
+            	// END FCMOD
                 {
                     Entity var13 = this.getEntityByID(par1Packet23VehicleSpawn.throwerEntityId);
 
@@ -317,7 +355,16 @@ public class NetClientHandler extends NetHandler
      */
     public void handleEntityExpOrb(Packet26EntityExpOrb par1Packet26EntityExpOrb)
     {
+    	// FCMOD: Changed to deal with ownership parameter, and to fix vanilla bug that cause an invalid initial pos (client only)
+    	/*
         EntityXPOrb var2 = new EntityXPOrb(this.worldClient, (double)par1Packet26EntityExpOrb.posX, (double)par1Packet26EntityExpOrb.posY, (double)par1Packet26EntityExpOrb.posZ, par1Packet26EntityExpOrb.xpValue);
+        */
+    	double posX = par1Packet26EntityExpOrb.posX / 32D;
+    	double posY = par1Packet26EntityExpOrb.posY / 32D;
+    	double posZ = par1Packet26EntityExpOrb.posZ / 32D;
+        EntityXPOrb var2 = new EntityXPOrb(worldClient, posX, posY, posZ, 
+    		par1Packet26EntityExpOrb.xpValue, par1Packet26EntityExpOrb.m_bNotPlayerOwned );
+        // END FCMOD
         var2.serverPosX = par1Packet26EntityExpOrb.posX;
         var2.serverPosY = par1Packet26EntityExpOrb.posY;
         var2.serverPosZ = par1Packet26EntityExpOrb.posZ;
@@ -335,12 +382,22 @@ public class NetClientHandler extends NetHandler
         double var2 = (double)par1Packet71Weather.posX / 32.0D;
         double var4 = (double)par1Packet71Weather.posY / 32.0D;
         double var6 = (double)par1Packet71Weather.posZ / 32.0D;
+        // FCMOD: Changed
+        /*
         EntityLightningBolt var8 = null;
 
         if (par1Packet71Weather.isLightningBolt == 1)
         {
             var8 = new EntityLightningBolt(this.worldClient, var2, var4, var6);
         }
+        */
+        FCEntityLightningBolt var8 = null;
+
+        if ( par1Packet71Weather.isLightningBolt == 1 )
+        {
+            var8 = new FCEntityLightningBolt( worldClient, var2, var4, var6 );
+        }
+        // END FCMOD
 
         if (var8 != null)
         {
@@ -520,10 +577,16 @@ public class NetClientHandler extends NetHandler
             this.mc.thePlayer.prevPosX = this.mc.thePlayer.posX;
             this.mc.thePlayer.prevPosY = this.mc.thePlayer.posY;
             this.mc.thePlayer.prevPosZ = this.mc.thePlayer.posZ;
+            // FCMOD: Changed (client only)
+            /*
             this.doneLoadingTerrain = true;
             this.mc.displayGuiScreen((GuiScreen)null);
+            */
+            m_bAwaitingChunkLoadToDisableGUIScreen = true;
+            m_iUpdatesSinceTerrainLoaded = 0;
+            // END FCMOD
         }
-    }
+    }    
 
     public void handleMultiBlockChange(Packet52MultiBlockChange par1Packet52MultiBlockChange)
     {
@@ -819,7 +882,11 @@ public class NetClientHandler extends NetHandler
 
         if (var2 != null)
         {
-            ((Entity)var2).mountEntity(var3);
+        	// FCMOD: Changed (client only) to implement fix described in MC-1291
+        	// for players dissapearing after riding boats in SMP
+            //((Entity)var2).mountEntity(var3);
+            ((Entity)var2).MountEntityRemote( var3 );
+        	// END FCMOD
         }
     }
 
@@ -875,6 +942,14 @@ public class NetClientHandler extends NetHandler
             this.mc.thePlayer.dimension = par1Packet9Respawn.respawnDimension;
             this.mc.displayGuiScreen(new GuiDownloadTerrain(this));
         }
+    	// FCMOD: Added (client only) to display loading screen on regular spawn due to 
+        // Hardcore Spawn making the player appear in ungenerated terrain
+        else
+        {
+            doneLoadingTerrain = false;
+            mc.displayGuiScreen(new GuiDownloadTerrain(this));
+        }
+        // END FCMOD        
 
         this.mc.setDimensionAndSpawnPlayer(par1Packet9Respawn.respawnDimension);
         this.mc.playerController.setGameType(par1Packet9Respawn.gameType);
@@ -907,6 +982,7 @@ public class NetClientHandler extends NetHandler
                 break;
 
             case 2:
+            	
                 TileEntityFurnace var4 = new TileEntityFurnace();
 
                 if (par1Packet100OpenWindow.useProvidedWindowTitle)
@@ -1123,6 +1199,12 @@ public class NetClientHandler extends NetHandler
                 {
                     var2.readFromNBT(par1Packet132TileEntityData.customParam1);
                 }
+                // FCMOD: Added (client only)
+                else if ( par1Packet132TileEntityData.actionType == 1 && ( var2 instanceof FCITileEntityDataPacketHandler ) )
+                {
+                    ((FCITileEntityDataPacketHandler)var2).readNBTFromPacket( par1Packet132TileEntityData.customParam1 );
+                }
+                // END FCMOD
             }
         }
     }
@@ -1217,6 +1299,12 @@ public class NetClientHandler extends NetHandler
         {
             this.worldClient.getWorldInfo().setRaining(true);
             this.worldClient.setRainStrength(0.0F);
+            // FCMOD: Added (client only)
+            if ( var4 != 0 )
+            {
+                this.worldClient.setRainStrength(1.0F);
+            }
+            // END FCMOD
         }
         else if (var3 == 2)
         {
@@ -1229,6 +1317,14 @@ public class NetClientHandler extends NetHandler
         }
         else if (var3 == 4)
         {
+        	// FCMOD: Added (client only) to skip the end text and just respawn immediately        	
+        	if ( FCBetterThanWolves.fcDisableEndText )
+        	{
+                this.mc.thePlayer.sendQueue.addToSendQueue(new Packet205ClientCommand(1));
+                
+                return;
+        	}
+        	// END FCMOD
             this.mc.displayGuiScreen(new GuiWinGame());
         }
         else if (var3 == 5)
@@ -1256,6 +1352,26 @@ public class NetClientHandler extends NetHandler
         {
             this.worldClient.playSound(var2.posX, var2.posY + (double)var2.getEyeHeight(), var2.posZ, "random.successful_hit", 0.18F, 0.45F, false);
         }
+        // FCMOD: Added (client only)
+        if (var3 == 7)
+        {
+            worldClient.getWorldInfo().setThundering(true);
+
+            if ( var4 == 0 )
+            {
+            	worldClient.prevThunderingStrength = worldClient.thunderingStrength = 0.0F;
+            }
+            else
+            {
+            	worldClient.prevThunderingStrength = worldClient.thunderingStrength = 1.0F;
+            }
+        }
+        else if (var3 == 8)
+        {
+            worldClient.getWorldInfo().setThundering(false);
+            worldClient.prevThunderingStrength = worldClient.thunderingStrength = 1.0F;
+        }
+        // END FCMOD
     }
 
     /**
@@ -1302,7 +1418,20 @@ public class NetClientHandler extends NetHandler
 
         if (var2 instanceof EntityLiving)
         {
+        	// FCMOD: Changed (client only) to add ambient param 
+        	/*
             PotionEffect var3 = new PotionEffect(par1Packet41EntityEffect.effectId, par1Packet41EntityEffect.duration, par1Packet41EntityEffect.effectAmplifier);
+            */
+        	boolean bIsAmbient = false;
+
+        	if ( par1Packet41EntityEffect.m_bIsAmbient > 0 )
+        	{
+        		bIsAmbient = true;
+        	}
+
+            PotionEffect var3 = new PotionEffect(par1Packet41EntityEffect.effectId, par1Packet41EntityEffect.duration, par1Packet41EntityEffect.effectAmplifier,
+				bIsAmbient );
+            // END FCMOD
             var3.setPotionDurationMax(par1Packet41EntityEffect.isDurationMax());
             ((EntityLiving)var2).addPotionEffect(var3);
         }
@@ -1433,6 +1562,12 @@ public class NetClientHandler extends NetHandler
                 var7.printStackTrace();
             }
         }
+        // FCMOD: Added (client only)
+        else if (!FCAddOnHandler.interceptCustomClientPacket(this.mc, par1Packet250CustomPayload))
+        {
+            FCAddOnHandler.ClientCustomPacketReceived(this.mc, par1Packet250CustomPayload);
+        }
+        // END FCMOD
     }
 
     /**
@@ -1580,4 +1715,56 @@ public class NetClientHandler extends NetHandler
     {
         return this.netManager;
     }
+    
+    // FCMOD: Added (client only)    
+    private boolean m_bAwaitingChunkLoadToDisableGUIScreen = false;
+    private int m_iUpdatesSinceTerrainLoaded = 0;
+    private static final int m_iAdditionalLoadDelay = 20;
+    
+    private void UpdateTerrainLoad()
+    {
+    	if ( m_bAwaitingChunkLoadToDisableGUIScreen )
+    	{
+    		if ( IsTerrainAroundPlayerLoaded() )
+    		{
+    			m_iUpdatesSinceTerrainLoaded++;
+    			
+    			// give it an extra second to help smooth things out post load
+    			if ( m_iUpdatesSinceTerrainLoaded > m_iAdditionalLoadDelay )
+    			{
+		            doneLoadingTerrain = true;
+		            mc.displayGuiScreen((GuiScreen)null);
+		            m_bAwaitingChunkLoadToDisableGUIScreen = false;
+    			}
+    		}
+    		else
+    		{
+    			m_iUpdatesSinceTerrainLoaded = 0;
+    		}
+    	}
+    }
+    
+    public boolean IsTerrainAroundPlayerLoaded()
+    {
+    	int iPlayerBlockI = (int)mc.thePlayer.posX;
+    	int iPlayerBlockK = (int)mc.thePlayer.posZ;
+
+    	int iScanRange = 48;
+    	
+    	for ( int iTempI = iPlayerBlockI - iScanRange; iTempI <= iPlayerBlockI + iScanRange; iTempI += 16 )
+    	{
+        	for ( int iTempK = iPlayerBlockK - iScanRange; iTempK <= iPlayerBlockK + iScanRange; iTempK +=16 )
+        	{
+        		Chunk tempChunk = worldClient.getChunkFromBlockCoords( iTempI, iTempK );
+        		
+        		if ( !tempChunk.isChunkLoaded )
+        		{
+        			return false;
+        		}
+        	}
+    	}
+    	
+    	return true;    	
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/NetHandler.java b/minecraft/net/minecraft/src/NetHandler.java
index e3aef85..7c6b110 100644
--- a/minecraft/net/minecraft/src/NetHandler.java
+++ b/minecraft/net/minecraft/src/NetHandler.java
@@ -458,4 +458,11 @@ public abstract class NetHandler
     {
         this.unexpectedPacket(par1Packet63WorldParticles);
     }
+    
+    // FCMOD: Added
+    public void HandleStartBlockHarvest( FCPacket166StartBlockHarvest packet )
+    {
+        unexpectedPacket( packet );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/NetServerHandler.java b/minecraft/net/minecraft/src/NetServerHandler.java
index 964bf29..6d6319e 100644
--- a/minecraft/net/minecraft/src/NetServerHandler.java
+++ b/minecraft/net/minecraft/src/NetServerHandler.java
@@ -8,13 +8,20 @@ import java.util.Iterator;
 import java.util.Random;
 import net.minecraft.server.MinecraftServer;
 
+// FCMOD: Added
+import java.util.List;
+// END FCMOD
+
 public class NetServerHandler extends NetHandler
 {
     /** The underlying network manager for this server handler. */
     public final INetworkManager netManager;
 
     /** Reference to the MinecraftServer object. */
-    private final MinecraftServer mcServer;
+    // FCMOD: Changed to public for simplicity with add-on authors
+    //private final MinecraftServer mcServer;
+    public final MinecraftServer mcServer;
+    // END FCMOD
 
     /** This is set to true whenever a player disconnects from the server. */
     public boolean connectionClosed = false;
@@ -261,11 +268,22 @@ public class NetServerHandler extends NetHandler
                 }
 
                 float var27 = 0.0625F;
+	            // FCMOD: Line changed so that players don't warp through platforms
+	            /*
                 boolean var28 = var2.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var27, (double)var27, (double)var27)).isEmpty();
+	            */
+	            boolean var28 = getCollidingBoundingBoxesIgnoreSpecifiedEntities( var2, playerEntity, playerEntity.boundingBox.copy().contract(var27, var27, var27)).isEmpty();
+	            // END FCMOD
 
                 if (this.playerEntity.onGround && !par1Packet10Flying.onGround && var15 > 0.0D)
                 {
-                    this.playerEntity.addExhaustion(0.2F);
+                	// FCMOD: Changed to take sprinting into account when jumping on server
+                    //this.playerEntity.addExhaustion(0.2F);
+                	if ( !playerEntity.isOnLadder() )
+                	{
+                		playerEntity.AddExhaustionForJump();
+                	}
+                    // END FCMOD
                 }
 
                 this.playerEntity.moveEntity(var13, var15, var17);
@@ -291,7 +309,12 @@ public class NetServerHandler extends NetHandler
                 }
 
                 this.playerEntity.setPositionAndRotation(var5, var7, var9, var11, var12);
+	            // FCMOD: Line changed so that players don't warp through platforms
+	            /*
                 boolean var32 = var2.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var27, (double)var27, (double)var27)).isEmpty();
+	            */
+	            boolean var32 = getCollidingBoundingBoxesIgnoreSpecifiedEntities( var2, playerEntity, playerEntity.boundingBox.copy().contract(var27, var27, var27)).isEmpty();
+	            // END FCMOD
 
                 if (var28 && (var31 || !var32) && !this.playerEntity.isPlayerSleeping())
                 {
@@ -301,7 +324,13 @@ public class NetServerHandler extends NetHandler
 
                 AxisAlignedBB var33 = this.playerEntity.boundingBox.copy().expand((double)var27, (double)var27, (double)var27).addCoord(0.0D, -0.55D, 0.0D);
 
+                // FCMOD: Line change to prevent player being kicked while standing on entities like Wind Mills or Platforms
+                /*
                 if (!this.mcServer.isFlightAllowed() && !this.playerEntity.theItemInWorldManager.isCreative() && !var2.checkBlockCollision(var33))
+                */
+                if (!mcServer.isFlightAllowed() && !playerEntity.theItemInWorldManager.isCreative() && !var2.checkBlockCollision(var33) && 
+            		var2.checkNoEntityCollision( var33, playerEntity ) )
+            	// END FCMOD
                 {
                     if (var29 >= -0.03125D)
                     {
@@ -410,7 +439,10 @@ public class NetServerHandler extends NetHandler
             }
             else if (par1Packet14BlockDig.status == 2)
             {
-                this.playerEntity.theItemInWorldManager.uncheckedTryHarvestBlock(var4, var5, var6);
+            	// FCMOD: Changed (function name differs between client and server )
+                //this.playerEntity.theItemInWorldManager.uncheckedTryHarvestBlock(var4, var5, var6);
+                this.playerEntity.theItemInWorldManager.uncheckedTryHarvestBlock(var4, var5, var6, par1Packet14BlockDig.face);
+                // END FCMOD
 
                 if (var2.getBlockId(var4, var5, var6) != 0)
                 {
@@ -547,6 +579,12 @@ public class NetServerHandler extends NetHandler
         this.kickPlayerFromServer("Protocol error, unexpected packet");
     }
 
+    // FCMOD: Added (client only) alias function to match naming on server
+    public void sendPacket( Packet packet )
+    {
+    	sendPacketToPlayer( packet );
+    }
+    // END FCMOD
     /**
      * addToSendQueue. if it is a chat packet, check before sending it
      */
@@ -720,6 +758,16 @@ public class NetServerHandler extends NetHandler
                 var5 = 9.0D;
             }
 
+        	// FCMOD: Code added to prevent funkiness in interacting with Wind Mills due to size            	
+        	if ( var3 instanceof FCIEntityPacketHandler )
+        	{
+        		if ( ((FCIEntityPacketHandler)var3).ShouldServerTreatAsOversized() )
+        		{
+	        		var4 = true;
+	        		var5 = 256D;
+        		}
+        	}
+        	// END FCMOD
             if (this.playerEntity.getDistanceSqToEntity(var3) < var5)
             {
                 if (par1Packet7UseEntity.isLeftClick == 0)
@@ -802,6 +850,32 @@ public class NetServerHandler extends NetHandler
                 this.playerEntity.openContainer.detectAndSendChanges();
                 this.playerEntity.updateHeldItem();
                 this.playerEntity.playerInventoryBeingManipulated = false;
+                // FCMOD: Added fix for items falling out of sync when player uses numerical hotkeys to swap items to the hotbar
+                // by mousing over in inventory (this is what the 2 indicates)
+                if ( par1Packet102WindowClick.holdingShift == 2 ) 
+                {
+                	int iSlotTo = par1Packet102WindowClick.mouseClick;
+
+                	if ( iSlotTo >= 0 && iSlotTo < 9 )
+                	{
+	                	int iSlotFrom = par1Packet102WindowClick.inventorySlot;
+	                	
+	                	playerEntity.sendSlotContents( playerEntity.openContainer, iSlotFrom, 
+	                		(ItemStack)playerEntity.openContainer.inventoryItemStacks.get( iSlotFrom ) );
+
+	                	// The following assumes the player's hotbar occupies the last 9 slots of all containers, but should be
+	                	// harmless if not, as it'll just refresh some other slot.
+	                	
+                		iSlotTo += playerEntity.openContainer.inventorySlots.size() - 9;
+                		
+                		if ( iSlotTo >= 0 && iSlotTo < playerEntity.openContainer.inventorySlots.size() )
+                		{
+		                	playerEntity.sendSlotContents( playerEntity.openContainer, iSlotTo,
+		                		(ItemStack)playerEntity.openContainer.inventoryItemStacks.get( iSlotTo ) );
+                		}
+                	}
+                }
+                // END FCMOD
             }
             else
             {
@@ -990,6 +1064,24 @@ public class NetServerHandler extends NetHandler
     public void handleClientInfo(Packet204ClientInfo par1Packet204ClientInfo)
     {
         this.playerEntity.updateClientInfo(par1Packet204ClientInfo);
+        
+        // FCMOD: Code added to encode whether BTW is installed in the game difficulty
+        if ( !par1Packet204ClientInfo.IsBTWInstalled() )
+        {
+        	playerEntity.playerNetServerHandler.sendPacketToPlayer( new Packet3Chat( (new StringBuilder()).append( "\2474"). // red text
+	    		append("WARNING: You do not currently have Better Than Wolves installed on your system." ).toString() ) );
+            	
+	    	playerEntity.playerNetServerHandler.sendPacketToPlayer( new Packet3Chat( (new StringBuilder()).append( "\2474"). // red text
+	    		append( "This server requires all clients to have Better Than Wolves version ").
+	    		append( FCBetterThanWolves.fcVersionString).toString() ) );
+                	
+			// client
+	    	mcServer.getLogAgent().logInfo( (new StringBuilder()).
+    		// server
+	    	//mcServer.getLogAgent().func_98233_a( (new StringBuilder()).	    		
+	    		append( playerEntity.username ).append( " logged in without BTW installed" ).toString() );
+        }
+        // END FCMOD
     }
 
     public void handleCustomPayload(Packet250CustomPayload par1Packet250CustomPayload)
@@ -1051,19 +1143,19 @@ public class NetServerHandler extends NetHandler
         }
         else
         {
-            int var13;
+            int var14;
 
             if ("MC|TrSel".equals(par1Packet250CustomPayload.channel))
             {
                 try
                 {
                     var2 = new DataInputStream(new ByteArrayInputStream(par1Packet250CustomPayload.data));
-                    var13 = var2.readInt();
-                    Container var15 = this.playerEntity.openContainer;
+                    var14 = var2.readInt();
+                    Container var16 = this.playerEntity.openContainer;
 
-                    if (var15 instanceof ContainerMerchant)
+                    if (var16 instanceof ContainerMerchant)
                     {
-                        ((ContainerMerchant)var15).setCurrentRecipeIndex(var13);
+                        ((ContainerMerchant)var16).setCurrentRecipeIndex(var14);
                     }
                 }
                 catch (Exception var10)
@@ -1073,7 +1165,7 @@ public class NetServerHandler extends NetHandler
             }
             else
             {
-                int var17;
+                int var18;
 
                 if ("MC|AdvCdm".equals(par1Packet250CustomPayload.channel))
                 {
@@ -1086,16 +1178,16 @@ public class NetServerHandler extends NetHandler
                         try
                         {
                             var2 = new DataInputStream(new ByteArrayInputStream(par1Packet250CustomPayload.data));
-                            var13 = var2.readInt();
-                            var17 = var2.readInt();
+                            var14 = var2.readInt();
+                            var18 = var2.readInt();
                             int var5 = var2.readInt();
                             String var6 = Packet.readString(var2, 256);
-                            TileEntity var7 = this.playerEntity.worldObj.getBlockTileEntity(var13, var17, var5);
+                            TileEntity var7 = this.playerEntity.worldObj.getBlockTileEntity(var14, var18, var5);
 
                             if (var7 != null && var7 instanceof TileEntityCommandBlock)
                             {
                                 ((TileEntityCommandBlock)var7).setCommand(var6);
-                                this.playerEntity.worldObj.markBlockForUpdate(var13, var17, var5);
+                                this.playerEntity.worldObj.markBlockForUpdate(var14, var18, var5);
                                 this.playerEntity.sendChatToPlayer("Command set: " + var6);
                             }
                         }
@@ -1116,17 +1208,17 @@ public class NetServerHandler extends NetHandler
                         try
                         {
                             var2 = new DataInputStream(new ByteArrayInputStream(par1Packet250CustomPayload.data));
-                            var13 = var2.readInt();
-                            var17 = var2.readInt();
-                            ContainerBeacon var18 = (ContainerBeacon)this.playerEntity.openContainer;
-                            Slot var19 = var18.getSlot(0);
+                            var14 = var2.readInt();
+                            var18 = var2.readInt();
+                            ContainerBeacon var17 = (ContainerBeacon)this.playerEntity.openContainer;
+                            Slot var19 = var17.getSlot(0);
 
                             if (var19.getHasStack())
                             {
                                 var19.decrStackSize(1);
-                                TileEntityBeacon var20 = var18.getBeacon();
-                                var20.setPrimaryEffect(var13);
-                                var20.setSecondaryEffect(var17);
+                                TileEntityBeacon var20 = var17.getBeacon();
+                                var20.setPrimaryEffect(var14);
+                                var20.setSecondaryEffect(var18);
                                 var20.onInventoryChanged();
                             }
                         }
@@ -1138,23 +1230,143 @@ public class NetServerHandler extends NetHandler
                 }
                 else if ("MC|ItemName".equals(par1Packet250CustomPayload.channel) && this.playerEntity.openContainer instanceof ContainerRepair)
                 {
-                    ContainerRepair var14 = (ContainerRepair)this.playerEntity.openContainer;
+                    ContainerRepair var13 = (ContainerRepair)this.playerEntity.openContainer;
 
                     if (par1Packet250CustomPayload.data != null && par1Packet250CustomPayload.data.length >= 1)
                     {
-                        String var16 = ChatAllowedCharacters.filerAllowedCharacters(new String(par1Packet250CustomPayload.data));
+                        String var15 = ChatAllowedCharacters.filerAllowedCharacters(new String(par1Packet250CustomPayload.data));
 
-                        if (var16.length() <= 30)
+                        if (var15.length() <= 30)
                         {
-                            var14.updateItemName(var16);
+                            var13.updateItemName(var15);
                         }
                     }
                     else
                     {
-                        var14.updateItemName("");
+                        var13.updateItemName("");
                     }
                 }
+                // FCMOD: Added
+                else
+                {
+                	FCAddOnHandler.ServerCustomPacketReceived( this, par1Packet250CustomPayload );
+                }
+                // END FCMOD
             }
         }
     }
+
+	// FCMOD: Added
+	public List getCollidingBoundingBoxesIgnoreSpecifiedEntities( World world, Entity par1Entity, AxisAlignedBB par2AxisAlignedBB)
+	{
+		// Copied over from World.java with modifications 
+
+	    ArrayList collidingBoundingBoxes = new ArrayList();
+	    
+	    int i = MathHelper.floor_double(par2AxisAlignedBB.minX);
+	    int j = MathHelper.floor_double(par2AxisAlignedBB.maxX + 1.0D);
+	    int k = MathHelper.floor_double(par2AxisAlignedBB.minY);
+	    int l = MathHelper.floor_double(par2AxisAlignedBB.maxY + 1.0D);
+	    int i1 = MathHelper.floor_double(par2AxisAlignedBB.minZ);
+	    int j1 = MathHelper.floor_double(par2AxisAlignedBB.maxZ + 1.0D);
+	
+	    for (int k1 = i; k1 < j; k1++)
+	    {
+	        for (int l1 = i1; l1 < j1; l1++)
+	        {
+	            if (!world.blockExists(k1, 64, l1))
+	            {
+	                continue;
+	            }
+	
+	            for (int i2 = k - 1; i2 < l; i2++)
+	            {
+	                Block block = Block.blocksList[world.getBlockId(k1, i2, l1)];
+	
+	                if (block != null)
+	                {
+	                    block.addCollisionBoxesToList(world, k1, i2, l1, par2AxisAlignedBB, collidingBoundingBoxes, par1Entity);
+	                }
+	            }
+	        }
+	    }
+	
+	    double d = 0.25D;
+	    // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
+		/*
+	    List list = getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d, d, d));
+		*/
+	    List list = world.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d, 2.0, d));
+	    // END FCMOD
+	    Iterator iterator = list.iterator();
+	
+	    do
+	    {
+	        if (!iterator.hasNext())
+	        {
+	            break;
+	        }
+	
+	        Entity entity = (Entity)iterator.next();
+	        
+	        if ( !( entity instanceof FCIEntityIgnoreServerValidation ) )
+			{
+	            AxisAlignedBB axisalignedbb = entity.getBoundingBox();
+	
+	            if (axisalignedbb != null && axisalignedbb.intersectsWith(par2AxisAlignedBB))
+	            {
+	                collidingBoundingBoxes.add(axisalignedbb);
+	            }
+	
+	            axisalignedbb = par1Entity.getCollisionBox(entity);
+	
+	            if (axisalignedbb != null && axisalignedbb.intersectsWith(par2AxisAlignedBB))
+	            {
+	                collidingBoundingBoxes.add(axisalignedbb);
+	            }
+			}
+	    }
+	    while (true);
+	
+	    return collidingBoundingBoxes;
+	}
+    
+    public void HandleStartBlockHarvest( FCPacket166StartBlockHarvest packet )
+    {
+        WorldServer world = mcServer.worldServerForDimension( playerEntity.dimension );
+
+        int i = packet.iIPos;
+        int j = packet.iJPos;
+        int k = packet.iKPos;
+
+        double dDeltaX = playerEntity.posX - ( (double)i + 0.5D );
+        double dDeltaY = playerEntity.posY - ( (double)j + 0.5D ) + 1.5D;
+        double dDeltaZ = playerEntity.posZ - ( (double)k + 0.5D );
+        
+        double dDistSq = dDeltaX * dDeltaX + dDeltaY * dDeltaY + dDeltaZ * dDeltaZ;
+
+        if ( dDistSq <= 36D && j < mcServer.getBuildLimit() )
+        {
+	        if ( !IsBlockWithinSpawnProtection( world, i, j, k ) )
+	        {
+	        	playerEntity.SetMiningSpeedModifier( packet.GetMiningSpeedModifier() );
+	        	
+	            playerEntity.theItemInWorldManager.onBlockClicked(i, j, k, packet.iFace );
+	        }
+	        else
+	        {
+	        	// I assume the following resets the block harvest on the player's client
+
+	        	FCUtilsWorld.SendPacketToPlayer( playerEntity.playerNetServerHandler, new Packet53BlockChange( i, j, k, world ) );
+	        }
+        }
+    }
+    
+    private boolean IsBlockWithinSpawnProtection( World world, int i, int j, int k )
+    {
+    	// func_96290_a checks if the block is within the spawn protection area on dedicated servers
+    	
+    	return mcServer.func_96290_a( world, i, j, k, playerEntity );
+    }
+	// END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/NpcMerchant.java b/minecraft/net/minecraft/src/NpcMerchant.java
index 318aa82..b3c8bea 100644
--- a/minecraft/net/minecraft/src/NpcMerchant.java
+++ b/minecraft/net/minecraft/src/NpcMerchant.java
@@ -34,5 +34,30 @@ public class NpcMerchant implements IMerchant
         this.recipeList = par1MerchantRecipeList;
     }
 
-    public void useRecipe(MerchantRecipe par1MerchantRecipe) {}
+    public void useRecipe(MerchantRecipe par1MerchantRecipe) 
+    {
+    	// FCMOD: Added so that trades are blocked on client when they are used up
+    	par1MerchantRecipe.incrementToolUses();
+        // END FCMOD
+    }    
+    
+    // FCMOD: Added
+    @Override
+    public int GetCurrentTradeLevel()
+    {
+    	return 0;
+    }
+    
+    @Override
+    public int GetCurrentTradeXP()
+    {
+    	return 0;
+    }
+    
+    @Override
+    public int GetCurrentTradeMaxXP()
+    {
+    	return 0;
+    }    
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/Packet15Place.java b/minecraft/net/minecraft/src/Packet15Place.java
index 4c74572..6aceaea 100644
--- a/minecraft/net/minecraft/src/Packet15Place.java
+++ b/minecraft/net/minecraft/src/Packet15Place.java
@@ -47,9 +47,16 @@ public class Packet15Place extends Packet
         this.zPosition = par1DataInputStream.readInt();
         this.direction = par1DataInputStream.read();
         this.itemStack = readItemStack(par1DataInputStream);
+        // FCMOD: Code change to fix rounding errors
+        /*
         this.xOffset = (float)par1DataInputStream.read() / 16.0F;
         this.yOffset = (float)par1DataInputStream.read() / 16.0F;
         this.zOffset = (float)par1DataInputStream.read() / 16.0F;
+        */
+        this.xOffset = (float)par1DataInputStream.readShort() / 32000F;
+        this.yOffset = (float)par1DataInputStream.readShort() / 32000F;
+        this.zOffset = (float)par1DataInputStream.readShort() / 32000F;
+        // END FCMOD
     }
 
     /**
@@ -62,9 +69,16 @@ public class Packet15Place extends Packet
         par1DataOutputStream.writeInt(this.zPosition);
         par1DataOutputStream.write(this.direction);
         writeItemStack(this.itemStack, par1DataOutputStream);
+        // FCMOD: Code change to fix rounding errors
+        /*
         par1DataOutputStream.write((int)(this.xOffset * 16.0F));
         par1DataOutputStream.write((int)(this.yOffset * 16.0F));
         par1DataOutputStream.write((int)(this.zOffset * 16.0F));
+        */
+        par1DataOutputStream.writeShort((int)(this.xOffset * 32000F + 0.5F));
+        par1DataOutputStream.writeShort((int)(this.yOffset * 32000F + 0.5F));
+        par1DataOutputStream.writeShort((int)(this.zOffset * 32000F + 0.5F));
+        // END FCMOD        
     }
 
     /**
@@ -80,7 +94,12 @@ public class Packet15Place extends Packet
      */
     public int getPacketSize()
     {
+    	// FCMOD: Code change
+    	/*
         return 19;
+        */
+        return 22;
+        // END FCMOD
     }
 
     public int getXPosition()
diff --git a/minecraft/net/minecraft/src/Packet204ClientInfo.java b/minecraft/net/minecraft/src/Packet204ClientInfo.java
index 67aecd1..96dc55a 100644
--- a/minecraft/net/minecraft/src/Packet204ClientInfo.java
+++ b/minecraft/net/minecraft/src/Packet204ClientInfo.java
@@ -23,6 +23,9 @@ public class Packet204ClientInfo extends Packet
         this.chatColours = par4;
         this.gameDifficulty = par5;
         this.showCape = par6;
+        // FCMOD: Added to encode whether BTW is installed in the game difficulty 
+        gameDifficulty = par5 + 10;
+        // FCMOD
     }
 
     /**
@@ -89,6 +92,12 @@ public class Packet204ClientInfo extends Packet
 
     public int getDifficulty()
     {
+        // FCMOD: Code added to encode whether BTW is installed in the game difficulty
+    	if ( gameDifficulty >= 10 )
+    	{
+    		return gameDifficulty - 10;
+    	}
+    	// END FCMOD
         return this.gameDifficulty;
     }
 
@@ -113,4 +122,11 @@ public class Packet204ClientInfo extends Packet
     {
         return true;
     }
+    
+    // FCMOD: Function added to encode whether BTW is installed in the game difficulty
+    public boolean IsBTWInstalled()
+    {
+    	return gameDifficulty >= 10;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/Packet24MobSpawn.java b/minecraft/net/minecraft/src/Packet24MobSpawn.java
index 7590564..3dd0bb9 100644
--- a/minecraft/net/minecraft/src/Packet24MobSpawn.java
+++ b/minecraft/net/minecraft/src/Packet24MobSpawn.java
@@ -43,7 +43,12 @@ public class Packet24MobSpawn extends Packet
     public Packet24MobSpawn(EntityLiving par1EntityLiving)
     {
         this.entityId = par1EntityLiving.entityId;
+        // FCMOD: Code change to avoid truncation
+        /*
         this.type = (byte)EntityList.getEntityID(par1EntityLiving);
+        */
+        this.type = EntityList.getEntityID(par1EntityLiving);
+        // END FCMOD
         this.xPosition = par1EntityLiving.myEntitySize.multiplyBy32AndRound(par1EntityLiving.posX);
         this.yPosition = MathHelper.floor_double(par1EntityLiving.posY * 32.0D);
         this.zPosition = par1EntityLiving.myEntitySize.multiplyBy32AndRound(par1EntityLiving.posZ);
@@ -97,7 +102,7 @@ public class Packet24MobSpawn extends Packet
     public void readPacketData(DataInputStream par1DataInputStream) throws IOException
     {
         this.entityId = par1DataInputStream.readInt();
-        this.type = par1DataInputStream.readByte() & 255;
+        this.type = par1DataInputStream.readInt();
         this.xPosition = par1DataInputStream.readInt();
         this.yPosition = par1DataInputStream.readInt();
         this.zPosition = par1DataInputStream.readInt();
@@ -116,7 +121,7 @@ public class Packet24MobSpawn extends Packet
     public void writePacketData(DataOutputStream par1DataOutputStream) throws IOException
     {
         par1DataOutputStream.writeInt(this.entityId);
-        par1DataOutputStream.writeByte(this.type & 255);
+        par1DataOutputStream.writeInt(this.type);
         par1DataOutputStream.writeInt(this.xPosition);
         par1DataOutputStream.writeInt(this.yPosition);
         par1DataOutputStream.writeInt(this.zPosition);
diff --git a/minecraft/net/minecraft/src/Packet26EntityExpOrb.java b/minecraft/net/minecraft/src/Packet26EntityExpOrb.java
index 4664b22..c7e2f8d 100644
--- a/minecraft/net/minecraft/src/Packet26EntityExpOrb.java
+++ b/minecraft/net/minecraft/src/Packet26EntityExpOrb.java
@@ -6,6 +6,10 @@ import java.io.IOException;
 
 public class Packet26EntityExpOrb extends Packet
 {
+    // FCMOD: Code added
+    public boolean m_bNotPlayerOwned;
+    // END FCMOD
+
     /** Entity ID for the XP Orb */
     public int entityId;
     public int posX;
@@ -24,6 +28,9 @@ public class Packet26EntityExpOrb extends Packet
         this.posY = MathHelper.floor_double(par1EntityXPOrb.posY * 32.0D);
         this.posZ = MathHelper.floor_double(par1EntityXPOrb.posZ * 32.0D);
         this.xpValue = par1EntityXPOrb.getXpValue();
+        // FCMOD: Code added
+        m_bNotPlayerOwned = par1EntityXPOrb.m_bNotPlayerOwned;
+        // END FCMOD
     }
 
     /**
@@ -36,6 +43,9 @@ public class Packet26EntityExpOrb extends Packet
         this.posY = par1DataInputStream.readInt();
         this.posZ = par1DataInputStream.readInt();
         this.xpValue = par1DataInputStream.readShort();
+        // FCMOD: Code added
+        m_bNotPlayerOwned = par1DataInputStream.readBoolean();
+        // END FCMOD
     }
 
     /**
@@ -48,6 +58,9 @@ public class Packet26EntityExpOrb extends Packet
         par1DataOutputStream.writeInt(this.posY);
         par1DataOutputStream.writeInt(this.posZ);
         par1DataOutputStream.writeShort(this.xpValue);
+        // FCMOD: Code added
+        par1DataOutputStream.writeBoolean( m_bNotPlayerOwned );
+        // END FCMOD
     }
 
     /**
@@ -63,6 +76,11 @@ public class Packet26EntityExpOrb extends Packet
      */
     public int getPacketSize()
     {
+    	// FCMOD: Code changed
+    	/*
         return 18;
+        */
+        return 19;
+        // END FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/Packet41EntityEffect.java b/minecraft/net/minecraft/src/Packet41EntityEffect.java
index 69157d3..1671097 100644
--- a/minecraft/net/minecraft/src/Packet41EntityEffect.java
+++ b/minecraft/net/minecraft/src/Packet41EntityEffect.java
@@ -12,6 +12,9 @@ public class Packet41EntityEffect extends Packet
     /** The effect's amplifier. */
     public byte effectAmplifier;
     public short duration;
+    // FCMOD: Code added
+    public byte m_bIsAmbient;
+    // END FCMOD
 
     public Packet41EntityEffect() {}
 
@@ -29,6 +32,14 @@ public class Packet41EntityEffect extends Packet
         {
             this.duration = (short)par2PotionEffect.getDuration();
         }
+
+        // FCMOD: Code added
+        m_bIsAmbient = 0;
+        if ( par2PotionEffect.getIsAmbient() )
+        {
+        	m_bIsAmbient = 1;
+        }
+        // END FCMOD
     }
 
     /**
@@ -40,6 +51,9 @@ public class Packet41EntityEffect extends Packet
         this.effectId = par1DataInputStream.readByte();
         this.effectAmplifier = par1DataInputStream.readByte();
         this.duration = par1DataInputStream.readShort();
+        // FCMOD: Code added
+        m_bIsAmbient = par1DataInputStream.readByte();
+        // END FCMOD
     }
 
     /**
@@ -51,6 +65,9 @@ public class Packet41EntityEffect extends Packet
         par1DataOutputStream.writeByte(this.effectId);
         par1DataOutputStream.writeByte(this.effectAmplifier);
         par1DataOutputStream.writeShort(this.duration);
+        // FCMOD: Code added
+        par1DataOutputStream.writeByte(m_bIsAmbient);
+        // END FCMOD
     }
 
     /**
@@ -74,7 +91,12 @@ public class Packet41EntityEffect extends Packet
      */
     public int getPacketSize()
     {
+    	// FCMOD: Code change
+    	/*
         return 8;
+        */
+    	return 9;
+    	// END FCMOD
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/PathFinder.java b/minecraft/net/minecraft/src/PathFinder.java
index 979c82a..149b44d 100644
--- a/minecraft/net/minecraft/src/PathFinder.java
+++ b/minecraft/net/minecraft/src/PathFinder.java
@@ -54,6 +54,8 @@ public class PathFinder
     /**
      * Internal implementation of creating a path from an entity to a point
      */
+    // FCMOD: Removed and replaced
+    /*
     private PathEntity createEntityPathTo(Entity par1Entity, double par2, double par4, double par6, float par8)
     {
         this.path.clearPath();
@@ -85,6 +87,8 @@ public class PathFinder
         this.isPathingInWater = var9;
         return var14;
     }
+    */
+    // END FCMOD
 
     /**
      * Adds a path from start to end and returns the whole path (args: unused, start, end, unused, maxDistance)
@@ -282,11 +286,27 @@ public class PathFinder
      */
     public int getVerticalOffset(Entity par1Entity, int par2, int par3, int par4, PathPoint par5PathPoint)
     {
+    	// FCMOD: Code changed to call custom function
+    	/*
         return func_82565_a(par1Entity, par2, par3, par4, par5PathPoint, this.isPathingInWater, this.isMovementBlockAllowed, this.isWoddenDoorAllowed);
+        */
+    	int pathWeight = GetPathWeightAtLocation( par1Entity, par2, par3, par4, par5PathPoint );
+    	
+    	// Stop babies from pathing up solid blocks
+    	if (pathWeight == 0 
+    			&& par1Entity instanceof EntityAnimal 
+    			&& ((EntityAnimal)par1Entity).getGrowingAge() < 0
+    			&& FCUtilsWorld.DoesBlockHaveSmallCenterHardpointToFacing(par1Entity.worldObj, par2, par3, par4, 1)) {
+    		pathWeight = -3;
+    	}
+    	
+    	return pathWeight;
+    	// END FCMOD
     }
 
     public static int func_82565_a(Entity par0Entity, int par1, int par2, int par3, PathPoint par4PathPoint, boolean par5, boolean par6, boolean par7)
     {
+    	// FCNOTE: *Mostly* dead code.  The mod prevents it being called above, but it's still called from EntityAIControlledByPlayer 
         boolean var8 = false;
 
         for (int var9 = par1; var9 < par1 + par4PathPoint.xCoord; ++var9)
@@ -305,7 +325,10 @@ public class PathFinder
                         }
                         else if (var12 != Block.waterMoving.blockID && var12 != Block.waterStill.blockID)
                         {
-                            if (!par7 && var12 == Block.doorWood.blockID)
+                        	// FCMOD: Changed
+                            //if (!par7 && var12 == Block.doorWood.blockID)
+                            if (!par7 && ( var12 == Block.doorWood.blockID || var12 == FCBetterThanWolves.fcBlockDoorWood.blockID ) )
+                        	// END FCMOD
                             {
                                 return 0;
                             }
@@ -323,6 +346,7 @@ public class PathFinder
                         Block var13 = Block.blocksList[var12];
                         int var14 = var13.getRenderType();
 
+                        // FCNOTE: 9 is the render type of BlockRailBase
                         if (par0Entity.worldObj.blockGetRenderType(var9, var10, var11) == 9)
                         {
                             int var18 = MathHelper.floor_double(par0Entity.posX);
@@ -336,6 +360,7 @@ public class PathFinder
                         }
                         else if (!var13.getBlocksMovement(par0Entity.worldObj, var9, var10, var11) && (!par6 || var12 != Block.doorWood.blockID))
                         {
+                        	// FCNOTE: 11 is the render type of BlockFence, 32 is that of BlockWall
                             if (var14 == 11 || var12 == Block.fenceGate.blockID || var14 == 32)
                             {
                                 return -3;
@@ -391,4 +416,175 @@ public class PathFinder
 
         return new PathEntity(var5);
     }
+    
+    // FCMOD: Added New
+    public int GetPathWeightAtLocation( Entity entity, int i, int j, int k, PathPoint pathPoint )
+    {
+    	boolean bAvoidsWater = isPathingInWater;
+    	boolean bPathThroughClosedWoodDoor = isMovementBlockAllowed;
+    	boolean bPathThroughOpenWoodDoor = isWoddenDoorAllowed;
+    	
+    	// this is pathfinding's inner loop, and has been rewritten to optimize
+    	
+    	World world = entity.worldObj;
+        int iReturnWeight = 1;
+        
+        int iMaxI = i + pathPoint.xCoord;
+        int iMaxJ = j + pathPoint.yCoord;
+        int iMaxK = k + pathPoint.zCoord;
+
+        for ( int iTempI = i; iTempI < iMaxI; ++iTempI )
+        {
+            for ( int iTempJ = j; iTempJ < iMaxJ; ++iTempJ )
+            {
+                for ( int iTempK = k; iTempK < iMaxK; ++iTempK )
+                {
+                    int iTempBlockID = world.getBlockId( iTempI, iTempJ, iTempK );
+
+                    if ( iTempBlockID > 0 )
+                    {
+                        Block tempBlock = Block.blocksList[iTempBlockID];
+
+                        if ( !tempBlock.CanPathThroughBlock( world, iTempI, iTempJ, iTempK, entity, this ) )
+                        {                        	
+                        	return tempBlock.GetWeightOnPathBlocked( world, iTempI, iTempJ, iTempK );
+                        }
+                        else
+                        {
+                        	iReturnWeight = tempBlock.AdjustPathWeightOnNotBlocked( iReturnWeight );
+                        }
+                    }
+                }
+            }
+        }
+
+        return iReturnWeight;
+    }
+    
+    public boolean CanPathThroughClosedWoodDoor()
+    {
+    	return isMovementBlockAllowed;
+    }
+    
+    public boolean CanPathThroughOpenWoodDoor()
+    {
+    	return isWoddenDoorAllowed;
+    }
+    
+    public boolean CanPathThroughWater()
+    {
+    	return !isPathingInWater; // member variable is misnamed
+    }
+    
+    private PathEntity createEntityPathTo( Entity entity, double dDestX, double dDestY, 
+    	double dDestZ, float fTolerance )
+    {
+        path.clearPath();
+        pointMap.clearMap();
+        
+        boolean bTempPathingInWater = isPathingInWater; // not sure what's up with how this is used
+        
+        int iIStart = MathHelper.floor_double( entity.boundingBox.minX );
+        int iJStart = MathHelper.floor_double( entity.boundingBox.minY + 0.5D );
+        int iKStart = MathHelper.floor_double( entity.boundingBox.minZ );
+        
+        if ( canEntityDrown && entity.isInWater() )
+        {
+            iJStart = (int)entity.boundingBox.minY;
+
+            for ( int iTempBlockID = worldMap.getBlockId( MathHelper.floor_double( entity.posX ), 
+            	iJStart, MathHelper.floor_double( entity.posZ ) ); 
+            	iTempBlockID == Block.waterMoving.blockID || 
+            	iTempBlockID == Block.waterStill.blockID; 
+            	iTempBlockID = worldMap.getBlockId( MathHelper.floor_double( entity.posX ), 
+        		iJStart, MathHelper.floor_double( entity.posZ ) ) )
+            {
+                ++iJStart;
+            }
+
+            bTempPathingInWater = isPathingInWater;
+            
+            isPathingInWater = false;
+        }        
+        else if ( ShouldOffsetPositionIfPathingOutOfBlock( iIStart, iJStart, iKStart, entity ) )
+		{
+    		// smaller entities can get stuck on fence corners and such.  This bit
+        	// offsets the start point for pathing to open neighboring blocks.
+        	// Intentionally uses horizontal center of entity to determine offset.
+
+    		double dPartialX = entity.posX - (double)iIStart;
+    		
+    		int iIOffset = iIStart + ( dPartialX < 0.5 ? -1: 1 );
+
+        	if ( !CanPathThroughBlock( iIOffset, iJStart, iKStart, entity ) )
+    		{
+        		double dPartialZ = entity.posZ - (double)iKStart;	            		
+        		
+        		int iKOffset = iKStart + ( dPartialZ < 0.5 ? -1: 1 );
+        		
+            	if ( !CanPathThroughBlock( iIStart, iJStart, iKOffset, entity ) )
+        		{
+            		if ( CanPathThroughBlock( iIOffset, iJStart, iKOffset, entity ) )
+            		{
+                		iIStart = iIOffset;
+                		iKStart = iKOffset;
+            		}
+        		}
+            	else
+            	{
+            		iKStart = iKOffset;
+            	}
+    		}
+        	else
+        	{
+        		iIStart = iIOffset;
+        	}
+        }
+
+        PathPoint startPoint = openPoint( iIStart, iJStart, iKStart ); 
+        
+        PathPoint endPoint = openPoint( 
+        	MathHelper.floor_double( dDestX - ( entity.width / 2F ) ), 
+        	MathHelper.floor_double( dDestY ), 
+        	MathHelper.floor_double( dDestZ - ( entity.width / 2F ) ) );
+        
+        PathPoint spaceNeeded = new PathPoint( MathHelper.floor_float( entity.width + 1F ), 
+        	MathHelper.floor_float( entity.height + 1F ), 
+        	MathHelper.floor_float( entity.width + 1F ) );
+        
+        PathEntity path = addToPath( entity, startPoint, endPoint, spaceNeeded, fTolerance );
+        
+        isPathingInWater = bTempPathingInWater;
+        
+        return path;
+    }
+    
+    private boolean ShouldOffsetPositionIfPathingOutOfBlock( int i, int j, int k, Entity entity )
+    {
+        int iStartBlockID = worldMap.getBlockId( i, j, k );
+
+        if ( iStartBlockID > 0 )
+        {
+	        Block startBlock = Block.blocksList[iStartBlockID];
+	    	
+	        return startBlock.ShouldOffsetPositionIfPathingOutOf( worldMap, i, j, k, entity, this );
+        }
+        
+        return false;
+    }
+    
+    private boolean CanPathThroughBlock( int i, int j, int k, Entity entity )
+    {
+        int iStartBlockID = worldMap.getBlockId( i, j, k );
+
+        if ( iStartBlockID > 0 )
+        {
+	        Block startBlock = Block.blocksList[iStartBlockID];
+	    	
+	        return startBlock.CanPathThroughBlock( worldMap, i, j, k, entity, this );
+        }
+        
+        return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/PathNavigate.java b/minecraft/net/minecraft/src/PathNavigate.java
index 1f57bdf..18da351 100644
--- a/minecraft/net/minecraft/src/PathNavigate.java
+++ b/minecraft/net/minecraft/src/PathNavigate.java
@@ -226,6 +226,8 @@ public class PathNavigate
             }
         }
 
+        // FCMOD: Changed to use rectangular bounds to reduce spazziness.
+        /*
         float var8 = this.theEntity.width * this.theEntity.width;
         int var4;
 
@@ -236,6 +238,24 @@ public class PathNavigate
                 this.currentPath.setCurrentPathIndex(var4 + 1);
             }
         }
+        */
+        // slightly less than a half block width to ensure the creature is actually within the
+        // destination block, which is important for stuff like eating grass
+        
+        for ( int iTempIndex = currentPath.getCurrentPathIndex(); iTempIndex < var2; iTempIndex++ )
+        {
+        	Vec3 currentDest = currentPath.getVectorFromIndex( theEntity, iTempIndex );
+        	
+            if ( Math.abs( var1.xCoord - currentDest.xCoord ) < 0.49D && 
+            	Math.abs( var1.zCoord - currentDest.zCoord ) < 0.49D &&
+            	Math.abs( var1.yCoord - currentDest.yCoord ) < 0.49D )
+            {
+                currentPath.setCurrentPathIndex( iTempIndex + 1 );
+            }
+        }
+        
+        int var4;
+        // END FCMOD
 
         var4 = MathHelper.ceiling_float_int(this.theEntity.width);
         int var5 = (int)this.theEntity.height + 1;
@@ -516,4 +536,43 @@ public class PathNavigate
 
         return true;
     }
+    
+    // FCMOD: Added New
+    public boolean tryMoveToXYZ( int i, int j, int k, float fSpeed )
+    {
+    	// int based version of vanilla double based function, to avoid unnecessary type casts
+    	
+        PathEntity path = getPathToXYZ( i, j, k );
+        
+        return setPath( path, fSpeed );
+    }
+    
+    public PathEntity getPathToXYZ( int i, int j, int k )
+    {
+    	// int based version of vanilla double based function, to avoid unnecessary type casts
+    	
+    	if ( canNavigate() )
+    	{
+    		return worldObj.getEntityPathToXYZ( theEntity, i, j, k,  
+    			pathSearchRange, canPassOpenWoodenDoors, canPassClosedWoodenDoors, 
+    			avoidsWater, canSwim);
+    	}
+    	
+    	return null;
+    }
+    
+    public PathEntity GetPathToEntity( Entity toEntity )
+    {
+        return !canNavigate() ? null : worldObj.getPathEntityToEntity( theEntity, 
+        	toEntity, pathSearchRange, canPassOpenWoodenDoors, canPassClosedWoodenDoors, 
+        	avoidsWater, canSwim);
+    }
+
+    public boolean TryMoveToEntity( Entity toEntity, float fMoveSpeed )
+    {
+        PathEntity newPath = GetPathToEntity( toEntity );
+        
+        return newPath != null ? setPath( newPath, fMoveSpeed ) : false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/PlayerControllerMP.java b/minecraft/net/minecraft/src/PlayerControllerMP.java
index de92b40..1280f28 100644
--- a/minecraft/net/minecraft/src/PlayerControllerMP.java
+++ b/minecraft/net/minecraft/src/PlayerControllerMP.java
@@ -111,6 +111,12 @@ public class PlayerControllerMP
         }
         else
         {
+            // FCMOD: Code added (client only)
+            if ( blockHitDelay > 0 && !currentGameType.isCreative() )
+            {
+            	return false;
+            }
+            // END FCMOD
             WorldClient var5 = this.mc.theWorld;
             Block var6 = Block.blocksList[var5.getBlockId(par1, par2, par3)];
 
@@ -122,11 +128,35 @@ public class PlayerControllerMP
             {
                 var5.playAuxSFX(2001, par1, par2, par3, var6.blockID + (var5.getBlockMetadata(par1, par2, par3) << 12));
                 int var7 = var5.getBlockMetadata(par1, par2, par3);
-                boolean var8 = var5.setBlockToAir(par1, par2, par3);
+                // FCMOD: Changed (client only)
+                //boolean var8 = var5.setBlockToAir(par1, par2, par3);
+                boolean var8 = false;
+                
+                if ( !currentGameType.isCreative() && 
+                	!mc.thePlayer.canHarvestBlock( var6, par1, par2, par3 ) &&
+                	var6.CanConvertBlock( mc.thePlayer.getCurrentEquippedItem(), var5, par1, par2, par3 ) )
+            	{
+                    var8 = var6.ConvertBlock( mc.thePlayer.getCurrentEquippedItem(), var5, par1, par2, par3, par4 );
+            	}
+                
+                if ( !var8 )
+                {
+                	var8 = var5.setBlockToAir(par1, par2, par3);
+                	
+                	if ( var8 )
+                	{
+                		var6.onBlockDestroyedByPlayer(var5, par1, par2, par3, var7);
+                	}
+                }
+                // END FCMOD
 
                 if (var8)
                 {
-                    var6.onBlockDestroyedByPlayer(var5, par1, par2, par3, var7);
+                    // FCMOD: Changed  (client only)
+                    //var6.onBlockDestroyedByPlayer(var5, par1, par2, par3, var7);
+                    OnBlockBrokenClientSide( var6.blockID, par1, par2, par3, var7 );
+                    blockHitDelay = 5;
+                    // END FCMOD
                 }
 
                 this.currentBlockY = -1;
@@ -156,6 +186,15 @@ public class PlayerControllerMP
      */
     public void clickBlock(int par1, int par2, int par3, int par4)
     {
+    	// FCMOD: Added (client only)
+    	if ( mc.thePlayer.isUsingItem() )
+    	{
+    		// don't allow block harvesting when block with a sword, drawing a bow, eating food, etc.
+    		
+    		return;
+    	}
+    	// END FCMOD
+    	
         if (!this.currentGameType.isAdventure() || this.mc.thePlayer.canCurrentToolHarvestBlock(par1, par2, par3))
         {
             if (this.currentGameType.isCreative())
@@ -168,10 +207,17 @@ public class PlayerControllerMP
             {
                 if (this.isHittingBlock)
                 {
+                	// FCNOTE: Packet14BlockDig with a status of 1 (first param) cancels block harvesting, I assume here to cancel
+                	// the previous block harvest before starting a new one
                     this.netClientHandler.addToSendQueue(new Packet14BlockDig(1, this.currentBlockX, this.currentBlockY, this.currentblockZ, par4));
                 }
 
-                this.netClientHandler.addToSendQueue(new Packet14BlockDig(0, par1, par2, par3, par4));
+                // FCMOD: Changed (client only) so that the client and server are updated to harvest at the same speed
+                //this.netClientHandler.addToSendQueue(new Packet14BlockDig(0, par1, par2, par3, par4));
+            	float fMiningSpeedModifier = mc.thePlayer.UpdateMiningSpeedModifier();
+            	
+                netClientHandler.addToSendQueue( new FCPacket166StartBlockHarvest( par1, par2, par3, par4, fMiningSpeedModifier ) );
+            	// END FCMOD
                 int var5 = this.mc.theWorld.getBlockId(par1, par2, par3);
 
                 if (var5 > 0 && this.curBlockDamageMP == 0.0F)
@@ -222,7 +268,11 @@ public class PlayerControllerMP
 
         if (this.blockHitDelay > 0)
         {
+        	// FCMOD: Code removed to correct insta-harvest (client only)
+        	/*
             --this.blockHitDelay;
+            */
+        	// END FCMOD
         }
         else if (this.currentGameType.isCreative())
         {
@@ -232,6 +282,12 @@ public class PlayerControllerMP
         }
         else
         {
+        	if ( mc.thePlayer.isUsingItem() )
+        	{
+        		// don't allow block harvesting when block with a sword, drawing a bow, eating food, etc.
+        		
+        		return;
+        	}
             if (this.sameToolAndBlock(par1, par2, par3))
             {
                 int var5 = this.mc.theWorld.getBlockId(par1, par2, par3);
@@ -281,6 +337,12 @@ public class PlayerControllerMP
 
     public void updateController()
     {
+        // FCMOD: Code added to prevent insta-harvest
+    	if ( blockHitDelay > 0 )
+    	{
+    		blockHitDelay--;
+    	}
+    	// END FCMOD
         this.syncCurrentPlayItem();
         this.mc.sndManager.playRandomMusicIfReady();
     }
@@ -334,6 +396,8 @@ public class PlayerControllerMP
             }
         }
 
+        // FCMOD: Changed (client only)
+        /*
         if (!var12 && par3ItemStack != null && par3ItemStack.getItem() instanceof ItemBlock)
         {
             ItemBlock var16 = (ItemBlock)par3ItemStack.getItem();
@@ -343,6 +407,14 @@ public class PlayerControllerMP
                 return false;
             }
         }
+        */        
+        if ( !var12 && par3ItemStack != null && 
+        	!par3ItemStack.getItem().CanItemBeUsedByPlayer( par2World, 
+    		par4, par5, par6, par7, par1EntityPlayer, par3ItemStack ) )
+        {
+        	return false;
+        }
+        // END FCMOD
 
         this.netClientHandler.addToSendQueue(new Packet15Place(par4, par5, par6, par7, par1EntityPlayer.inventory.getCurrentItem(), var9, var10, var11));
 
@@ -418,6 +490,7 @@ public class PlayerControllerMP
         return par1EntityPlayer.interactWith(par2Entity);
     }
 
+    // FCNOTE: par1 is windowId, par2 is slotnumber, par3 is hotkey num, par4 2 when this is called by checkHotbarKeys()
     public ItemStack windowClick(int par1, int par2, int par3, int par4, EntityPlayer par5EntityPlayer)
     {
         short var6 = par5EntityPlayer.openContainer.getNextTransactionID(par5EntityPlayer.inventory);
@@ -489,4 +562,30 @@ public class PlayerControllerMP
     {
         return this.currentGameType.isCreative();
     }
+    
+    // FCMOD: Added (client only)
+    private void OnBlockBrokenClientSide( int iBlockID, int iBlockI, int iBlockJ, int iBlockK, int iBlockMetadata )
+    {
+    	float fExhaustionConsumed = 1F;
+    	
+	    ItemStack currentItemStack = mc.thePlayer.inventory.mainInventory[mc.thePlayer.inventory.currentItem];
+	    
+	    if ( currentItemStack != null )
+	    {
+	    	fExhaustionConsumed = currentItemStack.getItem().GetExhaustionOnUsedToHarvestBlock( iBlockID, mc.theWorld, 
+	    		iBlockI, iBlockJ, iBlockK, iBlockMetadata );	    	
+	    }
+		
+		if ( fExhaustionConsumed > 0F )
+		{
+			mc.thePlayer.m_bExhaustionAddedSinceLastGuiUpdate = true;
+		}
+    }
+    
+    public boolean IsHittingBlock()
+    {
+    	return isHittingBlock;
+    }
+	// END FCMOD
+    
 }
diff --git a/minecraft/net/minecraft/src/Potion.java b/minecraft/net/minecraft/src/Potion.java
index c248947..7577c85 100644
--- a/minecraft/net/minecraft/src/Potion.java
+++ b/minecraft/net/minecraft/src/Potion.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeItem;
+
 public class Potion
 {
     /** The array of potion types. */
@@ -61,7 +63,7 @@ public class Potion
     public final int id;
 
     /** The name of the Potion. */
-    private String name = "";
+    public String name = "";
 
     /** The index for the icon displayed when the potion effect is active. */
     private int statusIconIndex = -1;
@@ -74,7 +76,8 @@ public class Potion
     private boolean usable;
 
     /** Is the color of the liquid for this potion. */
-    private final int liquidColor;
+    public int liquidColor;
+    public int origColor;
 
     protected Potion(int par1, boolean par2, int par3)
     {
@@ -135,6 +138,8 @@ public class Potion
         {
             ((EntityPlayer)par1EntityLiving).addExhaustion(0.025F * (float)(par2 + 1));
         }
+        // FCMOD: Changed this to get rid of whole "healing hurts undead, harming helps them" thing
+        /*
         else if ((this.id != heal.id || par1EntityLiving.isEntityUndead()) && (this.id != harm.id || !par1EntityLiving.isEntityUndead()))
         {
             if (this.id == harm.id && !par1EntityLiving.isEntityUndead() || this.id == heal.id && par1EntityLiving.isEntityUndead())
@@ -146,6 +151,16 @@ public class Potion
         {
             par1EntityLiving.heal(6 << par2);
         }
+        */
+        else if ( this.id == harm.id )
+        {
+            par1EntityLiving.attackEntityFrom(DamageSource.magic, 6 << par2);
+        }
+        else if ( this.id == heal.id )
+        {
+            par1EntityLiving.heal(6 << par2);
+        }
+        // END FCMOD
     }
 
     /**
@@ -155,6 +170,8 @@ public class Potion
     {
         int var6;
 
+        // FCMOD: Code change to get rid of special casing of undead in potion use
+        /*
         if ((this.id != heal.id || par2EntityLiving.isEntityUndead()) && (this.id != harm.id || !par2EntityLiving.isEntityUndead()))
         {
             if (this.id == harm.id && !par2EntityLiving.isEntityUndead() || this.id == heal.id && par2EntityLiving.isEntityUndead())
@@ -172,6 +189,22 @@ public class Potion
             }
         }
         else
+        */
+        if ( this.id == harm.id )
+        {
+            var6 = (int)(par4 * (double)(6 << par3) + 0.5D);
+
+            if (par1EntityLiving == null)
+            {
+                par2EntityLiving.attackEntityFrom(DamageSource.magic, var6);
+            }
+            else
+            {
+                par2EntityLiving.attackEntityFrom(DamageSource.causeIndirectMagicDamage(par2EntityLiving, par1EntityLiving), var6);
+            }
+        }
+        else if ( this.id == heal.id )
+        // END FCMOD        
         {
             var6 = (int)(par4 * (double)(6 << par3) + 0.5D);
             par2EntityLiving.heal(var6);
@@ -218,6 +251,7 @@ public class Potion
     public Potion setPotionName(String par1Str)
     {
         this.name = par1Str;
+        ColorizeItem.setupPotion(this);
         return this;
     }
 
diff --git a/minecraft/net/minecraft/src/PotionHelper.java b/minecraft/net/minecraft/src/PotionHelper.java
index afd1ecd..e7b2613 100644
--- a/minecraft/net/minecraft/src/PotionHelper.java
+++ b/minecraft/net/minecraft/src/PotionHelper.java
@@ -1,10 +1,12 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeItem;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 public class PotionHelper
 {
@@ -63,7 +65,7 @@ public class PotionHelper
      */
     public static int calcPotionLiquidColor(Collection par0Collection)
     {
-        int var1 = 3694022;
+    	int var1 = ColorizeItem.getWaterBottleColor();
 
         if (par0Collection != null && !par0Collection.isEmpty())
         {
@@ -605,4 +607,9 @@ public class PotionHelper
         field_77925_n = new HashMap();
         potionPrefixes = new String[] {"potion.prefix.mundane", "potion.prefix.uninteresting", "potion.prefix.bland", "potion.prefix.clear", "potion.prefix.milky", "potion.prefix.diffuse", "potion.prefix.artless", "potion.prefix.thin", "potion.prefix.awkward", "potion.prefix.flat", "potion.prefix.bulky", "potion.prefix.bungling", "potion.prefix.buttered", "potion.prefix.smooth", "potion.prefix.suave", "potion.prefix.debonair", "potion.prefix.thick", "potion.prefix.elegant", "potion.prefix.fancy", "potion.prefix.charming", "potion.prefix.dashing", "potion.prefix.refined", "potion.prefix.cordial", "potion.prefix.sparkling", "potion.prefix.potent", "potion.prefix.foul", "potion.prefix.odorless", "potion.prefix.rank", "potion.prefix.harsh", "potion.prefix.acrid", "potion.prefix.gross", "potion.prefix.stinky"};
     }
+    
+    public static Map getPotionColorCache()
+    {
+        return field_77925_n;
+    }
 }
diff --git a/minecraft/net/minecraft/src/RConThreadClient.java b/minecraft/net/minecraft/src/RConThreadClient.java
index 5577623..10d5a8f 100644
--- a/minecraft/net/minecraft/src/RConThreadClient.java
+++ b/minecraft/net/minecraft/src/RConThreadClient.java
@@ -55,16 +55,16 @@ public class RConThreadClient extends RConThreadBase
                 BufferedInputStream var1 = new BufferedInputStream(this.clientSocket.getInputStream());
                 int var2 = var1.read(this.buffer, 0, 1460);
 
-                if (10 > var2)
+                if (10 <= var2)
                 {
-                    return;
-                }
+                	byte var3 = 0;
+                    int var4 = RConUtils.getBytesAsLEInt(this.buffer, 0, var2);
 
-                byte var3 = 0;
-                int var4 = RConUtils.getBytesAsLEInt(this.buffer, 0, var2);
+                    if (var4 != var2 - 4)
+                    {
+                        return;
+                    }
 
-                if (var4 == var2 - 4)
-                {
                     int var21 = var3 + 4;
                     int var5 = RConUtils.getBytesAsLEInt(this.buffer, var21, var2);
                     var21 += 4;
diff --git a/minecraft/net/minecraft/src/RandomPositionGenerator.java b/minecraft/net/minecraft/src/RandomPositionGenerator.java
index ba689f2..120a191 100644
--- a/minecraft/net/minecraft/src/RandomPositionGenerator.java
+++ b/minecraft/net/minecraft/src/RandomPositionGenerator.java
@@ -67,9 +67,14 @@ public class RandomPositionGenerator
 
         for (int var16 = 0; var16 < 10; ++var16)
         {
-            int var12 = var4.nextInt(2 * par1) - par1;
-            int var17 = var4.nextInt(2 * par2) - par2;
-            int var14 = var4.nextInt(2 * par1) - par1;
+        	// FCMOD: Changed to fix bias towards the northwest
+            //int var12 = var4.nextInt(2 * par1) - par1;
+            //int var17 = var4.nextInt(2 * par2) - par2;
+            //int var14 = var4.nextInt(2 * par1) - par1;
+            int var12 = var4.nextInt( 2 * par1 + 1 ) - par1;
+            int var17 = var4.nextInt( 2 * par2 + 1 ) - par2;
+            int var14 = var4.nextInt( 2 * par1 + 1 ) - par1;
+            // END FCMOD
 
             if (par3Vec3 == null || (double)var12 * par3Vec3.xCoord + (double)var14 * par3Vec3.zCoord >= 0.0D)
             {
diff --git a/minecraft/net/minecraft/src/RecipeFireworks.java b/minecraft/net/minecraft/src/RecipeFireworks.java
index a7cb60e..81174f9 100644
--- a/minecraft/net/minecraft/src/RecipeFireworks.java
+++ b/minecraft/net/minecraft/src/RecipeFireworks.java
@@ -77,8 +77,8 @@ public class RecipeFireworks implements IRecipe
 
         if (var4 <= 3 && var3 <= 1)
         {
-            NBTTagCompound var16;
-            NBTTagCompound var19;
+            NBTTagCompound var15;
+            NBTTagCompound var18;
 
             if (var4 >= 1 && var3 == 1 && var7 == 0)
             {
@@ -86,8 +86,8 @@ public class RecipeFireworks implements IRecipe
 
                 if (var6 > 0)
                 {
-                    var16 = new NBTTagCompound();
-                    var19 = new NBTTagCompound("Fireworks");
+                    var15 = new NBTTagCompound();
+                    var18 = new NBTTagCompound("Fireworks");
                     NBTTagList var25 = new NBTTagList("Explosions");
 
                     for (int var22 = 0; var22 < par1InventoryCrafting.getSizeInventory(); ++var22)
@@ -100,10 +100,10 @@ public class RecipeFireworks implements IRecipe
                         }
                     }
 
-                    var19.setTag("Explosions", var25);
-                    var19.setByte("Flight", (byte)var4);
-                    var16.setTag("Fireworks", var19);
-                    this.field_92102_a.setTagCompound(var16);
+                    var18.setTag("Explosions", var25);
+                    var18.setByte("Flight", (byte)var4);
+                    var15.setTag("Fireworks", var18);
+                    this.field_92102_a.setTagCompound(var15);
                 }
 
                 return true;
@@ -111,9 +111,9 @@ public class RecipeFireworks implements IRecipe
             else if (var4 == 1 && var3 == 0 && var6 == 0 && var5 > 0 && var8 <= 1)
             {
                 this.field_92102_a = new ItemStack(Item.fireworkCharge);
-                var16 = new NBTTagCompound();
-                var19 = new NBTTagCompound("Explosion");
-                byte var23 = 0;
+                var15 = new NBTTagCompound();
+                var18 = new NBTTagCompound("Explosion");
+                byte var21 = 0;
                 ArrayList var12 = new ArrayList();
 
                 for (int var13 = 0; var13 < par1InventoryCrafting.getSizeInventory(); ++var13)
@@ -128,27 +128,27 @@ public class RecipeFireworks implements IRecipe
                         }
                         else if (var14.itemID == Item.lightStoneDust.itemID)
                         {
-                            var19.setBoolean("Flicker", true);
+                            var18.setBoolean("Flicker", true);
                         }
                         else if (var14.itemID == Item.diamond.itemID)
                         {
-                            var19.setBoolean("Trail", true);
+                            var18.setBoolean("Trail", true);
                         }
                         else if (var14.itemID == Item.fireballCharge.itemID)
                         {
-                            var23 = 1;
+                            var21 = 1;
                         }
                         else if (var14.itemID == Item.feather.itemID)
                         {
-                            var23 = 4;
+                            var21 = 4;
                         }
                         else if (var14.itemID == Item.goldNugget.itemID)
                         {
-                            var23 = 2;
+                            var21 = 2;
                         }
                         else if (var14.itemID == Item.skull.itemID)
                         {
-                            var23 = 3;
+                            var21 = 3;
                         }
                     }
                 }
@@ -160,25 +160,25 @@ public class RecipeFireworks implements IRecipe
                     var24[var27] = ((Integer)var12.get(var27)).intValue();
                 }
 
-                var19.setIntArray("Colors", var24);
-                var19.setByte("Type", var23);
-                var16.setTag("Explosion", var19);
-                this.field_92102_a.setTagCompound(var16);
+                var18.setIntArray("Colors", var24);
+                var18.setByte("Type", var21);
+                var15.setTag("Explosion", var18);
+                this.field_92102_a.setTagCompound(var15);
                 return true;
             }
             else if (var4 == 0 && var3 == 0 && var6 == 1 && var5 > 0 && var5 == var7)
             {
-                ArrayList var15 = new ArrayList();
+                ArrayList var16 = new ArrayList();
 
-                for (int var17 = 0; var17 < par1InventoryCrafting.getSizeInventory(); ++var17)
+                for (int var20 = 0; var20 < par1InventoryCrafting.getSizeInventory(); ++var20)
                 {
-                    ItemStack var11 = par1InventoryCrafting.getStackInSlot(var17);
+                    ItemStack var11 = par1InventoryCrafting.getStackInSlot(var20);
 
                     if (var11 != null)
                     {
                         if (var11.itemID == Item.dyePowder.itemID)
                         {
-                            var15.add(Integer.valueOf(ItemDye.dyeColors[var11.getItemDamage()]));
+                            var16.add(Integer.valueOf(ItemDye.dyeColors[var11.getItemDamage()]));
                         }
                         else if (var11.itemID == Item.fireworkCharge.itemID)
                         {
@@ -188,24 +188,24 @@ public class RecipeFireworks implements IRecipe
                     }
                 }
 
-                int[] var18 = new int[var15.size()];
+                int[] var17 = new int[var16.size()];
 
-                for (int var20 = 0; var20 < var18.length; ++var20)
+                for (int var19 = 0; var19 < var17.length; ++var19)
                 {
-                    var18[var20] = ((Integer)var15.get(var20)).intValue();
+                    var17[var19] = ((Integer)var16.get(var19)).intValue();
                 }
 
                 if (this.field_92102_a != null && this.field_92102_a.hasTagCompound())
                 {
-                    NBTTagCompound var21 = this.field_92102_a.getTagCompound().getCompoundTag("Explosion");
+                    NBTTagCompound var23 = this.field_92102_a.getTagCompound().getCompoundTag("Explosion");
 
-                    if (var21 == null)
+                    if (var23 == null)
                     {
                         return false;
                     }
                     else
                     {
-                        var21.setIntArray("FadeColors", var18);
+                        var23.setIntArray("FadeColors", var17);
                         return true;
                     }
                 }
@@ -245,4 +245,18 @@ public class RecipeFireworks implements IRecipe
     {
         return this.field_92102_a;
     }
+    
+    // FCMOD: Function added
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RecipesArmorDyes.java b/minecraft/net/minecraft/src/RecipesArmorDyes.java
index 582d01c..1f87cac 100644
--- a/minecraft/net/minecraft/src/RecipesArmorDyes.java
+++ b/minecraft/net/minecraft/src/RecipesArmorDyes.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
 import java.util.ArrayList;
 
 public class RecipesArmorDyes implements IRecipe
@@ -22,7 +23,19 @@ public class RecipesArmorDyes implements IRecipe
                 {
                     ItemArmor var7 = (ItemArmor)var6.getItem();
 
+                    // FCMOD: Code change
+                    /*
                     if (var7.getArmorMaterial() != EnumArmorMaterial.CLOTH || var3 != null)
+                    */                    
+                    if ( var7 instanceof FCItemArmorMod )
+                    {
+                    	if ( !((FCItemArmorMod)var7).HasCustomColors() || var3 != null )
+                    	{
+                    		return false;
+                    	}
+                    }
+                    else if (var7.getArmorMaterial() != EnumArmorMaterial.CLOTH || var3 != null)
+                	// END FCMOD
                     {
                         return false;
                     }
@@ -69,8 +82,19 @@ public class RecipesArmorDyes implements IRecipe
                 if (var8.getItem() instanceof ItemArmor)
                 {
                     var6 = (ItemArmor)var8.getItem();
-
+                    // FCMOD: Code change
+                    /*
                     if (var6.getArmorMaterial() != EnumArmorMaterial.CLOTH || var2 != null)
+                    */                    
+                    if ( var6 instanceof FCItemArmorMod )
+                    {
+                    	if ( !((FCItemArmorMod)var6).HasCustomColors() || var2 != null )
+                    	{
+                    		return null;
+                    	}
+                    }
+                    else if (var6.getArmorMaterial() != EnumArmorMaterial.CLOTH || var2 != null)
+                	// END FCMOD
                     {
                         return null;
                     }
@@ -98,13 +122,13 @@ public class RecipesArmorDyes implements IRecipe
                         return null;
                     }
 
-                    float[] var14 = EntitySheep.fleeceColorTable[BlockCloth.getBlockFromDye(var8.getItemDamage())];
-                    int var15 = (int)(var14[0] * 255.0F);
-                    int var16 = (int)(var14[1] * 255.0F);
+                    float[] var14 = ColorizeEntity.getArmorDyeColor(EntitySheep.fleeceColorTable[BlockCloth.getBlockFromDye(var8.getItemDamage())], BlockCloth.getBlockFromDye(var8.getItemDamage()));
+                    int var16 = (int)(var14[0] * 255.0F);
+                    int var15 = (int)(var14[1] * 255.0F);
                     var17 = (int)(var14[2] * 255.0F);
-                    var4 += Math.max(var15, Math.max(var16, var17));
-                    var3[0] += var15;
-                    var3[1] += var16;
+                    var4 += Math.max(var16, Math.max(var15, var17));
+                    var3[0] += var16;
+                    var3[1] += var15;
                     var3[2] += var17;
                     ++var5;
                 }
@@ -144,4 +168,18 @@ public class RecipesArmorDyes implements IRecipe
     {
         return null;
     }
+    
+    // FCMOD: Function added
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RecipesMapCloning.java b/minecraft/net/minecraft/src/RecipesMapCloning.java
index 24c89c7..ad918a3 100644
--- a/minecraft/net/minecraft/src/RecipesMapCloning.java
+++ b/minecraft/net/minecraft/src/RecipesMapCloning.java
@@ -104,4 +104,18 @@ public class RecipesMapCloning implements IRecipe
     {
         return null;
     }
+    
+    // FCMOD: Function added
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderBiped.java b/minecraft/net/minecraft/src/RenderBiped.java
index d075bb6..27bd72d 100644
--- a/minecraft/net/minecraft/src/RenderBiped.java
+++ b/minecraft/net/minecraft/src/RenderBiped.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cit.CITUtils;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
 import org.lwjgl.opengl.GL11;
 
 public class RenderBiped extends RenderLiving
@@ -45,7 +47,13 @@ public class RenderBiped extends RenderLiving
             if (var5 instanceof ItemArmor)
             {
                 ItemArmor var6 = (ItemArmor)var5;
-                this.loadTexture("/armor/" + bipedArmorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + ".png");
+                // FCMOD: Code added
+                if ( var5 instanceof FCItemArmorMod )
+                {
+                	return ShouldRenderPassModArmor( var4, par2, (FCItemArmorMod)var5 );
+                }
+            	// END FCMOD
+                this.loadTexture(FakeResourceLocation.unwrap(CITUtils.getArmorTexture(FakeResourceLocation.wrap("/armor/" + bipedArmorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + ".png"), par1EntityLiving, var4)));
                 ModelBiped var7 = par2 == 2 ? this.field_82425_h : this.field_82423_g;
                 var7.bipedHead.showModel = par2 == 0;
                 var7.bipedHeadwear.showModel = par2 == 0;
@@ -113,8 +121,16 @@ public class RenderBiped extends RenderLiving
 
             if (var5 instanceof ItemArmor)
             {
+            	// FCMOD
+            	if ( var5 instanceof FCItemArmorMod )
+            	{
+            		LoadSecondLayerOfModArmorTexture( par2, (FCItemArmorMod)var5 );
+            		
+                	return;
+            	}
+            	// END FCMOD
                 ItemArmor var6 = (ItemArmor)var5;
-                this.loadTexture("/armor/" + bipedArmorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + "_b.png");
+                this.loadTexture(FakeResourceLocation.unwrap(CITUtils.getArmorTexture(FakeResourceLocation.wrap("/armor/" + bipedArmorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + "_b.png"), par1EntityLiving, var4)));
                 float var7 = 1.0F;
                 GL11.glColor3f(var7, var7, var7);
             }
@@ -160,9 +176,17 @@ public class RenderBiped extends RenderLiving
             GL11.glPushMatrix();
             this.modelBipedMain.bipedHead.postRender(0.0625F);
 
-            if (var5.getItem().itemID < 256)
+            // FCMOD: Change
+            //if (var5.getItem().itemID < 256)
+            if ( var5.getItem().itemID < 4096 && Block.blocksList[var5.itemID] != null )
+        	// END FCMOD
             {
+                // FCMOD: Change
+                /*
                 if (RenderBlocks.renderItemIn3d(Block.blocksList[var5.itemID].getRenderType()))
+                */
+                if ( Block.blocksList[var5.itemID].DoesItemRenderAsBlock( var5.getItemDamage() ) )
+            	// END FCMOD
                 {
                     var6 = 0.625F;
                     GL11.glTranslatef(0.0F, -0.25F, 0.0F);
@@ -204,7 +228,12 @@ public class RenderBiped extends RenderLiving
             this.modelBipedMain.bipedRightArm.postRender(0.0625F);
             GL11.glTranslatef(-0.0625F, 0.4375F, 0.0625F);
 
+            // FCMOD: Change
+            /*
             if (var4.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var4.itemID].getRenderType()))
+            */
+            if ( var4.itemID < 4096 && Block.blocksList[var4.itemID] != null && Block.blocksList[var4.itemID].DoesItemRenderAsBlock( var4.getItemDamage() ) )
+            // END FCMOD
             {
                 var6 = 0.5F;
                 GL11.glTranslatef(0.0F, 0.1875F, -0.3125F);
@@ -273,4 +302,71 @@ public class RenderBiped extends RenderLiving
     {
         this.doRenderLiving((EntityLiving)par1Entity, par2, par4, par6, par8, par9);
     }
+    
+    // FCMOD: Function added
+    private int ShouldRenderPassModArmor( ItemStack stack, int iArmorSlot, FCItemArmorMod armorItem )
+    {
+        loadTexture( armorItem.GetWornTextureDirectory() + armorItem.GetWornTexturePrefix() + "_" + (iArmorSlot == 2 ? 2 : 1) + ".png");
+        
+        ModelBiped model = iArmorSlot == 2 ? this.field_82425_h : this.field_82423_g;
+        
+        model.bipedHead.showModel = iArmorSlot == 0;
+        model.bipedHeadwear.showModel = iArmorSlot == 0;
+        model.bipedBody.showModel = iArmorSlot == 1 || iArmorSlot == 2;
+        model.bipedRightArm.showModel = iArmorSlot == 1;
+        model.bipedLeftArm.showModel = iArmorSlot == 1;
+        model.bipedRightLeg.showModel = iArmorSlot == 2 || iArmorSlot == 3;
+        model.bipedLeftLeg.showModel = iArmorSlot == 2 || iArmorSlot == 3;
+        
+        setRenderPassModel(model);
+
+        if (model != null)
+        {
+            model.onGround = this.mainModel.onGround;
+            model.isRiding = this.mainModel.isRiding;
+            model.isChild = this.mainModel.isChild;
+        }
+
+        if ( armorItem.HasCustomColors() )
+        {
+            int iColor = armorItem.getColor( stack );
+            
+            float fRed = (float)(iColor >> 16 & 255) / 255.0F;
+            float fGreen = (float)(iColor >> 8 & 255) / 255.0F;
+            float fBlue = (float)(iColor & 255) / 255.0F;
+            
+            GL11.glColor3f( fRed, fGreen, fBlue);
+        }
+        else
+        {
+            GL11.glColor3f( 1F, 1F, 1F);
+        }
+
+        if ( armorItem.HasSecondRenderLayerWhenWorn() )
+        {
+	        if (stack.isItemEnchanted())
+	        {
+	            return 31;
+	        }
+	
+	        return 16;
+        }
+        else
+        {        
+	        if ( stack.isItemEnchanted() )
+	        {
+	            return 15;
+	        }
+	
+	        return 1;
+        }
+    }
+    
+    private void LoadSecondLayerOfModArmorTexture( int iArmorSlot, FCItemArmorMod armorItem )
+    {
+        loadTexture( armorItem.GetWornTextureDirectory() + armorItem.GetWornTexturePrefix() + "_" + (iArmorSlot == 2 ? 2 : 1) + "_b.png");
+	    
+	    GL11.glColor3f(1F, 1F, 1F);
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderBlocks.java b/minecraft/net/minecraft/src/RenderBlocks.java
index 64e872c..19f6530 100644
--- a/minecraft/net/minecraft/src/RenderBlocks.java
+++ b/minecraft/net/minecraft/src/RenderBlocks.java
@@ -1,5 +1,11 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeBlock;
+import com.prupe.mcpatcher.cc.Colorizer;
+import com.prupe.mcpatcher.ctm.CTMUtils;
+import com.prupe.mcpatcher.ctm.GlassPaneRenderer;
+import com.prupe.mcpatcher.mal.block.RenderBlocksUtils;
+import com.prupe.mcpatcher.renderpass.RenderPass;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
@@ -235,40 +241,40 @@ public class RenderBlocks
     private int brightnessTopRight;
 
     /** Red color value for the top left corner */
-    private float colorRedTopLeft;
+    public float colorRedTopLeft;
 
     /** Red color value for the bottom left corner */
-    private float colorRedBottomLeft;
+    public float colorRedBottomLeft;
 
     /** Red color value for the bottom right corner */
-    private float colorRedBottomRight;
+    public float colorRedBottomRight;
 
     /** Red color value for the top right corner */
-    private float colorRedTopRight;
+    public float colorRedTopRight;
 
     /** Green color value for the top left corner */
-    private float colorGreenTopLeft;
+    public float colorGreenTopLeft;
 
     /** Green color value for the bottom left corner */
-    private float colorGreenBottomLeft;
+    public float colorGreenBottomLeft;
 
     /** Green color value for the bottom right corner */
-    private float colorGreenBottomRight;
+    public float colorGreenBottomRight;
 
     /** Green color value for the top right corner */
-    private float colorGreenTopRight;
+    public float colorGreenTopRight;
 
     /** Blue color value for the top left corner */
-    private float colorBlueTopLeft;
+    public float colorBlueTopLeft;
 
     /** Blue color value for the bottom left corner */
-    private float colorBlueBottomLeft;
+    public float colorBlueBottomLeft;
 
     /** Blue color value for the bottom right corner */
-    private float colorBlueBottomRight;
+    public float colorBlueBottomRight;
 
     /** Blue color value for the top right corner */
-    private float colorBlueTopRight;
+    public float colorBlueTopRight;
 
     public RenderBlocks(IBlockAccess par1IBlockAccess)
     {
@@ -326,16 +332,28 @@ public class RenderBlocks
     {
         if (!this.lockBlockBounds)
         {
-            this.renderMinX = par1Block.getBlockBoundsMinX();
-            this.renderMaxX = par1Block.getBlockBoundsMaxX();
-            this.renderMinY = par1Block.getBlockBoundsMinY();
-            this.renderMaxY = par1Block.getBlockBoundsMaxY();
-            this.renderMinZ = par1Block.getBlockBoundsMinZ();
-            this.renderMaxZ = par1Block.getBlockBoundsMaxZ();
+        	// FCMOD: Changed
+            //this.renderMinX = par1Block.getBlockBoundsMinX();
+            //this.renderMaxX = par1Block.getBlockBoundsMaxX();
+            //this.renderMinY = par1Block.getBlockBoundsMinY();
+            //this.renderMaxY = par1Block.getBlockBoundsMaxY();
+            //this.renderMinZ = par1Block.getBlockBoundsMinZ();
+            //this.renderMaxZ = par1Block.getBlockBoundsMaxZ();
+        	AxisAlignedBB blockBounds = par1Block.GetFixedBlockBoundsFromPool();
+        	
+            renderMinX = blockBounds.minX;
+            renderMinY = blockBounds.minY;
+            renderMinZ = blockBounds.minZ;
+            	
+            renderMaxX = blockBounds.maxX;
+            renderMaxY = blockBounds.maxY;
+            renderMaxZ = blockBounds.maxZ;
+            // END FCMOD
+            
             this.partialRenderBounds = this.minecraftRB.gameSettings.ambientOcclusion >= 2 && (this.renderMinX > 0.0D || this.renderMaxX < 1.0D || this.renderMinY > 0.0D || this.renderMaxY < 1.0D || this.renderMinZ > 0.0D || this.renderMaxZ < 1.0D);
         }
     }
-
+    
     /**
      * Like setRenderBounds, but locks the values so that RenderBlocks won't change them.  If you use this, you must
      * call unlockBlockBounds after you finish rendering!
@@ -383,6 +401,8 @@ public class RenderBlocks
     /**
      * Renders the block at the given coordinates using the block's rendering type
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public boolean renderBlockByRenderType(Block par1Block, int par2, int par3, int par4)
     {
         int var5 = par1Block.getRenderType();
@@ -398,6 +418,8 @@ public class RenderBlocks
             return var5 == 0 ? this.renderStandardBlock(par1Block, par2, par3, par4) : (var5 == 4 ? this.renderBlockFluids(par1Block, par2, par3, par4) : (var5 == 31 ? this.renderBlockLog(par1Block, par2, par3, par4) : (var5 == 1 ? this.renderCrossedSquares(par1Block, par2, par3, par4) : (var5 == 2 ? this.renderBlockTorch(par1Block, par2, par3, par4) : (var5 == 20 ? this.renderBlockVine(par1Block, par2, par3, par4) : (var5 == 11 ? this.renderBlockFence((BlockFence)par1Block, par2, par3, par4) : (var5 == 39 ? this.renderBlockQuartz(par1Block, par2, par3, par4) : (var5 == 5 ? this.renderBlockRedstoneWire(par1Block, par2, par3, par4) : (var5 == 13 ? this.renderBlockCactus(par1Block, par2, par3, par4) : (var5 == 9 ? this.renderBlockMinecartTrack((BlockRailBase)par1Block, par2, par3, par4) : (var5 == 19 ? this.renderBlockStem(par1Block, par2, par3, par4) : (var5 == 23 ? this.renderBlockLilyPad(par1Block, par2, par3, par4) : (var5 == 6 ? this.renderBlockCrops(par1Block, par2, par3, par4) : (var5 == 3 ? this.renderBlockFire((BlockFire)par1Block, par2, par3, par4) : (var5 == 8 ? this.renderBlockLadder(par1Block, par2, par3, par4) : (var5 == 7 ? this.renderBlockDoor(par1Block, par2, par3, par4) : (var5 == 10 ? this.renderBlockStairs((BlockStairs)par1Block, par2, par3, par4) : (var5 == 27 ? this.renderBlockDragonEgg((BlockDragonEgg)par1Block, par2, par3, par4) : (var5 == 32 ? this.renderBlockWall((BlockWall)par1Block, par2, par3, par4) : (var5 == 12 ? this.renderBlockLever(par1Block, par2, par3, par4) : (var5 == 29 ? this.renderBlockTripWireSource(par1Block, par2, par3, par4) : (var5 == 30 ? this.renderBlockTripWire(par1Block, par2, par3, par4) : (var5 == 14 ? this.renderBlockBed(par1Block, par2, par3, par4) : (var5 == 15 ? this.renderBlockRepeater((BlockRedstoneRepeater)par1Block, par2, par3, par4) : (var5 == 36 ? this.renderBlockRedstoneLogic((BlockRedstoneLogic)par1Block, par2, par3, par4) : (var5 == 37 ? this.renderBlockComparator((BlockComparator)par1Block, par2, par3, par4) : (var5 == 16 ? this.renderPistonBase(par1Block, par2, par3, par4, false) : (var5 == 17 ? this.renderPistonExtension(par1Block, par2, par3, par4, true) : (var5 == 18 ? this.renderBlockPane((BlockPane)par1Block, par2, par3, par4) : (var5 == 21 ? this.renderBlockFenceGate((BlockFenceGate)par1Block, par2, par3, par4) : (var5 == 24 ? this.renderBlockCauldron((BlockCauldron)par1Block, par2, par3, par4) : (var5 == 33 ? this.renderBlockFlowerpot((BlockFlowerPot)par1Block, par2, par3, par4) : (var5 == 35 ? this.renderBlockAnvil((BlockAnvil)par1Block, par2, par3, par4) : (var5 == 25 ? this.renderBlockBrewingStand((BlockBrewingStand)par1Block, par2, par3, par4) : (var5 == 26 ? this.renderBlockEndPortalFrame((BlockEndPortalFrame)par1Block, par2, par3, par4) : (var5 == 28 ? this.renderBlockCocoa((BlockCocoa)par1Block, par2, par3, par4) : (var5 == 34 ? this.renderBlockBeacon((BlockBeacon)par1Block, par2, par3, par4) : (var5 == 38 ? this.renderBlockHopper((BlockHopper)par1Block, par2, par3, par4) : false))))))))))))))))))))))))))))))))))))));
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Render BlockEndPortalFrame
@@ -549,7 +571,7 @@ public class RenderBlocks
                 var63 = 2;
         }
 
-        if (var62 != 2 && (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2)))
+        if (var62 != 2 && (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 - 1, 2)))
         {
             var5.setBrightness(this.renderMinZ > 0.0D ? var25 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1));
             var5.setColorOpaque_F(var11, var11, var11);
@@ -557,7 +579,7 @@ public class RenderBlocks
             this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 2));
         }
 
-        if (var62 != 3 && (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3)))
+        if (var62 != 3 && (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 + 1, 3)))
         {
             var5.setBrightness(this.renderMaxZ < 1.0D ? var25 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1));
             var5.setColorOpaque_F(var11, var11, var11);
@@ -565,7 +587,7 @@ public class RenderBlocks
             this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3));
         }
 
-        if (var62 != 4 && (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4)))
+        if (var62 != 4 && (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 - 1, par3, par4, 4)))
         {
             var5.setBrightness(this.renderMinZ > 0.0D ? var25 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4));
             var5.setColorOpaque_F(var12, var12, var12);
@@ -573,7 +595,7 @@ public class RenderBlocks
             this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 4));
         }
 
-        if (var62 != 5 && (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5)))
+        if (var62 != 5 && (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 + 1, par3, par4, 5)))
         {
             var5.setBrightness(this.renderMaxZ < 1.0D ? var25 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4));
             var5.setColorOpaque_F(var12, var12, var12);
@@ -608,6 +630,8 @@ public class RenderBlocks
         float var9 = (float)(var7 >> 8 & 255) / 255.0F;
         float var10 = (float)(var7 & 255) / 255.0F;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var11 = (var8 * 30.0F + var9 * 59.0F + var10 * 11.0F) / 100.0F;
@@ -617,9 +641,11 @@ public class RenderBlocks
             var9 = var12;
             var10 = var13;
         }
+        */
+        // END FCMOD
 
         var5.setColorOpaque_F(var6 * var8, var6 * var9, var6 * var10);
-        Icon var32 = this.getBlockIconFromSideAndMetadata(par1BlockBrewingStand, 0, 0);
+        Icon var32 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockBrewingStand, 0, 0) : this.getBlockIcon(par1BlockBrewingStand, this.blockAccess, par2, par3, par4, 0);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -655,14 +681,21 @@ public class RenderBlocks
             var5.addVertexWithUV(var24, (double)(par3 + 1), var28, var20, var33);
         }
 
-        par1BlockBrewingStand.setBlockBoundsForItemRender();
+        // FCMOD: Removed
+        //par1BlockBrewingStand.setBlockBoundsForItemRender();
+        // END FCMOD
         return true;
     }
 
     /**
      * Render block cauldron
      */
+    // FCMOD: Changed to public
+    /*
     private boolean renderBlockCauldron(BlockCauldron par1BlockCauldron, int par2, int par3, int par4)
+    */
+    public boolean renderBlockCauldron(BlockCauldron par1BlockCauldron, int par2, int par3, int par4)
+    // END FCMOD
     {
         this.renderStandardBlock(par1BlockCauldron, par2, par3, par4);
         Tessellator var5 = Tessellator.instance;
@@ -674,6 +707,8 @@ public class RenderBlocks
         float var10 = (float)(var7 & 255) / 255.0F;
         float var12;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var11 = (var8 * 30.0F + var9 * 59.0F + var10 * 11.0F) / 100.0F;
@@ -683,10 +718,17 @@ public class RenderBlocks
             var9 = var12;
             var10 = var13;
         }
+        */
+        // END FCMOD
 
         var5.setColorOpaque_F(var6 * var8, var6 * var9, var6 * var10);
         Icon var16 = par1BlockCauldron.getBlockTextureFromSide(2);
-        var12 = 0.125F;
+        ColorizeBlock.computeWaterColor();
+        var5.setColorOpaque_F(Colorizer.setColor[0], Colorizer.setColor[1], Colorizer.setColor[2]);
+        // FCMOD: Changed to eliminate visual gaps around edge
+        //var12 = 0.125F;
+        var12 = 0.124F;
+        // END FCMOD
         this.renderFaceXPos(par1BlockCauldron, (double)((float)par2 - 1.0F + var12), (double)par3, (double)par4, var16);
         this.renderFaceXNeg(par1BlockCauldron, (double)((float)par2 + 1.0F - var12), (double)par3, (double)par4, var16);
         this.renderFaceZPos(par1BlockCauldron, (double)par2, (double)par3, (double)((float)par4 - 1.0F + var12), var16);
@@ -721,13 +763,15 @@ public class RenderBlocks
         var5.setBrightness(par1BlockFlowerPot.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4));
         float var6 = 1.0F;
         int var7 = par1BlockFlowerPot.colorMultiplier(this.blockAccess, par2, par3, par4);
-        Icon var8 = this.getBlockIconFromSide(par1BlockFlowerPot, 0);
+        Icon var8 = this.blockAccess == null ? this.getBlockIconFromSide(par1BlockFlowerPot, 0) : this.getBlockIcon(par1BlockFlowerPot, this.blockAccess, par2, par3, par4, 0);
         float var9 = (float)(var7 >> 16 & 255) / 255.0F;
         float var10 = (float)(var7 >> 8 & 255) / 255.0F;
         float var11 = (float)(var7 & 255) / 255.0F;
         float var12;
         float var14;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             var12 = (var9 * 30.0F + var10 * 59.0F + var11 * 11.0F) / 100.0F;
@@ -737,6 +781,8 @@ public class RenderBlocks
             var10 = var13;
             var11 = var14;
         }
+        */
+        // END FCMOD
 
         var5.setColorOpaque_F(var6 * var9, var6 * var10, var6 * var11);
         var12 = 0.1865F;
@@ -854,6 +900,8 @@ public class RenderBlocks
         float var10 = (float)(var8 >> 8 & 255) / 255.0F;
         float var11 = (float)(var8 & 255) / 255.0F;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var12 = (var9 * 30.0F + var10 * 59.0F + var11 * 11.0F) / 100.0F;
@@ -863,6 +911,8 @@ public class RenderBlocks
             var10 = var13;
             var11 = var14;
         }
+        */
+        // END FCMOD
 
         var6.setColorOpaque_F(var7 * var9, var7 * var10, var7 * var11);
         return this.renderBlockAnvilOrient(par1BlockAnvil, par2, par3, par4, par5, false);
@@ -943,27 +993,27 @@ public class RenderBlocks
             Tessellator var14 = Tessellator.instance;
             var14.startDrawingQuads();
             var14.setNormal(0.0F, -1.0F, 0.0F);
-            this.renderFaceYNeg(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 0, par12));
+            this.renderFaceYNeg(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 0, par12) : this.getBlockIcon(par1BlockAnvil, this.blockAccess, par2, par3, par4, 0));
             var14.draw();
             var14.startDrawingQuads();
             var14.setNormal(0.0F, 1.0F, 0.0F);
-            this.renderFaceYPos(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 1, par12));
+            this.renderFaceYPos(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 1, par12) : this.getBlockIcon(par1BlockAnvil, this.blockAccess, par2, par3, par4, 1));
             var14.draw();
             var14.startDrawingQuads();
             var14.setNormal(0.0F, 0.0F, -1.0F);
-            this.renderFaceZNeg(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 2, par12));
+            this.renderFaceZNeg(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 2, par12) : this.getBlockIcon(par1BlockAnvil, this.blockAccess, par2, par3, par4, 2));
             var14.draw();
             var14.startDrawingQuads();
             var14.setNormal(0.0F, 0.0F, 1.0F);
-            this.renderFaceZPos(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 3, par12));
+            this.renderFaceZPos(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 3, par12) : this.getBlockIcon(par1BlockAnvil, this.blockAccess, par2, par3, par4, 3));
             var14.draw();
             var14.startDrawingQuads();
             var14.setNormal(-1.0F, 0.0F, 0.0F);
-            this.renderFaceXNeg(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 4, par12));
+            this.renderFaceXNeg(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 4, par12) : this.getBlockIcon(par1BlockAnvil, this.blockAccess, par2, par3, par4, 4));
             var14.draw();
             var14.startDrawingQuads();
             var14.setNormal(1.0F, 0.0F, 0.0F);
-            this.renderFaceXPos(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 5, par12));
+            this.renderFaceXPos(par1BlockAnvil, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockAnvil, 5, par12) : this.getBlockIcon(par1BlockAnvil, this.blockAccess, par2, par3, par4, 5));
             var14.draw();
         }
         else
@@ -979,7 +1029,11 @@ public class RenderBlocks
      */
     public boolean renderBlockTorch(Block par1Block, int par2, int par3, int par4)
     {
-        int var5 = this.blockAccess.getBlockMetadata(par2, par3, par4);
+    	// FCMOD: Changed
+        //int var5 = this.blockAccess.getBlockMetadata(par2, par3, par4);
+        int iMetadata = blockAccess.getBlockMetadata(par2, par3, par4);
+        int var5 = FCBlockTorchBase.GetOrientation( iMetadata );
+    	// END FCMOD
         Tessellator var6 = Tessellator.instance;
         var6.setBrightness(par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4));
         var6.setColorOpaque_F(1.0F, 1.0F, 1.0F);
@@ -989,23 +1043,38 @@ public class RenderBlocks
 
         if (var5 == 1)
         {
-            this.renderTorchAtAngle(par1Block, (double)par2 - var9, (double)par3 + var11, (double)par4, -var7, 0.0D, 0);
+        	// FCMOD: Changed
+            //this.renderTorchAtAngle(par1Block, (double)par2 - var9, (double)par3 + var11, (double)par4, -var7, 0.0D, 0);
+            this.renderTorchAtAngle(par1Block, (double)par2 - var9, (double)par3 + var11, (double)par4, -var7, 0.0D, iMetadata);
+            /// END FCMOD
         }
         else if (var5 == 2)
         {
-            this.renderTorchAtAngle(par1Block, (double)par2 + var9, (double)par3 + var11, (double)par4, var7, 0.0D, 0);
+        	// FCMOD: Changed
+            //this.renderTorchAtAngle(par1Block, (double)par2 + var9, (double)par3 + var11, (double)par4, var7, 0.0D, 0);
+            this.renderTorchAtAngle(par1Block, (double)par2 + var9, (double)par3 + var11, (double)par4, var7, 0.0D, iMetadata);
+            /// END FCMOD
         }
         else if (var5 == 3)
         {
-            this.renderTorchAtAngle(par1Block, (double)par2, (double)par3 + var11, (double)par4 - var9, 0.0D, -var7, 0);
+        	// FCMOD: Changed
+            //this.renderTorchAtAngle(par1Block, (double)par2, (double)par3 + var11, (double)par4 - var9, 0.0D, -var7, 0);
+            this.renderTorchAtAngle(par1Block, (double)par2, (double)par3 + var11, (double)par4 - var9, 0.0D, -var7, iMetadata);
+            /// END FCMOD
         }
         else if (var5 == 4)
         {
-            this.renderTorchAtAngle(par1Block, (double)par2, (double)par3 + var11, (double)par4 + var9, 0.0D, var7, 0);
+        	// FCMOD: Changed
+            //this.renderTorchAtAngle(par1Block, (double)par2, (double)par3 + var11, (double)par4 + var9, 0.0D, var7, 0);
+            this.renderTorchAtAngle(par1Block, (double)par2, (double)par3 + var11, (double)par4 + var9, 0.0D, var7, iMetadata);
+            /// END FCMOD
         }
         else
         {
-            this.renderTorchAtAngle(par1Block, (double)par2, (double)par3, (double)par4, 0.0D, 0.0D, 0);
+        	// FCMOD: Changed
+            //this.renderTorchAtAngle(par1Block, (double)par2, (double)par3, (double)par4, 0.0D, 0.0D, 0);
+            this.renderTorchAtAngle(par1Block, (double)par2, (double)par3, (double)par4, 0.0D, 0.0D, iMetadata);
+            /// END FCMOD
         }
 
         return true;
@@ -1014,7 +1083,12 @@ public class RenderBlocks
     /**
      * render a redstone repeater at the given coordinates
      */
+    // FCMOD: Changed to public
+    /*
     private boolean renderBlockRepeater(BlockRedstoneRepeater par1BlockRedstoneRepeater, int par2, int par3, int par4)
+    */
+    public boolean renderBlockRepeater(BlockRedstoneRepeater par1BlockRedstoneRepeater, int par2, int par3, int par4)
+    // END FCMOD
     {
         int var5 = this.blockAccess.getBlockMetadata(par2, par3, par4);
         int var6 = var5 & 3;
@@ -1159,15 +1233,20 @@ public class RenderBlocks
         this.renderBlockRedstoneLogicMetadata(par1BlockRedstoneLogic, par2, par3, par4, this.blockAccess.getBlockMetadata(par2, par3, par4) & 3);
         return true;
     }
-
+    
+    // FCMOD: Changed to public
+    /*
     private void renderBlockRedstoneLogicMetadata(BlockRedstoneLogic par1BlockRedstoneLogic, int par2, int par3, int par4, int par5)
+    */
+    public void renderBlockRedstoneLogicMetadata(BlockRedstoneLogic par1BlockRedstoneLogic, int par2, int par3, int par4, int par5)
+    // END FCMOD
     {
         this.renderStandardBlock(par1BlockRedstoneLogic, par2, par3, par4);
         Tessellator var6 = Tessellator.instance;
         var6.setBrightness(par1BlockRedstoneLogic.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4));
         var6.setColorOpaque_F(1.0F, 1.0F, 1.0F);
         int var7 = this.blockAccess.getBlockMetadata(par2, par3, par4);
-        Icon var8 = this.getBlockIconFromSideAndMetadata(par1BlockRedstoneLogic, 1, var7);
+        Icon var8 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockRedstoneLogic, 1, var7) : this.getBlockIcon(par1BlockRedstoneLogic, this.blockAccess, par2, par3, par4, 1);
         double var9 = (double)var8.getMinU();
         double var11 = (double)var8.getMaxU();
         double var13 = (double)var8.getMinV();
@@ -1224,7 +1303,12 @@ public class RenderBlocks
     /**
      * renders a block as a piston base
      */
+    // FCMOD: Changed to public
+    /*
     private boolean renderPistonBase(Block par1Block, int par2, int par3, int par4, boolean par5)
+    */
+    public boolean renderPistonBase(Block par1Block, int par2, int par3, int par4, boolean par5)
+    // END FCMOD
     {
         int var6 = this.blockAccess.getBlockMetadata(par2, par3, par4);
         boolean var7 = par5 || (var6 & 8) != 0;
@@ -1276,7 +1360,10 @@ public class RenderBlocks
                     this.setRenderBounds(0.0D, 0.0D, 0.0D, 0.75D, 1.0D, 1.0D);
             }
 
-            ((BlockPistonBase)par1Block).func_96479_b((float)this.renderMinX, (float)this.renderMinY, (float)this.renderMinZ, (float)this.renderMaxX, (float)this.renderMaxY, (float)this.renderMaxZ);
+            // FCMOD: Changed
+            //((BlockPistonBase)par1Block).func_96479_b((float)this.renderMinX, (float)this.renderMinY, (float)this.renderMinZ, (float)this.renderMaxX, (float)this.renderMaxY, (float)this.renderMaxZ);
+            FCBlockPistonBase.m_bIsRenderingExtendedBase = true;
+            // END FCMOD
             this.renderStandardBlock(par1Block, par2, par3, par4);
             this.uvRotateEast = 0;
             this.uvRotateWest = 0;
@@ -1285,7 +1372,10 @@ public class RenderBlocks
             this.uvRotateTop = 0;
             this.uvRotateBottom = 0;
             this.setRenderBounds(0.0D, 0.0D, 0.0D, 1.0D, 1.0D, 1.0D);
-            ((BlockPistonBase)par1Block).func_96479_b((float)this.renderMinX, (float)this.renderMinY, (float)this.renderMinZ, (float)this.renderMaxX, (float)this.renderMaxY, (float)this.renderMaxZ);
+            // FCMOD: Changed
+            //((BlockPistonBase)par1Block).func_96479_b((float)this.renderMinX, (float)this.renderMinY, (float)this.renderMinZ, (float)this.renderMaxX, (float)this.renderMaxY, (float)this.renderMaxZ);
+            FCBlockPistonBase.m_bIsRenderingExtendedBase = false;
+            // END FCMOD
         }
         else
         {
@@ -1424,7 +1514,12 @@ public class RenderBlocks
     /**
      * renders the pushing part of a piston
      */
+    // FCMOD: Changed to public
+    /*
     private boolean renderPistonExtension(Block par1Block, int par2, int par3, int par4, boolean par5)
+    */
+    public boolean renderPistonExtension(Block par1Block, int par2, int par3, int par4, boolean par5)
+    // END FCMOD
     {
         int var6 = this.blockAccess.getBlockMetadata(par2, par3, par4);
         int var7 = BlockPistonExtension.getDirectionMeta(var6);
@@ -1585,7 +1680,7 @@ public class RenderBlocks
         }
 
         var8.setColorOpaque_F(var13, var13, var13);
-        Icon var14 = this.getBlockIconFromSide(par1Block, 0);
+        Icon var14 = this.blockAccess == null ? this.getBlockIconFromSide(par1Block, 0) : this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -1806,7 +1901,7 @@ public class RenderBlocks
         }
 
         var5.setColorOpaque_F(var17, var17, var17);
-        Icon var18 = this.getBlockIconFromSide(par1Block, 0);
+        Icon var18 = this.blockAccess == null ? this.getBlockIconFromSide(par1Block, 0) : this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -2003,7 +2098,7 @@ public class RenderBlocks
             var27[var42].zCoord += (double)par4 + 0.5D;
         }
 
-        byte var64 = 5;
+        byte var65 = 5;
         byte var43 = 11;
         byte var44 = 3;
         byte var45 = 9;
@@ -2016,7 +2111,7 @@ public class RenderBlocks
                 var32 = var27[1];
                 var33 = var27[2];
                 var34 = var27[3];
-                var19 = (double)var18.getInterpolatedU((double)var64);
+                var19 = (double)var18.getInterpolatedU((double)var65);
                 var21 = (double)var18.getInterpolatedV((double)var44);
                 var23 = (double)var18.getInterpolatedU((double)var43);
                 var25 = (double)var18.getInterpolatedV((double)var45);
@@ -2034,7 +2129,7 @@ public class RenderBlocks
                 var32 = var27[0];
                 var33 = var27[4];
                 var34 = var27[5];
-                var19 = (double)var18.getInterpolatedU((double)var64);
+                var19 = (double)var18.getInterpolatedU((double)var65);
                 var21 = (double)var18.getInterpolatedV((double)var44);
                 var23 = (double)var18.getInterpolatedU((double)var43);
                 var25 = (double)var18.getInterpolatedV((double)(var44 + 2));
@@ -2069,7 +2164,7 @@ public class RenderBlocks
 
         if (var8)
         {
-            double var65 = var27[0].yCoord;
+            double var64 = var27[0].yCoord;
             float var48 = 0.03125F;
             float var49 = 0.5F - var48 / 2.0F;
             float var50 = var49 + var48;
@@ -2088,8 +2183,8 @@ public class RenderBlocks
                 var5.addVertexWithUV((double)((float)par2 + var50), (double)par3 + var60, (double)par4 + 0.25D, var52, var58);
                 var5.addVertexWithUV((double)((float)par2 + var50), (double)par3 + var60, (double)par4, var56, var58);
                 var5.addVertexWithUV((double)((float)par2 + var49), (double)par3 + var60, (double)par4, var56, var54);
-                var5.addVertexWithUV((double)((float)par2 + var49), var65, (double)par4 + 0.5D, var52, var54);
-                var5.addVertexWithUV((double)((float)par2 + var50), var65, (double)par4 + 0.5D, var52, var58);
+                var5.addVertexWithUV((double)((float)par2 + var49), var64, (double)par4 + 0.5D, var52, var54);
+                var5.addVertexWithUV((double)((float)par2 + var50), var64, (double)par4 + 0.5D, var52, var58);
                 var5.addVertexWithUV((double)((float)par2 + var50), (double)par3 + var60, (double)par4 + 0.25D, var56, var58);
                 var5.addVertexWithUV((double)((float)par2 + var49), (double)par3 + var60, (double)par4 + 0.25D, var56, var54);
             }
@@ -2097,8 +2192,8 @@ public class RenderBlocks
             {
                 var5.addVertexWithUV((double)((float)par2 + var49), (double)par3 + var60, (double)par4 + 0.75D, var52, var54);
                 var5.addVertexWithUV((double)((float)par2 + var50), (double)par3 + var60, (double)par4 + 0.75D, var52, var58);
-                var5.addVertexWithUV((double)((float)par2 + var50), var65, (double)par4 + 0.5D, var56, var58);
-                var5.addVertexWithUV((double)((float)par2 + var49), var65, (double)par4 + 0.5D, var56, var54);
+                var5.addVertexWithUV((double)((float)par2 + var50), var64, (double)par4 + 0.5D, var56, var58);
+                var5.addVertexWithUV((double)((float)par2 + var49), var64, (double)par4 + 0.5D, var56, var54);
                 var5.addVertexWithUV((double)((float)par2 + var49), (double)par3 + var60, (double)(par4 + 1), var52, var54);
                 var5.addVertexWithUV((double)((float)par2 + var50), (double)par3 + var60, (double)(par4 + 1), var52, var58);
                 var5.addVertexWithUV((double)((float)par2 + var50), (double)par3 + var60, (double)par4 + 0.75D, var56, var58);
@@ -2111,16 +2206,16 @@ public class RenderBlocks
                 var5.addVertexWithUV((double)par2 + 0.25D, (double)par3 + var60, (double)((float)par4 + var49), var56, var54);
                 var5.addVertexWithUV((double)par2, (double)par3 + var60, (double)((float)par4 + var49), var52, var54);
                 var5.addVertexWithUV((double)par2 + 0.25D, (double)par3 + var60, (double)((float)par4 + var50), var52, var58);
-                var5.addVertexWithUV((double)par2 + 0.5D, var65, (double)((float)par4 + var50), var56, var58);
-                var5.addVertexWithUV((double)par2 + 0.5D, var65, (double)((float)par4 + var49), var56, var54);
+                var5.addVertexWithUV((double)par2 + 0.5D, var64, (double)((float)par4 + var50), var56, var58);
+                var5.addVertexWithUV((double)par2 + 0.5D, var64, (double)((float)par4 + var49), var56, var54);
                 var5.addVertexWithUV((double)par2 + 0.25D, (double)par3 + var60, (double)((float)par4 + var49), var52, var54);
             }
             else
             {
-                var5.addVertexWithUV((double)par2 + 0.5D, var65, (double)((float)par4 + var50), var52, var58);
+                var5.addVertexWithUV((double)par2 + 0.5D, var64, (double)((float)par4 + var50), var52, var58);
                 var5.addVertexWithUV((double)par2 + 0.75D, (double)par3 + var60, (double)((float)par4 + var50), var56, var58);
                 var5.addVertexWithUV((double)par2 + 0.75D, (double)par3 + var60, (double)((float)par4 + var49), var56, var54);
-                var5.addVertexWithUV((double)par2 + 0.5D, var65, (double)((float)par4 + var49), var52, var54);
+                var5.addVertexWithUV((double)par2 + 0.5D, var64, (double)((float)par4 + var49), var52, var54);
                 var5.addVertexWithUV((double)par2 + 0.75D, (double)par3 + var60, (double)((float)par4 + var50), var52, var58);
                 var5.addVertexWithUV((double)(par2 + 1), (double)par3 + var60, (double)((float)par4 + var50), var56, var58);
                 var5.addVertexWithUV((double)(par2 + 1), (double)par3 + var60, (double)((float)par4 + var49), var56, var54);
@@ -2137,7 +2232,7 @@ public class RenderBlocks
     public boolean renderBlockTripWire(Block par1Block, int par2, int par3, int par4)
     {
         Tessellator var5 = Tessellator.instance;
-        Icon var6 = this.getBlockIconFromSide(par1Block, 0);
+        Icon var6 = this.blockAccess == null ? this.getBlockIconFromSide(par1Block, 0) : this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0);
         int var7 = this.blockAccess.getBlockMetadata(par2, par3, par4);
         boolean var8 = (var7 & 4) == 4;
         boolean var9 = (var7 & 2) == 2;
@@ -2298,7 +2393,15 @@ public class RenderBlocks
         double var30;
         double var32;
 
+        // FCMOD: Code added
+        boolean bFireRendered = false;
+        // END FCMOD
+        // FCMOD: Changed line so that fire will prefer the sides of flammable surfaces rather than the top of non-falmmable
+        /*
         if (!this.blockAccess.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4) && !Block.fire.canBlockCatchFire(this.blockAccess, par2, par3 - 1, par4))
+        */
+        if ( !Block.fire.ShouldFirePreferToDisplayUpwards( blockAccess, par2, par3, par4 ) )
+        // END FCMOD
         {
             float var36 = 0.2F;
             float var19 = 0.0625F;
@@ -2328,6 +2431,9 @@ public class RenderBlocks
                 var5.addVertexWithUV((double)(par2 + 0), (double)((float)(par3 + 0) + var19), (double)(par4 + 0), var9, var15);
                 var5.addVertexWithUV((double)(par2 + 0), (double)((float)(par3 + 0) + var19), (double)(par4 + 1), var13, var15);
                 var5.addVertexWithUV((double)((float)par2 + var36), (double)((float)par3 + var17 + var19), (double)(par4 + 1), var13, var11);
+                // FCMOD: Code added
+                bFireRendered = true;
+                // END FCMOD
             }
 
             if (Block.fire.canBlockCatchFire(this.blockAccess, par2 + 1, par3, par4))
@@ -2340,6 +2446,9 @@ public class RenderBlocks
                 var5.addVertexWithUV((double)(par2 + 1 - 0), (double)((float)(par3 + 0) + var19), (double)(par4 + 1), var13, var15);
                 var5.addVertexWithUV((double)(par2 + 1 - 0), (double)((float)(par3 + 0) + var19), (double)(par4 + 0), var9, var15);
                 var5.addVertexWithUV((double)((float)(par2 + 1) - var36), (double)((float)par3 + var17 + var19), (double)(par4 + 0), var9, var11);
+                // FCMOD: Code added
+                bFireRendered = true;
+                // END FCMOD
             }
 
             if (Block.fire.canBlockCatchFire(this.blockAccess, par2, par3, par4 - 1))
@@ -2352,6 +2461,9 @@ public class RenderBlocks
                 var5.addVertexWithUV((double)(par2 + 1), (double)((float)(par3 + 0) + var19), (double)(par4 + 0), var9, var15);
                 var5.addVertexWithUV((double)(par2 + 0), (double)((float)(par3 + 0) + var19), (double)(par4 + 0), var13, var15);
                 var5.addVertexWithUV((double)(par2 + 0), (double)((float)par3 + var17 + var19), (double)((float)par4 + var36), var13, var11);
+                // FCMOD: Code added
+                bFireRendered = true;
+                // END FCMOD
             }
 
             if (Block.fire.canBlockCatchFire(this.blockAccess, par2, par3, par4 + 1))
@@ -2364,6 +2476,9 @@ public class RenderBlocks
                 var5.addVertexWithUV((double)(par2 + 0), (double)((float)(par3 + 0) + var19), (double)(par4 + 1 - 0), var13, var15);
                 var5.addVertexWithUV((double)(par2 + 1), (double)((float)(par3 + 0) + var19), (double)(par4 + 1 - 0), var9, var15);
                 var5.addVertexWithUV((double)(par2 + 1), (double)((float)par3 + var17 + var19), (double)((float)(par4 + 1) - var36), var9, var11);
+                // FCMOD: Code added
+                bFireRendered = true;
+                // END FCMOD
             }
 
             if (Block.fire.canBlockCatchFire(this.blockAccess, par2, par3 + 1, par4))
@@ -2413,9 +2528,17 @@ public class RenderBlocks
                     var5.addVertexWithUV((double)(par2 + 0), (double)(par3 + 0), var24, var9, var15);
                     var5.addVertexWithUV((double)(par2 + 0), (double)((float)par3 + var17), var32, var9, var11);
                 }
+                // FCMOD: Code added
+                bFireRendered = true;
+                // END FCMOD
             }
         }
+        // FCMOD: Changed line so that fire will prefer the sides of flammable surfaces rather than the top of non-falmmable
+        /*
         else
+        */
+        if ( !bFireRendered && ( blockAccess.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4) || Block.fire.canBlockCatchFire(this.blockAccess, par2, par3 - 1, par4) ) )
+        // END FCMOD        	
         {
             double var18 = (double)par2 + 0.5D + 0.2D;
             var20 = (double)par2 + 0.5D - 0.2D;
@@ -2491,16 +2614,29 @@ public class RenderBlocks
         Icon var10 = BlockRedstoneWire.func_94409_b("redstoneDust_line_overlay");
         var5.setBrightness(par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4));
         float var11 = 1.0F;
-        float var12 = (float)var6 / 15.0F;
-        float var13 = var12 * 0.6F + 0.4F;
+        float var13;
+        float var14;
+        float var15;
 
-        if (var6 == 0)
+        if (ColorizeBlock.computeRedstoneWireColor(var6))
         {
-            var13 = 0.3F;
+        	var13 = Colorizer.setColor[0];
+            var14 = Colorizer.setColor[1];
+            var15 = Colorizer.setColor[2];
         }
+        else
+        {
+            float var12 = (float)var6 / 15.0F;
+            var13 = var12 * 0.6F + 0.4F;
+
+            if (var6 == 0)
+            {
+                var13 = 0.3F;
+            }
 
-        float var14 = var12 * var12 * 0.7F - 0.5F;
-        float var15 = var12 * var12 * 0.6F - 0.7F;
+            var14 = var12 * var12 * 0.7F - 0.5F;
+            var15 = var12 * var12 * 0.6F - 0.7F;
+        }
 
         if (var14 < 0.0F)
         {
@@ -2708,7 +2844,7 @@ public class RenderBlocks
     {
         Tessellator var5 = Tessellator.instance;
         int var6 = this.blockAccess.getBlockMetadata(par2, par3, par4);
-        Icon var7 = this.getBlockIconFromSideAndMetadata(par1BlockRailBase, 0, var6);
+        Icon var7 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockRailBase, 0, var6) : this.getBlockIcon(par1BlockRailBase, this.blockAccess, par2, par3, par4, 0);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -2796,7 +2932,7 @@ public class RenderBlocks
     public boolean renderBlockLadder(Block par1Block, int par2, int par3, int par4)
     {
         Tessellator var5 = Tessellator.instance;
-        Icon var6 = this.getBlockIconFromSide(par1Block, 0);
+        Icon var6 = this.blockAccess == null ? this.getBlockIconFromSide(par1Block, 0) : this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -2855,7 +2991,7 @@ public class RenderBlocks
     public boolean renderBlockVine(Block par1Block, int par2, int par3, int par4)
     {
         Tessellator var5 = Tessellator.instance;
-        Icon var6 = this.getBlockIconFromSide(par1Block, 0);
+        Icon var6 = this.blockAccess == null ? this.getBlockIconFromSide(par1Block, 0) : this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -2946,6 +3082,8 @@ public class RenderBlocks
         float var10 = (float)(var8 >> 8 & 255) / 255.0F;
         float var11 = (float)(var8 & 255) / 255.0F;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var12 = (var9 * 30.0F + var10 * 59.0F + var11 * 11.0F) / 100.0F;
@@ -2955,6 +3093,8 @@ public class RenderBlocks
             var10 = var13;
             var11 = var14;
         }
+        */
+        // END FCMOD
 
         var6.setColorOpaque_F(var7 * var9, var7 * var10, var7 * var11);
         Icon var64;
@@ -2969,7 +3109,7 @@ public class RenderBlocks
         else
         {
             var66 = this.blockAccess.getBlockMetadata(par2, par3, par4);
-            var64 = this.getBlockIconFromSideAndMetadata(par1BlockPane, 0, var66);
+            var64 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockPane, 0, var66) : this.getBlockIcon(par1BlockPane, this.blockAccess, par2, par3, par4, 0);
             var65 = par1BlockPane.getSideTextureIndex();
         }
 
@@ -3003,19 +3143,23 @@ public class RenderBlocks
         boolean var61 = par1BlockPane.canThisPaneConnectToThisBlockID(this.blockAccess.getBlockId(par2 + 1, par3, par4));
         boolean var62 = par1BlockPane.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1);
         boolean var63 = par1BlockPane.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0);
+        GlassPaneRenderer.renderThin(this, par1BlockPane, var64, par2, par3, par4, var58, var59, var60, var61);
 
         if ((!var60 || !var61) && (var60 || var61 || var58 || var59))
         {
             if (var60 && !var61)
             {
-                var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var16, var22);
-                var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var16, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var16, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var16, var24);
-                var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var18, var24);
-                var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var18, var22);
+            	if (!GlassPaneRenderer.skipPaneRendering)
+                {
+                    var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var16, var22);
+                    var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var16, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var16, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var16, var24);
+                    var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var18, var24);
+                    var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var18, var22);
+                }
 
                 if (!var59 && !var58)
                 {
@@ -3041,7 +3185,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var40, (double)(par3 + 1) + 0.01D, var54, var28, var34);
                 }
 
-                if (var63 || par3 > 1 && this.blockAccess.isAirBlock(par2 - 1, par3 - 1, par4))
+                if ((var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 - 1, par3 + 1, par4)) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var38, (double)par3 - 0.01D, var56, var30, var34);
                     var6.addVertexWithUV(var40, (double)par3 - 0.01D, var56, var30, var36);
@@ -3055,14 +3199,17 @@ public class RenderBlocks
             }
             else if (!var60 && var61)
             {
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
-                var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var20, var24);
-                var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var20, var22);
-                var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var18, var22);
-                var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var18, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var20, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var20, var22);
+            	if (!GlassPaneRenderer.skipPaneRendering)
+                {
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
+                    var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var20, var24);
+                    var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var20, var22);
+                    var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var18, var22);
+                    var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var18, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var20, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var20, var22);
+                }
 
                 if (!var59 && !var58)
                 {
@@ -3076,7 +3223,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var40, (double)(par3 + 1), var54, var30, var32);
                 }
 
-                if (var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 + 1, par3 + 1, par4))
+                if ((var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 + 1, par3 + 1, par4)) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var40, (double)(par3 + 1) + 0.01D, var56, var30, var32);
                     var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var56, var30, var34);
@@ -3088,7 +3235,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var54, var28, var32);
                 }
 
-                if (var63 || par3 > 1 && this.blockAccess.isAirBlock(par2 + 1, par3 - 1, par4))
+                if ((var63 || par3 > 1 && this.blockAccess.isAirBlock(par2 + 1, par3 - 1, par4)) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var40, (double)par3 - 0.01D, var56, var30, var32);
                     var6.addVertexWithUV(var42, (double)par3 - 0.01D, var56, var30, var34);
@@ -3103,29 +3250,35 @@ public class RenderBlocks
         }
         else
         {
-            var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var16, var22);
-            var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var16, var24);
-            var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var20, var24);
-            var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var20, var22);
-            var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var16, var22);
-            var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var16, var24);
-            var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var20, var24);
-            var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var20, var22);
+        	if (!GlassPaneRenderer.skipPaneRendering)
+            {
+                var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var16, var22);
+                var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var16, var24);
+                var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var20, var24);
+                var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var20, var22);
+                var6.addVertexWithUV(var42, (double)(par3 + 1), var46, var16, var22);
+                var6.addVertexWithUV(var42, (double)(par3 + 0), var46, var16, var24);
+                var6.addVertexWithUV(var38, (double)(par3 + 0), var46, var20, var24);
+                var6.addVertexWithUV(var38, (double)(par3 + 1), var46, var20, var22);
+            }
 
             if (var62)
             {
-                var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var56, var30, var36);
-                var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var56, var30, var32);
-                var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var54, var28, var32);
-                var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var54, var28, var36);
-                var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var56, var30, var36);
-                var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var56, var30, var32);
-                var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var54, var28, var32);
-                var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var54, var28, var36);
+            	if (!GlassPaneRenderer.skipTopEdgeRendering)
+                {
+                    var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var56, var30, var36);
+                    var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var56, var30, var32);
+                    var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var54, var28, var32);
+                    var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var54, var28, var36);
+                    var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var56, var30, var36);
+                    var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var56, var30, var32);
+                    var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var54, var28, var32);
+                    var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var54, var28, var36);
+                }
             }
             else
             {
-                if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 - 1, par3 + 1, par4))
+            	if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 - 1, par3 + 1, par4) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var38, (double)(par3 + 1) + 0.01D, var56, var30, var34);
                     var6.addVertexWithUV(var40, (double)(par3 + 1) + 0.01D, var56, var30, var36);
@@ -3137,7 +3290,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var40, (double)(par3 + 1) + 0.01D, var54, var28, var34);
                 }
 
-                if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 + 1, par3 + 1, par4))
+            	if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2 + 1, par3 + 1, par4) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var40, (double)(par3 + 1) + 0.01D, var56, var30, var32);
                     var6.addVertexWithUV(var42, (double)(par3 + 1) + 0.01D, var56, var30, var34);
@@ -3152,18 +3305,21 @@ public class RenderBlocks
 
             if (var63)
             {
-                var6.addVertexWithUV(var38, (double)par3 - 0.01D, var56, var30, var36);
-                var6.addVertexWithUV(var42, (double)par3 - 0.01D, var56, var30, var32);
-                var6.addVertexWithUV(var42, (double)par3 - 0.01D, var54, var28, var32);
-                var6.addVertexWithUV(var38, (double)par3 - 0.01D, var54, var28, var36);
-                var6.addVertexWithUV(var42, (double)par3 - 0.01D, var56, var30, var36);
-                var6.addVertexWithUV(var38, (double)par3 - 0.01D, var56, var30, var32);
-                var6.addVertexWithUV(var38, (double)par3 - 0.01D, var54, var28, var32);
-                var6.addVertexWithUV(var42, (double)par3 - 0.01D, var54, var28, var36);
+            	if (!GlassPaneRenderer.skipBottomEdgeRendering)
+                {
+                    var6.addVertexWithUV(var38, (double)par3 - 0.01D, var56, var30, var36);
+                    var6.addVertexWithUV(var42, (double)par3 - 0.01D, var56, var30, var32);
+                    var6.addVertexWithUV(var42, (double)par3 - 0.01D, var54, var28, var32);
+                    var6.addVertexWithUV(var38, (double)par3 - 0.01D, var54, var28, var36);
+                    var6.addVertexWithUV(var42, (double)par3 - 0.01D, var56, var30, var36);
+                    var6.addVertexWithUV(var38, (double)par3 - 0.01D, var56, var30, var32);
+                    var6.addVertexWithUV(var38, (double)par3 - 0.01D, var54, var28, var32);
+                    var6.addVertexWithUV(var42, (double)par3 - 0.01D, var54, var28, var36);
+                }
             }
             else
             {
-                if (par3 > 1 && this.blockAccess.isAirBlock(par2 - 1, par3 - 1, par4))
+            	if (par3 > 1 && this.blockAccess.isAirBlock(par2 - 1, par3 - 1, par4) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var38, (double)par3 - 0.01D, var56, var30, var34);
                     var6.addVertexWithUV(var40, (double)par3 - 0.01D, var56, var30, var36);
@@ -3175,7 +3331,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var40, (double)par3 - 0.01D, var54, var28, var34);
                 }
 
-                if (par3 > 1 && this.blockAccess.isAirBlock(par2 + 1, par3 - 1, par4))
+            	if (par3 > 1 && this.blockAccess.isAirBlock(par2 + 1, par3 - 1, par4) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var40, (double)par3 - 0.01D, var56, var30, var32);
                     var6.addVertexWithUV(var42, (double)par3 - 0.01D, var56, var30, var34);
@@ -3193,14 +3349,17 @@ public class RenderBlocks
         {
             if (var58 && !var59)
             {
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var16, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var16, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var16, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var16, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var18, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var18, var22);
+            	if (!GlassPaneRenderer.skipPaneRendering)
+                {
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var16, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var16, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var16, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var16, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var18, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var18, var22);
+                }
 
                 if (!var61 && !var60)
                 {
@@ -3214,7 +3373,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var50, (double)(par3 + 1), var46, var30, var32);
                 }
 
-                if (var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 - 1))
+                if ((var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 - 1)) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var44, var30, var32);
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var46, var30, var34);
@@ -3226,7 +3385,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var46, var28, var32);
                 }
 
-                if (var63 || par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 - 1))
+                if ((var63 || par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 - 1)) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var44, var30, var32);
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var46, var30, var34);
@@ -3240,14 +3399,17 @@ public class RenderBlocks
             }
             else if (!var58 && var59)
             {
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var20, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var20, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var18, var22);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var18, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var20, var24);
-                var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var20, var22);
+            	if (!GlassPaneRenderer.skipPaneRendering)
+                {
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var18, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var18, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var20, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var20, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var18, var22);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var18, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 0), var46, var20, var24);
+                    var6.addVertexWithUV(var40, (double)(par3 + 1), var46, var20, var22);
+                }
 
                 if (!var61 && !var60)
                 {
@@ -3261,7 +3423,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var52, (double)(par3 + 1), var46, var30, var32);
                 }
 
-                if (var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 + 1))
+                if ((var62 || par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 + 1)) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var46, var28, var34);
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var48, var28, var36);
@@ -3273,7 +3435,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var48, var30, var34);
                 }
 
-                if (var63 || par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 + 1))
+                if ((var63 || par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 + 1)) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var46, var28, var34);
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var48, var28, var36);
@@ -3288,29 +3450,35 @@ public class RenderBlocks
         }
         else
         {
-            var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var16, var22);
-            var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var16, var24);
-            var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var20, var24);
-            var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var20, var22);
-            var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var16, var22);
-            var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var16, var24);
-            var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var20, var24);
-            var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var20, var22);
+        	if (!GlassPaneRenderer.skipPaneRendering)
+            {
+                var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var16, var22);
+                var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var16, var24);
+                var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var20, var24);
+                var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var20, var22);
+                var6.addVertexWithUV(var40, (double)(par3 + 1), var44, var16, var22);
+                var6.addVertexWithUV(var40, (double)(par3 + 0), var44, var16, var24);
+                var6.addVertexWithUV(var40, (double)(par3 + 0), var48, var20, var24);
+                var6.addVertexWithUV(var40, (double)(par3 + 1), var48, var20, var22);
+            }
 
             if (var62)
             {
-                var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var48, var30, var36);
-                var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var44, var30, var32);
-                var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var44, var28, var32);
-                var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var48, var28, var36);
-                var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var44, var30, var36);
-                var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var48, var30, var32);
-                var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var48, var28, var32);
-                var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var44, var28, var36);
+            	if (!GlassPaneRenderer.skipTopEdgeRendering)
+                {
+                    var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var48, var30, var36);
+                    var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var44, var30, var32);
+                    var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var44, var28, var32);
+                    var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var48, var28, var36);
+                    var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var44, var30, var36);
+                    var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var48, var30, var32);
+                    var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var48, var28, var32);
+                    var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var44, var28, var36);
+                }
             }
             else
             {
-                if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 - 1))
+            	if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 - 1) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var44, var30, var32);
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var46, var30, var34);
@@ -3322,7 +3490,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var52, (double)(par3 + 1) + 0.005D, var46, var28, var32);
                 }
 
-                if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 + 1))
+            	if (par3 < var5 - 1 && this.blockAccess.isAirBlock(par2, par3 + 1, par4 + 1) && !GlassPaneRenderer.skipTopEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var46, var28, var34);
                     var6.addVertexWithUV(var50, (double)(par3 + 1) + 0.005D, var48, var28, var36);
@@ -3337,18 +3505,21 @@ public class RenderBlocks
 
             if (var63)
             {
-                var6.addVertexWithUV(var52, (double)par3 - 0.005D, var48, var30, var36);
-                var6.addVertexWithUV(var52, (double)par3 - 0.005D, var44, var30, var32);
-                var6.addVertexWithUV(var50, (double)par3 - 0.005D, var44, var28, var32);
-                var6.addVertexWithUV(var50, (double)par3 - 0.005D, var48, var28, var36);
-                var6.addVertexWithUV(var52, (double)par3 - 0.005D, var44, var30, var36);
-                var6.addVertexWithUV(var52, (double)par3 - 0.005D, var48, var30, var32);
-                var6.addVertexWithUV(var50, (double)par3 - 0.005D, var48, var28, var32);
-                var6.addVertexWithUV(var50, (double)par3 - 0.005D, var44, var28, var36);
+            	if (!GlassPaneRenderer.skipBottomEdgeRendering)
+                {
+                    var6.addVertexWithUV(var52, (double)par3 - 0.005D, var48, var30, var36);
+                    var6.addVertexWithUV(var52, (double)par3 - 0.005D, var44, var30, var32);
+                    var6.addVertexWithUV(var50, (double)par3 - 0.005D, var44, var28, var32);
+                    var6.addVertexWithUV(var50, (double)par3 - 0.005D, var48, var28, var36);
+                    var6.addVertexWithUV(var52, (double)par3 - 0.005D, var44, var30, var36);
+                    var6.addVertexWithUV(var52, (double)par3 - 0.005D, var48, var30, var32);
+                    var6.addVertexWithUV(var50, (double)par3 - 0.005D, var48, var28, var32);
+                    var6.addVertexWithUV(var50, (double)par3 - 0.005D, var44, var28, var36);
+                }
             }
             else
             {
-                if (par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 - 1))
+            	if (par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 - 1) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var44, var30, var32);
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var46, var30, var34);
@@ -3360,7 +3531,7 @@ public class RenderBlocks
                     var6.addVertexWithUV(var52, (double)par3 - 0.005D, var46, var28, var32);
                 }
 
-                if (par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 + 1))
+            	if (par3 > 1 && this.blockAccess.isAirBlock(par2, par3 - 1, par4 + 1) && !GlassPaneRenderer.skipBottomEdgeRendering)
                 {
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var46, var28, var34);
                     var6.addVertexWithUV(var50, (double)par3 - 0.005D, var48, var28, var36);
@@ -3390,6 +3561,8 @@ public class RenderBlocks
         float var9 = (float)(var7 >> 8 & 255) / 255.0F;
         float var10 = (float)(var7 & 255) / 255.0F;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var11 = (var8 * 30.0F + var9 * 59.0F + var10 * 11.0F) / 100.0F;
@@ -3399,6 +3572,8 @@ public class RenderBlocks
             var9 = var12;
             var10 = var13;
         }
+        */
+        // END FCMOD
 
         var5.setColorOpaque_F(var6 * var8, var6 * var9, var6 * var10);
         double var19 = (double)par2;
@@ -3432,6 +3607,8 @@ public class RenderBlocks
         float var10 = (float)(var8 >> 8 & 255) / 255.0F;
         float var11 = (float)(var8 & 255) / 255.0F;
 
+        // FCMOD: Removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var12 = (var9 * 30.0F + var10 * 59.0F + var11 * 11.0F) / 100.0F;
@@ -3441,11 +3618,15 @@ public class RenderBlocks
             var10 = var13;
             var11 = var14;
         }
+        */
+        // END FCMOD
 
         var6.setColorOpaque_F(var7 * var9, var7 * var10, var7 * var11);
         var5.setBlockBoundsBasedOnState(this.blockAccess, par2, par3, par4);
         int var15 = var5.getState(this.blockAccess, par2, par3, par4);
 
+        // FCMOD: Changed to display stems correctly over Planters
+        /*
         if (var15 < 0)
         {
             this.renderBlockStemSmall(var5, this.blockAccess.getBlockMetadata(par2, par3, par4), this.renderMaxY, (double)par2, (double)((float)par3 - 0.0625F), (double)par4);
@@ -3455,6 +3636,31 @@ public class RenderBlocks
             this.renderBlockStemSmall(var5, this.blockAccess.getBlockMetadata(par2, par3, par4), 0.5D, (double)par2, (double)((float)par3 - 0.0625F), (double)par4);
             this.renderBlockStemBig(var5, this.blockAccess.getBlockMetadata(par2, par3, par4), var15, this.renderMaxY, (double)par2, (double)((float)par3 - 0.0625F), (double)par4);
         }
+        */
+        Block blockBelow = Block.blocksList[blockAccess.getBlockId( par2, par3 - 1, par4 )];
+        
+        float fVerticalOffset = 0F;
+        
+        if ( blockBelow != null )
+        {
+        	fVerticalOffset = blockBelow.GroundCoverRestingOnVisualOffset( blockAccess, 
+        		par2, par3 - 1, par4 );
+        }
+        
+        if (var15 < 0)
+        {
+            renderBlockStemSmall( var5, blockAccess.getBlockMetadata( par2, par3, par4 ), renderMaxY, 
+            	par2, par3 + fVerticalOffset, par4 );
+        }
+        else
+        {
+            renderBlockStemSmall( var5, blockAccess.getBlockMetadata( par2, par3, par4 ), 0.5D, 
+            	par2, par3 + fVerticalOffset, par4 );
+            
+            renderBlockStemBig( var5, blockAccess.getBlockMetadata( par2, par3, par4 ), var15, 
+            	renderMaxY, par2, par3 + fVerticalOffset, par4);
+        }
+        // END FCMOD
 
         return true;
     }
@@ -3467,7 +3673,20 @@ public class RenderBlocks
         Tessellator var5 = Tessellator.instance;
         var5.setBrightness(par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4));
         var5.setColorOpaque_F(1.0F, 1.0F, 1.0F);
-        this.renderBlockCropsImpl(par1Block, this.blockAccess.getBlockMetadata(par2, par3, par4), (double)par2, (double)((float)par3 - 0.0625F), (double)par4);
+        // FCMOD: Changed to display crops correctly over Planters
+        //this.renderBlockCropsImpl(par1Block, this.blockAccess.getBlockMetadata(par2, par3, par4), (double)par2, (double)((float)par3 - 0.0625F), (double)par4);
+        Block blockBelow = Block.blocksList[blockAccess.getBlockId( par2, par3 - 1, par4 )];
+        double dVerticalOffset = 0F;
+        
+        if ( blockBelow != null )
+        {
+        	dVerticalOffset = blockBelow.GroundCoverRestingOnVisualOffset( blockAccess, 
+        		par2, par3 - 1, par4 );
+        }
+        
+        renderBlockCropsImpl( par1Block, blockAccess.getBlockMetadata( par2, par3, par4 ), 
+        	par2, par3 + dVerticalOffset, (double)par4 );
+        // END FCMOD
         return true;
     }
 
@@ -3536,7 +3755,7 @@ public class RenderBlocks
     public void drawCrossedSquares(Block par1Block, int par2, double par3, double par5, double par7, float par9)
     {
         Tessellator var10 = Tessellator.instance;
-        Icon var11 = this.getBlockIconFromSideAndMetadata(par1Block, 0, par2);
+        Icon var11 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1Block, 0, par2) : this.getBlockIcon(par1Block, this.blockAccess, (int)Math.round(par3), (int)Math.round(par5), (int)Math.round(par7), -1);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -3615,7 +3834,7 @@ public class RenderBlocks
     public boolean renderBlockLilyPad(Block par1Block, int par2, int par3, int par4)
     {
         Tessellator var5 = Tessellator.instance;
-        Icon var6 = this.getBlockIconFromSide(par1Block, 1);
+        Icon var6 = this.blockAccess == null ? this.getBlockIconFromSide(par1Block, 1) : this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 1);
 
         if (this.hasOverrideBlockTexture())
         {
@@ -3765,6 +3984,8 @@ public class RenderBlocks
     /**
      * Renders a block based on the BlockFluids class at the given coordinates
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public boolean renderBlockFluids(Block par1Block, int par2, int par3, int par4)
     {
         Tessellator var5 = Tessellator.instance;
@@ -3772,10 +3993,10 @@ public class RenderBlocks
         float var7 = (float)(var6 >> 16 & 255) / 255.0F;
         float var8 = (float)(var6 >> 8 & 255) / 255.0F;
         float var9 = (float)(var6 & 255) / 255.0F;
-        boolean var10 = par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1);
-        boolean var11 = par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0);
-        boolean[] var12 = new boolean[] {par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2), par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3), par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4), par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5)};
-
+        boolean var10 = RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 + 1, par4, 1);
+        boolean var11 = RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 - 1, par4, 0);
+        boolean[] var12 = new boolean[] {RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 - 1, 2), RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 + 1, 3), RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 - 1, par3, par4, 4), RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 + 1, par3, par4, 5)};
+        
         if (!var10 && !var11 && !var12[0] && !var12[1] && !var12[2] && !var12[3])
         {
             return false;
@@ -3796,8 +4017,8 @@ public class RenderBlocks
             double var28 = (double)this.getFluidHeight(par2 + 1, par3, par4 + 1, var22);
             double var30 = (double)this.getFluidHeight(par2 + 1, par3, par4, var22);
             double var32 = 0.0010000000474974513D;
-            float var52;
             float var53;
+            float var52;
 
             if (this.renderAllFaces || var10)
             {
@@ -3814,14 +4035,14 @@ public class RenderBlocks
                 var26 -= var32;
                 var28 -= var32;
                 var30 -= var32;
-                double var36;
                 double var38;
-                double var40;
+                double var36;
                 double var42;
-                double var44;
+                double var40;
                 double var46;
-                double var48;
+                double var44;
                 double var50;
+                double var48;
 
                 if (var35 < -999.0F)
                 {
@@ -3860,49 +4081,49 @@ public class RenderBlocks
             if (this.renderAllFaces || var11)
             {
                 var5.setBrightness(par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4));
-                float var57 = 1.0F;
-                var5.setColorOpaque_F(var14 * var57, var14 * var57, var14 * var57);
+                float var58 = 1.0F;
+                var5.setColorOpaque_F(var14 * var58, var14 * var58, var14 * var58);
                 this.renderFaceYNeg(par1Block, (double)par2, (double)par3 + var32, (double)par4, this.getBlockIconFromSide(par1Block, 0));
                 var13 = true;
             }
 
-            for (int var59 = 0; var59 < 4; ++var59)
+            for (int var57 = 0; var57 < 4; ++var57)
             {
-                int var58 = par2;
+                int var59 = par2;
                 int var37 = par4;
 
-                if (var59 == 0)
+                if (var57 == 0)
                 {
                     var37 = par4 - 1;
                 }
 
-                if (var59 == 1)
+                if (var57 == 1)
                 {
                     ++var37;
                 }
 
-                if (var59 == 2)
+                if (var57 == 2)
                 {
-                    var58 = par2 - 1;
+                    var59 = par2 - 1;
                 }
 
-                if (var59 == 3)
+                if (var57 == 3)
                 {
-                    ++var58;
+                    ++var59;
                 }
 
-                Icon var60 = this.getBlockIconFromSideAndMetadata(par1Block, var59 + 2, var23);
+                Icon var60 = this.getBlockIconFromSideAndMetadata(par1Block, var57 + 2, var23);
 
-                if (this.renderAllFaces || var12[var59])
+                if (this.renderAllFaces || var12[var57])
                 {
                     double var39;
-                    double var41;
                     double var43;
-                    double var45;
+                    double var41;
                     double var47;
+                    double var45;
                     double var49;
 
-                    if (var59 == 0)
+                    if (var57 == 0)
                     {
                         var39 = var24;
                         var41 = var30;
@@ -3911,7 +4132,7 @@ public class RenderBlocks
                         var45 = (double)par4 + var32;
                         var49 = (double)par4 + var32;
                     }
-                    else if (var59 == 1)
+                    else if (var57 == 1)
                     {
                         var39 = var28;
                         var41 = var26;
@@ -3920,7 +4141,7 @@ public class RenderBlocks
                         var45 = (double)(par4 + 1) - var32;
                         var49 = (double)(par4 + 1) - var32;
                     }
-                    else if (var59 == 2)
+                    else if (var57 == 2)
                     {
                         var39 = var26;
                         var41 = var24;
@@ -3945,10 +4166,10 @@ public class RenderBlocks
                     var53 = var60.getInterpolatedV((1.0D - var39) * 16.0D * 0.5D);
                     float var54 = var60.getInterpolatedV((1.0D - var41) * 16.0D * 0.5D);
                     float var55 = var60.getInterpolatedV(8.0D);
-                    var5.setBrightness(par1Block.getMixedBrightnessForBlock(this.blockAccess, var58, par3, var37));
+                    var5.setBrightness(par1Block.getMixedBrightnessForBlock(this.blockAccess, var59, par3, var37));
                     float var56 = 1.0F;
 
-                    if (var59 < 2)
+                    if (var57 < 2)
                     {
                         var56 *= var16;
                     }
@@ -3970,6 +4191,8 @@ public class RenderBlocks
             return var13;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Get fluid height
@@ -4034,7 +4257,11 @@ public class RenderBlocks
             var13 = var12;
         }
 
-        var11.setColorOpaque_F(var7 * var13, var7 * var13, var7 * var13);
+        if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, par2World, par3, par4, par5, 0))
+        {
+            var11.setColorOpaque_F(var7 * var13, var7 * var13, var7 * var13);
+        }
+        
         this.renderFaceYNeg(par1Block, -0.5D, -0.5D, -0.5D, this.getBlockIconFromSideAndMetadata(par1Block, 0, par6));
         var13 = 1.0F;
 
@@ -4043,7 +4270,11 @@ public class RenderBlocks
             var13 = var12;
         }
 
-        var11.setColorOpaque_F(var8 * var13, var8 * var13, var8 * var13);
+        if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, par2World, par3, par4, par5, 1))
+        {
+            var11.setColorOpaque_F(var8 * var13, var8 * var13, var8 * var13);
+        }
+        
         this.renderFaceYPos(par1Block, -0.5D, -0.5D, -0.5D, this.getBlockIconFromSideAndMetadata(par1Block, 1, par6));
         var13 = 1.0F;
 
@@ -4052,7 +4283,11 @@ public class RenderBlocks
             var13 = var12;
         }
 
-        var11.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+        if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, par2World, par3, par4, par5, 2))
+        {
+            var11.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+        }
+        
         this.renderFaceZNeg(par1Block, -0.5D, -0.5D, -0.5D, this.getBlockIconFromSideAndMetadata(par1Block, 2, par6));
         var13 = 1.0F;
 
@@ -4061,7 +4296,11 @@ public class RenderBlocks
             var13 = var12;
         }
 
-        var11.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+        if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, par2World, par3, par4, par5, 2))
+        {
+            var11.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+        }
+        
         this.renderFaceZPos(par1Block, -0.5D, -0.5D, -0.5D, this.getBlockIconFromSideAndMetadata(par1Block, 3, par6));
         var13 = 1.0F;
 
@@ -4070,7 +4309,11 @@ public class RenderBlocks
             var13 = var12;
         }
 
-        var11.setColorOpaque_F(var10 * var13, var10 * var13, var10 * var13);
+        if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, par2World, par3, par4, par5, 2))
+        {
+            var11.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+        }
+        
         this.renderFaceXNeg(par1Block, -0.5D, -0.5D, -0.5D, this.getBlockIconFromSideAndMetadata(par1Block, 4, par6));
         var13 = 1.0F;
 
@@ -4079,7 +4322,11 @@ public class RenderBlocks
             var13 = var12;
         }
 
-        var11.setColorOpaque_F(var10 * var13, var10 * var13, var10 * var13);
+        if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, par2World, par3, par4, par5, 2))
+        {
+            var11.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
+        }
+        
         this.renderFaceXPos(par1Block, -0.5D, -0.5D, -0.5D, this.getBlockIconFromSideAndMetadata(par1Block, 5, par6));
         var11.draw();
     }
@@ -4087,24 +4334,26 @@ public class RenderBlocks
     /**
      * Renders a standard cube block at the given coordinates
      */
-    public boolean renderStandardBlock(Block par1Block, int par2, int par3, int par4)
+    public boolean renderStandardBlock(Block block, int x, int y, int z)
     {
-        int var5 = par1Block.colorMultiplier(this.blockAccess, par2, par3, par4);
-        float var6 = (float)(var5 >> 16 & 255) / 255.0F;
-        float var7 = (float)(var5 >> 8 & 255) / 255.0F;
-        float var8 = (float)(var5 & 255) / 255.0F;
-
-        if (EntityRenderer.anaglyphEnable)
-        {
-            float var9 = (var6 * 30.0F + var7 * 59.0F + var8 * 11.0F) / 100.0F;
-            float var10 = (var6 * 30.0F + var7 * 70.0F) / 100.0F;
-            float var11 = (var6 * 30.0F + var8 * 70.0F) / 100.0F;
-            var6 = var9;
-            var7 = var10;
-            var8 = var11;
+        int color = block.colorMultiplier(this.blockAccess, x, y, z);
+        float red = (float)(color >> 16 & 255) / 255.0F;
+        float green = (float)(color >> 8 & 255) / 255.0F;
+        float blue = (float)(color & 255) / 255.0F;
+
+        RenderBlocksUtils.setupColorMultiplier(block, this.blockAccess, x, y, z, this.hasOverrideBlockTexture(), red, green, blue);
+        
+        if (Minecraft.isAmbientOcclusionEnabled()&& Block.lightValue[block.blockID] == 0) {
+        	if (this.partialRenderBounds) {
+        		return this.func_102027_b(block, x, y, z, red, green, blue);
+        	}
+        	else {
+        		return this.renderStandardBlockWithAmbientOcclusion(block, x, y, z, red, green, blue);
+        	}
+        }
+        else {
+        	return this.renderStandardBlockWithColorMultiplier(block, x, y, z, red, green, blue);
         }
-
-        return Minecraft.isAmbientOcclusionEnabled() && Block.lightValue[par1Block.blockID] == 0 ? (this.partialRenderBounds ? this.func_102027_b(par1Block, par2, par3, par4, var6, var7, var8) : this.renderStandardBlockWithAmbientOcclusion(par1Block, par2, par3, par4, var6, var7, var8)) : this.renderStandardBlockWithColorMultiplier(par1Block, par2, par3, par4, var6, var7, var8);
     }
 
     /**
@@ -4178,23 +4427,28 @@ public class RenderBlocks
         Tessellator var15 = Tessellator.instance;
         var15.setBrightness(983055);
 
+        // FCMOD: Changed
+        /*
         if (this.getBlockIcon(par1Block).getIconName().equals("grass_top"))
         {
             var13 = false;
         }
         else if (this.hasOverrideBlockTexture())
+        */
+        if (this.hasOverrideBlockTexture())
+        // END FCMOD
         {
             var13 = false;
         }
 
-        boolean var16;
         boolean var17;
-        boolean var18;
+        boolean var16;
         boolean var19;
-        int var20;
+        boolean var18;
         float var21;
+        int var20;
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 - 1, par4, 0))
         {
             if (this.renderMinY <= 0.0D)
             {
@@ -4280,36 +4534,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYPN, this.aoBrightnessXYZPNN, var20);
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYNN, this.aoBrightnessXYZNNN, this.aoBrightnessYZNN, var20);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.5F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.5F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.5F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 0, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.5F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.5F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.5F;
+            	if (RenderBlocksUtils.useColorMultiplier(0))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * RenderPass.getAOBaseMultiplier(0.5F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * RenderPass.getAOBaseMultiplier(0.5F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * RenderPass.getAOBaseMultiplier(0.5F);
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = RenderPass.getAOBaseMultiplier(0.5F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = RenderPass.getAOBaseMultiplier(0.5F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = RenderPass.getAOBaseMultiplier(0.5F);
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             this.renderFaceYNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0));
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 + 1, par4, 1))
         {
             if (this.renderMaxY >= 1.0D)
             {
@@ -4394,28 +4652,33 @@ public class RenderBlocks
             this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessYZPP, this.aoBrightnessXYZPPP, this.aoBrightnessXYPP, var20);
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessYZPN, this.aoBrightnessXYPP, this.aoBrightnessXYZPPN, var20);
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYNP, this.aoBrightnessXYZNPN, this.aoBrightnessYZPN, var20);
-            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5;
-            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6;
-            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7;
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
+            
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 1, var9, var10, var11, var12))
+            {
+                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5;
+                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6;
+                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7;
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
+            }
+            
             this.renderFaceYPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 1));
             var8 = true;
         }
 
         Icon var22;
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 - 1, 2))
         {
             if (this.renderMinZ <= 0.0D)
             {
@@ -4501,34 +4764,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYZPNN, this.aoBrightnessXZPN, var20);
             this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYZNNN, this.aoBrightnessXZNN, this.aoBrightnessYZNN, var20);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.8F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 2, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+            	if (RenderBlocksUtils.useColorMultiplier(2))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * RenderPass.getAOBaseMultiplier(0.8F);
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = RenderPass.getAOBaseMultiplier(0.8F);
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 2);
             this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, var22);
 
+            // FCMOD: Removed
+            /*
             if (fancyGrass && var22.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -4545,11 +4814,13 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 + 1, 3))
         {
             if (this.renderMaxZ >= 1.0D)
             {
@@ -4635,34 +4906,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNP, this.aoBrightnessXYZPNP, this.aoBrightnessXZPP, var20);
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYZNNP, this.aoBrightnessXZNP, this.aoBrightnessYZNP, var20);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.8F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 3, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+            	if (RenderBlocksUtils.useColorMultiplier(3))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * RenderPass.getAOBaseMultiplier(0.8F);
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = RenderPass.getAOBaseMultiplier(0.8F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = RenderPass.getAOBaseMultiplier(0.8F);
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3);
             this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3));
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var22.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -4679,11 +4956,13 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+			*/
+			// END FCMOD
 
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 - 1, par3, par4, 4))
         {
             if (this.renderMinX <= 0.0D)
             {
@@ -4769,34 +5048,40 @@ public class RenderBlocks
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXZNN, this.aoBrightnessXYZNPN, this.aoBrightnessXYNP, var20);
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYZNNN, this.aoBrightnessXYNN, this.aoBrightnessXZNN, var20);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.6F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 4, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+            	if (RenderBlocksUtils.useColorMultiplier(4))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * RenderPass.getAOBaseMultiplier(0.6F);
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = RenderPass.getAOBaseMultiplier(0.6F);
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 4);
             this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, var22);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var22.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -4813,11 +5098,13 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 + 1, par3, par4, 5))
         {
             if (this.renderMaxX >= 1.0D)
             {
@@ -4903,34 +5190,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXZPN, this.aoBrightnessXYZPPN, this.aoBrightnessXYPP, var20);
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYZPNN, this.aoBrightnessXYPN, this.aoBrightnessXZPN, var20);
 
-            if (var13)
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 5, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.6F;
-            }
-            else
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+            	if (RenderBlocksUtils.useColorMultiplier(5))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * RenderPass.getAOBaseMultiplier(0.6F);
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = RenderPass.getAOBaseMultiplier(0.6F);
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = RenderPass.getAOBaseMultiplier(0.6F);
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 5);
             this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, var22);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var22.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -4947,6 +5240,8 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
@@ -4968,23 +5263,28 @@ public class RenderBlocks
         Tessellator var15 = Tessellator.instance;
         var15.setBrightness(983055);
 
+        // FCMOD: Code change
+        /*
         if (this.getBlockIcon(par1Block).getIconName().equals("grass_top"))
         {
             var13 = false;
         }
         else if (this.hasOverrideBlockTexture())
+        */
+        if (this.hasOverrideBlockTexture())
+        // END FCMOD
         {
             var13 = false;
         }
 
-        boolean var16;
         boolean var17;
-        boolean var18;
+        boolean var16;
         boolean var19;
-        int var20;
+        boolean var18;
         float var21;
+        int var20;
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 - 1, par4, 0))
         {
             if (this.renderMinY <= 0.0D)
             {
@@ -5070,36 +5370,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYPN, this.aoBrightnessXYZPNN, var20);
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYNN, this.aoBrightnessXYZNNN, this.aoBrightnessYZNN, var20);
 
-            if (var13)
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 0, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.5F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.5F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.5F;
-            }
-            else
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.5F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.5F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.5F;
+            	if (RenderBlocksUtils.useColorMultiplier(0))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.5F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.5F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.5F;
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.5F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.5F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.5F;
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             this.renderFaceYNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0));
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 + 1, par4, 1))
         {
             if (this.renderMaxY >= 1.0D)
             {
@@ -5184,36 +5488,41 @@ public class RenderBlocks
             this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessYZPP, this.aoBrightnessXYZPPP, this.aoBrightnessXYPP, var20);
             this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessYZPN, this.aoBrightnessXYPP, this.aoBrightnessXYZPPN, var20);
             this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYNP, this.aoBrightnessXYZNPN, this.aoBrightnessYZPN, var20);
-            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5;
-            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6;
-            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7;
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
+            
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 1, var9, var10, var11, var12))
+            {
+                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5;
+                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6;
+                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7;
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
+            }
+            
             this.renderFaceYPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 1));
             var8 = true;
         }
 
-        float var22;
         float var23;
-        float var24;
+        float var22;
         float var25;
-        int var26;
+        float var24;
         int var27;
-        int var28;
+        int var26;
         int var29;
+        int var28;
         Icon var30;
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 - 1, 2))
         {
             if (this.renderMinZ <= 0.0D)
             {
@@ -5307,34 +5616,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.mixAoBrightness(var26, var27, var28, var29, this.renderMinY * (1.0D - this.renderMaxX), this.renderMinY * this.renderMaxX, (1.0D - this.renderMinY) * this.renderMaxX, (1.0D - this.renderMinY) * (1.0D - this.renderMaxX));
             this.brightnessTopRight = this.mixAoBrightness(var26, var27, var28, var29, this.renderMinY * (1.0D - this.renderMinX), this.renderMinY * this.renderMinX, (1.0D - this.renderMinY) * this.renderMinX, (1.0D - this.renderMinY) * (1.0D - this.renderMinX));
 
-            if (var13)
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 2, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.8F;
-            }
-            else
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
-            }
+            	if (RenderBlocksUtils.useColorMultiplier(2))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.8F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.8F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.8F;
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+                }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
+            }
+            
             var30 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 2);
             this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, var30);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var30.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -5351,11 +5666,13 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 + 1, 3))
         {
             if (this.renderMaxZ >= 1.0D)
             {
@@ -5449,34 +5766,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.mixAoBrightness(var26, var29, var28, var27, this.renderMinY * (1.0D - this.renderMaxX), (1.0D - this.renderMinY) * (1.0D - this.renderMaxX), (1.0D - this.renderMinY) * this.renderMaxX, this.renderMinY * this.renderMaxX);
             this.brightnessTopRight = this.mixAoBrightness(var26, var29, var28, var27, this.renderMaxY * (1.0D - this.renderMaxX), (1.0D - this.renderMaxY) * (1.0D - this.renderMaxX), (1.0D - this.renderMaxY) * this.renderMaxX, this.renderMaxY * this.renderMaxX);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.8F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 3, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+            	if (RenderBlocksUtils.useColorMultiplier(3))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.8F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.8F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.8F;
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+                }
+
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
             }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
             var30 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3);
             this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3));
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var30.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -5493,11 +5816,13 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 - 1, par3, par4, 4))
         {
             if (this.renderMinX <= 0.0D)
             {
@@ -5591,34 +5916,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.mixAoBrightness(var27, var28, var29, var26, this.renderMinY * this.renderMinZ, this.renderMinY * (1.0D - this.renderMinZ), (1.0D - this.renderMinY) * (1.0D - this.renderMinZ), (1.0D - this.renderMinY) * this.renderMinZ);
             this.brightnessTopRight = this.mixAoBrightness(var27, var28, var29, var26, this.renderMinY * this.renderMaxZ, this.renderMinY * (1.0D - this.renderMaxZ), (1.0D - this.renderMinY) * (1.0D - this.renderMaxZ), (1.0D - this.renderMinY) * this.renderMaxZ);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.6F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 4, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
-            }
+            	if (RenderBlocksUtils.useColorMultiplier(4))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.6F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.6F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.6F;
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+                }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
+            }
+            
             var30 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 4);
             this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, var30);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var30.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -5635,11 +5966,13 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 + 1, par3, par4, 5))
         {
             if (this.renderMaxX >= 1.0D)
             {
@@ -5733,34 +6066,40 @@ public class RenderBlocks
             this.brightnessBottomRight = this.mixAoBrightness(var26, var29, var28, var27, (1.0D - this.renderMaxY) * this.renderMinZ, (1.0D - this.renderMaxY) * (1.0D - this.renderMinZ), this.renderMaxY * (1.0D - this.renderMinZ), this.renderMaxY * this.renderMinZ);
             this.brightnessTopRight = this.mixAoBrightness(var26, var29, var28, var27, (1.0D - this.renderMaxY) * this.renderMaxZ, (1.0D - this.renderMaxY) * (1.0D - this.renderMaxZ), this.renderMaxY * (1.0D - this.renderMaxZ), this.renderMaxY * this.renderMaxZ);
 
-            if (var13)
-            {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.6F;
-            }
-            else
+            if (!ColorizeBlock.setupBlockSmoothing(this, par1Block, this.blockAccess, par2, par3, par4, 5, var9, var10, var11, var12))
             {
-                this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
-                this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
-                this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
-            }
+            	if (RenderBlocksUtils.useColorMultiplier(5))
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5 * 0.6F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6 * 0.6F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7 * 0.6F;
+                }
+                else
+                {
+                    this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
+                    this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
+                    this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+                }
 
-            this.colorRedTopLeft *= var9;
-            this.colorGreenTopLeft *= var9;
-            this.colorBlueTopLeft *= var9;
-            this.colorRedBottomLeft *= var10;
-            this.colorGreenBottomLeft *= var10;
-            this.colorBlueBottomLeft *= var10;
-            this.colorRedBottomRight *= var11;
-            this.colorGreenBottomRight *= var11;
-            this.colorBlueBottomRight *= var11;
-            this.colorRedTopRight *= var12;
-            this.colorGreenTopRight *= var12;
-            this.colorBlueTopRight *= var12;
+                this.colorRedTopLeft *= var9;
+                this.colorGreenTopLeft *= var9;
+                this.colorBlueTopLeft *= var9;
+                this.colorRedBottomLeft *= var10;
+                this.colorGreenBottomLeft *= var10;
+                this.colorBlueBottomLeft *= var10;
+                this.colorRedBottomRight *= var11;
+                this.colorGreenBottomRight *= var11;
+                this.colorBlueBottomRight *= var11;
+                this.colorRedTopRight *= var12;
+                this.colorGreenTopRight *= var12;
+                this.colorBlueTopRight *= var12;
+            }
+            
             var30 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 5);
             this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, var30);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var30.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 this.colorRedTopLeft *= par5;
@@ -5777,6 +6116,8 @@ public class RenderBlocks
                 this.colorBlueTopRight *= par7;
                 this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var8 = true;
         }
@@ -5827,112 +6168,129 @@ public class RenderBlocks
         float var11 = 1.0F;
         float var12 = 0.8F;
         float var13 = 0.6F;
-        float var14 = var11 * par5;
-        float var15 = var11 * par6;
-        float var16 = var11 * par7;
-        float var17 = var10;
+        float var10000 = var11 * par5;
+        var10000 = var11 * par6;
+        var10000 = var11 * par7;
         float var18 = var12;
         float var19 = var13;
-        float var20 = var10;
         float var21 = var12;
         float var22 = var13;
-        float var23 = var10;
         float var24 = var12;
         float var25 = var13;
 
+        // FCMOD: Code removed
+        /*
         if (par1Block != Block.grass)
+        */
+        // END FCMOD
         {
-            var17 = var10 * par5;
+        	var10000 = var10 * par5;
             var18 = var12 * par5;
             var19 = var13 * par5;
-            var20 = var10 * par6;
+            float var20 = var10 * par6;
             var21 = var12 * par6;
             var22 = var13 * par6;
-            var23 = var10 * par7;
+            float var23 = var10 * par7;
             var24 = var12 * par7;
             var25 = var13 * par7;
         }
 
         int var26 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4);
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 - 1, par4, 0))
         {
             var8.setBrightness(this.renderMinY > 0.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4));
-            var8.setColorOpaque_F(var17, var20, var23);
+            var8.setColorOpaque_F(RenderBlocksUtils.getColorMultiplierRed(0), RenderBlocksUtils.getColorMultiplierGreen(0), RenderBlocksUtils.getColorMultiplierBlue(0));
             this.renderFaceYNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0));
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 + 1, par4, 1))
         {
             var8.setBrightness(this.renderMaxY < 1.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4));
-            var8.setColorOpaque_F(var14, var15, var16);
+            var8.setColorOpaque_F(RenderBlocksUtils.getColorMultiplierRed(1), RenderBlocksUtils.getColorMultiplierGreen(1), RenderBlocksUtils.getColorMultiplierBlue(1));
             this.renderFaceYPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 1));
             var9 = true;
         }
 
         Icon var28;
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 - 1, 2))
         {
             var8.setBrightness(this.renderMinZ > 0.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1));
-            var8.setColorOpaque_F(var18, var21, var24);
+            var8.setColorOpaque_F(RenderBlocksUtils.getColorMultiplierRed(2), RenderBlocksUtils.getColorMultiplierGreen(2), RenderBlocksUtils.getColorMultiplierBlue(2));
             var28 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 2);
             this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, var28);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var28.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 var8.setColorOpaque_F(var18 * par5, var21 * par6, var24 * par7);
                 this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 + 1, 3))
         {
             var8.setBrightness(this.renderMaxZ < 1.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1));
-            var8.setColorOpaque_F(var18, var21, var24);
+            var8.setColorOpaque_F(RenderBlocksUtils.getColorMultiplierRed(3), RenderBlocksUtils.getColorMultiplierGreen(3), RenderBlocksUtils.getColorMultiplierBlue(3));
             var28 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3);
             this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, var28);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var28.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 var8.setColorOpaque_F(var18 * par5, var21 * par6, var24 * par7);
                 this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 - 1, par3, par4, 4))
         {
             var8.setBrightness(this.renderMinX > 0.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4));
-            var8.setColorOpaque_F(var19, var22, var25);
+            var8.setColorOpaque_F(RenderBlocksUtils.getColorMultiplierRed(4), RenderBlocksUtils.getColorMultiplierGreen(4), RenderBlocksUtils.getColorMultiplierBlue(4));
             var28 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 4);
             this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, var28);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var28.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 var8.setColorOpaque_F(var19 * par5, var22 * par6, var25 * par7);
                 this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 + 1, par3, par4, 5))
         {
             var8.setBrightness(this.renderMaxX < 1.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4));
-            var8.setColorOpaque_F(var19, var22, var25);
+            var8.setColorOpaque_F(RenderBlocksUtils.getColorMultiplierRed(5), RenderBlocksUtils.getColorMultiplierGreen(5), RenderBlocksUtils.getColorMultiplierBlue(5));
             var28 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 5);
             this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, var28);
 
+            // FCMOD: Code removed
+            /*
             if (fancyGrass && var28.getIconName().equals("grass_side") && !this.hasOverrideBlockTexture())
             {
                 var8.setColorOpaque_F(var19 * par5, var22 * par6, var25 * par7);
                 this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, BlockGrass.getIconSideOverlay());
             }
+            */
+            // END FCMOD
 
             var9 = true;
         }
@@ -6129,6 +6487,8 @@ public class RenderBlocks
         float var7 = (float)(var5 >> 8 & 255) / 255.0F;
         float var8 = (float)(var5 & 255) / 255.0F;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var9 = (var6 * 30.0F + var7 * 59.0F + var8 * 11.0F) / 100.0F;
@@ -6138,6 +6498,8 @@ public class RenderBlocks
             var7 = var10;
             var8 = var11;
         }
+        */
+        // END FCMOD
 
         return this.renderBlockCactusImpl(par1Block, par2, par3, par4, var6, var7, var8);
     }
@@ -6168,7 +6530,7 @@ public class RenderBlocks
         float var26 = 0.0625F;
         int var28 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4);
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 - 1, par4, 0))
         {
             var8.setBrightness(this.renderMinY > 0.0D ? var28 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4));
             var8.setColorOpaque_F(var14, var18, var22);
@@ -6176,7 +6538,7 @@ public class RenderBlocks
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3 + 1, par4, 1))
         {
             var8.setBrightness(this.renderMaxY < 1.0D ? var28 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4));
             var8.setColorOpaque_F(var15, var19, var23);
@@ -6184,7 +6546,7 @@ public class RenderBlocks
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 - 1, 2))
         {
             var8.setBrightness(this.renderMinZ > 0.0D ? var28 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1));
             var8.setColorOpaque_F(var16, var20, var24);
@@ -6194,7 +6556,7 @@ public class RenderBlocks
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2, par3, par4 + 1, 3))
         {
             var8.setBrightness(this.renderMaxZ < 1.0D ? var28 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1));
             var8.setColorOpaque_F(var16, var20, var24);
@@ -6204,7 +6566,7 @@ public class RenderBlocks
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 - 1, par3, par4, 4))
         {
             var8.setBrightness(this.renderMinX > 0.0D ? var28 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4));
             var8.setColorOpaque_F(var17, var21, var25);
@@ -6214,7 +6576,7 @@ public class RenderBlocks
             var9 = true;
         }
 
-        if (this.renderAllFaces || par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5))
+        if (this.renderAllFaces || RenderPass.shouldSideBeRendered(par1Block, this.blockAccess, par2 + 1, par3, par4, 5))
         {
             var8.setBrightness(this.renderMaxX < 1.0D ? var28 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4));
             var8.setColorOpaque_F(var17, var21, var25);
@@ -6314,6 +6676,10 @@ public class RenderBlocks
         boolean var9 = var7 && var8 && !var5 && !var6;
         boolean var10 = !var7 && !var8 && var5 && var6;
         boolean var11 = this.blockAccess.isAirBlock(par2, par3 + 1, par4);
+        
+        // FCMOD: Added
+    	var11 = var11 || FCUtilsWorld.IsGroundCoverOnBlock( blockAccess, par2, par3, par4 );
+        // END FCMOD
 
         if ((var9 || var10) && var11)
         {
@@ -6457,8 +6823,8 @@ public class RenderBlocks
 
         this.renderAllFaces = true;
         float var15;
-        float var16;
         float var17;
+        float var16;
         float var18;
 
         if (var8 != 3 && var8 != 1)
@@ -6626,6 +6992,8 @@ public class RenderBlocks
         float var9 = (float)(var7 >> 8 & 255) / 255.0F;
         float var10 = (float)(var7 & 255) / 255.0F;
 
+        // FCMOD: Code removed
+        /*
         if (EntityRenderer.anaglyphEnable)
         {
             float var11 = (var8 * 30.0F + var9 * 59.0F + var10 * 11.0F) / 100.0F;
@@ -6635,6 +7003,8 @@ public class RenderBlocks
             var9 = var12;
             var10 = var13;
         }
+        */
+        // END FCMOD
 
         var5.setColorOpaque_F(var6 * var8, var6 * var9, var6 * var10);
         return this.renderBlockHopperMetadata(par1BlockHopper, par2, par3, par4, this.blockAccess.getBlockMetadata(par2, par3, par4), false);
@@ -6651,27 +7021,27 @@ public class RenderBlocks
         {
             var7.startDrawingQuads();
             var7.setNormal(0.0F, -1.0F, 0.0F);
-            this.renderFaceYNeg(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockHopper, 0, par5));
+            this.renderFaceYNeg(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockHopper, 0, par5) : this.getBlockIcon(par1BlockHopper, this.blockAccess, par2, par3, par4, 0));
             var7.draw();
             var7.startDrawingQuads();
             var7.setNormal(0.0F, 1.0F, 0.0F);
-            this.renderFaceYPos(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockHopper, 1, par5));
+            this.renderFaceYPos(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockHopper, 1, par5) : this.getBlockIcon(par1BlockHopper, this.blockAccess, par2, par3, par4, 1));
             var7.draw();
             var7.startDrawingQuads();
             var7.setNormal(0.0F, 0.0F, -1.0F);
-            this.renderFaceZNeg(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockHopper, 2, par5));
+            this.renderFaceZNeg(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockHopper, 2, par5) : this.getBlockIcon(par1BlockHopper, this.blockAccess, par2, par3, par4, 2));
             var7.draw();
             var7.startDrawingQuads();
             var7.setNormal(0.0F, 0.0F, 1.0F);
-            this.renderFaceZPos(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockHopper, 3, par5));
+            this.renderFaceZPos(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockHopper, 3, par5) : this.getBlockIcon(par1BlockHopper, this.blockAccess, par2, par3, par4, 3));
             var7.draw();
             var7.startDrawingQuads();
             var7.setNormal(-1.0F, 0.0F, 0.0F);
-            this.renderFaceXNeg(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockHopper, 4, par5));
+            this.renderFaceXNeg(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockHopper, 4, par5) : this.getBlockIcon(par1BlockHopper, this.blockAccess, par2, par3, par4, 4));
             var7.draw();
             var7.startDrawingQuads();
             var7.setNormal(1.0F, 0.0F, 0.0F);
-            this.renderFaceXPos(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1BlockHopper, 5, par5));
+            this.renderFaceXPos(par1BlockHopper, 0.0D, 0.0D, 0.0D, this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(par1BlockHopper, 5, par5) : this.getBlockIcon(par1BlockHopper, this.blockAccess, par2, par3, par4, 5));
             var7.draw();
         }
         else
@@ -6690,6 +7060,8 @@ public class RenderBlocks
             float var14 = (float)(var12 >> 8 & 255) / 255.0F;
             float var15 = (float)(var12 & 255) / 255.0F;
 
+            // FCMOD: Code removed
+            /*
             if (EntityRenderer.anaglyphEnable)
             {
                 float var16 = (var13 * 30.0F + var14 * 59.0F + var15 * 11.0F) / 100.0F;
@@ -6699,6 +7071,8 @@ public class RenderBlocks
                 var14 = var17;
                 var15 = var18;
             }
+            */
+            // END FCMOD
 
             var7.setColorOpaque_F(var11 * var13, var11 * var14, var11 * var15);
         }
@@ -7546,7 +7920,11 @@ public class RenderBlocks
     /**
      * Is called to render the image of a block on an inventory, as a held item, or as a an item on the ground
      */
+    // FCMOD: Changed (client only)
+    /*
     public void renderBlockAsItem(Block par1Block, int par2, float par3)
+    */
+    public void renderBlockAsItemVanilla(Block par1Block, int par2, float par3)    
     {
         Tessellator var4 = Tessellator.instance;
         boolean var5 = par1Block.blockID == Block.grass.blockID;
@@ -7593,7 +7971,9 @@ public class RenderBlocks
             {
                 var4.startDrawingQuads();
                 var4.setNormal(0.0F, -1.0F, 0.0F);
-                par1Block.setBlockBoundsForItemRender();
+                // FCMOD: Removed
+                //par1Block.setBlockBoundsForItemRender();
+                // END FCMOD
                 this.renderBlockStemSmall(par1Block, par2, this.renderMaxY, -0.5D, -0.5D, -0.5D);
                 var4.draw();
             }
@@ -7601,12 +7981,16 @@ public class RenderBlocks
             {
                 var4.startDrawingQuads();
                 var4.setNormal(0.0F, -1.0F, 0.0F);
-                par1Block.setBlockBoundsForItemRender();
+                // FCMOD: Removed
+                //par1Block.setBlockBoundsForItemRender();
+                // END FCMOD
                 var4.draw();
             }
             else if (var6 == 13)
             {
-                par1Block.setBlockBoundsForItemRender();
+                // FCMOD: Removed
+                //par1Block.setBlockBoundsForItemRender();
+                // END FCMOD
                 GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
                 var7 = 0.0625F;
                 var4.startDrawingQuads();
@@ -7681,27 +8065,57 @@ public class RenderBlocks
                     GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
                     var4.startDrawingQuads();
                     var4.setNormal(0.0F, -1.0F, 0.0F);
+                    // FCMOD: Change to pass along item damage as metadata
+                    /*
                     this.renderFaceYNeg(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSide(par1Block, 0));
+                    */
+                    this.renderFaceYNeg(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1Block, 0, par2));
+                    // END FCMOD
                     var4.draw();
                     var4.startDrawingQuads();
                     var4.setNormal(0.0F, 1.0F, 0.0F);
+                    // FCMOD: Change to pass along item damage as metadata
+                    /*
                     this.renderFaceYPos(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSide(par1Block, 1));
+                    */
+                    this.renderFaceYPos(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata( par1Block, 1, par2));
+                    // END FCMOD
                     var4.draw();
                     var4.startDrawingQuads();
                     var4.setNormal(0.0F, 0.0F, -1.0F);
+                    // FCMOD: Change to pass along item damage as metadata
+                    /*
                     this.renderFaceZNeg(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSide(par1Block, 2));
+                    */
+                    this.renderFaceZNeg(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1Block, 2, par2));
+                    // END FCMOD
                     var4.draw();
                     var4.startDrawingQuads();
                     var4.setNormal(0.0F, 0.0F, 1.0F);
+                    // FCMOD: Change to pass along item damage as metadata
+                    /*
                     this.renderFaceZPos(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSide(par1Block, 3));
+                    */
+                    this.renderFaceZPos(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1Block, 3, par2));
+                    // END FCMOD
                     var4.draw();
                     var4.startDrawingQuads();
                     var4.setNormal(-1.0F, 0.0F, 0.0F);
+                    // FCMOD: Change to pass along item damage as metadata
+                    /*
                     this.renderFaceXNeg(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSide(par1Block, 4));
+                    */
+                    this.renderFaceXNeg(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1Block, 4, par2));
+                    // END FCMOD
                     var4.draw();
                     var4.startDrawingQuads();
                     var4.setNormal(1.0F, 0.0F, 0.0F);
+                    // FCMOD: Change to pass along item damage as metadata
+                    /*
                     this.renderFaceXPos(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSide(par1Block, 5));
+                    */
+                    this.renderFaceXPos(par1Block, 0.0D, 0.0D, 0.0D, this.getBlockIconFromSideAndMetadata(par1Block, 5, par2));
+                    // END FCMOD
                     var4.draw();
                     GL11.glTranslatef(0.5F, 0.5F, 0.5F);
                 }
@@ -8008,8 +8422,11 @@ public class RenderBlocks
                 par2 = 1;
             }
 
-            par1Block.setBlockBoundsForItemRender();
-            this.setRenderBoundsFromBlock(par1Block);
+            // FCMOD: Changed
+            //par1Block.setBlockBoundsForItemRender();
+            //this.setRenderBoundsFromBlock(par1Block);
+            setRenderBounds( par1Block.GetBlockBoundsFromPoolForItemRender( par2 ) );
+            // END FCMOD
             GL11.glRotatef(90.0F, 0.0F, 1.0F, 0.0F);
             GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
             var4.startDrawingQuads();
@@ -8059,24 +8476,29 @@ public class RenderBlocks
     /**
      * Checks to see if the item's render type indicates that it should be rendered as a regular block or not.
      */
+    // FCMOD: Code change
+    /*
     public static boolean renderItemIn3d(int par0)
+    */
+    public static boolean DoesRenderIDRenderItemIn3d(int par0)
+    // END FCMOD
     {
         return par0 == 0 ? true : (par0 == 31 ? true : (par0 == 39 ? true : (par0 == 13 ? true : (par0 == 10 ? true : (par0 == 11 ? true : (par0 == 27 ? true : (par0 == 22 ? true : (par0 == 21 ? true : (par0 == 16 ? true : (par0 == 26 ? true : (par0 == 32 ? true : (par0 == 34 ? true : par0 == 35))))))))))));
     }
 
     public Icon getBlockIcon(Block par1Block, IBlockAccess par2IBlockAccess, int par3, int par4, int par5, int par6)
     {
-        return this.getIconSafe(par1Block.getBlockTexture(par2IBlockAccess, par3, par4, par5, par6));
+    	return CTMUtils.getBlockIcon(this.getIconSafe(par1Block.getBlockTexture(par2IBlockAccess, par3, par4, par5, par6)), this, par1Block, par2IBlockAccess, par3, par4, par5, par6);
     }
 
     public Icon getBlockIconFromSideAndMetadata(Block par1Block, int par2, int par3)
     {
-        return this.getIconSafe(par1Block.getIcon(par2, par3));
+    	return CTMUtils.getBlockIcon(this.getIconSafe(par1Block.getIcon(par2, par3)), this, par1Block, par2, par3);
     }
 
     public Icon getBlockIconFromSide(Block par1Block, int par2)
     {
-        return this.getIconSafe(par1Block.getBlockTextureFromSide(par2));
+    	return CTMUtils.getBlockIcon(this.getIconSafe(par1Block.getBlockTextureFromSide(par2)), this, par1Block, par2);
     }
 
     public Icon getBlockIcon(Block par1Block)
@@ -8088,4 +8510,2394 @@ public class RenderBlocks
     {
         return par1Icon == null ? this.minecraftRB.renderEngine.getMissingIcon(0) : par1Icon;
     }
+    
+    // FCMOD: Added New
+    public boolean renderBlockFluids( Block block, int i, int j, int k )
+    {
+        BlockFluid.bIsAnySideBeingRendered = false;
+        
+        boolean bRenderTop = RenderPass.shouldSideBeRendered(block, this.blockAccess, i, j + 1, k, 1);
+        boolean bRenderBottom = RenderPass.shouldSideBeRendered(block, this.blockAccess, i, j - 1, k, 0);
+        boolean[] bRenderSides = new boolean[] {RenderPass.shouldSideBeRendered(block, this.blockAccess, i, j, k - 1, 2), RenderPass.shouldSideBeRendered(block, this.blockAccess, i, j, k + 1, 3), RenderPass.shouldSideBeRendered(block, this.blockAccess, i - 1, j, k, 4), RenderPass.shouldSideBeRendered(block, this.blockAccess, i + 1, j, k, 5)};
+
+        if ( !BlockFluid.bIsAnySideBeingRendered )
+        {
+            return false;
+        }
+        
+        Tessellator tesselator = Tessellator.instance;
+        
+        int iColor = block.colorMultiplier( blockAccess, i, j, k );
+        
+        float fRed = (float)(iColor >> 16 & 255) / 255.0F;
+        float fGreen = (float)(iColor >> 8 & 255) / 255.0F;
+        float fBlue = (float)(iColor & 255) / 255.0F;
+
+        float var14 = 0.5F;
+        float var15 = 1.0F;
+        float var16 = 0.8F;
+        float var17 = 0.6F;
+        
+        double var18 = 0.0D;
+        double var20 = 1.0D;
+        
+        Material material = block.blockMaterial;
+        int iMetadata = this.blockAccess.getBlockMetadata(i, j, k);
+        
+        double var24 = (double)this.getFluidHeight(i, j, k, material);
+        double var26 = (double)this.getFluidHeight(i, j, k + 1, material);
+        double var28 = (double)this.getFluidHeight(i + 1, j, k + 1, material);
+        double var30 = (double)this.getFluidHeight(i + 1, j, k, material);
+        
+        double var32 = 0.0010000000474974513D;
+        float var34;
+        float var35;
+        double var42;
+        double var40;
+        double var46;
+        double var44;
+        double var50;
+        double var48;
+
+        if ( bRenderTop )
+        {
+            Icon var36 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(block, 1, iMetadata) : this.getBlockIcon(block, this.blockAccess, i, j, k, 1);
+            float var37 = (float)BlockFluid.getFlowDirection(this.blockAccess, i, j, k, material);
+
+            if (var37 > -999.0F)
+            {
+                var36 = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(block, 2, iMetadata) : this.getBlockIcon(block, this.blockAccess, i, j, k, 2);
+            }
+
+            var24 -= var32;
+            var26 -= var32;
+            var28 -= var32;
+            var30 -= var32;
+            double var38;
+            double var52;
+
+            if (var37 < -999.0F)
+            {
+                var40 = (double)var36.getInterpolatedU(0.0D);
+                var48 = (double)var36.getInterpolatedV(0.0D);
+                var38 = var40;
+                var46 = (double)var36.getInterpolatedV(16.0D);
+                var44 = (double)var36.getInterpolatedU(16.0D);
+                var52 = var46;
+                var42 = var44;
+                var50 = var48;
+            }
+            else
+            {
+                var35 = MathHelper.sin(var37) * 0.25F;
+                var34 = MathHelper.cos(var37) * 0.25F;
+                var40 = (double)var36.getInterpolatedU((double)(8.0F + (-var34 - var35) * 16.0F));
+                var48 = (double)var36.getInterpolatedV((double)(8.0F + (-var34 + var35) * 16.0F));
+                var38 = (double)var36.getInterpolatedU((double)(8.0F + (-var34 + var35) * 16.0F));
+                var46 = (double)var36.getInterpolatedV((double)(8.0F + (var34 + var35) * 16.0F));
+                var44 = (double)var36.getInterpolatedU((double)(8.0F + (var34 + var35) * 16.0F));
+                var52 = (double)var36.getInterpolatedV((double)(8.0F + (var34 - var35) * 16.0F));
+                var42 = (double)var36.getInterpolatedU((double)(8.0F + (var34 - var35) * 16.0F));
+                var50 = (double)var36.getInterpolatedV((double)(8.0F + (-var34 - var35) * 16.0F));
+            }
+
+            tesselator.setBrightness(block.getMixedBrightnessForBlock(this.blockAccess, i, j, k));
+            var35 = 1.0F;
+            
+            ColorizeBlock.isSmooth = ColorizeBlock.setupBlockSmoothing(this, block, this.blockAccess, i, j, k, 1 + 6);
+
+            if (!ColorizeBlock.isSmooth)
+            {
+                tesselator.setColorOpaque_F(var15 * var35 * fRed, var15 * var35 * fGreen, var15 * var35 * fBlue);
+            }
+
+            if (ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            	tesselator.addVertexWithUV((double)(i + 0), (double)j + var24, (double)(k + 0), var40, var48);
+            	tesselator.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            	tesselator.addVertexWithUV((double)(i + 0), (double)j + var26, (double)(k + 1), var38, var46);
+            	tesselator.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            	tesselator.addVertexWithUV((double)(i + 1), (double)j + var28, (double)(k + 1), var44, var52);
+            	tesselator.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            	tesselator.addVertexWithUV((double)(i + 1), (double)j + var30, (double)(k + 0), var42, var50);
+            }
+            else
+            {
+            	tesselator.addVertexWithUV((double)(i + 0), (double)j + var24, (double)(k + 0), var40, var48);
+            	tesselator.addVertexWithUV((double)(i + 0), (double)j + var26, (double)(k + 1), var38, var46);
+            	tesselator.addVertexWithUV((double)(i + 1), (double)j + var28, (double)(k + 1), var44, var52);
+            	tesselator.addVertexWithUV((double)(i + 1), (double)j + var30, (double)(k + 0), var42, var50);
+            }
+        }
+
+        if ( bRenderBottom )
+        {
+            tesselator.setBrightness(block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k));
+            float var58 = 1.0F;
+            ColorizeBlock.isSmooth = ColorizeBlock.setupBlockSmoothing(this, block, this.blockAccess, i, j, k, 0 + 6);
+
+            if (!ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(var14 * var58, var14 * var58, var14 * var58);
+            }
+
+            if (ColorizeBlock.isSmooth)
+            {
+                this.enableAO = true;
+            }
+
+            double var10002 = (double)i;
+            double var10003 = (double)j + var32;
+            double var10004 = (double)k;
+            Icon var10005 = this.blockAccess == null ? this.getBlockIconFromSide(block, 0) : this.getBlockIcon(block, this.blockAccess, i, j, k, 0);
+            this.enableAO = false;
+            this.renderFaceYNeg(block, var10002, var10003, var10004, var10005);
+        }
+
+        if ( bRenderSides[0] )
+        {
+            Icon texture = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(block, 2, iMetadata) : this.getBlockIcon(block, this.blockAccess, i, j, k, 2);
+
+            var40 = var24;
+            var44 = var30;
+            var42 = (double)i;
+            var46 = (double)(i + 1);
+            var48 = (double)k + var32;
+            var50 = (double)k + var32;
+            
+            float var60 = texture.getInterpolatedU(0.0D);
+            var35 = texture.getInterpolatedU(8.0D);
+            var34 = texture.getInterpolatedV((1.0D - var40) * 16.0D * 0.5D);
+            float var53 = texture.getInterpolatedV((1.0D - var44) * 16.0D * 0.5D);
+            float var54 = texture.getInterpolatedV(8.0D);
+            tesselator.setBrightness(block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1));
+            float var55 = var16;
+            
+            ColorizeBlock.isSmooth = ColorizeBlock.setupBlockSmoothing(this, block, this.blockAccess, i, j, k, 0 + 2 + 6);
+
+            if (!ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(var15 * var55 * fRed, var15 * var55 * fGreen, var15 * var55 * fBlue);
+            }
+
+            if (ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+            	tesselator.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            	tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+            	tesselator.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            	tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+            	tesselator.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            	tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+            else
+            {
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+                tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+                tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+                tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+        }
+        
+        if ( bRenderSides[1] )
+        {
+            Icon texture = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(block, 3, iMetadata) : this.getBlockIcon(block, this.blockAccess, i, j, k, 3);
+
+            var40 = var28;
+            var44 = var26;
+            var42 = (double)(i + 1);
+            var46 = (double)i;
+            var48 = (double)(k + 1) - var32;
+            var50 = (double)(k + 1) - var32;
+
+            float var60 = texture.getInterpolatedU(0.0D);
+            var35 = texture.getInterpolatedU(8.0D);
+            var34 = texture.getInterpolatedV((1.0D - var40) * 16.0D * 0.5D);
+            float var53 = texture.getInterpolatedV((1.0D - var44) * 16.0D * 0.5D);
+            float var54 = texture.getInterpolatedV(8.0D);
+            tesselator.setBrightness(block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1));
+            float var55 = var16;
+
+            ColorizeBlock.isSmooth = ColorizeBlock.setupBlockSmoothing(this, block, this.blockAccess, i, j, k, 1 + 2 + 6);
+
+            if (!ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(var15 * var55 * fRed, var15 * var55 * fGreen, var15 * var55 * fBlue);
+            }
+
+            if (ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+            	tesselator.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            	tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+            	tesselator.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            	tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+            	tesselator.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            	tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+            else
+            {
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+                tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+                tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+                tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+        }
+        
+        if ( bRenderSides[2] )
+        {
+            Icon texture = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(block, 4, iMetadata) : this.getBlockIcon(block, this.blockAccess, i, j, k, 4);
+
+            var40 = var26;
+            var44 = var24;
+            var42 = (double)i + var32;
+            var46 = (double)i + var32;
+            var48 = (double)(k + 1);
+            var50 = (double)k;
+
+            float var60 = texture.getInterpolatedU(0.0D);
+            var35 = texture.getInterpolatedU(8.0D);
+            var34 = texture.getInterpolatedV((1.0D - var40) * 16.0D * 0.5D);
+            float var53 = texture.getInterpolatedV((1.0D - var44) * 16.0D * 0.5D);
+            float var54 = texture.getInterpolatedV(8.0D);
+            
+            tesselator.setBrightness(block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k ));
+            
+            float var55 = var17;
+
+            ColorizeBlock.isSmooth = ColorizeBlock.setupBlockSmoothing(this, block, this.blockAccess, i, j, k, 2 + 2 + 6);
+
+            if (!ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(var15 * var55 * fRed, var15 * var55 * fGreen, var15 * var55 * fBlue);
+            }
+
+            if (ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+            	tesselator.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            	tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+            	tesselator.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            	tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+            	tesselator.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            	tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+            else
+            {
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+                tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+                tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+                tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+        }
+        
+        if ( bRenderSides[3] )
+        {
+            Icon texture = this.blockAccess == null ? this.getBlockIconFromSideAndMetadata(block, 5, iMetadata) : this.getBlockIcon(block, this.blockAccess, i, j, k, 5);
+
+            var40 = var30;
+            var44 = var28;
+            var42 = (double)(i + 1) - var32;
+            var46 = (double)(i + 1) - var32;
+            var48 = (double)k;
+            var50 = (double)(k + 1);
+
+            float var60 = texture.getInterpolatedU(0.0D);
+            var35 = texture.getInterpolatedU(8.0D);
+            var34 = texture.getInterpolatedV((1.0D - var40) * 16.0D * 0.5D);
+            float var53 = texture.getInterpolatedV((1.0D - var44) * 16.0D * 0.5D);
+            float var54 = texture.getInterpolatedV(8.0D);
+            
+            tesselator.setBrightness(block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k));
+            
+            float var55 = var17;
+
+            ColorizeBlock.isSmooth = ColorizeBlock.setupBlockSmoothing(this, block, this.blockAccess, i, j, k, 3 + 2 + 6);
+
+            if (!ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(var15 * var55 * fRed, var15 * var55 * fGreen, var15 * var55 * fBlue);
+            }
+
+            if (ColorizeBlock.isSmooth)
+            {
+            	tesselator.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+            	tesselator.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            	tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+            	tesselator.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            	tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+            	tesselator.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            	tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+            else
+            {
+            	tesselator.addVertexWithUV(var42, (double)j + var40, var48, (double)var60, (double)var34);
+                tesselator.addVertexWithUV(var46, (double)j + var44, var50, (double)var35, (double)var53);
+                tesselator.addVertexWithUV(var46, (double)(j + 0), var50, (double)var35, (double)var54);
+                tesselator.addVertexWithUV(var42, (double)(j + 0), var48, (double)var60, (double)var54);
+            }
+        }
+        
+        this.renderMinY = var18;
+        this.renderMaxY = var20;
+        
+        return true;
+    }
+    
+    public boolean renderGrassBlockWithAmbientOcclusion( Block par1Block, int par2, int par3, int par4, float par5, float par6, float par7, Icon sideOverlayIcon )
+    {
+        this.enableAO = true;
+        boolean var8 = false;
+        float var9 = 0.0F;
+        float var10 = 0.0F;
+        float var11 = 0.0F;
+        float var12 = 0.0F;
+        boolean var13 = true;
+        int var14 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4);
+        Tessellator var15 = Tessellator.instance;
+        var15.setBrightness(983055);
+
+        boolean var17;
+        boolean var16;
+        boolean var19;
+        boolean var18;
+        int var21;
+        float var20;
+        
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0))
+        {
+            if (this.renderMinY <= 0.0D)
+            {
+                --par3;
+            }
+
+            this.aoBrightnessXYNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4);
+            this.aoBrightnessYZNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1);
+            this.aoBrightnessYZNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1);
+            this.aoBrightnessXYPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4);
+            this.aoLightValueScratchXYNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4);
+            this.aoLightValueScratchYZNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 - 1);
+            this.aoLightValueScratchYZNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 + 1);
+            this.aoLightValueScratchXYPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3 - 1, par4)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3 - 1, par4)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 - 1, par4 + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 - 1, par4 - 1)];
+
+            if (!var18 && !var16)
+            {
+                this.aoLightValueScratchXYZNNN = this.aoLightValueScratchXYNN;
+                this.aoBrightnessXYZNNN = this.aoBrightnessXYNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4 - 1);
+                this.aoBrightnessXYZNNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4 - 1);
+            }
+
+            if (!var19 && !var16)
+            {
+                this.aoLightValueScratchXYZNNP = this.aoLightValueScratchXYNN;
+                this.aoBrightnessXYZNNP = this.aoBrightnessXYNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4 + 1);
+                this.aoBrightnessXYZNNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4 + 1);
+            }
+
+            if (!var18 && !var17)
+            {
+                this.aoLightValueScratchXYZPNN = this.aoLightValueScratchXYPN;
+                this.aoBrightnessXYZPNN = this.aoBrightnessXYPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4 - 1);
+                this.aoBrightnessXYZPNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4 - 1);
+            }
+
+            if (!var19 && !var17)
+            {
+                this.aoLightValueScratchXYZPNP = this.aoLightValueScratchXYPN;
+                this.aoBrightnessXYZPNP = this.aoBrightnessXYPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4 + 1);
+                this.aoBrightnessXYZPNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4 + 1);
+            }
+
+            if (this.renderMinY <= 0.0D)
+            {
+                ++par3;
+            }
+
+            var21 = var14;
+
+            if (this.renderMinY <= 0.0D || !this.blockAccess.isBlockOpaqueCube(par2, par3 - 1, par4))
+            {
+                var21 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4);
+            }
+
+            var20 = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4);
+            var9 = (this.aoLightValueScratchXYZNNP + this.aoLightValueScratchXYNN + this.aoLightValueScratchYZNP + var20) / 4.0F;
+            var12 = (this.aoLightValueScratchYZNP + var20 + this.aoLightValueScratchXYZPNP + this.aoLightValueScratchXYPN) / 4.0F;
+            var11 = (var20 + this.aoLightValueScratchYZNN + this.aoLightValueScratchXYPN + this.aoLightValueScratchXYZPNN) / 4.0F;
+            var10 = (this.aoLightValueScratchXYNN + this.aoLightValueScratchXYZNNN + var20 + this.aoLightValueScratchYZNN) / 4.0F;
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXYZNNP, this.aoBrightnessXYNN, this.aoBrightnessYZNP, var21);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessYZNP, this.aoBrightnessXYZPNP, this.aoBrightnessXYPN, var21);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYPN, this.aoBrightnessXYZPNN, var21);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYNN, this.aoBrightnessXYZNNN, this.aoBrightnessYZNN, var21);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.5F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.5F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.5F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            this.renderFaceYNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0));
+            var8 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1))
+        {
+            if (this.renderMaxY >= 1.0D)
+            {
+                ++par3;
+            }
+
+            this.aoBrightnessXYNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4);
+            this.aoBrightnessXYPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4);
+            this.aoBrightnessYZPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1);
+            this.aoBrightnessYZPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1);
+            this.aoLightValueScratchXYNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4);
+            this.aoLightValueScratchXYPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4);
+            this.aoLightValueScratchYZPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 - 1);
+            this.aoLightValueScratchYZPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 + 1);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3 + 1, par4)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3 + 1, par4)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 + 1, par4 + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 + 1, par4 - 1)];
+
+            if (!var18 && !var16)
+            {
+                this.aoLightValueScratchXYZNPN = this.aoLightValueScratchXYNP;
+                this.aoBrightnessXYZNPN = this.aoBrightnessXYNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4 - 1);
+                this.aoBrightnessXYZNPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4 - 1);
+            }
+
+            if (!var18 && !var17)
+            {
+                this.aoLightValueScratchXYZPPN = this.aoLightValueScratchXYPP;
+                this.aoBrightnessXYZPPN = this.aoBrightnessXYPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4 - 1);
+                this.aoBrightnessXYZPPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4 - 1);
+            }
+
+            if (!var19 && !var16)
+            {
+                this.aoLightValueScratchXYZNPP = this.aoLightValueScratchXYNP;
+                this.aoBrightnessXYZNPP = this.aoBrightnessXYNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4 + 1);
+                this.aoBrightnessXYZNPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4 + 1);
+            }
+
+            if (!var19 && !var17)
+            {
+                this.aoLightValueScratchXYZPPP = this.aoLightValueScratchXYPP;
+                this.aoBrightnessXYZPPP = this.aoBrightnessXYPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4 + 1);
+                this.aoBrightnessXYZPPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4 + 1);
+            }
+
+            if (this.renderMaxY >= 1.0D)
+            {
+                --par3;
+            }
+
+            var21 = var14;
+
+            if (this.renderMaxY >= 1.0D || !this.blockAccess.isBlockOpaqueCube(par2, par3 + 1, par4))
+            {
+                var21 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4);
+            }
+
+            var20 = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4);
+            var12 = (this.aoLightValueScratchXYZNPP + this.aoLightValueScratchXYNP + this.aoLightValueScratchYZPP + var20) / 4.0F;
+            var9 = (this.aoLightValueScratchYZPP + var20 + this.aoLightValueScratchXYZPPP + this.aoLightValueScratchXYPP) / 4.0F;
+            var10 = (var20 + this.aoLightValueScratchYZPN + this.aoLightValueScratchXYPP + this.aoLightValueScratchXYZPPN) / 4.0F;
+            var11 = (this.aoLightValueScratchXYNP + this.aoLightValueScratchXYZNPN + var20 + this.aoLightValueScratchYZPN) / 4.0F;
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYZNPP, this.aoBrightnessXYNP, this.aoBrightnessYZPP, var21);
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessYZPP, this.aoBrightnessXYZPPP, this.aoBrightnessXYPP, var21);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessYZPN, this.aoBrightnessXYPP, this.aoBrightnessXYZPPN, var21);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYNP, this.aoBrightnessXYZNPN, this.aoBrightnessYZPN, var21);
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = par5;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = par6;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = par7;
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            this.renderFaceYPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 1));
+            var8 = true;
+        }
+
+        Icon var22;
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2))
+        {
+            if (this.renderMinZ <= 0.0D)
+            {
+                --par4;
+            }
+
+            this.aoLightValueScratchXZNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4);
+            this.aoLightValueScratchYZNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4);
+            this.aoLightValueScratchYZPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4);
+            this.aoLightValueScratchXZPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4);
+            this.aoBrightnessXZNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4);
+            this.aoBrightnessYZNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4);
+            this.aoBrightnessYZPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4);
+            this.aoBrightnessXZPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3, par4 - 1)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3, par4 - 1)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 + 1, par4 - 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 - 1, par4 - 1)];
+
+            if (!var16 && !var18)
+            {
+                this.aoLightValueScratchXYZNNN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNNN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3 - 1, par4);
+                this.aoBrightnessXYZNNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3 - 1, par4);
+            }
+
+            if (!var16 && !var19)
+            {
+                this.aoLightValueScratchXYZNPN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNPN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3 + 1, par4);
+                this.aoBrightnessXYZNPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3 + 1, par4);
+            }
+
+            if (!var17 && !var18)
+            {
+                this.aoLightValueScratchXYZPNN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPNN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3 - 1, par4);
+                this.aoBrightnessXYZPNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3 - 1, par4);
+            }
+
+            if (!var17 && !var19)
+            {
+                this.aoLightValueScratchXYZPPN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPPN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3 + 1, par4);
+                this.aoBrightnessXYZPPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3 + 1, par4);
+            }
+
+            if (this.renderMinZ <= 0.0D)
+            {
+                ++par4;
+            }
+
+            var21 = var14;
+
+            if (this.renderMinZ <= 0.0D || !this.blockAccess.isBlockOpaqueCube(par2, par3, par4 - 1))
+            {
+                var21 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1);
+            }
+
+            var20 = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 - 1);
+            var9 = (this.aoLightValueScratchXZNN + this.aoLightValueScratchXYZNPN + var20 + this.aoLightValueScratchYZPN) / 4.0F;
+            var10 = (var20 + this.aoLightValueScratchYZPN + this.aoLightValueScratchXZPN + this.aoLightValueScratchXYZPPN) / 4.0F;
+            var11 = (this.aoLightValueScratchYZNN + var20 + this.aoLightValueScratchXYZPNN + this.aoLightValueScratchXZPN) / 4.0F;
+            var12 = (this.aoLightValueScratchXYZNNN + this.aoLightValueScratchXZNN + this.aoLightValueScratchYZNN + var20) / 4.0F;
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXZNN, this.aoBrightnessXYZNPN, this.aoBrightnessYZPN, var21);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessYZPN, this.aoBrightnessXZPN, this.aoBrightnessXYZPPN, var21);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYZPNN, this.aoBrightnessXZPN, var21);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYZNNN, this.aoBrightnessXZNN, this.aoBrightnessYZNN, var21);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 2);
+            this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, var22);
+
+            this.colorRedTopLeft *= par5;
+            this.colorRedBottomLeft *= par5;
+            this.colorRedBottomRight *= par5;
+            this.colorRedTopRight *= par5;
+            this.colorGreenTopLeft *= par6;
+            this.colorGreenBottomLeft *= par6;
+            this.colorGreenBottomRight *= par6;
+            this.colorGreenTopRight *= par6;
+            this.colorBlueTopLeft *= par7;
+            this.colorBlueBottomLeft *= par7;
+            this.colorBlueBottomRight *= par7;
+            this.colorBlueTopRight *= par7;
+            this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon );
+
+            var8 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3))
+        {
+            if (this.renderMaxZ >= 1.0D)
+            {
+                ++par4;
+            }
+
+            this.aoLightValueScratchXZNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4);
+            this.aoLightValueScratchXZPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4);
+            this.aoLightValueScratchYZNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4);
+            this.aoLightValueScratchYZPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4);
+            this.aoBrightnessXZNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4);
+            this.aoBrightnessXZPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4);
+            this.aoBrightnessYZNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4);
+            this.aoBrightnessYZPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3, par4 + 1)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3, par4 + 1)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 + 1, par4 + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(par2, par3 - 1, par4 + 1)];
+
+            if (!var16 && !var18)
+            {
+                this.aoLightValueScratchXYZNNP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNNP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3 - 1, par4);
+                this.aoBrightnessXYZNNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3 - 1, par4);
+            }
+
+            if (!var16 && !var19)
+            {
+                this.aoLightValueScratchXYZNPP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNPP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3 + 1, par4);
+                this.aoBrightnessXYZNPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3 + 1, par4);
+            }
+
+            if (!var17 && !var18)
+            {
+                this.aoLightValueScratchXYZPNP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPNP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3 - 1, par4);
+                this.aoBrightnessXYZPNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3 - 1, par4);
+            }
+
+            if (!var17 && !var19)
+            {
+                this.aoLightValueScratchXYZPPP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPPP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3 + 1, par4);
+                this.aoBrightnessXYZPPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3 + 1, par4);
+            }
+
+            if (this.renderMaxZ >= 1.0D)
+            {
+                --par4;
+            }
+
+            var21 = var14;
+
+            if (this.renderMaxZ >= 1.0D || !this.blockAccess.isBlockOpaqueCube(par2, par3, par4 + 1))
+            {
+                var21 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1);
+            }
+
+            var20 = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 + 1);
+            var9 = (this.aoLightValueScratchXZNP + this.aoLightValueScratchXYZNPP + var20 + this.aoLightValueScratchYZPP) / 4.0F;
+            var12 = (var20 + this.aoLightValueScratchYZPP + this.aoLightValueScratchXZPP + this.aoLightValueScratchXYZPPP) / 4.0F;
+            var11 = (this.aoLightValueScratchYZNP + var20 + this.aoLightValueScratchXYZPNP + this.aoLightValueScratchXZPP) / 4.0F;
+            var10 = (this.aoLightValueScratchXYZNNP + this.aoLightValueScratchXZNP + this.aoLightValueScratchYZNP + var20) / 4.0F;
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXZNP, this.aoBrightnessXYZNPP, this.aoBrightnessYZPP, var21);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessYZPP, this.aoBrightnessXZPP, this.aoBrightnessXYZPPP, var21);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNP, this.aoBrightnessXYZPNP, this.aoBrightnessXZPP, var21);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYZNNP, this.aoBrightnessXZNP, this.aoBrightnessYZNP, var21);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3);
+            this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3));
+
+            this.colorRedTopLeft *= par5;
+            this.colorRedBottomLeft *= par5;
+            this.colorRedBottomRight *= par5;
+            this.colorRedTopRight *= par5;
+            this.colorGreenTopLeft *= par6;
+            this.colorGreenBottomLeft *= par6;
+            this.colorGreenBottomRight *= par6;
+            this.colorGreenTopRight *= par6;
+            this.colorBlueTopLeft *= par7;
+            this.colorBlueBottomLeft *= par7;
+            this.colorBlueBottomRight *= par7;
+            this.colorBlueTopRight *= par7;
+            this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon );
+
+            var8 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4))
+        {
+            if (this.renderMinX <= 0.0D)
+            {
+                --par2;
+            }
+
+            this.aoLightValueScratchXYNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4);
+            this.aoLightValueScratchXZNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 - 1);
+            this.aoLightValueScratchXZNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 + 1);
+            this.aoLightValueScratchXYNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4);
+            this.aoBrightnessXYNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4);
+            this.aoBrightnessXZNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1);
+            this.aoBrightnessXZNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1);
+            this.aoBrightnessXYNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3 + 1, par4)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3 - 1, par4)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3, par4 - 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 - 1, par3, par4 + 1)];
+
+            if (!var19 && !var16)
+            {
+                this.aoLightValueScratchXYZNNN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNNN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4 - 1);
+                this.aoBrightnessXYZNNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4 - 1);
+            }
+
+            if (!var18 && !var16)
+            {
+                this.aoLightValueScratchXYZNNP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNNP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4 + 1);
+                this.aoBrightnessXYZNNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4 + 1);
+            }
+
+            if (!var19 && !var17)
+            {
+                this.aoLightValueScratchXYZNPN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNPN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4 - 1);
+                this.aoBrightnessXYZNPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4 - 1);
+            }
+
+            if (!var18 && !var17)
+            {
+                this.aoLightValueScratchXYZNPP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNPP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4 + 1);
+                this.aoBrightnessXYZNPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4 + 1);
+            }
+
+            if (this.renderMinX <= 0.0D)
+            {
+                ++par2;
+            }
+
+            var21 = var14;
+
+            if (this.renderMinX <= 0.0D || !this.blockAccess.isBlockOpaqueCube(par2 - 1, par3, par4))
+            {
+                var21 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4);
+            }
+
+            var20 = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 - 1, par3, par4);
+            var12 = (this.aoLightValueScratchXYNN + this.aoLightValueScratchXYZNNP + var20 + this.aoLightValueScratchXZNP) / 4.0F;
+            var9 = (var20 + this.aoLightValueScratchXZNP + this.aoLightValueScratchXYNP + this.aoLightValueScratchXYZNPP) / 4.0F;
+            var10 = (this.aoLightValueScratchXZNN + var20 + this.aoLightValueScratchXYZNPN + this.aoLightValueScratchXYNP) / 4.0F;
+            var11 = (this.aoLightValueScratchXYZNNN + this.aoLightValueScratchXYNN + this.aoLightValueScratchXZNN + var20) / 4.0F;
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYNN, this.aoBrightnessXYZNNP, this.aoBrightnessXZNP, var21);
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXZNP, this.aoBrightnessXYNP, this.aoBrightnessXYZNPP, var21);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXZNN, this.aoBrightnessXYZNPN, this.aoBrightnessXYNP, var21);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYZNNN, this.aoBrightnessXYNN, this.aoBrightnessXZNN, var21);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 4);
+            this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, var22);
+
+            this.colorRedTopLeft *= par5;
+            this.colorRedBottomLeft *= par5;
+            this.colorRedBottomRight *= par5;
+            this.colorRedTopRight *= par5;
+            this.colorGreenTopLeft *= par6;
+            this.colorGreenBottomLeft *= par6;
+            this.colorGreenBottomRight *= par6;
+            this.colorGreenTopRight *= par6;
+            this.colorBlueTopLeft *= par7;
+            this.colorBlueBottomLeft *= par7;
+            this.colorBlueBottomRight *= par7;
+            this.colorBlueTopRight *= par7;
+            this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon);
+
+            var8 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5))
+        {
+            if (this.renderMaxX >= 1.0D)
+            {
+                ++par2;
+            }
+
+            this.aoLightValueScratchXYPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4);
+            this.aoLightValueScratchXZPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 - 1);
+            this.aoLightValueScratchXZPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3, par4 + 1);
+            this.aoLightValueScratchXYPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4);
+            this.aoBrightnessXYPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4);
+            this.aoBrightnessXZPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1);
+            this.aoBrightnessXZPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1);
+            this.aoBrightnessXYPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3 + 1, par4)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3 - 1, par4)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3, par4 + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(par2 + 1, par3, par4 - 1)];
+
+            if (!var16 && !var18)
+            {
+                this.aoLightValueScratchXYZPNN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPNN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4 - 1);
+                this.aoBrightnessXYZPNN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4 - 1);
+            }
+
+            if (!var16 && !var19)
+            {
+                this.aoLightValueScratchXYZPNP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPNP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 - 1, par4 + 1);
+                this.aoBrightnessXYZPNP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4 + 1);
+            }
+
+            if (!var17 && !var18)
+            {
+                this.aoLightValueScratchXYZPPN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPPN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPN = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4 - 1);
+                this.aoBrightnessXYZPPN = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4 - 1);
+            }
+
+            if (!var17 && !var19)
+            {
+                this.aoLightValueScratchXYZPPP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPPP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPP = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2, par3 + 1, par4 + 1);
+                this.aoBrightnessXYZPPP = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4 + 1);
+            }
+
+            if (this.renderMaxX >= 1.0D)
+            {
+                --par2;
+            }
+
+            var21 = var14;
+
+            if (this.renderMaxX >= 1.0D || !this.blockAccess.isBlockOpaqueCube(par2 + 1, par3, par4))
+            {
+                var21 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4);
+            }
+
+            var20 = par1Block.getAmbientOcclusionLightValue(this.blockAccess, par2 + 1, par3, par4);
+            var9 = (this.aoLightValueScratchXYPN + this.aoLightValueScratchXYZPNP + var20 + this.aoLightValueScratchXZPP) / 4.0F;
+            var10 = (this.aoLightValueScratchXYZPNN + this.aoLightValueScratchXYPN + this.aoLightValueScratchXZPN + var20) / 4.0F;
+            var11 = (this.aoLightValueScratchXZPN + var20 + this.aoLightValueScratchXYZPPN + this.aoLightValueScratchXYPP) / 4.0F;
+            var12 = (var20 + this.aoLightValueScratchXZPP + this.aoLightValueScratchXYPP + this.aoLightValueScratchXYZPPP) / 4.0F;
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXYPN, this.aoBrightnessXYZPNP, this.aoBrightnessXZPP, var21);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXZPP, this.aoBrightnessXYPP, this.aoBrightnessXYZPPP, var21);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXZPN, this.aoBrightnessXYZPPN, this.aoBrightnessXYPP, var21);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYZPNN, this.aoBrightnessXYPN, this.aoBrightnessXZPN, var21);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            var22 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 5);
+            this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, var22);
+
+            this.colorRedTopLeft *= par5;
+            this.colorRedBottomLeft *= par5;
+            this.colorRedBottomRight *= par5;
+            this.colorRedTopRight *= par5;
+            this.colorGreenTopLeft *= par6;
+            this.colorGreenBottomLeft *= par6;
+            this.colorGreenBottomRight *= par6;
+            this.colorGreenTopRight *= par6;
+            this.colorBlueTopLeft *= par7;
+            this.colorBlueBottomLeft *= par7;
+            this.colorBlueBottomRight *= par7;
+            this.colorBlueTopRight *= par7;
+            this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon);
+
+            var8 = true;
+        }
+
+        this.enableAO = false;
+        return var8;
+    }
+    
+    public boolean renderGrassBlockWithColorMultiplier( Block par1Block, int par2, int par3, int par4, float par5, float par6, float par7, Icon sideOverlayIcon )
+    {
+        this.enableAO = false;
+        Tessellator var8 = Tessellator.instance;
+        boolean var9 = false;
+        float var10 = 0.5F;
+        float var11 = 1.0F;
+        float var12 = 0.8F;
+        float var13 = 0.6F;
+        float var14 = var11 * par5;
+        float var15 = var11 * par6;
+        float var16 = var11 * par7;
+        float var17 = var10;
+        float var18 = var12;
+        float var19 = var13;
+        float var20 = var10;
+        float var21 = var12;
+        float var22 = var13;
+        float var23 = var10;
+        float var24 = var12;
+        float var25 = var13;
+
+        int var26 = par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4);
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 - 1, par4, 0))
+        {
+            var8.setBrightness(this.renderMinY > 0.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 - 1, par4));
+            var8.setColorOpaque_F(var17, var20, var23);
+            this.renderFaceYNeg(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 0));
+            var9 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3 + 1, par4, 1))
+        {
+            var8.setBrightness(this.renderMaxY < 1.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3 + 1, par4));
+            var8.setColorOpaque_F(var14, var15, var16);
+            this.renderFaceYPos(par1Block, (double)par2, (double)par3, (double)par4, this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 1));
+            var9 = true;
+        }
+
+        Icon var27;
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 - 1, 2))
+        {
+            var8.setBrightness(this.renderMinZ > 0.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 - 1));
+            var8.setColorOpaque_F(var18, var21, var24);
+            var27 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 2);
+            this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, var27);
+
+            var8.setColorOpaque_F(var18 * par5, var21 * par6, var24 * par7);
+            this.renderFaceZNeg(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon);
+
+            var9 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2, par3, par4 + 1, 3))
+        {
+            var8.setBrightness(this.renderMaxZ < 1.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2, par3, par4 + 1));
+            var8.setColorOpaque_F(var18, var21, var24);
+            var27 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 3);
+            this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, var27);
+
+            var8.setColorOpaque_F(var18 * par5, var21 * par6, var24 * par7);
+            this.renderFaceZPos(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon);
+
+            var9 = true;
+        }
+
+        if ( par1Block.shouldSideBeRendered(this.blockAccess, par2 - 1, par3, par4, 4))
+        {
+            var8.setBrightness(this.renderMinX > 0.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 - 1, par3, par4));
+            var8.setColorOpaque_F(var19, var22, var25);
+            var27 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 4);
+            this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, var27);
+
+            var8.setColorOpaque_F(var19 * par5, var22 * par6, var25 * par7);
+            this.renderFaceXNeg(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon);
+
+            var9 = true;
+        }
+
+        if (par1Block.shouldSideBeRendered(this.blockAccess, par2 + 1, par3, par4, 5))
+        {
+            var8.setBrightness(this.renderMaxX < 1.0D ? var26 : par1Block.getMixedBrightnessForBlock(this.blockAccess, par2 + 1, par3, par4));
+            var8.setColorOpaque_F(var19, var22, var25);
+            var27 = this.getBlockIcon(par1Block, this.blockAccess, par2, par3, par4, 5);
+            this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, var27);
+
+            var8.setColorOpaque_F(var19 * par5, var22 * par6, var25 * par7);
+            this.renderFaceXPos(par1Block, (double)par2, (double)par3, (double)par4, sideOverlayIcon);
+
+            var9 = true;
+        }
+
+        return var9;
+    }
+    
+    public boolean renderBlockByRenderType( Block block, int i, int j, int k )
+    {
+    	block.m_currentBlockRenderer = this;
+    	
+    	boolean bReturnValue = block.RenderBlock( this, i, j, k );
+    	
+    	block.RenderBlockSecondPass( this, i, j, k, bReturnValue );
+    	
+    	return bReturnValue;
+    }
+    
+    public void renderBlockAsItem( Block block, int iItemDamage, float fBrightness )
+    {
+    	block.RenderBlockAsItem( this, iItemDamage, fBrightness ); 
+    }
+    
+    /**
+     * speed render of typical blocks
+     */	
+    public boolean RenderStandardFullBlock( Block block, int i, int j, int k )
+    {
+    	// set block bounds here to avoid unnecessary conditional checks in setRenderBounds()
+    	
+        renderMinX = renderMinY = renderMinZ = 0D;        	
+        renderMaxX = renderMaxY = renderMaxZ = 1D;
+        
+        partialRenderBounds = false;
+        
+    	if ( Minecraft.isAmbientOcclusionEnabled() )
+        {
+        	return RenderStandardFullBlockWithAmbientOcclusion( block, i, j, k );
+        }
+        else
+        {
+        	return RenderStandardFullBlockWithColorMultiplier( block, i, j, k );
+        }        
+    }
+    
+    public boolean RenderStandardFullBlockWithAmbientOcclusion( Block block, int i, int j, int k )
+    {
+        this.enableAO = true;
+        boolean bSideRendered = false;
+        
+        float var9;
+        float var10;
+        float var11;
+        float var12;
+        
+        // FCTODO: This appears to be unnecessary
+        //int iMixedBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k);
+        
+        Tessellator tesselator = Tessellator.instance;
+        tesselator.setBrightness( 983055 );
+
+        boolean var17;
+        boolean var16;
+        boolean var19;
+        boolean var18;
+        
+        int iFaceBrightness;
+        float var20;
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j - 1, k, 0 ) )
+        {
+            --j;
+
+            this.aoBrightnessXYNN = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k);
+            this.aoBrightnessYZNN = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1);
+            this.aoBrightnessYZNP = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1);
+            this.aoBrightnessXYPN = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k);
+            
+            this.aoLightValueScratchXYNN = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k);
+            this.aoLightValueScratchYZNN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k - 1);
+            this.aoLightValueScratchYZNP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k + 1);
+            this.aoLightValueScratchXYPN = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k);
+            
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j - 1, k)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j - 1, k)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j - 1, k + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j - 1, k - 1)];
+
+            if (!var18 && !var16)
+            {
+                this.aoLightValueScratchXYZNNN = this.aoLightValueScratchXYNN;
+                this.aoBrightnessXYZNNN = this.aoBrightnessXYNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNN = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k - 1);
+                this.aoBrightnessXYZNNN = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k - 1);
+            }
+
+            if (!var19 && !var16)
+            {
+                this.aoLightValueScratchXYZNNP = this.aoLightValueScratchXYNN;
+                this.aoBrightnessXYZNNP = this.aoBrightnessXYNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNP = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k + 1);
+                this.aoBrightnessXYZNNP = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k + 1);
+            }
+
+            if (!var18 && !var17)
+            {
+                this.aoLightValueScratchXYZPNN = this.aoLightValueScratchXYPN;
+                this.aoBrightnessXYZPNN = this.aoBrightnessXYPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNN = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k - 1);
+                this.aoBrightnessXYZPNN = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k - 1);
+            }
+
+            if (!var19 && !var17)
+            {
+                this.aoLightValueScratchXYZPNP = this.aoLightValueScratchXYPN;
+                this.aoBrightnessXYZPNP = this.aoBrightnessXYPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNP = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k + 1);
+                this.aoBrightnessXYZPNP = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k + 1);
+            }
+
+            ++j;
+
+            iFaceBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k);
+
+            var20 = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k);
+            
+            var9 = (this.aoLightValueScratchXYZNNP + this.aoLightValueScratchXYNN + this.aoLightValueScratchYZNP + var20) / 4.0F;
+            var12 = (this.aoLightValueScratchYZNP + var20 + this.aoLightValueScratchXYZPNP + this.aoLightValueScratchXYPN) / 4.0F;
+            var11 = (var20 + this.aoLightValueScratchYZNN + this.aoLightValueScratchXYPN + this.aoLightValueScratchXYZPNN) / 4.0F;
+            var10 = (this.aoLightValueScratchXYNN + this.aoLightValueScratchXYZNNN + var20 + this.aoLightValueScratchYZNN) / 4.0F;
+            
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXYZNNP, this.aoBrightnessXYNN, this.aoBrightnessYZNP, iFaceBrightness);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessYZNP, this.aoBrightnessXYZPNP, this.aoBrightnessXYPN, iFaceBrightness);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYPN, this.aoBrightnessXYZPNN, iFaceBrightness);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYNN, this.aoBrightnessXYZNNN, this.aoBrightnessYZNN, iFaceBrightness);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.5F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.5F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.5F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            
+            this.RenderFullBottomFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, this.blockAccess, i, j, k, 0));
+            
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j + 1, k, 1 ) )
+        {
+            ++j;
+
+            this.aoBrightnessXYNP = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k);
+            this.aoBrightnessXYPP = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k);
+            this.aoBrightnessYZPN = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1);
+            this.aoBrightnessYZPP = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1);
+            
+            this.aoLightValueScratchXYNP = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k);
+            this.aoLightValueScratchXYPP = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k);
+            this.aoLightValueScratchYZPN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k - 1);
+            this.aoLightValueScratchYZPP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k + 1);
+            
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j + 1, k)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j + 1, k)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j + 1, k + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j + 1, k - 1)];
+
+            if (!var18 && !var16)
+            {
+                this.aoLightValueScratchXYZNPN = this.aoLightValueScratchXYNP;
+                this.aoBrightnessXYZNPN = this.aoBrightnessXYNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPN = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k - 1);
+                this.aoBrightnessXYZNPN = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k - 1);
+            }
+
+            if (!var18 && !var17)
+            {
+                this.aoLightValueScratchXYZPPN = this.aoLightValueScratchXYPP;
+                this.aoBrightnessXYZPPN = this.aoBrightnessXYPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPN = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k - 1);
+                this.aoBrightnessXYZPPN = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k - 1);
+            }
+
+            if (!var19 && !var16)
+            {
+                this.aoLightValueScratchXYZNPP = this.aoLightValueScratchXYNP;
+                this.aoBrightnessXYZNPP = this.aoBrightnessXYNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPP = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k + 1);
+                this.aoBrightnessXYZNPP = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k + 1);
+            }
+
+            if (!var19 && !var17)
+            {
+                this.aoLightValueScratchXYZPPP = this.aoLightValueScratchXYPP;
+                this.aoBrightnessXYZPPP = this.aoBrightnessXYPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPP = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k + 1);
+                this.aoBrightnessXYZPPP = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k + 1);
+            }
+
+            --j;
+
+            iFaceBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k);
+
+            var20 = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k);
+            
+            var12 = (this.aoLightValueScratchXYZNPP + this.aoLightValueScratchXYNP + this.aoLightValueScratchYZPP + var20) / 4.0F;
+            var9 = (this.aoLightValueScratchYZPP + var20 + this.aoLightValueScratchXYZPPP + this.aoLightValueScratchXYPP) / 4.0F;
+            var10 = (var20 + this.aoLightValueScratchYZPN + this.aoLightValueScratchXYPP + this.aoLightValueScratchXYZPPN) / 4.0F;
+            var11 = (this.aoLightValueScratchXYNP + this.aoLightValueScratchXYZNPN + var20 + this.aoLightValueScratchYZPN) / 4.0F;
+            
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYZNPP, this.aoBrightnessXYNP, this.aoBrightnessYZPP, iFaceBrightness);
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessYZPP, this.aoBrightnessXYZPPP, this.aoBrightnessXYPP, iFaceBrightness);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessYZPN, this.aoBrightnessXYPP, this.aoBrightnessXYZPPN, iFaceBrightness);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYNP, this.aoBrightnessXYZNPN, this.aoBrightnessYZPN, iFaceBrightness);
+            
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 1F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 1F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 1F;
+            
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            
+            RenderFullTopFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, this.blockAccess, i, j, k, 1));
+            
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j, k - 1, 2 ) )
+        {
+            --k;
+
+            this.aoLightValueScratchXZNN = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k);
+            this.aoLightValueScratchYZNN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k);
+            this.aoLightValueScratchYZPN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k);
+            this.aoLightValueScratchXZPN = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k);
+            this.aoBrightnessXZNN = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k);
+            this.aoBrightnessYZNN = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k);
+            this.aoBrightnessYZPN = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k);
+            this.aoBrightnessXZPN = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j, k - 1)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j, k - 1)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j + 1, k - 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j - 1, k - 1)];
+
+            if (!var16 && !var18)
+            {
+                this.aoLightValueScratchXYZNNN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNNN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNN = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j - 1, k);
+                this.aoBrightnessXYZNNN = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j - 1, k);
+            }
+
+            if (!var16 && !var19)
+            {
+                this.aoLightValueScratchXYZNPN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNPN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPN = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j + 1, k);
+                this.aoBrightnessXYZNPN = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j + 1, k);
+            }
+
+            if (!var17 && !var18)
+            {
+                this.aoLightValueScratchXYZPNN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPNN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNN = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j - 1, k);
+                this.aoBrightnessXYZPNN = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j - 1, k);
+            }
+
+            if (!var17 && !var19)
+            {
+                this.aoLightValueScratchXYZPPN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPPN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPN = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j + 1, k);
+                this.aoBrightnessXYZPPN = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j + 1, k);
+            }
+
+            ++k;
+
+            iFaceBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1);
+
+            var20 = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k - 1);
+            var9 = (this.aoLightValueScratchXZNN + this.aoLightValueScratchXYZNPN + var20 + this.aoLightValueScratchYZPN) / 4.0F;
+            var10 = (var20 + this.aoLightValueScratchYZPN + this.aoLightValueScratchXZPN + this.aoLightValueScratchXYZPPN) / 4.0F;
+            var11 = (this.aoLightValueScratchYZNN + var20 + this.aoLightValueScratchXYZPNN + this.aoLightValueScratchXZPN) / 4.0F;
+            var12 = (this.aoLightValueScratchXYZNNN + this.aoLightValueScratchXZNN + this.aoLightValueScratchYZNN + var20) / 4.0F;
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXZNN, this.aoBrightnessXYZNPN, this.aoBrightnessYZPN, iFaceBrightness);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessYZPN, this.aoBrightnessXZPN, this.aoBrightnessXYZPPN, iFaceBrightness);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNN, this.aoBrightnessXYZPNN, this.aoBrightnessXZPN, iFaceBrightness);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYZNNN, this.aoBrightnessXZNN, this.aoBrightnessYZNN, iFaceBrightness);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            
+            RenderFullEastFace( block, (double)i, (double)j, (double)k, getBlockIcon(block, this.blockAccess, i, j, k, 2) );
+
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j, k + 1, 3 ) )
+        {
+            ++k;
+
+            this.aoLightValueScratchXZNP = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k);
+            this.aoLightValueScratchXZPP = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k);
+            this.aoLightValueScratchYZNP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k);
+            this.aoLightValueScratchYZPP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k);
+            this.aoBrightnessXZNP = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k);
+            this.aoBrightnessXZPP = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k);
+            this.aoBrightnessYZNP = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k);
+            this.aoBrightnessYZPP = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j, k + 1)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j, k + 1)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j + 1, k + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(i, j - 1, k + 1)];
+
+            if (!var16 && !var18)
+            {
+                this.aoLightValueScratchXYZNNP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNNP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNP = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j - 1, k);
+                this.aoBrightnessXYZNNP = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j - 1, k);
+            }
+
+            if (!var16 && !var19)
+            {
+                this.aoLightValueScratchXYZNPP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNPP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPP = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j + 1, k);
+                this.aoBrightnessXYZNPP = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j + 1, k);
+            }
+
+            if (!var17 && !var18)
+            {
+                this.aoLightValueScratchXYZPNP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPNP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNP = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j - 1, k);
+                this.aoBrightnessXYZPNP = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j - 1, k);
+            }
+
+            if (!var17 && !var19)
+            {
+                this.aoLightValueScratchXYZPPP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPPP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPP = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j + 1, k);
+                this.aoBrightnessXYZPPP = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j + 1, k);
+            }
+
+            --k;
+
+            iFaceBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1);
+
+            var20 = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k + 1);
+            
+            var9 = (this.aoLightValueScratchXZNP + this.aoLightValueScratchXYZNPP + var20 + this.aoLightValueScratchYZPP) / 4.0F;
+            var12 = (var20 + this.aoLightValueScratchYZPP + this.aoLightValueScratchXZPP + this.aoLightValueScratchXYZPPP) / 4.0F;
+            var11 = (this.aoLightValueScratchYZNP + var20 + this.aoLightValueScratchXYZPNP + this.aoLightValueScratchXZPP) / 4.0F;
+            var10 = (this.aoLightValueScratchXYZNNP + this.aoLightValueScratchXZNP + this.aoLightValueScratchYZNP + var20) / 4.0F;
+            
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXZNP, this.aoBrightnessXYZNPP, this.aoBrightnessYZPP, iFaceBrightness);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessYZPP, this.aoBrightnessXZPP, this.aoBrightnessXYZPPP, iFaceBrightness);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessYZNP, this.aoBrightnessXYZPNP, this.aoBrightnessXZPP, iFaceBrightness);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYZNNP, this.aoBrightnessXZNP, this.aoBrightnessYZNP, iFaceBrightness);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.8F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.8F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.8F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            
+            RenderFullWestFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, this.blockAccess, i, j, k, 3));
+
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i - 1, j, k, 4 ) )
+        {
+            --i;
+
+            this.aoLightValueScratchXYNN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k);
+            this.aoLightValueScratchXZNN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k - 1);
+            this.aoLightValueScratchXZNP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k + 1);
+            this.aoLightValueScratchXYNP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k);
+            this.aoBrightnessXYNN = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k);
+            this.aoBrightnessXZNN = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1);
+            this.aoBrightnessXZNP = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1);
+            this.aoBrightnessXYNP = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j + 1, k)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j - 1, k)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j, k - 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(i - 1, j, k + 1)];
+
+            if (!var19 && !var16)
+            {
+                this.aoLightValueScratchXYZNNN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNNN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k - 1);
+                this.aoBrightnessXYZNNN = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k - 1);
+            }
+
+            if (!var18 && !var16)
+            {
+                this.aoLightValueScratchXYZNNP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNNP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNNP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k + 1);
+                this.aoBrightnessXYZNNP = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k + 1);
+            }
+
+            if (!var19 && !var17)
+            {
+                this.aoLightValueScratchXYZNPN = this.aoLightValueScratchXZNN;
+                this.aoBrightnessXYZNPN = this.aoBrightnessXZNN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k - 1);
+                this.aoBrightnessXYZNPN = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k - 1);
+            }
+
+            if (!var18 && !var17)
+            {
+                this.aoLightValueScratchXYZNPP = this.aoLightValueScratchXZNP;
+                this.aoBrightnessXYZNPP = this.aoBrightnessXZNP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZNPP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k + 1);
+                this.aoBrightnessXYZNPP = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k + 1);
+            }
+
+            ++i;
+
+            iFaceBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k);
+
+            var20 = block.getAmbientOcclusionLightValue(this.blockAccess, i - 1, j, k);
+            
+            var12 = (this.aoLightValueScratchXYNN + this.aoLightValueScratchXYZNNP + var20 + this.aoLightValueScratchXZNP) / 4.0F;
+            var9 = (var20 + this.aoLightValueScratchXZNP + this.aoLightValueScratchXYNP + this.aoLightValueScratchXYZNPP) / 4.0F;
+            var10 = (this.aoLightValueScratchXZNN + var20 + this.aoLightValueScratchXYZNPN + this.aoLightValueScratchXYNP) / 4.0F;
+            var11 = (this.aoLightValueScratchXYZNNN + this.aoLightValueScratchXYNN + this.aoLightValueScratchXZNN + var20) / 4.0F;
+            
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXYNN, this.aoBrightnessXYZNNP, this.aoBrightnessXZNP, iFaceBrightness);
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXZNP, this.aoBrightnessXYNP, this.aoBrightnessXYZNPP, iFaceBrightness);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXZNN, this.aoBrightnessXYZNPN, this.aoBrightnessXYNP, iFaceBrightness);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXYZNNN, this.aoBrightnessXYNN, this.aoBrightnessXZNN, iFaceBrightness);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            
+            RenderFullNorthFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, blockAccess, i, j, k, 4) );
+
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i + 1, j, k, 5 ) )
+        {
+            ++i;
+
+            this.aoLightValueScratchXYPN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k);
+            this.aoLightValueScratchXZPN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k - 1);
+            this.aoLightValueScratchXZPP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j, k + 1);
+            this.aoLightValueScratchXYPP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k);
+            this.aoBrightnessXYPN = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k);
+            this.aoBrightnessXZPN = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1);
+            this.aoBrightnessXZPP = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1);
+            this.aoBrightnessXYPP = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k);
+            var17 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j + 1, k)];
+            var16 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j - 1, k)];
+            var19 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j, k + 1)];
+            var18 = Block.canBlockGrass[this.blockAccess.getBlockId(i + 1, j, k - 1)];
+
+            if (!var16 && !var18)
+            {
+                this.aoLightValueScratchXYZPNN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPNN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k - 1);
+                this.aoBrightnessXYZPNN = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k - 1);
+            }
+
+            if (!var16 && !var19)
+            {
+                this.aoLightValueScratchXYZPNP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPNP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPNP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j - 1, k + 1);
+                this.aoBrightnessXYZPNP = block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k + 1);
+            }
+
+            if (!var17 && !var18)
+            {
+                this.aoLightValueScratchXYZPPN = this.aoLightValueScratchXZPN;
+                this.aoBrightnessXYZPPN = this.aoBrightnessXZPN;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPN = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k - 1);
+                this.aoBrightnessXYZPPN = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k - 1);
+            }
+
+            if (!var17 && !var19)
+            {
+                this.aoLightValueScratchXYZPPP = this.aoLightValueScratchXZPP;
+                this.aoBrightnessXYZPPP = this.aoBrightnessXZPP;
+            }
+            else
+            {
+                this.aoLightValueScratchXYZPPP = block.getAmbientOcclusionLightValue(this.blockAccess, i, j + 1, k + 1);
+                this.aoBrightnessXYZPPP = block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k + 1);
+            }
+
+            --i;
+
+            iFaceBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k);
+
+            var20 = block.getAmbientOcclusionLightValue(this.blockAccess, i + 1, j, k);
+            var9 = (this.aoLightValueScratchXYPN + this.aoLightValueScratchXYZPNP + var20 + this.aoLightValueScratchXZPP) / 4.0F;
+            var10 = (this.aoLightValueScratchXYZPNN + this.aoLightValueScratchXYPN + this.aoLightValueScratchXZPN + var20) / 4.0F;
+            var11 = (this.aoLightValueScratchXZPN + var20 + this.aoLightValueScratchXYZPPN + this.aoLightValueScratchXYPP) / 4.0F;
+            var12 = (var20 + this.aoLightValueScratchXZPP + this.aoLightValueScratchXYPP + this.aoLightValueScratchXYZPPP) / 4.0F;
+            this.brightnessTopLeft = this.getAoBrightness(this.aoBrightnessXYPN, this.aoBrightnessXYZPNP, this.aoBrightnessXZPP, iFaceBrightness);
+            this.brightnessTopRight = this.getAoBrightness(this.aoBrightnessXZPP, this.aoBrightnessXYPP, this.aoBrightnessXYZPPP, iFaceBrightness);
+            this.brightnessBottomRight = this.getAoBrightness(this.aoBrightnessXZPN, this.aoBrightnessXYZPPN, this.aoBrightnessXYPP, iFaceBrightness);
+            this.brightnessBottomLeft = this.getAoBrightness(this.aoBrightnessXYZPNN, this.aoBrightnessXYPN, this.aoBrightnessXZPN, iFaceBrightness);
+
+            this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = 0.6F;
+            this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = 0.6F;
+            this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = 0.6F;
+
+            this.colorRedTopLeft *= var9;
+            this.colorGreenTopLeft *= var9;
+            this.colorBlueTopLeft *= var9;
+            this.colorRedBottomLeft *= var10;
+            this.colorGreenBottomLeft *= var10;
+            this.colorBlueBottomLeft *= var10;
+            this.colorRedBottomRight *= var11;
+            this.colorGreenBottomRight *= var11;
+            this.colorBlueBottomRight *= var11;
+            this.colorRedTopRight *= var12;
+            this.colorGreenTopRight *= var12;
+            this.colorBlueTopRight *= var12;
+            
+            RenderFullSouthFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, this.blockAccess, i, j, k, 5) );
+
+            bSideRendered = true;
+        }
+
+        enableAO = false;
+        
+        return bSideRendered;
+    }
+    
+    public boolean RenderStandardFullBlockWithColorMultiplier( Block block, int i, int j, int k )
+    {
+        this.enableAO = false;
+        Tessellator bTesselator = Tessellator.instance;
+        boolean bSideRendered = false;
+        
+        int iMixedBrightness = block.getMixedBrightnessForBlock(this.blockAccess, i, j, k);
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j - 1, k, 0 ) )
+        {
+            bTesselator.setBrightness(this.renderMinY > 0.0D ? iMixedBrightness : block.getMixedBrightnessForBlock(this.blockAccess, i, j - 1, k));
+            
+            bTesselator.setColorOpaque_F( 0.5F, 0.5F, 0.5F );
+            
+            RenderFullBottomFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, this.blockAccess, i, j, k, 0));
+            
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j + 1, k, 1 ) )
+        {
+            bTesselator.setBrightness(this.renderMaxY < 1.0D ? iMixedBrightness : block.getMixedBrightnessForBlock(this.blockAccess, i, j + 1, k));
+            
+            bTesselator.setColorOpaque_F( 1F, 1F, 1F );
+            
+            RenderFullTopFace(block, (double)i, (double)j, (double)k, this.getBlockIcon(block, this.blockAccess, i, j, k, 1));
+            
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j, k - 1, 2 ) )
+        {
+            bTesselator.setBrightness(this.renderMinZ > 0.0D ? iMixedBrightness : block.getMixedBrightnessForBlock(this.blockAccess, i, j, k - 1));
+            
+            bTesselator.setColorOpaque_F( 0.8F, 0.8F, 0.8F );
+            
+            RenderFullEastFace(block, (double)i, (double)j, (double)k, getBlockIcon(block, this.blockAccess, i, j, k, 2));
+
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i, j, k + 1, 3 ) )
+        {
+            bTesselator.setBrightness(this.renderMaxZ < 1.0D ? iMixedBrightness : block.getMixedBrightnessForBlock(this.blockAccess, i, j, k + 1));
+            bTesselator.setColorOpaque_F( 0.8F, 0.8F, 0.8F );
+            
+            RenderFullWestFace(block, (double)i, (double)j, (double)k, getBlockIcon(block, this.blockAccess, i, j, k, 3));
+
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i - 1, j, k, 4 ) )
+        {
+            bTesselator.setBrightness(this.renderMinX > 0.0D ? iMixedBrightness : block.getMixedBrightnessForBlock(this.blockAccess, i - 1, j, k));
+            bTesselator.setColorOpaque_F( 0.6F, 0.6F, 0.6F );
+            
+            RenderFullNorthFace(block, (double)i, (double)j, (double)k, getBlockIcon(block, this.blockAccess, i, j, k, 4));
+
+            bSideRendered = true;
+        }
+
+        if ( block.shouldSideBeRendered( blockAccess, i + 1, j, k, 5 ) )
+        {
+            bTesselator.setBrightness(this.renderMaxX < 1.0D ? iMixedBrightness : block.getMixedBrightnessForBlock(this.blockAccess, i + 1, j, k));
+            bTesselator.setColorOpaque_F( 0.6F, 0.6F, 0.6F );
+            
+            RenderFullSouthFace(block, (double)i, (double)j, (double)k, getBlockIcon(block, this.blockAccess, i, j, k, 5));
+
+            bSideRendered = true;
+        }
+
+        return bSideRendered;
+    }
+    
+    public void RenderFullBottomFace(Block par1Block, double par2, double par4, double par6, Icon par8Icon)
+    {
+        Tessellator var9 = Tessellator.instance;
+
+        double var10 = (double)par8Icon.getInterpolatedU(this.renderMinX * 16.0D);
+        double var12 = (double)par8Icon.getInterpolatedU(this.renderMaxX * 16.0D);
+        double var14 = (double)par8Icon.getInterpolatedV(this.renderMinZ * 16.0D);
+        double var16 = (double)par8Icon.getInterpolatedV(this.renderMaxZ * 16.0D);
+
+        double var18 = var12;
+        double var20 = var10;
+        double var22 = var14;
+        double var24 = var16;
+
+        double var26 = par2 + this.renderMinX;
+        double var28 = par2 + this.renderMaxX;
+        double var30 = par4 + this.renderMinY;
+        double var32 = par6 + this.renderMinZ;
+        double var34 = par6 + this.renderMaxZ;
+
+        if (this.enableAO)
+        {
+            var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            var9.setBrightness(this.brightnessTopLeft);
+            var9.addVertexWithUV(var26, var30, var34, var20, var24);
+            var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            var9.setBrightness(this.brightnessBottomLeft);
+            var9.addVertexWithUV(var26, var30, var32, var10, var14);
+            var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            var9.setBrightness(this.brightnessBottomRight);
+            var9.addVertexWithUV(var28, var30, var32, var18, var22);
+            var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            var9.setBrightness(this.brightnessTopRight);
+            var9.addVertexWithUV(var28, var30, var34, var12, var16);
+        }
+        else
+        {
+            var9.addVertexWithUV(var26, var30, var34, var20, var24);
+            var9.addVertexWithUV(var26, var30, var32, var10, var14);
+            var9.addVertexWithUV(var28, var30, var32, var18, var22);
+            var9.addVertexWithUV(var28, var30, var34, var12, var16);
+        }
+    }
+
+    public void RenderFullTopFace(Block par1Block, double par2, double par4, double par6, Icon par8Icon)
+    {
+        Tessellator var9 = Tessellator.instance;
+
+        double var10 = (double)par8Icon.getInterpolatedU(this.renderMinX * 16.0D);
+        double var12 = (double)par8Icon.getInterpolatedU(this.renderMaxX * 16.0D);
+        double var14 = (double)par8Icon.getInterpolatedV(this.renderMinZ * 16.0D);
+        double var16 = (double)par8Icon.getInterpolatedV(this.renderMaxZ * 16.0D);
+
+        double var18 = var12;
+        double var20 = var10;
+        double var22 = var14;
+        double var24 = var16;
+
+        double var26 = par2 + this.renderMinX;
+        double var28 = par2 + this.renderMaxX;
+        double var30 = par4 + this.renderMaxY;
+        double var32 = par6 + this.renderMinZ;
+        double var34 = par6 + this.renderMaxZ;
+
+        if (this.enableAO)
+        {
+            var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            var9.setBrightness(this.brightnessTopLeft);
+            var9.addVertexWithUV(var28, var30, var34, var12, var16);
+            var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            var9.setBrightness(this.brightnessBottomLeft);
+            var9.addVertexWithUV(var28, var30, var32, var18, var22);
+            var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            var9.setBrightness(this.brightnessBottomRight);
+            var9.addVertexWithUV(var26, var30, var32, var10, var14);
+            var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            var9.setBrightness(this.brightnessTopRight);
+            var9.addVertexWithUV(var26, var30, var34, var20, var24);
+        }
+        else
+        {
+            var9.addVertexWithUV(var28, var30, var34, var12, var16);
+            var9.addVertexWithUV(var28, var30, var32, var18, var22);
+            var9.addVertexWithUV(var26, var30, var32, var10, var14);
+            var9.addVertexWithUV(var26, var30, var34, var20, var24);
+        }
+    }
+
+    public void RenderFullEastFace(Block par1Block, double par2, double par4, double par6, Icon par8Icon)
+    {
+        Tessellator var9 = Tessellator.instance;
+
+        double var10 = (double)par8Icon.getInterpolatedU(this.renderMinX * 16.0D);
+        double var12 = (double)par8Icon.getInterpolatedU(this.renderMaxX * 16.0D);
+        double var14 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMaxY * 16.0D);
+        double var16 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMinY * 16.0D);
+        double var18;
+
+        var18 = var12;
+        double var20 = var10;
+        double var22 = var14;
+        double var24 = var16;
+
+        double var26 = par2 + this.renderMinX;
+        double var28 = par2 + this.renderMaxX;
+        double var30 = par4 + this.renderMinY;
+        double var32 = par4 + this.renderMaxY;
+        double var34 = par6 + this.renderMinZ;
+
+        if (this.enableAO)
+        {
+            var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            var9.setBrightness(this.brightnessTopLeft);
+            var9.addVertexWithUV(var26, var32, var34, var18, var22);
+            var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            var9.setBrightness(this.brightnessBottomLeft);
+            var9.addVertexWithUV(var28, var32, var34, var10, var14);
+            var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            var9.setBrightness(this.brightnessBottomRight);
+            var9.addVertexWithUV(var28, var30, var34, var20, var24);
+            var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            var9.setBrightness(this.brightnessTopRight);
+            var9.addVertexWithUV(var26, var30, var34, var12, var16);
+        }
+        else
+        {
+            var9.addVertexWithUV(var26, var32, var34, var18, var22);
+            var9.addVertexWithUV(var28, var32, var34, var10, var14);
+            var9.addVertexWithUV(var28, var30, var34, var20, var24);
+            var9.addVertexWithUV(var26, var30, var34, var12, var16);
+        }
+    }
+
+    public void RenderFullWestFace(Block par1Block, double par2, double par4, double par6, Icon par8Icon)
+    {
+        Tessellator var9 = Tessellator.instance;
+
+        double var10 = (double)par8Icon.getInterpolatedU(this.renderMinX * 16.0D);
+        double var12 = (double)par8Icon.getInterpolatedU(this.renderMaxX * 16.0D);
+        double var14 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMaxY * 16.0D);
+        double var16 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMinY * 16.0D);
+        double var18;
+
+        var18 = var12;
+        double var20 = var10;
+        double var22 = var14;
+        double var24 = var16;
+
+        double var26 = par2 + this.renderMinX;
+        double var28 = par2 + this.renderMaxX;
+        double var30 = par4 + this.renderMinY;
+        double var32 = par4 + this.renderMaxY;
+        double var34 = par6 + this.renderMaxZ;
+
+        if (this.enableAO)
+        {
+            var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            var9.setBrightness(this.brightnessTopLeft);
+            var9.addVertexWithUV(var26, var32, var34, var10, var14);
+            var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            var9.setBrightness(this.brightnessBottomLeft);
+            var9.addVertexWithUV(var26, var30, var34, var20, var24);
+            var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            var9.setBrightness(this.brightnessBottomRight);
+            var9.addVertexWithUV(var28, var30, var34, var12, var16);
+            var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            var9.setBrightness(this.brightnessTopRight);
+            var9.addVertexWithUV(var28, var32, var34, var18, var22);
+        }
+        else
+        {
+            var9.addVertexWithUV(var26, var32, var34, var10, var14);
+            var9.addVertexWithUV(var26, var30, var34, var20, var24);
+            var9.addVertexWithUV(var28, var30, var34, var12, var16);
+            var9.addVertexWithUV(var28, var32, var34, var18, var22);
+        }
+    }
+
+    /**
+     * Renders the given texture to the north (x-negative) face of the block.  Args: block, x, y, z, texture
+     */
+    public void RenderFullNorthFace(Block par1Block, double par2, double par4, double par6, Icon par8Icon)
+    {
+        Tessellator var9 = Tessellator.instance;
+
+        double var10 = (double)par8Icon.getInterpolatedU(this.renderMinZ * 16.0D);
+        double var12 = (double)par8Icon.getInterpolatedU(this.renderMaxZ * 16.0D);
+        double var14 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMaxY * 16.0D);
+        double var16 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMinY * 16.0D);
+        double var18;
+
+        var18 = var12;
+        double var20 = var10;
+        double var22 = var14;
+        double var24 = var16;
+
+        double var26 = par2 + this.renderMinX;
+        double var28 = par4 + this.renderMinY;
+        double var30 = par4 + this.renderMaxY;
+        double var32 = par6 + this.renderMinZ;
+        double var34 = par6 + this.renderMaxZ;
+
+        if (this.enableAO)
+        {
+            var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            var9.setBrightness(this.brightnessTopLeft);
+            var9.addVertexWithUV(var26, var30, var34, var18, var22);
+            var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            var9.setBrightness(this.brightnessBottomLeft);
+            var9.addVertexWithUV(var26, var30, var32, var10, var14);
+            var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            var9.setBrightness(this.brightnessBottomRight);
+            var9.addVertexWithUV(var26, var28, var32, var20, var24);
+            var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            var9.setBrightness(this.brightnessTopRight);
+            var9.addVertexWithUV(var26, var28, var34, var12, var16);
+        }
+        else
+        {
+            var9.addVertexWithUV(var26, var30, var34, var18, var22);
+            var9.addVertexWithUV(var26, var30, var32, var10, var14);
+            var9.addVertexWithUV(var26, var28, var32, var20, var24);
+            var9.addVertexWithUV(var26, var28, var34, var12, var16);
+        }
+    }
+
+    /**
+     * Renders the given texture to the south (x-positive) face of the block.  Args: block, x, y, z, texture
+     */
+    public void RenderFullSouthFace(Block par1Block, double par2, double par4, double par6, Icon par8Icon)
+    {
+        Tessellator var9 = Tessellator.instance;
+
+        double var10 = (double)par8Icon.getInterpolatedU(this.renderMinZ * 16.0D);
+        double var12 = (double)par8Icon.getInterpolatedU(this.renderMaxZ * 16.0D);
+        double var14 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMaxY * 16.0D);
+        double var16 = (double)par8Icon.getInterpolatedV(16.0D - this.renderMinY * 16.0D);
+        double var18;
+
+        var18 = var12;
+        double var20 = var10;
+        double var22 = var14;
+        double var24 = var16;
+
+        double var26 = par2 + this.renderMaxX;
+        double var28 = par4 + this.renderMinY;
+        double var30 = par4 + this.renderMaxY;
+        double var32 = par6 + this.renderMinZ;
+        double var34 = par6 + this.renderMaxZ;
+
+        if (this.enableAO)
+        {
+            var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+            var9.setBrightness(this.brightnessTopLeft);
+            var9.addVertexWithUV(var26, var28, var34, var20, var24);
+            var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+            var9.setBrightness(this.brightnessBottomLeft);
+            var9.addVertexWithUV(var26, var28, var32, var12, var16);
+            var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+            var9.setBrightness(this.brightnessBottomRight);
+            var9.addVertexWithUV(var26, var30, var32, var18, var22);
+            var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+            var9.setBrightness(this.brightnessTopRight);
+            var9.addVertexWithUV(var26, var30, var34, var10, var14);
+        }
+        else
+        {
+            var9.addVertexWithUV(var26, var28, var34, var20, var24);
+            var9.addVertexWithUV(var26, var28, var32, var12, var16);
+            var9.addVertexWithUV(var26, var30, var32, var18, var22);
+            var9.addVertexWithUV(var26, var30, var34, var10, var14);
+        }
+    }
+    
+    public Icon GetOverrideTexture()
+    {
+    	return overrideBlockTexture;
+    }
+    
+    public void SetUvRotateEast( int iValue )
+    {
+    	uvRotateEast = iValue;
+    }
+    
+    public void SetUvRotateWest( int iValue )
+    {
+    	uvRotateWest = iValue;
+    }
+    
+    public void SetUvRotateSouth( int iValue )
+    {
+    	uvRotateSouth = iValue;
+    }
+    
+    public void SetUvRotateNorth( int iValue )
+    {
+    	uvRotateNorth = iValue;
+    }
+    
+    public void SetUvRotateTop( int iValue )
+    {
+    	uvRotateTop = iValue;
+    }
+    
+    public void SetUvRotateBottom( int iValue )
+    {
+    	uvRotateBottom = iValue;
+    }
+    
+    public void ClearUvRotation()
+    {
+		uvRotateEast = 0;
+		uvRotateWest = 0;
+		uvRotateSouth = 0;
+		uvRotateNorth = 0;
+		uvRotateTop = 0;
+		uvRotateBottom = 0;
+    }
+    
+    public boolean GetRenderAllFaces()
+    {
+    	return renderAllFaces;
+    }
+    
+    public void SetRenderAllFaces( boolean bValue )
+    {
+    	renderAllFaces = bValue;
+    }
+    
+    public boolean RenderBlockRedstoneLogic( BlockRedstoneLogic block, int i, int j, int k )
+    {
+    	return renderBlockRedstoneLogic( block, i, j, k );
+    }
+    
+    public boolean RenderBlockBeacon( BlockBeacon block, int i, int j, int k )
+    {
+    	return renderBlockBeacon( block, i, j, k );
+    }
+    
+    public boolean RenderBlockBed( Block block, int i, int j, int k )
+    {
+    	return renderBlockBed( block, i, j, k );    
+	}
+    
+    public boolean RenderBlockBrewingStand( BlockBrewingStand block, int i, int j, int k )
+    {
+    	return renderBlockBrewingStand( block, i, j, k);
+    }
+    
+    public boolean RenderBlockCocoa( BlockCocoa block, int i, int j, int k )
+    {
+    	return renderBlockCocoa( block, i, j, k );
+    }
+    
+    public boolean RenderBlockAnvil( BlockAnvil block, int i, int j, int k )
+    {
+    	return renderBlockAnvil( block, i, j, k);    
+	}
+    
+    public boolean RenderBlockEndPortalFrame( BlockEndPortalFrame block, int i, int j, int k )
+    {
+    	return renderBlockEndPortalFrame( block, i, j, k );
+    }
+    
+    public boolean RenderBlockFlowerpot( BlockFlowerPot block, int i, int j, int k )
+    {
+    	return renderBlockFlowerpot( block, i, j, k );
+    }
+    
+    public void setRenderBounds( AxisAlignedBB box )
+    {
+        if (!this.lockBlockBounds)
+        {
+            this.renderMinX = box.minX;
+            this.renderMaxX = box.maxX;
+            this.renderMinY = box.minY;
+            this.renderMaxY = box.maxY;
+            this.renderMinZ = box.minZ;
+            this.renderMaxZ = box.maxZ;
+            this.partialRenderBounds = this.minecraftRB.gameSettings.ambientOcclusion >= 2 && (this.renderMinX > 0.0D || this.renderMaxX < 1.0D || this.renderMinY > 0.0D || this.renderMaxY < 1.0D || this.renderMinZ > 0.0D || this.renderMaxZ < 1.0D);
+        }
+    }
+
+    /**
+     * Used for falling blocks, and those being moved by pistons
+     */
+    public void RenderStandardFallingBlock( Block block, int i, int j, int k, int iMetadata )
+    {
+    	enableAO = false;
+    	
+        Tessellator tess = Tessellator.instance;
+        
+        tess.setBrightness( block.getMixedBrightnessForBlock( blockAccess, i, j, k ) );
+        
+        final float fBottomColor = 0.5F;
+        final float fTopColor = 1F;
+        final float fZColor = 0.8F;
+        final float fXColor = 0.6F;
+        
+        int iColorMultiplier = block.colorMultiplier( blockAccess, i, j, k );
+        
+        float fRedMul = (float)( iColorMultiplier >> 16 & 255 ) / 255F;
+        float fGreenMul = (float)( iColorMultiplier >> 8 & 255 ) / 255F;
+        float fBlueMul = (float)( iColorMultiplier & 255 ) / 255F;
+        
+        if ( block.ShouldSideBeRenderedOnFallingBlock( 0, iMetadata ) )
+    	{
+	        tess.setColorOpaque_F( fBottomColor * fRedMul, fBottomColor * fGreenMul, fBottomColor * fBlueMul );
+	        
+	        renderFaceYNeg(block, (double)i, (double)j, (double)k, 
+	        	getBlockIconFromSideAndMetadata(block, 0, iMetadata));
+    	}
+        
+        if ( block.ShouldSideBeRenderedOnFallingBlock( 1, iMetadata ) )
+    	{
+	        tess.setColorOpaque_F( fTopColor * fRedMul, fTopColor * fGreenMul, fTopColor * fBlueMul );
+	        
+	        renderFaceYPos(block, (double)i, (double)j, (double)k, 
+	        	getBlockIconFromSideAndMetadata(block, 1, iMetadata));
+    	}
+        
+        if ( block.ShouldSideBeRenderedOnFallingBlock( 2, iMetadata ) )
+    	{
+	        tess.setColorOpaque_F( fZColor * fRedMul, fZColor * fGreenMul, fZColor * fBlueMul );
+	        
+	        renderFaceZNeg(block, (double)i, (double)j, (double)k, 
+	        	getBlockIconFromSideAndMetadata(block, 2, iMetadata));
+    	}
+        
+        if ( block.ShouldSideBeRenderedOnFallingBlock( 3, iMetadata ) )
+    	{
+	        tess.setColorOpaque_F( fZColor * fRedMul, fZColor * fGreenMul, fZColor * fBlueMul );
+	        
+	        renderFaceZPos(block, (double)i, (double)j, (double)k, 
+	        	getBlockIconFromSideAndMetadata(block, 3, iMetadata));
+    	}
+        
+        if ( block.ShouldSideBeRenderedOnFallingBlock( 4, iMetadata ) )
+    	{
+	        tess.setColorOpaque_F( fXColor * fRedMul, fXColor * fGreenMul, fXColor * fBlueMul );
+	        
+	        renderFaceXNeg(block, (double)i, (double)j, (double)k, 
+	        	getBlockIconFromSideAndMetadata(block, 4, iMetadata));
+    	}
+        
+        if ( block.ShouldSideBeRenderedOnFallingBlock( 5, iMetadata ) )
+    	{
+	        tess.setColorOpaque_F( fXColor * fRedMul, fXColor * fGreenMul, fXColor * fBlueMul );
+	        
+	        renderFaceXPos(block, (double)i, (double)j, (double)k, 
+	        	getBlockIconFromSideAndMetadata(block, 5, iMetadata));
+    	}
+    }
+    
+    protected void RenderStandardFullBlockMovedByPiston( Block block, int i, int j, int k )
+    {
+		// this is used when the block is being moved by a piston so that faces
+		// aren't occluded by nearby blocks with RenderStandardFullBlock(), since that function
+    	// strips out all the renderAllFaces tests
+    	
+    	SetRenderAllFaces( true );
+    	
+        setRenderBoundsFromBlock( block);
+        renderStandardBlock( block, i, j, k );
+        
+    	SetRenderAllFaces( false );
+    }
+    
+    public boolean ShouldSideBeRenderedBasedOnCurrentBounds( int iNeighborI, 
+    	int iNeighborJ, int iNeighborK, int iSide )
+    {
+    	if ( 
+    		( iSide == 0 && renderMinY > 0D ) ||
+    		( iSide == 1 && renderMaxY < 1D ) ||
+    		( iSide == 2 && renderMinZ > 0D ) ||
+    		( iSide == 3 && renderMaxZ < 1D ) ||
+    		( iSide == 4 && renderMinX > 0D ) ||
+    		( iSide == 5 && renderMaxX < 1D )  
+		)
+    	{
+    		return true;
+    	}
+    		
+        Block neighborBlock = Block.blocksList[blockAccess.getBlockId( 
+        	iNeighborI, iNeighborJ, iNeighborK )];
+        
+        if ( neighborBlock != null )
+        {
+        	return neighborBlock.ShouldRenderNeighborFullFaceSide( blockAccess, 
+        		iNeighborI, iNeighborJ, iNeighborK, iSide ); 
+        }
+        
+        return true;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/RenderCow.java b/minecraft/net/minecraft/src/RenderCow.java
index f4339dd..08098bb 100644
--- a/minecraft/net/minecraft/src/RenderCow.java
+++ b/minecraft/net/minecraft/src/RenderCow.java
@@ -1,10 +1,18 @@
 package net.minecraft.src;
 
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
+
 public class RenderCow extends RenderLiving
 {
     public RenderCow(ModelBase par1ModelBase, float par2)
     {
         super(par1ModelBase, par2);
+        // FCMOD: Added (client only)        
+        m_ModelUdder = new FCClientModelCowUdder();
+        
+        setRenderPassModel(m_ModelUdder);
+        // END FCMOD
     }
 
     public void renderCow(EntityCow par1EntityCow, double par2, double par4, double par6, float par8, float par9)
@@ -26,5 +34,111 @@ public class RenderCow extends RenderLiving
     public void doRender(Entity par1Entity, double par2, double par4, double par6, float par8, float par9)
     {
         this.renderCow((EntityCow)par1Entity, par2, par4, par6, par8, par9);
+        // FCMOD: Added (client only)
+        //RenderKickAttackDebug( (FCEntityCow)par1Entity, par2, par4, par6, par8, par9 );
+        // END FCMOD
+    }
+    
+    // FCMOD: Added (client only)
+    FCClientModelCowUdder m_ModelUdder;
+    
+    protected int shouldRenderPass(EntityLiving par1EntityLiving, int par2, float par3)
+    {
+    	if ( par2 == 0 && ((FCEntityCow)par1EntityLiving).GotMilk() )
+    	{
+    		loadTexture( "/btwmodtex/cow_udder.png" );
+    		
+    		return 1;
+    	}
+    	
+        return -1;
+    }
+    
+    public void RenderKickAttackDebug( FCEntityCow cow, double dRenderX, double dRenderY, double dRenderZ, float par8, float dPartialTick)
+    {
+    		
+		Vec3 worldTipPos = cow.ComputeKickAttackCenter();
+		
+		double dLocalSourcePosX = dRenderX;
+		double dLocalSourcePosY = dRenderY + ( cow.height / 2F );
+		double dLocalSourcePosZ = dRenderZ;
+		
+		double dLocalTipPosX = ( worldTipPos.xCoord - cow.posX ) + dRenderX;
+		double dLocalTipPosY = ( worldTipPos.yCoord - cow.posY ) + dRenderY;
+		double dLocalTipPosZ = ( worldTipPos.zCoord - cow.posZ ) + dRenderZ;
+		
+        Tessellator tesslator = Tessellator.instance;
+        
+        GL11.glDisable(GL11.GL_TEXTURE_2D);
+        GL11.glDisable(GL11.GL_LIGHTING);
+        
+        tesslator.startDrawing(3);
+        
+		if ( cow.m_iKickAttackInProgressCounter >= 0 )
+		{
+            tesslator.setColorOpaque_I( 0xFF0000 );
+		}
+		else
+		{
+            tesslator.setColorOpaque_I(0);
+		}
+
+        tesslator.addVertex( dLocalSourcePosX, dLocalSourcePosY, dLocalSourcePosZ );
+        tesslator.addVertex( dLocalTipPosX, dLocalTipPosY, dLocalTipPosZ );
+        
+        tesslator.draw();
+        
+        tesslator.startDrawing(3);
+        
+		if ( cow.m_iKickAttackInProgressCounter >= 0 )
+		{
+            tesslator.setColorOpaque_I( 0xFFFF00 );
+		}
+		else
+		{
+            tesslator.setColorOpaque_I( 0xFFFFFF );
+		}
+
+        tesslator.addVertex( dLocalTipPosX + cow.m_dKickAttackTipCollisionHalfWidth, dLocalTipPosY, dLocalTipPosZ );
+        tesslator.addVertex( dLocalTipPosX - cow.m_dKickAttackTipCollisionHalfWidth, dLocalTipPosY, dLocalTipPosZ );
+        
+        tesslator.draw();
+        
+        tesslator.startDrawing(3);
+        
+		if ( cow.m_iKickAttackInProgressCounter >= 0 )
+		{
+            tesslator.setColorOpaque_I( 0xFFFF00 );
+		}
+		else
+		{
+            tesslator.setColorOpaque_I( 0xFFFFFF );
+		}
+
+        tesslator.addVertex( dLocalTipPosX, dLocalTipPosY, dLocalTipPosZ + cow.m_dKickAttackTipCollisionHalfWidth );
+        tesslator.addVertex( dLocalTipPosX, dLocalTipPosY, dLocalTipPosZ - cow.m_dKickAttackTipCollisionHalfWidth );
+        
+        tesslator.draw();
+        
+        tesslator.startDrawing(3);
+        
+		if ( cow.m_iKickAttackInProgressCounter >= 0 )
+		{
+            tesslator.setColorOpaque_I( 0xFFFF00 );
+		}
+		else
+		{
+            tesslator.setColorOpaque_I( 0xFFFFFF );
+		}
+
+        tesslator.addVertex( dLocalTipPosX, dLocalTipPosY + cow.m_dKickAttackTipCollisionHalfHeight, dLocalTipPosZ );
+        tesslator.addVertex( dLocalTipPosX, dLocalTipPosY - cow.m_dKickAttackTipCollisionHalfHeight, dLocalTipPosZ );
+        
+        tesslator.draw();
+        
+        GL11.glEnable(GL11.GL_LIGHTING);
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        
     }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderEnderman.java b/minecraft/net/minecraft/src/RenderEnderman.java
index 2f64f0f..813bed6 100644
--- a/minecraft/net/minecraft/src/RenderEnderman.java
+++ b/minecraft/net/minecraft/src/RenderEnderman.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mob.MobRandomizer;
 import java.util.Random;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
@@ -76,7 +78,7 @@ public class RenderEnderman extends RenderLiving
         }
         else
         {
-            this.loadTexture("/mob/enderman_eyes.png");
+        	this.loadTexture(FakeResourceLocation.unwrap(MobRandomizer.randomTexture((Entity)par1EntityEnderman, FakeResourceLocation.wrap("/mob/enderman_eyes.png"))));
             float var4 = 1.0F;
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glDisable(GL11.GL_ALPHA_TEST);
diff --git a/minecraft/net/minecraft/src/RenderEngine.java b/minecraft/net/minecraft/src/RenderEngine.java
index 95376f2..6b795c2 100644
--- a/minecraft/net/minecraft/src/RenderEngine.java
+++ b/minecraft/net/minecraft/src/RenderEngine.java
@@ -1,5 +1,9 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.CustomAnimation;
+import com.prupe.mcpatcher.hd.Wrapper15;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mal.resource.TexturePackChangeHandler;
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
@@ -115,10 +119,17 @@ public class RenderEngine
 
     private int[] getImageContents(BufferedImage par1BufferedImage, int[] par2ArrayOfInteger)
     {
-        int var3 = par1BufferedImage.getWidth();
-        int var4 = par1BufferedImage.getHeight();
-        par1BufferedImage.getRGB(0, 0, var3, var4, par2ArrayOfInteger, 0, var3);
-        return par2ArrayOfInteger;
+    	if (par1BufferedImage == null)
+        {
+            return par2ArrayOfInteger;
+        }
+        else
+        {
+            int var3 = par1BufferedImage.getWidth();
+            int var4 = par1BufferedImage.getHeight();
+            par1BufferedImage.getRGB(0, 0, var3, var4, par2ArrayOfInteger, 0, var3);
+            return par2ArrayOfInteger;
+        }
     }
 
     public void bindTexture(String par1Str)
@@ -126,7 +137,7 @@ public class RenderEngine
         this.bindTexture(this.getTexture(par1Str));
     }
 
-    private void bindTexture(int par1)
+    public void bindTexture(int par1)
     {
         if (par1 != this.boundTexture)
         {
@@ -140,7 +151,7 @@ public class RenderEngine
         this.boundTexture = -1;
     }
 
-    private int getTexture(String par1Str)
+    public int getTexture(String par1Str)
     {
         if (par1Str.equals("/terrain.png"))
         {
@@ -185,11 +196,11 @@ public class RenderEngine
 
                     if (var6 == null)
                     {
-                        this.setupTextureExt(this.missingTextureImage, var3, var9, var5);
+                    	Wrapper15.setupTexture(this, this.missingTextureImage, var3, var9, var5, FakeResourceLocation.wrap(par1Str));
                     }
                     else
                     {
-                        this.setupTextureExt(this.readTextureImage(var6), var3, var9, var5);
+                    	Wrapper15.setupTexture(this, this.readTextureImage(var6), var3, var9, var5, FakeResourceLocation.wrap(par1Str));
                     }
 
                     this.textureMap.put(var8, Integer.valueOf(var3));
@@ -228,41 +239,42 @@ public class RenderEngine
 
     public void setupTextureExt(BufferedImage par1BufferedImage, int par2, boolean par3, boolean par4)
     {
-        this.bindTexture(par2);
-        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
-        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
-
-        if (par3)
+    	if (par1BufferedImage != null)
         {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-        }
+    		this.bindTexture(par2);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
 
-        if (par4)
-        {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_CLAMP);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_CLAMP);
-        }
-        else
-        {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
-        }
+            if (par3)
+            {
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+            }
+
+            if (par4)
+            {
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_CLAMP);
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_CLAMP);
+            }
+            else
+            {
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
+            }
 
-        int var5 = par1BufferedImage.getWidth();
-        int var6 = par1BufferedImage.getHeight();
-        int[] var7 = new int[var5 * var6];
-        par1BufferedImage.getRGB(0, 0, var5, var6, var7, 0, var5);
+            int var5 = par1BufferedImage.getWidth();
+            int var6 = par1BufferedImage.getHeight();
+            int[] var7 = new int[var5 * var6];
+            par1BufferedImage.getRGB(0, 0, var5, var6, var7, 0, var5);
 
-        if (this.options != null && this.options.anaglyph)
-        {
-            var7 = this.colorToAnaglyph(var7);
-        }
+            if (this.options != null && this.options.anaglyph)
+            {
+                var7 = this.colorToAnaglyph(var7);
+            }
 
-        this.imageData.clear();
-        this.imageData.put(var7);
-        this.imageData.position(0).limit(var7.length);
-        GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, var5, var6, 0, GL12.GL_BGRA, GL12.GL_UNSIGNED_INT_8_8_8_8_REV, this.imageData);
+            this.imageData = FakeResourceLocation.getIntBuffer(this.imageData, var7);
+            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, var5, var6, 0, GL12.GL_BGRA, GL12.GL_UNSIGNED_INT_8_8_8_8_REV, this.imageData);
+        }
     }
 
     private int[] colorToAnaglyph(int[] par1ArrayOfInteger)
@@ -297,9 +309,7 @@ public class RenderEngine
             par1ArrayOfInteger = this.colorToAnaglyph(par1ArrayOfInteger);
         }
 
-        this.imageData.clear();
-        this.imageData.put(par1ArrayOfInteger);
-        this.imageData.position(0).limit(par1ArrayOfInteger.length);
+        this.imageData = FakeResourceLocation.getIntBuffer(this.imageData, par1ArrayOfInteger);
         GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, 0, 0, par2, par3, GL12.GL_BGRA, GL12.GL_UNSIGNED_INT_8_8_8_8_REV, this.imageData);
     }
 
@@ -393,6 +403,7 @@ public class RenderEngine
     {
         this.textureMapBlocks.updateAnimations();
         this.textureMapItems.updateAnimations();
+        CustomAnimation.updateAll();
     }
 
     /**
@@ -400,6 +411,7 @@ public class RenderEngine
      */
     public void refreshTextures()
     {
+    	TexturePackChangeHandler.beforeChange1();
         ITexturePack var1 = this.texturePack.getSelectedTexturePack();
         this.refreshTextureMaps();
         Iterator var2 = this.textureNameToImageMap.getKeySet().iterator();
@@ -444,7 +456,7 @@ public class RenderEngine
                 }
 
                 BufferedImage var5 = this.readTextureImage(var1.getResourceAsStream(var11));
-                this.setupTextureExt(var5, var12, var6, var7);
+                Wrapper15.setupTexture(this, var5, var12, var6, var7, FakeResourceLocation.wrap(var11));
             }
             catch (IOException var9)
             {
@@ -471,6 +483,7 @@ public class RenderEngine
 
         Minecraft.getMinecraft().fontRenderer.readFontData();
         Minecraft.getMinecraft().standardGalacticFontRenderer.readFontData();
+        TexturePackChangeHandler.afterChange1();
     }
 
     /**
@@ -478,9 +491,16 @@ public class RenderEngine
      */
     private BufferedImage readTextureImage(InputStream par1InputStream) throws IOException
     {
-        BufferedImage var2 = ImageIO.read(par1InputStream);
-        par1InputStream.close();
-        return var2;
+    	if (par1InputStream == null)
+        {
+            return null;
+        }
+        else
+        {
+            BufferedImage var2 = ImageIO.read(par1InputStream);
+            par1InputStream.close();
+            return var2;
+        }
     }
 
     public void refreshTextureMaps()
diff --git a/minecraft/net/minecraft/src/RenderFallingSand.java b/minecraft/net/minecraft/src/RenderFallingSand.java
index 22ab79c..5cc885f 100644
--- a/minecraft/net/minecraft/src/RenderFallingSand.java
+++ b/minecraft/net/minecraft/src/RenderFallingSand.java
@@ -19,8 +19,15 @@ public class RenderFallingSand extends Render
         World var10 = par1EntityFallingSand.getWorld();
         Block var11 = Block.blocksList[par1EntityFallingSand.blockID];
 
+        // FCMOD: Changed (client only)
+        /*
         if (var10.getBlockId(MathHelper.floor_double(par1EntityFallingSand.posX), MathHelper.floor_double(par1EntityFallingSand.posY), MathHelper.floor_double(par1EntityFallingSand.posZ)) != par1EntityFallingSand.blockID)
         {
+        */
+        if ( ShouldRender( var10, par1EntityFallingSand ) )
+        {
+            shadowSize = 0.5F;
+    	// END FCMOD
             GL11.glPushMatrix();
             GL11.glTranslatef((float)par2, (float)par4, (float)par6);
             this.loadTexture("/terrain.png");
@@ -49,13 +56,41 @@ public class RenderFallingSand extends Render
             }
             else if (var11 != null)
             {
+                // FCMOD: Changed (client only)
+            	/*
                 this.sandRenderBlocks.setRenderBoundsFromBlock(var11);
                 this.sandRenderBlocks.renderBlockSandFalling(var11, var10, MathHelper.floor_double(par1EntityFallingSand.posX), MathHelper.floor_double(par1EntityFallingSand.posY), MathHelper.floor_double(par1EntityFallingSand.posZ), par1EntityFallingSand.metadata);
+                */
+                sandRenderBlocks.blockAccess = var10;
+                
+                Tessellator.instance.startDrawingQuads();
+                
+                Tessellator.instance.setTranslation( -MathHelper.floor_double( par1EntityFallingSand.posX ) - 0.5D, 
+                	-MathHelper.floor_double( par1EntityFallingSand.posY ) - 0.5D, 
+                	-MathHelper.floor_double( par1EntityFallingSand.posZ ) - 0.5D );
+                
+                var11.m_currentBlockRenderer = sandRenderBlocks;
+            	
+		        var11.RenderFallingBlock( sandRenderBlocks, MathHelper.floor_double( par1EntityFallingSand.posX ), 
+		        	MathHelper.floor_double( par1EntityFallingSand.posY ), 
+		        	MathHelper.floor_double( par1EntityFallingSand.posZ ),
+		        	par1EntityFallingSand.metadata );
+		        
+		        Tessellator.instance.setTranslation( 0D, 0D, 0D );
+		        
+		        Tessellator.instance.draw();
+            	// END FCMOD
             }
 
             GL11.glEnable(GL11.GL_LIGHTING);
             GL11.glPopMatrix();
         }
+        // FCMOD: Added (client only)
+        else
+        {
+        	shadowSize = 0F;
+        }
+        // END FCMOD
     }
 
     /**
@@ -68,4 +103,18 @@ public class RenderFallingSand extends Render
     {
         this.doRenderFallingSand((EntityFallingSand)par1Entity, par2, par4, par6, par8, par9);
     }
+    
+    // FCMOD: Added (client only)
+    private boolean ShouldRender( World world, EntityFallingSand entity )
+    {
+        Block fallingBlock = Block.blocksList[entity.blockID];
+        
+        if ( fallingBlock != null )
+        {
+        	return fallingBlock.ShouldRenderWhileFalling( world, entity );
+        }
+        
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderFish.java b/minecraft/net/minecraft/src/RenderFish.java
index bc37f30..96af071 100644
--- a/minecraft/net/minecraft/src/RenderFish.java
+++ b/minecraft/net/minecraft/src/RenderFish.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mob.LineRenderer;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
@@ -68,21 +69,25 @@ public class RenderFish extends Render
             double var37 = (double)((float)(var23 - var46));
             double var39 = (double)((float)(var25 - var33));
             double var41 = (double)((float)(var27 - var35));
-            GL11.glDisable(GL11.GL_TEXTURE_2D);
-            GL11.glDisable(GL11.GL_LIGHTING);
-            var12.startDrawing(3);
-            var12.setColorOpaque_I(0);
-            byte var43 = 16;
-
-            for (int var44 = 0; var44 <= var43; ++var44)
+            
+            if (!LineRenderer.renderLine(0, par2, par4, par6, var37, var39, var41))
             {
-                float var45 = (float)var44 / (float)var43;
-                var12.addVertex(par2 + var37 * (double)var45, par4 + var39 * (double)(var45 * var45 + var45) * 0.5D + 0.25D, par6 + var41 * (double)var45);
-            }
+            	GL11.glDisable(GL11.GL_TEXTURE_2D);
+                GL11.glDisable(GL11.GL_LIGHTING);
+                var12.startDrawing(3);
+                var12.setColorOpaque_I(0);
+                byte var43 = 16;
 
-            var12.draw();
-            GL11.glEnable(GL11.GL_LIGHTING);
-            GL11.glEnable(GL11.GL_TEXTURE_2D);
+                for (int var44 = 0; var44 <= var43; ++var44)
+                {
+                    float var45 = (float)var44 / (float)var43;
+                    var12.addVertex(par2 + var37 * (double)var45, par4 + var39 * (double)(var45 * var45 + var45) * 0.5D + 0.25D, par6 + var41 * (double)var45);
+                }
+
+                var12.draw();
+                GL11.glEnable(GL11.GL_LIGHTING);
+                GL11.glEnable(GL11.GL_TEXTURE_2D);
+            }
         }
     }
 
diff --git a/minecraft/net/minecraft/src/RenderGlobal.java b/minecraft/net/minecraft/src/RenderGlobal.java
index cb85d1e..4d17d38 100644
--- a/minecraft/net/minecraft/src/RenderGlobal.java
+++ b/minecraft/net/minecraft/src/RenderGlobal.java
@@ -1,5 +1,10 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.renderpass.RenderPass;
+import com.prupe.mcpatcher.renderpass.RenderPassMap;
+import com.prupe.mcpatcher.sky.SkyRenderer;
 import java.nio.IntBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -158,7 +163,7 @@ public class RenderGlobal implements IWorldAccess
         this.renderEngine = par2RenderEngine;
         byte var3 = 34;
         byte var4 = 32;
-        this.glRenderListBase = GLAllocation.generateDisplayLists(var3 * var3 * var4 * 3);
+        this.glRenderListBase = GLAllocation.generateDisplayLists(var3 * var3 * var4 * 5);
         this.occlusionEnabled = OpenGlCapsChecker.checkARBOcclusion();
 
         if (this.occlusionEnabled)
@@ -365,7 +370,7 @@ public class RenderGlobal implements IWorldAccess
                         this.worldRenderers[(var6 * this.renderChunksTall + var5) * this.renderChunksWide + var4].markDirty();
                         this.sortedWorldRenderers[(var6 * this.renderChunksTall + var5) * this.renderChunksWide + var4] = this.worldRenderers[(var6 * this.renderChunksTall + var5) * this.renderChunksWide + var4];
                         this.worldRenderersToUpdate.add(this.worldRenderers[(var6 * this.renderChunksTall + var5) * this.renderChunksWide + var4]);
-                        var2 += 3;
+                        var2 += 5;
                     }
                 }
             }
@@ -433,7 +438,12 @@ public class RenderGlobal implements IWorldAccess
             {
                 var7 = (Entity)var5.get(var6);
 
+                // FCMOD: Code change so that entities may adjust their own visual bounding box for this test (client only)
+                /*
                 if (var7.isInRangeToRenderVec3D(par1Vec3) && (var7.ignoreFrustumCheck || par2ICamera.isBoundingBoxInFrustum(var7.boundingBox) || var7.riddenByEntity == this.mc.thePlayer) && (var7 != this.mc.renderViewEntity || this.mc.gameSettings.thirdPersonView != 0 || this.mc.renderViewEntity.isPlayerSleeping()) && this.theWorld.blockExists(MathHelper.floor_double(var7.posX), 0, MathHelper.floor_double(var7.posZ)))
+                */
+                if (var7.isInRangeToRenderVec3D(par1Vec3) && (var7.ignoreFrustumCheck || par2ICamera.isBoundingBoxInFrustum(var7.GetVisualBoundingBox()) || var7.riddenByEntity == this.mc.thePlayer) && (var7 != this.mc.renderViewEntity || this.mc.gameSettings.thirdPersonView != 0 || this.mc.renderViewEntity.isPlayerSleeping()) && this.theWorld.blockExists(MathHelper.floor_double(var7.posX), 0, MathHelper.floor_double(var7.posZ)))
+            	// END FCMOD
                 {
                     ++this.countEntitiesRendered;
                     RenderManager.instance.renderEntity(var7, par3);
@@ -565,175 +575,183 @@ public class RenderGlobal implements IWorldAccess
      */
     public int sortAndRender(EntityLiving par1EntityLiving, int par2, double par3)
     {
-        this.theWorld.theProfiler.startSection("sortchunks");
-
-        for (int var5 = 0; var5 < 10; ++var5)
+        if (!RenderPass.preRenderPass(RenderPassMap.map17To18(par2)))
         {
-            this.worldRenderersCheckIndex = (this.worldRenderersCheckIndex + 1) % this.worldRenderers.length;
-            WorldRenderer var6 = this.worldRenderers[this.worldRenderersCheckIndex];
-
-            if (var6.needsUpdate && !this.worldRenderersToUpdate.contains(var6))
-            {
-                this.worldRenderersToUpdate.add(var6);
-            }
+            return RenderPass.postRenderPass(0);
         }
-
-        if (this.mc.gameSettings.renderDistance != this.renderDistance)
+        else
         {
-            this.loadRenderers();
-        }
+            par2 = RenderPassMap.map18To17(par2);
+            this.theWorld.theProfiler.startSection("sortchunks");
 
-        if (par2 == 0)
-        {
-            this.renderersLoaded = 0;
-            this.dummyRenderInt = 0;
-            this.renderersBeingClipped = 0;
-            this.renderersBeingOccluded = 0;
-            this.renderersBeingRendered = 0;
-            this.renderersSkippingRenderPass = 0;
-        }
+            for (int var5 = 0; var5 < 10; ++var5)
+            {
+                this.worldRenderersCheckIndex = (this.worldRenderersCheckIndex + 1) % this.worldRenderers.length;
+                WorldRenderer var6 = this.worldRenderers[this.worldRenderersCheckIndex];
 
-        double var33 = par1EntityLiving.lastTickPosX + (par1EntityLiving.posX - par1EntityLiving.lastTickPosX) * par3;
-        double var7 = par1EntityLiving.lastTickPosY + (par1EntityLiving.posY - par1EntityLiving.lastTickPosY) * par3;
-        double var9 = par1EntityLiving.lastTickPosZ + (par1EntityLiving.posZ - par1EntityLiving.lastTickPosZ) * par3;
-        double var11 = par1EntityLiving.posX - this.prevSortX;
-        double var13 = par1EntityLiving.posY - this.prevSortY;
-        double var15 = par1EntityLiving.posZ - this.prevSortZ;
+                if (var6.needsUpdate && !this.worldRenderersToUpdate.contains(var6))
+                {
+                    this.worldRenderersToUpdate.add(var6);
+                }
+            }
 
-        if (var11 * var11 + var13 * var13 + var15 * var15 > 16.0D)
-        {
-            this.prevSortX = par1EntityLiving.posX;
-            this.prevSortY = par1EntityLiving.posY;
-            this.prevSortZ = par1EntityLiving.posZ;
-            this.markRenderersForNewPosition(MathHelper.floor_double(par1EntityLiving.posX), MathHelper.floor_double(par1EntityLiving.posY), MathHelper.floor_double(par1EntityLiving.posZ));
-            Arrays.sort(this.sortedWorldRenderers, new EntitySorter(par1EntityLiving));
-        }
+            if (this.mc.gameSettings.renderDistance != this.renderDistance)
+            {
+                this.loadRenderers();
+            }
 
-        RenderHelper.disableStandardItemLighting();
-        byte var17 = 0;
-        int var34;
+            if (par2 == 0)
+            {
+                this.renderersLoaded = 0;
+                this.dummyRenderInt = 0;
+                this.renderersBeingClipped = 0;
+                this.renderersBeingOccluded = 0;
+                this.renderersBeingRendered = 0;
+                this.renderersSkippingRenderPass = 0;
+            }
 
-        if (this.occlusionEnabled && this.mc.gameSettings.advancedOpengl && !this.mc.gameSettings.anaglyph && par2 == 0)
-        {
-            byte var18 = 0;
-            int var19 = 16;
-            this.checkOcclusionQueryResult(var18, var19);
+            double var33 = par1EntityLiving.lastTickPosX + (par1EntityLiving.posX - par1EntityLiving.lastTickPosX) * par3;
+            double var7 = par1EntityLiving.lastTickPosY + (par1EntityLiving.posY - par1EntityLiving.lastTickPosY) * par3;
+            double var9 = par1EntityLiving.lastTickPosZ + (par1EntityLiving.posZ - par1EntityLiving.lastTickPosZ) * par3;
+            double var11 = par1EntityLiving.posX - this.prevSortX;
+            double var13 = par1EntityLiving.posY - this.prevSortY;
+            double var15 = par1EntityLiving.posZ - this.prevSortZ;
 
-            for (int var20 = var18; var20 < var19; ++var20)
+            if (var11 * var11 + var13 * var13 + var15 * var15 > 16.0D)
             {
-                this.sortedWorldRenderers[var20].isVisible = true;
+                this.prevSortX = par1EntityLiving.posX;
+                this.prevSortY = par1EntityLiving.posY;
+                this.prevSortZ = par1EntityLiving.posZ;
+                this.markRenderersForNewPosition(MathHelper.floor_double(par1EntityLiving.posX), MathHelper.floor_double(par1EntityLiving.posY), MathHelper.floor_double(par1EntityLiving.posZ));
+                Arrays.sort(this.sortedWorldRenderers, new EntitySorter(par1EntityLiving));
             }
 
-            this.theWorld.theProfiler.endStartSection("render");
-            var34 = var17 + this.renderSortedRenderers(var18, var19, par2, par3);
+            RenderHelper.disableStandardItemLighting();
+            byte var17 = 0;
+            int var34;
 
-            do
+            if (this.occlusionEnabled && this.mc.gameSettings.advancedOpengl && !this.mc.gameSettings.anaglyph && par2 == 0)
             {
-                this.theWorld.theProfiler.endStartSection("occ");
-                int var35 = var19;
-                var19 *= 2;
+                byte var18 = 0;
+                int var19 = 16;
+                this.checkOcclusionQueryResult(var18, var19);
 
-                if (var19 > this.sortedWorldRenderers.length)
+                for (int var20 = var18; var20 < var19; ++var20)
                 {
-                    var19 = this.sortedWorldRenderers.length;
+                    this.sortedWorldRenderers[var20].isVisible = true;
                 }
 
-                GL11.glDisable(GL11.GL_TEXTURE_2D);
-                GL11.glDisable(GL11.GL_LIGHTING);
-                GL11.glDisable(GL11.GL_ALPHA_TEST);
-                GL11.glDisable(GL11.GL_FOG);
-                GL11.glColorMask(false, false, false, false);
-                GL11.glDepthMask(false);
-                this.theWorld.theProfiler.startSection("check");
-                this.checkOcclusionQueryResult(var35, var19);
-                this.theWorld.theProfiler.endSection();
-                GL11.glPushMatrix();
-                float var36 = 0.0F;
-                float var21 = 0.0F;
-                float var22 = 0.0F;
+                this.theWorld.theProfiler.endStartSection("render");
+                var34 = var17 + this.renderSortedRenderers(var18, var19, par2, par3);
 
-                for (int var23 = var35; var23 < var19; ++var23)
+                do
                 {
-                    if (this.sortedWorldRenderers[var23].skipAllRenderPasses())
+                    this.theWorld.theProfiler.endStartSection("occ");
+                    int var35 = var19;
+                    var19 *= 2;
+
+                    if (var19 > this.sortedWorldRenderers.length)
                     {
-                        this.sortedWorldRenderers[var23].isInFrustum = false;
+                        var19 = this.sortedWorldRenderers.length;
                     }
-                    else
+
+                    GL11.glDisable(GL11.GL_TEXTURE_2D);
+                    GL11.glDisable(GL11.GL_LIGHTING);
+                    GL11.glDisable(GL11.GL_ALPHA_TEST);
+                    GL11.glDisable(GL11.GL_FOG);
+                    GL11.glColorMask(false, false, false, false);
+                    GL11.glDepthMask(false);
+                    this.theWorld.theProfiler.startSection("check");
+                    this.checkOcclusionQueryResult(var35, var19);
+                    this.theWorld.theProfiler.endSection();
+                    GL11.glPushMatrix();
+                    float var36 = 0.0F;
+                    float var21 = 0.0F;
+                    float var22 = 0.0F;
+
+                    for (int var23 = var35; var23 < var19; ++var23)
                     {
-                        if (!this.sortedWorldRenderers[var23].isInFrustum)
+                        if (this.sortedWorldRenderers[var23].skipAllRenderPasses())
                         {
-                            this.sortedWorldRenderers[var23].isVisible = true;
+                            this.sortedWorldRenderers[var23].isInFrustum = false;
                         }
-
-                        if (this.sortedWorldRenderers[var23].isInFrustum && !this.sortedWorldRenderers[var23].isWaitingOnOcclusionQuery)
+                        else
                         {
-                            float var24 = MathHelper.sqrt_float(this.sortedWorldRenderers[var23].distanceToEntitySquared(par1EntityLiving));
-                            int var25 = (int)(1.0F + var24 / 128.0F);
+                            if (!this.sortedWorldRenderers[var23].isInFrustum)
+                            {
+                                this.sortedWorldRenderers[var23].isVisible = true;
+                            }
 
-                            if (this.cloudTickCounter % var25 == var23 % var25)
+                            if (this.sortedWorldRenderers[var23].isInFrustum && !this.sortedWorldRenderers[var23].isWaitingOnOcclusionQuery)
                             {
-                                WorldRenderer var26 = this.sortedWorldRenderers[var23];
-                                float var27 = (float)((double)var26.posXMinus - var33);
-                                float var28 = (float)((double)var26.posYMinus - var7);
-                                float var29 = (float)((double)var26.posZMinus - var9);
-                                float var30 = var27 - var36;
-                                float var31 = var28 - var21;
-                                float var32 = var29 - var22;
-
-                                if (var30 != 0.0F || var31 != 0.0F || var32 != 0.0F)
+                                float var24 = MathHelper.sqrt_float(this.sortedWorldRenderers[var23].distanceToEntitySquared(par1EntityLiving));
+                                int var25 = (int)(1.0F + var24 / 128.0F);
+
+                                if (this.cloudTickCounter % var25 == var23 % var25)
                                 {
-                                    GL11.glTranslatef(var30, var31, var32);
-                                    var36 += var30;
-                                    var21 += var31;
-                                    var22 += var32;
+                                    WorldRenderer var26 = this.sortedWorldRenderers[var23];
+                                    float var27 = (float)((double)var26.posXMinus - var33);
+                                    float var28 = (float)((double)var26.posYMinus - var7);
+                                    float var29 = (float)((double)var26.posZMinus - var9);
+                                    float var30 = var27 - var36;
+                                    float var31 = var28 - var21;
+                                    float var32 = var29 - var22;
+
+                                    if (var30 != 0.0F || var31 != 0.0F || var32 != 0.0F)
+                                    {
+                                        GL11.glTranslatef(var30, var31, var32);
+                                        var36 += var30;
+                                        var21 += var31;
+                                        var22 += var32;
+                                    }
+
+                                    this.theWorld.theProfiler.startSection("bb");
+                                    ARBOcclusionQuery.glBeginQueryARB(ARBOcclusionQuery.GL_SAMPLES_PASSED_ARB, this.sortedWorldRenderers[var23].glOcclusionQuery);
+                                    this.sortedWorldRenderers[var23].callOcclusionQueryList();
+                                    ARBOcclusionQuery.glEndQueryARB(ARBOcclusionQuery.GL_SAMPLES_PASSED_ARB);
+                                    this.theWorld.theProfiler.endSection();
+                                    this.sortedWorldRenderers[var23].isWaitingOnOcclusionQuery = true;
                                 }
-
-                                this.theWorld.theProfiler.startSection("bb");
-                                ARBOcclusionQuery.glBeginQueryARB(ARBOcclusionQuery.GL_SAMPLES_PASSED_ARB, this.sortedWorldRenderers[var23].glOcclusionQuery);
-                                this.sortedWorldRenderers[var23].callOcclusionQueryList();
-                                ARBOcclusionQuery.glEndQueryARB(ARBOcclusionQuery.GL_SAMPLES_PASSED_ARB);
-                                this.theWorld.theProfiler.endSection();
-                                this.sortedWorldRenderers[var23].isWaitingOnOcclusionQuery = true;
                             }
                         }
                     }
-                }
 
-                GL11.glPopMatrix();
+                    GL11.glPopMatrix();
 
-                if (this.mc.gameSettings.anaglyph)
-                {
-                    if (EntityRenderer.anaglyphField == 0)
+                    if (this.mc.gameSettings.anaglyph)
                     {
-                        GL11.glColorMask(false, true, true, true);
+                        if (EntityRenderer.anaglyphField == 0)
+                        {
+                            GL11.glColorMask(false, true, true, true);
+                        }
+                        else
+                        {
+                            GL11.glColorMask(true, false, false, true);
+                        }
                     }
                     else
                     {
-                        GL11.glColorMask(true, false, false, true);
+                        GL11.glColorMask(true, true, true, true);
                     }
-                }
-                else
-                {
-                    GL11.glColorMask(true, true, true, true);
-                }
 
-                GL11.glDepthMask(true);
-                GL11.glEnable(GL11.GL_TEXTURE_2D);
-                GL11.glEnable(GL11.GL_ALPHA_TEST);
-                GL11.glEnable(GL11.GL_FOG);
+                    GL11.glDepthMask(true);
+                    GL11.glEnable(GL11.GL_TEXTURE_2D);
+                    GL11.glEnable(GL11.GL_ALPHA_TEST);
+                    GL11.glEnable(GL11.GL_FOG);
+                    this.theWorld.theProfiler.endStartSection("render");
+                    var34 += this.renderSortedRenderers(var35, var19, par2, par3);
+                }
+                while (var19 < this.sortedWorldRenderers.length);
+            }
+            else
+            {
                 this.theWorld.theProfiler.endStartSection("render");
-                var34 += this.renderSortedRenderers(var35, var19, par2, par3);
+                var34 = var17 + this.renderSortedRenderers(0, this.sortedWorldRenderers.length, par2, par3);
             }
-            while (var19 < this.sortedWorldRenderers.length);
-        }
-        else
-        {
-            this.theWorld.theProfiler.endStartSection("render");
-            var34 = var17 + this.renderSortedRenderers(0, this.sortedWorldRenderers.length, par2, par3);
-        }
 
-        this.theWorld.theProfiler.endSection();
-        return var34;
+            this.theWorld.theProfiler.endSection();
+            return RenderPass.postRenderPass(var34);
+        }
     }
 
     private void checkOcclusionQueryResult(int par1, int par2)
@@ -844,7 +862,7 @@ public class RenderGlobal implements IWorldAccess
      */
     public void renderAllRenderLists(int par1, double par2)
     {
-        this.mc.entityRenderer.enableLightmap(par2);
+    	RenderPass.enableDisableLightmap(this.mc.entityRenderer, par2);
 
         for (int var4 = 0; var4 < this.allRenderLists.length; ++var4)
         {
@@ -880,6 +898,8 @@ public class RenderGlobal implements IWorldAccess
      */
     public void renderSky(float par1)
     {
+    	SkyRenderer.setup(this.theWorld, par1, this.theWorld.getCelestialAngle(par1));
+    	
         if (this.mc.theWorld.provider.dimensionId == 1)
         {
             GL11.glDisable(GL11.GL_FOG);
@@ -921,7 +941,7 @@ public class RenderGlobal implements IWorldAccess
                 }
 
                 var21.startDrawingQuads();
-                var21.setColorOpaque_I(2631720);
+                var21.setColorOpaque_I(ColorizeWorld.endSkyColor);
                 var21.addVertexWithUV(-100.0D, -100.0D, -100.0D, 0.0D, 0.0D);
                 var21.addVertexWithUV(-100.0D, -100.0D, 100.0D, 0.0D, 16.0D);
                 var21.addVertexWithUV(100.0D, -100.0D, 100.0D, 16.0D, 16.0D);
@@ -1022,9 +1042,10 @@ public class RenderGlobal implements IWorldAccess
             GL11.glColor4f(1.0F, 1.0F, 1.0F, var8);
             GL11.glTranslatef(var9, var10, var11);
             GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
+            SkyRenderer.renderAll();
             GL11.glRotatef(this.theWorld.getCelestialAngle(par1) * 360.0F, 1.0F, 0.0F, 0.0F);
             var12 = 30.0F;
-            this.renderEngine.bindTexture("/environment/sun.png");
+            this.renderEngine.bindTexture(FakeResourceLocation.unwrap(SkyRenderer.setupCelestialObject(FakeResourceLocation.wrap("/environment/sun.png"))));
             var23.startDrawingQuads();
             var23.addVertexWithUV((double)(-var12), 100.0D, (double)(-var12), 0.0D, 0.0D);
             var23.addVertexWithUV((double)var12, 100.0D, (double)(-var12), 1.0D, 0.0D);
@@ -1032,14 +1053,14 @@ public class RenderGlobal implements IWorldAccess
             var23.addVertexWithUV((double)(-var12), 100.0D, (double)var12, 0.0D, 1.0D);
             var23.draw();
             var12 = 20.0F;
-            this.renderEngine.bindTexture("/environment/moon_phases.png");
+            this.renderEngine.bindTexture(FakeResourceLocation.unwrap(SkyRenderer.setupCelestialObject(FakeResourceLocation.wrap("/environment/moon_phases.png"))));
             int var28 = this.theWorld.getMoonPhase();
-            int var29 = var28 % 4;
-            int var30 = var28 / 4 % 2;
-            float var16 = (float)(var29 + 0) / 4.0F;
-            float var17 = (float)(var30 + 0) / 2.0F;
-            float var18 = (float)(var29 + 1) / 4.0F;
-            float var19 = (float)(var30 + 1) / 2.0F;
+            int var30 = var28 % 4;
+            int var29 = var28 / 4 % 2;
+            float var16 = (float)(var30 + 0) / 4.0F;
+            float var17 = (float)(var29 + 0) / 2.0F;
+            float var18 = (float)(var30 + 1) / 4.0F;
+            float var19 = (float)(var29 + 1) / 2.0F;
             var23.startDrawingQuads();
             var23.addVertexWithUV((double)(-var12), -100.0D, (double)var12, (double)var18, (double)var19);
             var23.addVertexWithUV((double)var12, -100.0D, (double)var12, (double)var16, (double)var19);
@@ -1049,7 +1070,7 @@ public class RenderGlobal implements IWorldAccess
             GL11.glDisable(GL11.GL_TEXTURE_2D);
             float var20 = this.theWorld.getStarBrightness(par1) * var8;
 
-            if (var20 > 0.0F)
+            if (var20 > 0.0F && !SkyRenderer.active)
             {
                 GL11.glColor4f(var20, var20, var20, var20);
                 GL11.glCallList(this.starGLCallList);
@@ -1108,7 +1129,7 @@ public class RenderGlobal implements IWorldAccess
             }
 
             GL11.glPushMatrix();
-            GL11.glTranslatef(0.0F, -((float)(var25 - 16.0D)), 0.0F);
+            GL11.glTranslatef(0.0F, -((float)(var25 - SkyRenderer.horizonHeight)), 0.0F);
             GL11.glCallList(this.glSkyList2);
             GL11.glPopMatrix();
             GL11.glEnable(GL11.GL_TEXTURE_2D);
@@ -1120,7 +1141,7 @@ public class RenderGlobal implements IWorldAccess
     {
         if (this.mc.theWorld.provider.isSurfaceWorld())
         {
-            if (this.mc.gameSettings.fancyGraphics)
+        	if (ColorizeWorld.drawFancyClouds(this.mc.gameSettings.fancyGraphics))
             {
                 this.renderCloudsFancy(par1);
             }
@@ -1217,8 +1238,8 @@ public class RenderGlobal implements IWorldAccess
         float var17 = (float)var15.yCoord;
         float var18 = (float)var15.zCoord;
         float var19;
-        float var20;
         float var21;
+        float var20;
 
         if (this.mc.gameSettings.anaglyph)
         {
@@ -1587,7 +1608,13 @@ public class RenderGlobal implements IWorldAccess
                         var19 = Block.stone;
                     }
 
+                    // FCMOD: Changed
+                    /*
                     this.globalRenderBlocks.renderBlockUsingTexture(var19, var11.getPartialBlockX(), var11.getPartialBlockY(), var11.getPartialBlockZ(), this.destroyBlockIcons[var11.getPartialBlockDamage()]);
+                    */
+                    var19.RenderBlockWithTexture( globalRenderBlocks, var11.getPartialBlockX(), var11.getPartialBlockY(), var11.getPartialBlockZ(), 
+                		destroyBlockIcons[var11.getPartialBlockDamage()] );
+                    // END FCMOD
                 }
             }
 
@@ -1620,11 +1647,17 @@ public class RenderGlobal implements IWorldAccess
 
             if (var7 > 0)
             {
-                Block.blocksList[var7].setBlockBoundsBasedOnState(this.theWorld, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ);
+            	// FCMOD: Removed (client only)
+                //Block.blocksList[var7].setBlockBoundsBasedOnState(this.theWorld, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ);
+            	// END FCMOD
                 double var8 = par1EntityPlayer.lastTickPosX + (par1EntityPlayer.posX - par1EntityPlayer.lastTickPosX) * (double)par5;
                 double var10 = par1EntityPlayer.lastTickPosY + (par1EntityPlayer.posY - par1EntityPlayer.lastTickPosY) * (double)par5;
                 double var12 = par1EntityPlayer.lastTickPosZ + (par1EntityPlayer.posZ - par1EntityPlayer.lastTickPosZ) * (double)par5;
-                this.drawOutlinedBoundingBox(Block.blocksList[var7].getSelectedBoundingBoxFromPool(this.theWorld, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ).expand((double)var6, (double)var6, (double)var6).getOffsetBoundingBox(-var8, -var10, -var12));
+                // FCMOD: Changed (client only)
+                //this.drawOutlinedBoundingBox(Block.blocksList[var7].getSelectedBoundingBoxFromPool(this.theWorld, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ).expand((double)var6, (double)var6, (double)var6).getOffsetBoundingBox(-var8, -var10, -var12));
+            	drawOutlinedBoundingBox( Block.blocksList[var7].getSelectedBoundingBoxFromPool( theWorld, par2MovingObjectPosition ).
+                	expand((double)var6, (double)var6, (double)var6).getOffsetBoundingBox(-var8, -var10, -var12));
+                // END FCMOD
             }
 
             GL11.glDepthMask(true);
@@ -1835,6 +1868,17 @@ public class RenderGlobal implements IWorldAccess
             {
                 this.mc.effectRenderer.addEffect(var21 = new EntityFireworkSparkFX(this.theWorld, par2, par4, par6, par8, par10, par12, this.mc.effectRenderer));
             }
+            // FCMOD: Added (client only)
+            else if ( par1Str.equals( "fccinders" ) )
+            {
+            	double dDistSqToPlayer = var15 * var15 + var17 * var17 + var19 * var19;
+            	
+            	if ( dDistSqToPlayer < 32D * 32D )
+            	{
+            		this.mc.effectRenderer.addEffect( var21 = new FCClientEntityCindersFX(this.theWorld, par2, par4, par6) );
+            	}
+            }
+            // END FCMOD
 
             if (var21 != null)
             {
@@ -2003,6 +2047,23 @@ public class RenderGlobal implements IWorldAccess
                         int var26 = Integer.parseInt(var28[2]);
                         var21 = (new EntityDiggingFX(this.theWorld, par2, par4, par6, par8, par10, par12, Block.blocksList[var25], 0, var26, this.renderEngine)).applyRenderColor(var26);
                     }
+                    // FCMOD: Added (client only)
+                    else if ( par1Str.equals( "fcwhitesmoke" ) )
+                    {
+                        var21 = new FCClientEntityWhiteSmokeFX(theWorld, par2, par4, par6, par8, par10, par12);
+                    }
+                    else if ( par1Str.equals( "fcwhitecloud" ) )
+                    {
+                        var21 = new FCClientEntityWhiteCloudFX(theWorld, par2, par4, par6, par8, par10, par12);
+                    }
+                    else if ( par1Str.equals( "fcsmallflame" ) )
+                    {
+                        var21 = new FCClientEntitySmallFlameFX(theWorld, par2, par4, par6, par8, par10, par12);
+                    }
+                    else {
+                    	var21 = FCAddOnHandler.spawnCustomParticle(this.theWorld, par1Str, par2, par4, par6, par8, par10, par12);
+                    }
+                    // END FCMOD
 
                     if (var21 != null)
                     {
@@ -2099,6 +2160,11 @@ public class RenderGlobal implements IWorldAccess
                 }
 
             default:
+            	// FCMOD: Code added:            	
+            	FCAddOnHandler.ClientPlayCustomAuxFX( mc, theWorld, null, par1, par2, par3, par4, par5 );
+            	
+                break;
+                // END FCMOD
         }
     }
 
@@ -2196,6 +2262,10 @@ public class RenderGlobal implements IWorldAccess
 
             case 1016:
                 this.theWorld.playSound((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.zombie.infect", 2.0F, (var7.nextFloat() - var7.nextFloat()) * 0.2F + 1.0F, false);
+                // FCMOD: Added extra slow zombie moan on infect villager
+                theWorld.playSound( (double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.zombie.say", 
+                	1.0F + var7.nextFloat(), var7.nextFloat() * 0.2F + 0.5F, false );
+                // END FCMOD
                 break;
 
             case 1017:
@@ -2221,7 +2291,7 @@ public class RenderGlobal implements IWorldAccess
                 var12 = (double)par4 + 0.5D;
                 double var34 = (double)par5 + (double)var9 * 0.6D + 0.5D;
 
-                for (int var36 = 0; var36 < 10; ++var36)
+                for (int var35 = 0; var35 < 10; ++var35)
                 {
                     double var37 = var7.nextDouble() * 0.2D + 0.01D;
                     double var38 = var10 + (double)var33 * 0.01D + (var7.nextDouble() - 0.5D) * (double)var9 * 0.5D;
@@ -2300,10 +2370,10 @@ public class RenderGlobal implements IWorldAccess
                     this.spawnParticle(var14, var8, var10, var12, var7.nextGaussian() * 0.15D, var7.nextDouble() * 0.2D, var7.nextGaussian() * 0.15D);
                 }
 
-                for (double var35 = 0.0D; var35 < (Math.PI * 2D); var35 += 0.15707963267948966D)
+                for (double var36 = 0.0D; var36 < (Math.PI * 2D); var36 += 0.15707963267948966D)
                 {
-                    this.spawnParticle("portal", var8 + Math.cos(var35) * 5.0D, var10 - 0.4D, var12 + Math.sin(var35) * 5.0D, Math.cos(var35) * -5.0D, 0.0D, Math.sin(var35) * -5.0D);
-                    this.spawnParticle("portal", var8 + Math.cos(var35) * 5.0D, var10 - 0.4D, var12 + Math.sin(var35) * 5.0D, Math.cos(var35) * -7.0D, 0.0D, Math.sin(var35) * -7.0D);
+                    this.spawnParticle("portal", var8 + Math.cos(var36) * 5.0D, var10 - 0.4D, var12 + Math.sin(var36) * 5.0D, Math.cos(var36) * -5.0D, 0.0D, Math.sin(var36) * -5.0D);
+                    this.spawnParticle("portal", var8 + Math.cos(var36) * 5.0D, var10 - 0.4D, var12 + Math.sin(var36) * 5.0D, Math.cos(var36) * -7.0D, 0.0D, Math.sin(var36) * -7.0D);
                 }
 
                 return;
@@ -2322,6 +2392,14 @@ public class RenderGlobal implements IWorldAccess
 
             case 2005:
                 ItemDye.func_96603_a(this.theWorld, par3, par4, par5, par6);
+
+        	// FCMOD: Code added:
+            default:
+            	
+            	FCAddOnHandler.ClientPlayCustomAuxFX( mc, theWorld, par1EntityPlayer, par2, par3, par4, par5, par6 );
+            	
+                break;
+        	// END FCMOD
         }
     }
 
@@ -2359,4 +2437,16 @@ public class RenderGlobal implements IWorldAccess
             this.destroyBlockIcons[var2] = par1IconRegister.registerIcon("destroy_" + var2);
         }
     }
+    
+    // FCMOD: Added
+    public Icon GetDestroyedBlockIcon( int iBlockDamage )
+    {
+    	if ( iBlockDamage >= 10 || iBlockDamage < 0 )
+    	{
+    		iBlockDamage = 0;
+    	}
+    	
+    	return destroyBlockIcons[iBlockDamage];
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderItem.java b/minecraft/net/minecraft/src/RenderItem.java
index ffb4c86..ca352f1 100644
--- a/minecraft/net/minecraft/src/RenderItem.java
+++ b/minecraft/net/minecraft/src/RenderItem.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cit.CITUtils;
 import java.util.Random;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
@@ -16,6 +17,10 @@ public class RenderItem extends Render
     /** Defines the zLevel of rendering of item on GUI. */
     public float zLevel = 0.0F;
     public static boolean renderInFrame = false;
+    
+    // FCMOD: Added (client only)
+    public static boolean m_bForceFancyItemRender = false;
+    // END FCMOD
 
     public RenderItem()
     {
@@ -61,13 +66,18 @@ public class RenderItem extends Render
             GL11.glTranslatef((float)par2, (float)par4 + var11, (float)par6);
             GL11.glEnable(GL12.GL_RESCALE_NORMAL);
             int var17;
-            float var18;
             float var19;
+            float var18;
             float var20;
 
+            // FCMOD: Changed (client only)
+            /*
             if (var10.getItemSpriteNumber() == 0 && Block.blocksList[var10.itemID] != null && RenderBlocks.renderItemIn3d(Block.blocksList[var10.itemID].getRenderType()))
+            */
+            if (var10.getItemSpriteNumber() == 0 && Block.blocksList[var10.itemID] != null && Block.blocksList[var10.itemID].DoesItemRenderAsBlock( var10.getItemDamage() ) )
+            // END FCMOD
             {
-                Block var22 = Block.blocksList[var10.itemID];
+                Block var21 = Block.blocksList[var10.itemID];
                 GL11.glRotatef(var12, 0.0F, 1.0F, 0.0F);
 
                 if (renderInFrame)
@@ -78,15 +88,15 @@ public class RenderItem extends Render
                 }
 
                 this.loadTexture("/terrain.png");
-                float var24 = 0.25F;
-                int var25 = var22.getRenderType();
+                float var25 = 0.25F;
+                int var24 = var21.getRenderType();
 
-                if (var25 == 1 || var25 == 19 || var25 == 12 || var25 == 2)
+                if (var24 == 1 || var24 == 19 || var24 == 12 || var24 == 2)
                 {
-                    var24 = 0.5F;
+                    var25 = 0.5F;
                 }
 
-                GL11.glScalef(var24, var24, var24);
+                GL11.glScalef(var25, var25, var25);
 
                 for (var17 = 0; var17 < var13; ++var17)
                 {
@@ -94,14 +104,14 @@ public class RenderItem extends Render
 
                     if (var17 > 0)
                     {
-                        var18 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / var24;
-                        var19 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / var24;
-                        var20 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / var24;
+                        var18 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / var25;
+                        var19 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / var25;
+                        var20 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / var25;
                         GL11.glTranslatef(var18, var19, var20);
                     }
 
                     var18 = 1.0F;
-                    this.itemRenderBlocks.renderBlockAsItem(var22, var10.getItemDamage(), var18);
+                    this.itemRenderBlocks.renderBlockAsItem(var21, var10.getItemDamage(), var18);
                     GL11.glPopMatrix();
                 }
             }
@@ -126,7 +136,7 @@ public class RenderItem extends Render
                     for (int var14 = 0; var14 <= 1; ++var14)
                     {
                         this.random.setSeed(187L);
-                        Icon var15 = var10.getItem().getIconFromDamageForRenderPass(var10.getItemDamage(), var14);
+                        Icon var15 = CITUtils.getIcon(var10.getItem().getIconFromDamageForRenderPass(var10.getItemDamage(), var14), var10, var14);
                         var16 = 1.0F;
 
                         if (this.renderWithColor)
@@ -156,7 +166,7 @@ public class RenderItem extends Render
                         GL11.glScalef(0.5F, 0.5F, 0.5F);
                     }
 
-                    Icon var21 = var10.getIconIndex();
+                    Icon var23 = var10.getIconIndex();
 
                     if (var10.getItemSpriteNumber() == 0)
                     {
@@ -169,16 +179,16 @@ public class RenderItem extends Render
 
                     if (this.renderWithColor)
                     {
-                        int var23 = Item.itemsList[var10.itemID].getColorFromItemStack(var10, 0);
-                        var16 = (float)(var23 >> 16 & 255) / 255.0F;
-                        float var26 = (float)(var23 >> 8 & 255) / 255.0F;
-                        var18 = (float)(var23 & 255) / 255.0F;
+                        int var22 = Item.itemsList[var10.itemID].getColorFromItemStack(var10, 0);
+                        var16 = (float)(var22 >> 16 & 255) / 255.0F;
+                        float var26 = (float)(var22 >> 8 & 255) / 255.0F;
+                        var18 = (float)(var22 & 255) / 255.0F;
                         var19 = 1.0F;
-                        this.renderDroppedItem(par1EntityItem, var21, var13, par9, var16 * var19, var26 * var19, var18 * var19);
+                        this.renderDroppedItem(par1EntityItem, var23, var13, par9, var16 * var19, var26 * var19, var18 * var19);
                     }
                     else
                     {
-                        this.renderDroppedItem(par1EntityItem, var21, var13, par9, 1.0F, 1.0F, 1.0F);
+                        this.renderDroppedItem(par1EntityItem, var23, var13, par9, 1.0F, 1.0F, 1.0F);
                     }
                 }
             }
@@ -209,7 +219,10 @@ public class RenderItem extends Render
         float var15 = 0.25F;
         float var17;
 
-        if (this.renderManager.options.fancyGraphics)
+        // FCMOD: Changed (client only)
+        //if (this.renderManager.options.fancyGraphics)
+        if ( this.renderManager.options.fancyGraphics || m_bForceFancyItemRender )
+    	// END FCMOD
         {
             GL11.glPushMatrix();
 
@@ -263,7 +276,7 @@ public class RenderItem extends Render
                 GL11.glColor4f(par5, par6, par7, 1.0F);
                 ItemRenderer.renderItemIn2D(var8, var10, var11, var9, var12, par2Icon.getSheetWidth(), par2Icon.getSheetHeight(), var16);
 
-                if (var18 != null && var18.hasEffect())
+                if (var18 != null && !CITUtils.renderEnchantmentDropped(var18) && var18.hasEffect())
                 {
                     GL11.glDepthFunc(GL11.GL_EQUAL);
                     GL11.glDisable(GL11.GL_LIGHTING);
@@ -306,9 +319,9 @@ public class RenderItem extends Render
                 if (var25 > 0)
                 {
                     var17 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
-                    float var26 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                     float var27 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
-                    GL11.glTranslatef(var17, var26, var27);
+                    float var26 = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
+                    GL11.glTranslatef(var17, var27, var26);
                 }
 
                 if (!renderInFrame)
@@ -339,9 +352,14 @@ public class RenderItem extends Render
         Icon var8 = par3ItemStack.getIconIndex();
         float var12;
         float var13;
-        float var18;
+        float var16;
 
+        // FCMOD: Changed (client only)
+        /*
         if (par3ItemStack.getItemSpriteNumber() == 0 && RenderBlocks.renderItemIn3d(Block.blocksList[var6].getRenderType()))
+        */
+        if (par3ItemStack.getItemSpriteNumber() == 0 && Block.blocksList[var6].DoesItemRenderAsBlock( par3ItemStack.getItemDamage() ) )
+        // END FCMOD
         {
             par2RenderEngine.bindTexture("/terrain.png");
             Block var15 = Block.blocksList[var6];
@@ -352,14 +370,14 @@ public class RenderItem extends Render
             GL11.glScalef(1.0F, 1.0F, -1.0F);
             GL11.glRotatef(210.0F, 1.0F, 0.0F, 0.0F);
             GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
-            int var17 = Item.itemsList[var6].getColorFromItemStack(par3ItemStack, 0);
-            var18 = (float)(var17 >> 16 & 255) / 255.0F;
-            var12 = (float)(var17 >> 8 & 255) / 255.0F;
-            var13 = (float)(var17 & 255) / 255.0F;
+            int var18 = Item.itemsList[var6].getColorFromItemStack(par3ItemStack, 0);
+            var16 = (float)(var18 >> 16 & 255) / 255.0F;
+            var12 = (float)(var18 >> 8 & 255) / 255.0F;
+            var13 = (float)(var18 & 255) / 255.0F;
 
             if (this.renderWithColor)
             {
-                GL11.glColor4f(var18, var12, var13, 1.0F);
+                GL11.glColor4f(var16, var12, var13, 1.0F);
             }
 
             GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
@@ -379,7 +397,7 @@ public class RenderItem extends Render
 
                 for (var9 = 0; var9 <= 1; ++var9)
                 {
-                    Icon var10 = Item.itemsList[var6].getIconFromDamageForRenderPass(var7, var9);
+                	Icon var10 = CITUtils.getIcon(Item.itemsList[var6].getIconFromDamageForRenderPass(var7, var9), par3ItemStack, var9);
                     int var11 = Item.itemsList[var6].getColorFromItemStack(par3ItemStack, var9);
                     var12 = (float)(var11 >> 16 & 255) / 255.0F;
                     var13 = (float)(var11 >> 8 & 255) / 255.0F;
@@ -414,13 +432,13 @@ public class RenderItem extends Render
                 }
 
                 var9 = Item.itemsList[var6].getColorFromItemStack(par3ItemStack, 0);
-                float var16 = (float)(var9 >> 16 & 255) / 255.0F;
-                var18 = (float)(var9 >> 8 & 255) / 255.0F;
+                float var17 = (float)(var9 >> 16 & 255) / 255.0F;
+                var16 = (float)(var9 >> 8 & 255) / 255.0F;
                 var12 = (float)(var9 & 255) / 255.0F;
 
                 if (this.renderWithColor)
                 {
-                    GL11.glColor4f(var16, var18, var12, 1.0F);
+                    GL11.glColor4f(var17, var16, var12, 1.0F);
                 }
 
                 this.renderIcon(par4, par5, var8, 16, 16);
@@ -440,7 +458,7 @@ public class RenderItem extends Render
         {
             this.renderItemIntoGUI(par1FontRenderer, par2RenderEngine, par3ItemStack, par4, par5);
 
-            if (par3ItemStack.hasEffect())
+            if (!CITUtils.renderEnchantmentGUI(par3ItemStack, par4, par5, this.zLevel) && par3ItemStack.hasEffect())
             {
                 GL11.glDepthFunc(GL11.GL_GREATER);
                 GL11.glDisable(GL11.GL_LIGHTING);
diff --git a/minecraft/net/minecraft/src/RenderItemFrame.java b/minecraft/net/minecraft/src/RenderItemFrame.java
index b7a8573..432b845 100644
--- a/minecraft/net/minecraft/src/RenderItemFrame.java
+++ b/minecraft/net/minecraft/src/RenderItemFrame.java
@@ -124,6 +124,8 @@ public class RenderItemFrame extends Render
             {
                 TextureCompass var9;
 
+                // FCMOD: Removed
+                /*
                 if (var3.getEntityItem().getItem() == Item.compass)
                 {
                     var9 = TextureCompass.compassTexture;
@@ -135,16 +137,22 @@ public class RenderItemFrame extends Render
                     var9.currentAngle = var10;
                     var9.angleDelta = var7;
                 }
+                */
+                // END FCMOD
 
                 RenderItem.renderInFrame = true;
                 RenderManager.instance.renderEntityWithPosYaw(var3, 0.0D, 0.0D, 0.0D, 0.0F, 0.0F);
                 RenderItem.renderInFrame = false;
 
+                // FCMOD: Removed
+                /*
                 if (var3.getEntityItem().getItem() == Item.compass)
                 {
                     var9 = TextureCompass.compassTexture;
                     var9.updateAnimation();
                 }
+                */
+                // END FCMOD
             }
 
             GL11.glPopMatrix();
diff --git a/minecraft/net/minecraft/src/RenderLiving.java b/minecraft/net/minecraft/src/RenderLiving.java
index 476ce6f..53d7fd7 100644
--- a/minecraft/net/minecraft/src/RenderLiving.java
+++ b/minecraft/net/minecraft/src/RenderLiving.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cit.CITUtils;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mob.MobRandomizer;
 import java.util.Random;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
@@ -79,6 +82,12 @@ public class RenderLiving extends Render
             float var10 = this.interpolateRotation(par1EntityLiving.prevRenderYawOffset, par1EntityLiving.renderYawOffset, par9);
             float var11 = this.interpolateRotation(par1EntityLiving.prevRotationYawHead, par1EntityLiving.rotationYawHead, par9);
             float var12 = par1EntityLiving.prevRotationPitch + (par1EntityLiving.rotationPitch - par1EntityLiving.prevRotationPitch) * par9;
+            // FCMOD: Added (client only)
+            if ( par1EntityLiving.HasHeadCrabbedSquid() )
+            {
+            	var12 = 0;
+            }
+            // END IF
             this.renderLivingAt(par1EntityLiving, par2, par4, par6);
             float var13 = this.handleRotationFloat(par1EntityLiving, par9);
             this.rotateCorpse(par1EntityLiving, var13, var10, par9);
@@ -103,8 +112,8 @@ public class RenderLiving extends Render
             GL11.glEnable(GL11.GL_ALPHA_TEST);
             this.mainModel.setLivingAnimations(par1EntityLiving, var16, var15, par9);
             this.renderModel(par1EntityLiving, var16, var15, var13, var11 - var10, var12, var14);
-            int var18;
             float var19;
+            int var18;
             float var20;
             float var22;
 
@@ -123,7 +132,15 @@ public class RenderLiving extends Render
                         this.renderPassModel.render(par1EntityLiving, var16, var15, var13, var11 - var10, var12, var14);
                     }
 
-                    if ((var18 & 15) == 15)
+                    if (CITUtils.setupArmorEnchantments(par1EntityLiving, var17))
+                    {
+                        while (CITUtils.preRenderArmorEnchantment())
+                        {
+                            this.renderPassModel.render(par1EntityLiving, var16, var15, var13, var11 - var10, var12, var14);
+                            CITUtils.postRenderArmorEnchantment();
+                        }
+                    }
+                    else if ((var18 & 15) == 15)
                     {
                         var19 = (float)par1EntityLiving.ticksExisted + par9;
                         this.loadTexture("%blur%/misc/glint.png");
@@ -200,16 +217,16 @@ public class RenderLiving extends Render
                 {
                     var19 = (float)(var18 >> 16 & 255) / 255.0F;
                     var20 = (float)(var18 >> 8 & 255) / 255.0F;
-                    float var28 = (float)(var18 & 255) / 255.0F;
+                    float var29 = (float)(var18 & 255) / 255.0F;
                     var22 = (float)(var18 >> 24 & 255) / 255.0F;
-                    GL11.glColor4f(var19, var20, var28, var22);
+                    GL11.glColor4f(var19, var20, var29, var22);
                     this.mainModel.render(par1EntityLiving, var16, var15, var13, var11 - var10, var12, var14);
 
-                    for (int var29 = 0; var29 < 4; ++var29)
+                    for (int var28 = 0; var28 < 4; ++var28)
                     {
-                        if (this.inheritRenderPass(par1EntityLiving, var29, par9) >= 0)
+                        if (this.inheritRenderPass(par1EntityLiving, var28, par9) >= 0)
                         {
-                            GL11.glColor4f(var19, var20, var28, var22);
+                            GL11.glColor4f(var19, var20, var29, var22);
                             this.renderPassModel.render(par1EntityLiving, var16, var15, var13, var11 - var10, var12, var14);
                         }
                     }
@@ -269,7 +286,7 @@ public class RenderLiving extends Render
 
     protected void func_98190_a(EntityLiving par1EntityLiving)
     {
-        this.loadTexture(par1EntityLiving.getTexture());
+    	this.loadTexture(FakeResourceLocation.unwrap(MobRandomizer.randomTexture((Entity)par1EntityLiving, FakeResourceLocation.wrap(par1EntityLiving.getTexture()))));
     }
 
     /**
@@ -412,6 +429,12 @@ public class RenderLiving extends Render
 
                 if (par1EntityLiving.isSneaking())
                 {
+                	// FCMOD: Code added
+                	if ( FCBetterThanWolves.IsHardcorePlayerNamesEnabled( par1EntityLiving.worldObj ) )
+                	{
+                		return;
+                	}
+                	// END FCMOD
                     FontRenderer var14 = this.getFontRendererFromRenderManager();
                     GL11.glPushMatrix();
                     GL11.glTranslatef((float)par2 + 0.0F, (float)par4 + par1EntityLiving.height + 0.5F, (float)par6);
@@ -481,8 +504,17 @@ public class RenderLiving extends Render
             GL11.glRotatef(this.renderManager.playerViewX, 1.0F, 0.0F, 0.0F);
             GL11.glScalef(-var14, -var14, var14);
             GL11.glDisable(GL11.GL_LIGHTING);
+            
             GL11.glDepthMask(false);
+            // FCMOD: Changed so that player names aren't visible through walls
+            /*
             GL11.glDisable(GL11.GL_DEPTH_TEST);
+            */
+        	if ( !FCBetterThanWolves.AreHardcorePlayerNamesObstructed( par1EntityLiving.worldObj ) )
+        	{
+                GL11.glDisable(GL11.GL_DEPTH_TEST);
+        	}
+            // END FCMOD
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
             Tessellator var15 = Tessellator.instance;
@@ -503,6 +535,7 @@ public class RenderLiving extends Render
             var15.addVertex((double)(var17 + 1), (double)(-1 + var16), 0.0D);
             var15.draw();
             GL11.glEnable(GL11.GL_TEXTURE_2D);
+            
             var12.drawString(par2Str, -var12.getStringWidth(par2Str) / 2, var16, 553648127);
             GL11.glEnable(GL11.GL_DEPTH_TEST);
             GL11.glDepthMask(true);
diff --git a/minecraft/net/minecraft/src/RenderManager.java b/minecraft/net/minecraft/src/RenderManager.java
index 8c011da..8f37753 100644
--- a/minecraft/net/minecraft/src/RenderManager.java
+++ b/minecraft/net/minecraft/src/RenderManager.java
@@ -329,4 +329,13 @@ public class RenderManager
             var3.updateIcons(par1IconRegister);
         }
     }
+    
+    // FCMOD: Added (client only)
+    public static void AddEntityRenderer( Class entityClass, Render entityRenderer )
+    {
+        instance.entityRenderMap.put( entityClass, entityRenderer );
+        
+        entityRenderer.setRenderManager( instance );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderMooshroom.java b/minecraft/net/minecraft/src/RenderMooshroom.java
index 21fa3e0..99639eb 100644
--- a/minecraft/net/minecraft/src/RenderMooshroom.java
+++ b/minecraft/net/minecraft/src/RenderMooshroom.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mob.MobOverlay;
 import org.lwjgl.opengl.GL11;
 
 public class RenderMooshroom extends RenderLiving
@@ -7,6 +9,11 @@ public class RenderMooshroom extends RenderLiving
     public RenderMooshroom(ModelBase par1ModelBase, float par2)
     {
         super(par1ModelBase, par2);
+        // FCMOD: Added (client only)        
+        m_ModelUdder = new FCClientModelCowUdder();
+        
+        setRenderPassModel(m_ModelUdder);
+        // END FCMOD
     }
 
     public void renderLivingMooshroom(EntityMooshroom par1EntityMooshroom, double par2, double par4, double par6, float par8, float par9)
@@ -18,27 +25,53 @@ public class RenderMooshroom extends RenderLiving
     {
         super.renderEquippedItems(par1EntityMooshroom, par2);
 
-        if (!par1EntityMooshroom.isChild())
+        if (par1EntityMooshroom.isChild())
         {
-            this.loadTexture("/terrain.png");
+        	MobOverlay.finishMooshroom();
+        }
+        else
+        {
+            this.loadTexture(FakeResourceLocation.unwrap(MobOverlay.setupMooshroom(par1EntityMooshroom, FakeResourceLocation.wrap("/terrain.png"))));
             GL11.glEnable(GL11.GL_CULL_FACE);
             GL11.glPushMatrix();
             GL11.glScalef(1.0F, -1.0F, 1.0F);
             GL11.glTranslatef(0.2F, 0.4F, 0.5F);
             GL11.glRotatef(42.0F, 0.0F, 1.0F, 0.0F);
-            this.renderBlocks.renderBlockAsItem(Block.mushroomRed, 0, 1.0F);
+            
+            if (!MobOverlay.renderMooshroomOverlay(0.0D))
+            {
+                this.renderBlocks.renderBlockAsItem(Block.mushroomRed, 0, 1.0F);
+            }
+            
             GL11.glTranslatef(0.1F, 0.0F, -0.6F);
             GL11.glRotatef(42.0F, 0.0F, 1.0F, 0.0F);
-            this.renderBlocks.renderBlockAsItem(Block.mushroomRed, 0, 1.0F);
+            // FCMOD: Added (client only) to not display mid mushroom if starving
+            if ( !par1EntityMooshroom.IsStarving() )
+        	// END FCMOD
+            	
+        	if (!MobOverlay.renderMooshroomOverlay(0.0D))
+            {
+                this.renderBlocks.renderBlockAsItem(Block.mushroomRed, 0, 1.0F);
+            }
+            
             GL11.glPopMatrix();
             GL11.glPushMatrix();
             ((ModelQuadruped)this.mainModel).head.postRender(0.0625F);
             GL11.glScalef(1.0F, -1.0F, 1.0F);
             GL11.glTranslatef(0.0F, 0.75F, -0.2F);
             GL11.glRotatef(12.0F, 0.0F, 1.0F, 0.0F);
-            this.renderBlocks.renderBlockAsItem(Block.mushroomRed, 0, 1.0F);
+            // FCMOD: Added (client only) to not display head mushroom if not full
+            if ( par1EntityMooshroom.IsFullyFed() )
+        	// END FCMOD
+            	
+        	if (!MobOverlay.renderMooshroomOverlay(0.0D))
+            {
+                this.renderBlocks.renderBlockAsItem(Block.mushroomRed, 0, 1.0F);
+            }
+            
             GL11.glPopMatrix();
             GL11.glDisable(GL11.GL_CULL_FACE);
+            MobOverlay.finishMooshroom();
         }
     }
 
@@ -62,4 +95,20 @@ public class RenderMooshroom extends RenderLiving
     {
         this.renderLivingMooshroom((EntityMooshroom)par1Entity, par2, par4, par6, par8, par9);
     }
+    
+    // FCMOD: Added New (client only)
+    FCClientModelCowUdder m_ModelUdder;
+    
+    protected int shouldRenderPass(EntityLiving par1EntityLiving, int par2, float par3)
+    {
+    	if ( par2 == 0 && ((FCEntityCow)par1EntityLiving).GotMilk() )
+    	{
+    		loadTexture( "/btwmodtex/cow_udder.png" );
+    		
+    		return 1;
+    	}
+    	
+        return -1;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderPlayer.java b/minecraft/net/minecraft/src/RenderPlayer.java
index 50ddf04..a014493 100644
--- a/minecraft/net/minecraft/src/RenderPlayer.java
+++ b/minecraft/net/minecraft/src/RenderPlayer.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cit.CITUtils;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
 import org.lwjgl.opengl.GL11;
 
 public class RenderPlayer extends RenderLiving
@@ -11,10 +13,18 @@ public class RenderPlayer extends RenderLiving
 
     public RenderPlayer()
     {
+    	// FCMOD: Code change to use custom player model
+    	/*
         super(new ModelBiped(0.0F), 0.5F);
         this.modelBipedMain = (ModelBiped)this.mainModel;
         this.modelArmorChestplate = new ModelBiped(1.0F);
         this.modelArmor = new ModelBiped(0.5F);
+        */
+        super(new FCClientModelPlayer(0.0F), 0.5F);
+        this.modelBipedMain = (ModelBiped)this.mainModel;
+        this.modelArmorChestplate = new FCClientModelPlayerArmor(1.0F);
+        this.modelArmor = new FCClientModelPlayerArmor(0.5F);
+        // END FCMOD
     }
 
     protected void func_98191_a(EntityPlayer par1EntityPlayer)
@@ -36,7 +46,13 @@ public class RenderPlayer extends RenderLiving
             if (var5 instanceof ItemArmor)
             {
                 ItemArmor var6 = (ItemArmor)var5;
-                this.loadTexture("/armor/" + armorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + ".png");
+                // FCMOD: Code added
+                if ( var5 instanceof FCItemArmorMod )
+                {
+                	return ShouldRenderPassModArmor( var4, par2, (FCItemArmorMod)var5 );
+                }
+            	// END FCMOD
+                this.loadTexture(FakeResourceLocation.unwrap(CITUtils.getArmorTexture(FakeResourceLocation.wrap("/armor/" + armorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + ".png"), par1EntityPlayer, var4)));
                 ModelBiped var7 = par2 == 2 ? this.modelArmor : this.modelArmorChestplate;
                 var7.bipedHead.showModel = par2 == 0;
                 var7.bipedHeadwear.showModel = par2 == 0;
@@ -104,8 +120,16 @@ public class RenderPlayer extends RenderLiving
 
             if (var5 instanceof ItemArmor)
             {
+            	// FCMOD
+            	if ( var5 instanceof FCItemArmorMod )
+            	{
+            		LoadSecondLayerOfModArmorTexture( par2, (FCItemArmorMod)var5 );
+            		
+                	return;
+            	}
+            	// END FCMOD
                 ItemArmor var6 = (ItemArmor)var5;
-                this.loadTexture("/armor/" + armorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + "_b.png");
+                this.loadTexture(FakeResourceLocation.unwrap(CITUtils.getArmorTexture(FakeResourceLocation.wrap("/armor/" + armorFilenamePrefix[var6.renderIndex] + "_" + (par2 == 2 ? 2 : 1) + "_b.png"), par1EntityPlayer, var4)));
                 float var7 = 1.0F;
                 GL11.glColor3f(var7, var7, var7);
             }
@@ -164,9 +188,17 @@ public class RenderPlayer extends RenderLiving
             this.modelBipedMain.bipedHead.postRender(0.0625F);
             float var5;
 
-            if (var4.getItem().itemID < 256)
+            // FCMOD: Change
+            //if (var4.getItem().itemID < 256)
+            if ( var4.getItem().itemID < 4096 && Block.blocksList[var4.itemID] != null )
+        	// END FCMOD
             {
+            	// FCMOD: Code change
+            	/*
                 if (RenderBlocks.renderItemIn3d(Block.blocksList[var4.itemID].getRenderType()))
+                */
+                if ( Block.blocksList[var4.itemID].DoesItemRenderAsBlock( var4.getItemDamage() ) )
+            	// END FCMOD
                 {
                     var5 = 0.625F;
                     GL11.glTranslatef(0.0F, -0.25F, 0.0F);
@@ -200,15 +232,15 @@ public class RenderPlayer extends RenderLiving
         {
             for (int var20 = 0; var20 < 2; ++var20)
             {
-                float var23 = par1EntityPlayer.prevRotationYaw + (par1EntityPlayer.rotationYaw - par1EntityPlayer.prevRotationYaw) * par2 - (par1EntityPlayer.prevRenderYawOffset + (par1EntityPlayer.renderYawOffset - par1EntityPlayer.prevRenderYawOffset) * par2);
+                float var25 = par1EntityPlayer.prevRotationYaw + (par1EntityPlayer.rotationYaw - par1EntityPlayer.prevRotationYaw) * par2 - (par1EntityPlayer.prevRenderYawOffset + (par1EntityPlayer.renderYawOffset - par1EntityPlayer.prevRenderYawOffset) * par2);
                 var7 = par1EntityPlayer.prevRotationPitch + (par1EntityPlayer.rotationPitch - par1EntityPlayer.prevRotationPitch) * par2;
                 GL11.glPushMatrix();
-                GL11.glRotatef(var23, 0.0F, 1.0F, 0.0F);
+                GL11.glRotatef(var25, 0.0F, 1.0F, 0.0F);
                 GL11.glRotatef(var7, 1.0F, 0.0F, 0.0F);
                 GL11.glTranslatef(0.375F * (float)(var20 * 2 - 1), 0.0F, 0.0F);
                 GL11.glTranslatef(0.0F, -0.375F, 0.0F);
                 GL11.glRotatef(-var7, 1.0F, 0.0F, 0.0F);
-                GL11.glRotatef(-var23, 0.0F, 1.0F, 0.0F);
+                GL11.glRotatef(-var25, 0.0F, 1.0F, 0.0F);
                 var8 = 1.3333334F;
                 GL11.glScalef(var8, var8, var8);
                 this.modelBipedMain.renderEars(0.0625F);
@@ -222,7 +254,7 @@ public class RenderPlayer extends RenderLiving
         {
             GL11.glPushMatrix();
             GL11.glTranslatef(0.0F, 0.0F, 0.125F);
-            double var21 = par1EntityPlayer.field_71091_bM + (par1EntityPlayer.field_71094_bP - par1EntityPlayer.field_71091_bM) * (double)par2 - (par1EntityPlayer.prevPosX + (par1EntityPlayer.posX - par1EntityPlayer.prevPosX) * (double)par2);
+            double var22 = par1EntityPlayer.field_71091_bM + (par1EntityPlayer.field_71094_bP - par1EntityPlayer.field_71091_bM) * (double)par2 - (par1EntityPlayer.prevPosX + (par1EntityPlayer.posX - par1EntityPlayer.prevPosX) * (double)par2);
             double var24 = par1EntityPlayer.field_71096_bN + (par1EntityPlayer.field_71095_bQ - par1EntityPlayer.field_71096_bN) * (double)par2 - (par1EntityPlayer.prevPosY + (par1EntityPlayer.posY - par1EntityPlayer.prevPosY) * (double)par2);
             double var9 = par1EntityPlayer.field_71097_bO + (par1EntityPlayer.field_71085_bR - par1EntityPlayer.field_71097_bO) * (double)par2 - (par1EntityPlayer.prevPosZ + (par1EntityPlayer.posZ - par1EntityPlayer.prevPosZ) * (double)par2);
             var11 = par1EntityPlayer.prevRenderYawOffset + (par1EntityPlayer.renderYawOffset - par1EntityPlayer.prevRenderYawOffset) * par2;
@@ -240,8 +272,8 @@ public class RenderPlayer extends RenderLiving
                 var16 = 32.0F;
             }
 
-            float var17 = (float)(var21 * var12 + var9 * var14) * 100.0F;
-            float var18 = (float)(var21 * var14 - var9 * var12) * 100.0F;
+            float var17 = (float)(var22 * var12 + var9 * var14) * 100.0F;
+            float var18 = (float)(var22 * var14 - var9 * var12) * 100.0F;
 
             if (var17 < 0.0F)
             {
@@ -264,9 +296,9 @@ public class RenderPlayer extends RenderLiving
             GL11.glPopMatrix();
         }
 
-        ItemStack var22 = par1EntityPlayer.inventory.getCurrentItem();
+        ItemStack var21 = par1EntityPlayer.inventory.getCurrentItem();
 
-        if (var22 != null)
+        if (var21 != null)
         {
             GL11.glPushMatrix();
             this.modelBipedMain.bipedRightArm.postRender(0.0625F);
@@ -274,17 +306,22 @@ public class RenderPlayer extends RenderLiving
 
             if (par1EntityPlayer.fishEntity != null)
             {
-                var22 = new ItemStack(Item.stick);
+                var21 = new ItemStack(Item.stick);
             }
 
-            EnumAction var25 = null;
+            EnumAction var23 = null;
 
             if (par1EntityPlayer.getItemInUseCount() > 0)
             {
-                var25 = var22.getItemUseAction();
+                var23 = var21.getItemUseAction();
             }
 
-            if (var22.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var22.itemID].getRenderType()))
+            // FCMOD: Change
+            /*
+            if (var21.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var21.itemID].getRenderType()))
+            */
+            if ( var21.itemID < 4096 && Block.blocksList[var21.itemID] != null && Block.blocksList[var21.itemID].DoesItemRenderAsBlock( var21.getItemDamage() ) )
+            // END FCMOD
             {
                 var7 = 0.5F;
                 GL11.glTranslatef(0.0F, 0.1875F, -0.3125F);
@@ -293,7 +330,12 @@ public class RenderPlayer extends RenderLiving
                 GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
                 GL11.glScalef(-var7, -var7, var7);
             }
-            else if (var22.itemID == Item.bow.itemID)
+            // FCMOD: Changed line
+			/*
+            else if (var21.itemID == Item.bow.itemID)
+			*/
+            else if (var21.itemID == Item.bow.itemID || var21.itemID == FCBetterThanWolves.fcItemCompositeBow.itemID )
+        	// END FCMOD            	
             {
                 var7 = 0.625F;
                 GL11.glTranslatef(0.0F, 0.125F, 0.3125F);
@@ -302,17 +344,17 @@ public class RenderPlayer extends RenderLiving
                 GL11.glRotatef(-100.0F, 1.0F, 0.0F, 0.0F);
                 GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
             }
-            else if (Item.itemsList[var22.itemID].isFull3D())
+            else if (Item.itemsList[var21.itemID].isFull3D())
             {
                 var7 = 0.625F;
 
-                if (Item.itemsList[var22.itemID].shouldRotateAroundWhenRendering())
+                if (Item.itemsList[var21.itemID].shouldRotateAroundWhenRendering())
                 {
                     GL11.glRotatef(180.0F, 0.0F, 0.0F, 1.0F);
                     GL11.glTranslatef(0.0F, -0.125F, 0.0F);
                 }
 
-                if (par1EntityPlayer.getItemInUseCount() > 0 && var25 == EnumAction.block)
+                if (par1EntityPlayer.getItemInUseCount() > 0 && var23 == EnumAction.block)
                 {
                     GL11.glTranslatef(0.05F, 0.0F, -0.1F);
                     GL11.glRotatef(-50.0F, 0.0F, 1.0F, 0.0F);
@@ -339,26 +381,26 @@ public class RenderPlayer extends RenderLiving
             int var27;
             float var28;
 
-            if (var22.getItem().requiresMultipleRenderPasses())
+            if (var21.getItem().requiresMultipleRenderPasses())
             {
                 for (var27 = 0; var27 <= 1; ++var27)
                 {
-                    int var26 = var22.getItem().getColorFromItemStack(var22, var27);
+                    int var26 = var21.getItem().getColorFromItemStack(var21, var27);
                     var28 = (float)(var26 >> 16 & 255) / 255.0F;
                     var10 = (float)(var26 >> 8 & 255) / 255.0F;
                     var11 = (float)(var26 & 255) / 255.0F;
                     GL11.glColor4f(var28, var10, var11, 1.0F);
-                    this.renderManager.itemRenderer.renderItem(par1EntityPlayer, var22, var27);
+                    this.renderManager.itemRenderer.renderItem(par1EntityPlayer, var21, var27);
                 }
             }
             else
             {
-                var27 = var22.getItem().getColorFromItemStack(var22, 0);
+                var27 = var21.getItem().getColorFromItemStack(var21, 0);
                 var8 = (float)(var27 >> 16 & 255) / 255.0F;
                 var28 = (float)(var27 >> 8 & 255) / 255.0F;
                 var10 = (float)(var27 & 255) / 255.0F;
                 GL11.glColor4f(var8, var28, var10, 1.0F);
-                this.renderManager.itemRenderer.renderItem(par1EntityPlayer, var22, 0);
+                this.renderManager.itemRenderer.renderItem(par1EntityPlayer, var21, 0);
             }
 
             GL11.glPopMatrix();
@@ -373,6 +415,12 @@ public class RenderPlayer extends RenderLiving
 
     protected void func_96450_a(EntityPlayer par1EntityPlayer, double par2, double par4, double par6, String par8Str, float par9, double par10)
     {
+    	// FCMOD: Code added
+    	if ( FCBetterThanWolves.IsHardcorePlayerNamesEnabled( par1EntityPlayer.worldObj ) )
+    	{
+    		return;
+    	}
+    	// END FCMOD
         if (par10 < 100.0D)
         {
             Scoreboard var12 = par1EntityPlayer.getWorldScoreboard();
@@ -504,4 +552,71 @@ public class RenderPlayer extends RenderLiving
     {
         this.renderPlayer((EntityPlayer)par1Entity, par2, par4, par6, par8, par9);
     }
+    
+    // FCMOD: Code Added    
+    private int ShouldRenderPassModArmor( ItemStack stack, int iArmorSlot, FCItemArmorMod armorItem )
+    {
+        loadTexture( armorItem.GetWornTextureDirectory() + armorItem.GetWornTexturePrefix() + "_" + (iArmorSlot == 2 ? 2 : 1) + ".png");
+        
+        ModelBiped model = iArmorSlot == 2 ? this.modelArmor : this.modelArmorChestplate;
+        
+        model.bipedHead.showModel = iArmorSlot == 0;
+        model.bipedHeadwear.showModel = iArmorSlot == 0;
+        model.bipedBody.showModel = iArmorSlot == 1 || iArmorSlot == 2;
+        model.bipedRightArm.showModel = iArmorSlot == 1;
+        model.bipedLeftArm.showModel = iArmorSlot == 1;
+        model.bipedRightLeg.showModel = iArmorSlot == 2 || iArmorSlot == 3;
+        model.bipedLeftLeg.showModel = iArmorSlot == 2 || iArmorSlot == 3;
+        
+        setRenderPassModel(model);
+
+        if (model != null)
+        {
+            model.onGround = this.mainModel.onGround;
+            model.isRiding = this.mainModel.isRiding;
+            model.isChild = this.mainModel.isChild;
+        }
+
+        if ( armorItem.HasCustomColors() )
+        {
+            int iColor = armorItem.getColor( stack );
+            
+            float fRed = (float)(iColor >> 16 & 255) / 255.0F;
+            float fGreen = (float)(iColor >> 8 & 255) / 255.0F;
+            float fBlue = (float)(iColor & 255) / 255.0F;
+            
+            GL11.glColor3f( fRed, fGreen, fBlue);
+        }
+        else
+        {
+            GL11.glColor3f( 1F, 1F, 1F);
+        }
+
+        if ( armorItem.HasSecondRenderLayerWhenWorn() )
+        {
+	        if (stack.isItemEnchanted())
+	        {
+	            return 31;
+	        }
+	
+	        return 16;
+        }
+        else
+        {        
+	        if ( stack.isItemEnchanted() )
+	        {
+	            return 15;
+	        }
+	
+	        return 1;
+        }
+    }
+    
+    private void LoadSecondLayerOfModArmorTexture( int iArmorSlot, FCItemArmorMod armorItem )
+    {
+        loadTexture( armorItem.GetWornTextureDirectory() + armorItem.GetWornTexturePrefix() + "_" + (iArmorSlot == 2 ? 2 : 1) + "_b.png");
+	    
+	    GL11.glColor3f(1F, 1F, 1F);
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderSheep.java b/minecraft/net/minecraft/src/RenderSheep.java
index e19a1bc..a4b95de 100644
--- a/minecraft/net/minecraft/src/RenderSheep.java
+++ b/minecraft/net/minecraft/src/RenderSheep.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mob.MobRandomizer;
 import org.lwjgl.opengl.GL11;
 
 public class RenderSheep extends RenderLiving
@@ -14,7 +16,7 @@ public class RenderSheep extends RenderLiving
     {
         if (par2 == 0 && !par1EntitySheep.getSheared())
         {
-            this.loadTexture("/mob/sheep_fur.png");
+        	this.loadTexture(FakeResourceLocation.unwrap(MobRandomizer.randomTexture((Entity)par1EntitySheep, FakeResourceLocation.wrap("/mob/sheep_fur.png"))));
             float var4 = 1.0F;
             int var5 = par1EntitySheep.getFleeceColor();
             GL11.glColor3f(var4 * EntitySheep.fleeceColorTable[var5][0], var4 * EntitySheep.fleeceColorTable[var5][1], var4 * EntitySheep.fleeceColorTable[var5][2]);
diff --git a/minecraft/net/minecraft/src/RenderSnowMan.java b/minecraft/net/minecraft/src/RenderSnowMan.java
index bb3f80a..d4e0971 100644
--- a/minecraft/net/minecraft/src/RenderSnowMan.java
+++ b/minecraft/net/minecraft/src/RenderSnowMan.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mob.MobOverlay;
 import org.lwjgl.opengl.GL11;
 
 public class RenderSnowMan extends RenderLiving
@@ -22,12 +23,20 @@ public class RenderSnowMan extends RenderLiving
         super.renderEquippedItems(par1EntitySnowman, par2);
         ItemStack var3 = new ItemStack(Block.pumpkin, 1);
 
-        if (var3 != null && var3.getItem().itemID < 256)
+        // FCMOD: Changed (client only)
+        //if (var3 != null && var3.getItem().itemID < 256)
+        if ( var3 != null && var3.getItem().itemID < 4096 && Block.blocksList[var3.itemID] != null )
+    	// END FCMOD
         {
             GL11.glPushMatrix();
             this.snowmanModel.head.postRender(0.0625F);
 
+            // FCMOD: Changed (client only)
+            /*
             if (RenderBlocks.renderItemIn3d(Block.blocksList[var3.itemID].getRenderType()))
+            */
+            if ( Block.blocksList[var3.itemID].DoesItemRenderAsBlock( var3.getItemDamage() ) )
+            // END FCMOD
             {
                 float var4 = 0.625F;
                 GL11.glTranslatef(0.0F, -0.34375F, 0.0F);
@@ -35,7 +44,11 @@ public class RenderSnowMan extends RenderLiving
                 GL11.glScalef(var4, -var4, var4);
             }
 
-            this.renderManager.itemRenderer.renderItem(par1EntitySnowman, var3, 0);
+            if (!MobOverlay.renderSnowmanOverlay(par1EntitySnowman))
+            {
+                this.renderManager.itemRenderer.renderItem(par1EntitySnowman, var3, 0);
+            }
+            
             GL11.glPopMatrix();
         }
     }
diff --git a/minecraft/net/minecraft/src/RenderSnowball.java b/minecraft/net/minecraft/src/RenderSnowball.java
index 46b24a7..67b5f40 100644
--- a/minecraft/net/minecraft/src/RenderSnowball.java
+++ b/minecraft/net/minecraft/src/RenderSnowball.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cit.CITUtils;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
@@ -27,7 +28,7 @@ public class RenderSnowball extends Render
      */
     public void doRender(Entity par1Entity, double par2, double par4, double par6, float par8, float par9)
     {
-        Icon var10 = this.field_94151_a.getIconFromDamage(this.field_94150_f);
+    	Icon var10 = CITUtils.getEntityIcon(this.field_94151_a.getIconFromDamage(this.field_94150_f), par1Entity);
 
         if (var10 != null)
         {
diff --git a/minecraft/net/minecraft/src/RenderSpider.java b/minecraft/net/minecraft/src/RenderSpider.java
index 81825c5..76c6d57 100644
--- a/minecraft/net/minecraft/src/RenderSpider.java
+++ b/minecraft/net/minecraft/src/RenderSpider.java
@@ -1,5 +1,9 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mob.MobRandomizer;
 import org.lwjgl.opengl.GL11;
 
 public class RenderSpider extends RenderLiving
@@ -26,7 +30,7 @@ public class RenderSpider extends RenderLiving
         }
         else
         {
-            this.loadTexture("/mob/spider_eyes.png");
+        	this.loadTexture(FakeResourceLocation.unwrap(MobRandomizer.randomTexture((Entity)par1EntitySpider, FakeResourceLocation.wrap("/mob/spider_eyes.png"))));
             float var4 = 1.0F;
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glDisable(GL11.GL_ALPHA_TEST);
diff --git a/minecraft/net/minecraft/src/RenderTNTPrimed.java b/minecraft/net/minecraft/src/RenderTNTPrimed.java
index fe55320..ecc4f4b 100644
--- a/minecraft/net/minecraft/src/RenderTNTPrimed.java
+++ b/minecraft/net/minecraft/src/RenderTNTPrimed.java
@@ -48,6 +48,9 @@ public class RenderTNTPrimed extends Render
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_DST_ALPHA);
             GL11.glColor4f(1.0F, 1.0F, 1.0F, var10);
+            // FCMOD: Code added to prevent texture shimmering
+            GL11.glScalef(1.001F, 1.001F, 1.001F);
+            // END FCMOD
             this.blockRenderer.renderBlockAsItem(Block.tnt, 0, 1.0F);
             GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
             GL11.glDisable(GL11.GL_BLEND);
diff --git a/minecraft/net/minecraft/src/RenderVillager.java b/minecraft/net/minecraft/src/RenderVillager.java
index e02c326..ae16df3 100644
--- a/minecraft/net/minecraft/src/RenderVillager.java
+++ b/minecraft/net/minecraft/src/RenderVillager.java
@@ -11,6 +11,10 @@ public class RenderVillager extends RenderLiving
     {
         super(new ModelVillager(0.0F), 0.5F);
         this.villagerModel = (ModelVillager)this.mainModel;
+        
+        // FCMOD: Added (client only)
+        setRenderPassModel( villagerModel );
+        // END FCMOD
     }
 
     /**
@@ -18,7 +22,12 @@ public class RenderVillager extends RenderLiving
      */
     protected int shouldVillagerRenderPass(EntityVillager par1EntityVillager, int par2, float par3)
     {
+    	// FCMOD: Changed (client only)
+    	/*
         return -1;
+        */
+        return renderEyes( par1EntityVillager, par2 );
+        // END FCMOD
     }
 
     public void renderVillager(EntityVillager par1EntityVillager, double par2, double par4, double par6, float par8, float par9)
@@ -85,4 +94,43 @@ public class RenderVillager extends RenderLiving
     {
         this.renderVillager((EntityVillager)par1Entity, par2, par4, par6, par8, par9);
     }
+    
+    // FCMOD: Added (client only)
+    // TODO: make this generalizable
+    protected int renderEyes( EntityVillager villager, int iRenderPass )
+    {
+        if ( iRenderPass == 0 && villager.getProfession() == 2 && villager.GetCurrentTradeLevel() >= 5 )
+        {
+            loadTexture("/btwmodtex/fcPriestEyes.png");
+            
+            GL11.glEnable(GL11.GL_BLEND);
+            GL11.glDisable(GL11.GL_ALPHA_TEST);
+            GL11.glBlendFunc(GL11.GL_ONE, GL11.GL_ONE);
+            GL11.glDisable(GL11.GL_LIGHTING);
+
+            if ( villager.isInvisible() )
+            {
+                GL11.glDepthMask( false );
+            }
+            else
+            {
+                GL11.glDepthMask( true );
+            }
+
+            char var5 = 61680;
+            int var6 = var5 % 65536;
+            int var7 = var5 / 65536;
+            
+            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)var6 / 1.0F, (float)var7 / 1.0F);
+            
+            GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+            GL11.glEnable(GL11.GL_LIGHTING);
+            GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+            
+            return 1;
+        }
+        
+        return -1;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/RenderWitch.java b/minecraft/net/minecraft/src/RenderWitch.java
index 33f6ebb..ff8193f 100644
--- a/minecraft/net/minecraft/src/RenderWitch.java
+++ b/minecraft/net/minecraft/src/RenderWitch.java
@@ -53,7 +53,13 @@ public class RenderWitch extends RenderLiving
             this.field_82414_a.field_82898_f.postRender(0.0625F);
             GL11.glTranslatef(-0.0625F, 0.53125F, 0.21875F);
 
+            // FCMOD: Change
+            /*
             if (var4.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var4.itemID].getRenderType()))
+            */
+            if ( var4.itemID < 4096 && Block.blocksList[var4.itemID] != null && 
+            	Block.blocksList[var4.itemID].DoesItemRenderAsBlock( var4.getItemDamage() ) )
+            // END FCMOD
             {
                 var5 = 0.5F;
                 GL11.glTranslatef(0.0F, 0.1875F, -0.3125F);
diff --git a/minecraft/net/minecraft/src/RenderWolf.java b/minecraft/net/minecraft/src/RenderWolf.java
index 597ec31..1b56e5d 100644
--- a/minecraft/net/minecraft/src/RenderWolf.java
+++ b/minecraft/net/minecraft/src/RenderWolf.java
@@ -1,5 +1,10 @@
+// FCMOD: Class changes deprecated 09/10/2018
+
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
+import com.prupe.mcpatcher.mal.resource.FakeResourceLocation;
+import com.prupe.mcpatcher.mob.MobRandomizer;
 import org.lwjgl.opengl.GL11;
 
 public class RenderWolf extends RenderLiving
@@ -28,10 +33,10 @@ public class RenderWolf extends RenderLiving
         }
         else if (par2 == 1 && par1EntityWolf.isTamed())
         {
-            this.loadTexture("/mob/wolf_collar.png");
+        	this.loadTexture(FakeResourceLocation.unwrap(MobRandomizer.randomTexture((Entity)par1EntityWolf, FakeResourceLocation.wrap("/mob/wolf_collar.png"))));
             var4 = 1.0F;
             int var5 = par1EntityWolf.getCollarColor();
-            GL11.glColor3f(var4 * EntitySheep.fleeceColorTable[var5][0], var4 * EntitySheep.fleeceColorTable[var5][1], var4 * EntitySheep.fleeceColorTable[var5][2]);
+            GL11.glColor3f(var4 * ColorizeEntity.getWolfCollarColor(EntitySheep.fleeceColorTable[var5], var5)[0], var4 * ColorizeEntity.getWolfCollarColor(EntitySheep.fleeceColorTable[var5], var5)[1], var4 * ColorizeEntity.getWolfCollarColor(EntitySheep.fleeceColorTable[var5], var5)[2]);
             return 1;
         }
         else
diff --git a/minecraft/net/minecraft/src/RenderXPOrb.java b/minecraft/net/minecraft/src/RenderXPOrb.java
index 110b923..ad106b0 100644
--- a/minecraft/net/minecraft/src/RenderXPOrb.java
+++ b/minecraft/net/minecraft/src/RenderXPOrb.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeEntity;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
@@ -38,13 +39,21 @@ public class RenderXPOrb extends Render
         var21 = (int)((MathHelper.sin(var27 + 0.0F) + 1.0F) * 0.5F * var26);
         int var22 = (int)var26;
         int var23 = (int)((MathHelper.sin(var27 + 4.1887903F) + 1.0F) * 0.1F * var26);
+        // FCMOD: Code added
+        if ( par1EntityXPOrb.m_bNotPlayerOwned )
+        {
+        	var21 = (int)((MathHelper.sin(var27 / 10.0F) + 1.0F) * 0.5F * var26);
+        	var22 = var23 = 0;
+        	var21 = ( var21 >> 2 ) + 64;
+        }
+        // END FCMOD
         int var24 = var21 << 16 | var22 << 8 | var23;
         GL11.glRotatef(180.0F - this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
         GL11.glRotatef(-this.renderManager.playerViewX, 1.0F, 0.0F, 0.0F);
         float var25 = 0.3F;
         GL11.glScalef(var25, var25, var25);
         var11.startDrawingQuads();
-        var11.setColorRGBA_I(var24, 128);
+        var11.setColorRGBA_I(ColorizeEntity.colorizeXPOrb(var24, var27), 128);
         var11.setNormal(0.0F, 1.0F, 0.0F);
         var11.addVertexWithUV((double)(0.0F - var17), (double)(0.0F - var18), 0.0D, (double)var12, (double)var15);
         var11.addVertexWithUV((double)(var16 - var17), (double)(0.0F - var18), 0.0D, (double)var13, (double)var15);
diff --git a/minecraft/net/minecraft/src/RunnableTitleScreen.java b/minecraft/net/minecraft/src/RunnableTitleScreen.java
index cc23ebf..1a0137c 100644
--- a/minecraft/net/minecraft/src/RunnableTitleScreen.java
+++ b/minecraft/net/minecraft/src/RunnableTitleScreen.java
@@ -13,6 +13,8 @@ class RunnableTitleScreen implements Runnable
 
     public void run()
     {
+    	// FCMOD: Code removed to get rid of update pester
+    	/*
         try
         {
             String var1 = HttpUtil.func_104145_a(new URL("http://assets.minecraft.net/1_6_has_been_released.flag"));
@@ -39,5 +41,7 @@ class RunnableTitleScreen implements Runnable
         {
             var6.printStackTrace();
         }
+        */
+    	// END FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/SaveHandler.java b/minecraft/net/minecraft/src/SaveHandler.java
index 056af85..4a6b08b 100644
--- a/minecraft/net/minecraft/src/SaveHandler.java
+++ b/minecraft/net/minecraft/src/SaveHandler.java
@@ -345,4 +345,34 @@ public class SaveHandler implements ISaveHandler, IPlayerFileData
     {
         return this.saveDirectoryName;
     }
+    
+    // FCMOD: Added
+    @Override
+    public void LoadModSpecificData( WorldServer world )
+    {
+        world.loadWorldDataFromNBT(GetDimensionDirectory(world));
+    }
+    
+    @Override
+    public void SaveModSpecificData( WorldServer world )
+    {
+        world.saveWorldDataToNBT(GetDimensionDirectory(world));
+    }
+    
+    private File GetDimensionDirectory( WorldServer world )
+    {
+        if ( world.provider.dimensionId == -1 ) // nether
+        {
+            return new File( worldDirectory, "DIM-1");
+        }
+        else if ( world.provider.dimensionId == 1 ) // the end
+        {
+        	return new File( worldDirectory, "DIM1");
+        }
+        else
+        {
+            return worldDirectory;
+        }        
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/SaveHandlerMP.java b/minecraft/net/minecraft/src/SaveHandlerMP.java
index ed62589..f066a4a 100644
--- a/minecraft/net/minecraft/src/SaveHandlerMP.java
+++ b/minecraft/net/minecraft/src/SaveHandlerMP.java
@@ -63,4 +63,14 @@ public class SaveHandlerMP implements ISaveHandler
     {
         return "none";
     }
+    
+    // FCMOD: Added (client only)
+    public void LoadModSpecificData( WorldServer world )
+    {
+    }
+    
+    public void SaveModSpecificData( WorldServer world )
+    {
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ServerCommandManager.java b/minecraft/net/minecraft/src/ServerCommandManager.java
index c684aaf..05addc5 100644
--- a/minecraft/net/minecraft/src/ServerCommandManager.java
+++ b/minecraft/net/minecraft/src/ServerCommandManager.java
@@ -1,10 +1,14 @@
 package net.minecraft.src;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import net.minecraft.server.MinecraftServer;
 
 public class ServerCommandManager extends CommandHandler implements IAdminCommand
 {
+	private static ArrayList<ICommand> commandsClient = new ArrayList<ICommand>();
+	private static ArrayList<ICommand> commandsServer = new ArrayList<ICommand>();
+	
     public ServerCommandManager()
     {
         this.registerCommand(new CommandTime());
@@ -30,6 +34,7 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
         this.registerCommand(new CommandClearInventory());
         this.registerCommand(new ServerCommandTestFor());
         this.registerCommand(new ServerCommandScoreboard());
+        this.registerCommand(new FCCommandServerLoc());
 
         if (MinecraftServer.getServer().isDedicatedServer())
         {
@@ -47,10 +52,18 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
             this.registerCommand(new CommandServerKick());
             this.registerCommand(new CommandServerList());
             this.registerCommand(new CommandServerWhitelist());
+            
+            for (ICommand command : commandsServer) {
+    			this.registerCommand(command);
+    		}
         }
         else
         {
             this.registerCommand(new CommandServerPublishLocal());
+            
+            for (ICommand command : commandsClient) {
+    			this.registerCommand(command);
+            }
         }
 
         CommandBase.setAdminCommander(this);
@@ -94,4 +107,29 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
             par1ICommandSender.sendChatToPlayer(par1ICommandSender.translateString(par3Str, par4ArrayOfObj));
         }
     }
+	
+    /**
+     * Register a command for both client and server
+     * @param command
+     */
+	public static void registerAddonCommand(ICommand command) {
+		commandsClient.add(command);
+		commandsServer.add(command);
+	}
+	
+	/**
+	 * Register a client only command
+	 * @param command
+	 */
+	public static void registerAddonCommandClient(ICommand command) {
+		commandsClient.add(command);
+	}
+	
+	/**
+	 * Register a server only command
+	 * @param command
+	 */
+	public static void registerAddonCommandServer(ICommand command) {
+		commandsClient.add(command);
+	}
 }
diff --git a/minecraft/net/minecraft/src/ServerConfigurationManager.java b/minecraft/net/minecraft/src/ServerConfigurationManager.java
index 3047b37..1389a11 100644
--- a/minecraft/net/minecraft/src/ServerConfigurationManager.java
+++ b/minecraft/net/minecraft/src/ServerConfigurationManager.java
@@ -116,6 +116,8 @@ public abstract class ServerConfigurationManager
                 var10.field_98038_p = false;
             }
         }
+        
+        FCAddOnHandler.serverPlayerConnectionInitialized(var7, par2EntityPlayerMP);
     }
 
     protected void func_96456_a(ServerScoreboard par1ServerScoreboard, EntityPlayerMP par2EntityPlayerMP)
@@ -163,16 +165,25 @@ public abstract class ServerConfigurationManager
 
         if (par2WorldServer != null)
         {
-            par2WorldServer.getPlayerManager().removePlayer(par1EntityPlayerMP);
+        	// FCMOD: Changed
+            //par2WorldServer.getPlayerManager().removePlayer(par1EntityPlayerMP);
+            par2WorldServer.GetChunkTracker().RemovePlayer(par1EntityPlayerMP);
+            // END FCMOD
         }
 
-        var3.getPlayerManager().addPlayer(par1EntityPlayerMP);
+    	// FCMOD: Changed
+        //var3.getPlayerManager().addPlayer(par1EntityPlayerMP);
+        var3.GetChunkTracker().AddPlayer(par1EntityPlayerMP);
+        // END FCMOD
         var3.theChunkProviderServer.loadChunk((int)par1EntityPlayerMP.posX >> 4, (int)par1EntityPlayerMP.posZ >> 4);
     }
 
     public int getEntityViewDistance()
     {
-        return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
+    	// FCMOD: Changed    	
+        //return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
+        return FCChunkTracker.GetFurthestViewableBlock( getViewDistance() );
+    	// END FCMOD
     }
 
     /**
@@ -226,9 +237,16 @@ public abstract class ServerConfigurationManager
     /**
      * using player's dimension, update their movement when in a vehicle (e.g. cart, boat)
      */
+    /** 
+     * FCNOTE: This is totally misnamed.  It is called for all moving players, not just mounted ones
+     */
     public void serverUpdateMountedMovingPlayer(EntityPlayerMP par1EntityPlayerMP)
     {
-        par1EntityPlayerMP.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(par1EntityPlayerMP);
+    	// FCMOD: Changed
+        //par1EntityPlayerMP.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(par1EntityPlayerMP);
+        par1EntityPlayerMP.getServerForPlayer().GetChunkTracker().UpdateMovingPlayer(
+        	par1EntityPlayerMP);
+        // END FCMOD
     }
 
     /**
@@ -246,7 +264,10 @@ public abstract class ServerConfigurationManager
         }
 
         var2.removeEntity(par1EntityPlayerMP);
-        var2.getPlayerManager().removePlayer(par1EntityPlayerMP);
+        // FCMOD: Changed
+        //var2.getPlayerManager().removePlayer(par1EntityPlayerMP);
+        var2.GetChunkTracker().RemovePlayer(par1EntityPlayerMP);
+        // END FCMOD
         this.playerEntityList.remove(par1EntityPlayerMP);
         this.sendPacketToAllPlayers(new Packet201PlayerInfo(par1EntityPlayerMP.username, false, 9999));
     }
@@ -342,6 +363,8 @@ public abstract class ServerConfigurationManager
      * respawn, an INT for the dimension to respawn into (usually 0), and a boolean value that is true if the player
      * beat the game rather than dying
      */
+    // FCMOD: Function removed and replaced later
+    /*
     public EntityPlayerMP respawnPlayer(EntityPlayerMP par1EntityPlayerMP, int par2, boolean par3)
     {
         par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(par1EntityPlayerMP);
@@ -406,6 +429,8 @@ public abstract class ServerConfigurationManager
         var7.setEntityHealth(var7.getHealth());
         return var7;
     }
+	*/
+	// FCMOD
 
     public void transferPlayerToDimension(EntityPlayerMP par1EntityPlayerMP, int par2)
     {
@@ -429,6 +454,11 @@ public abstract class ServerConfigurationManager
             PotionEffect var7 = (PotionEffect)var6.next();
             par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet41EntityEffect(par1EntityPlayerMP.entityId, var7));
         }
+        
+        // FCMOD: Added
+        par1EntityPlayerMP.FlagAllWatchedObjectsDirty();        
+        par1EntityPlayerMP.m_lTimeOfLastDimensionSwitch = var5.getWorldTime();
+        // END FCMOD
     }
 
     /**
@@ -501,10 +531,21 @@ public abstract class ServerConfigurationManager
 
             if (par1Entity.isEntityAlive())
             {
+            	// FCMOD: Code change to fix other players not showing up when going through a portal in SMP
+            	/*
                 par4WorldServer.spawnEntityInWorld(par1Entity);
                 par1Entity.setLocationAndAngles(var5, par1Entity.posY, var7, par1Entity.rotationYaw, par1Entity.rotationPitch);
                 par4WorldServer.updateEntityWithOptionalForce(par1Entity, false);
                 par4WorldServer.getDefaultTeleporter().placeInPortal(par1Entity, var11, var13, var15, var17);
+                */
+                par1Entity.setLocationAndAngles(var5, par1Entity.posY, var7, par1Entity.rotationYaw, par1Entity.rotationPitch);
+                
+                FlagChunksAroundTeleportingEntityForCheckForUnload( par4WorldServer, par1Entity );
+                
+                par4WorldServer.getDefaultTeleporter().placeInPortal(par1Entity, var11, var13, var15, var17);
+                par4WorldServer.spawnEntityInWorld(par1Entity);
+                par4WorldServer.updateEntityWithOptionalForce(par1Entity, false);
+                // END FCMOD
             }
 
             par3WorldServer.theProfiler.endSection();
@@ -882,8 +923,20 @@ public abstract class ServerConfigurationManager
 
         if (par2WorldServer.isRaining())
         {
+        	// FCMOD: Code change so that initial rain strength is set to full on client
+        	/*
             par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet70GameEvent(1, 0));
+            */
+            par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet70GameEvent(1, 1));
+        	// END FCMOD
         }
+        
+        // FCMOD: Code added
+        if (par2WorldServer.worldInfo.isThundering())
+        {
+            par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet70GameEvent(7, 1));
+        }        
+        // END FCMOD
     }
 
     /**
@@ -1015,4 +1068,164 @@ public abstract class ServerConfigurationManager
         this.mcServer.logInfo(par1Str);
         this.sendPacketToAllPlayers(new Packet3Chat(par1Str));
     }
+
+    // FCMOD: Added
+    // client
+    public EntityPlayerMP respawnPlayer( EntityPlayerMP oldPlayer, int iDefaultDimension, boolean bPlayerLeavingTheEnd )
+    // server
+    //public EntityPlayerMP recreatePlayerEntity( EntityPlayerMP oldPlayer, int iDefaultDimension, boolean bPlayerLeavingTheEnd )
+    {
+        oldPlayer.getServerForPlayer().getEntityTracker().removePlayerFromTrackers( oldPlayer );
+        
+    	// client
+        oldPlayer.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers( oldPlayer );
+    	// server    	
+    	//oldPlayer.getServerForPlayer().getEntityTracker().untrackEntity( oldPlayer );
+        
+        oldPlayer.getServerForPlayer().GetChunkTracker().RemovePlayer( oldPlayer );
+        
+        playerEntityList.remove( oldPlayer );
+        
+        mcServer.worldServerForDimension( oldPlayer.dimension ).removePlayerEntityDangerously( oldPlayer );
+        
+        ChunkCoordinates verifiedRespawnCoords = null;
+        boolean bRetainPreviousSpawn = false;
+
+    	String sSpawnFailMessage = null;
+    	
+    	int iNewDimension = iDefaultDimension;
+    	
+        if ( oldPlayer.HasRespawnCoordinates() )
+        {
+            if ( !bPlayerLeavingTheEnd )
+            {
+	        	ChunkCoordinates rawRespawnCoords = new ChunkCoordinates();
+	        	
+	            int iReturnValue = oldPlayer.GetValidatedRespawnCoordinates( mcServer.worldServerForDimension( oldPlayer.m_iSpawnDimension ), rawRespawnCoords );
+	
+	            if ( iReturnValue == 0 )
+	            {
+	            	verifiedRespawnCoords = rawRespawnCoords;	
+	            	iNewDimension = oldPlayer.m_iSpawnDimension;
+	            }
+	            else
+	            {
+		            if ( iReturnValue == 1 )
+		            {
+		            	sSpawnFailMessage = "Your respawn location was invalid";
+		            }
+		            else if ( iReturnValue == 2 )
+		            {
+		            	sSpawnFailMessage = "The beacon to which you were bound is no longer present";
+		            }
+		            else if ( iReturnValue == 3 )
+		            {
+		            	sSpawnFailMessage = "The beacon to which you are bound was too far away";
+		            	bRetainPreviousSpawn = true;
+		            }
+		            else if ( iReturnValue == 4 )
+		            {
+		            	sSpawnFailMessage = "The beacon to which you are bound was obstructed";
+		            	bRetainPreviousSpawn = true;
+		            }
+		            else
+		            {
+		            	sSpawnFailMessage = "Your respawn failed for an unknown reason";
+		            }
+		            
+	            }
+	        }
+            else
+            {
+            	// retain the player's previous respawn location when you pop back from the end
+            	
+            	bRetainPreviousSpawn = true;
+            }
+        }
+
+        ItemInWorldManager worldManager;
+
+        if (this.mcServer.isDemo())
+        {
+            worldManager = new DemoWorldManager(this.mcServer.worldServerForDimension( iNewDimension ) );
+        }
+        else
+        {
+            worldManager = new ItemInWorldManager(this.mcServer.worldServerForDimension( iNewDimension ) );
+        }
+
+        EntityPlayerMP newPlayer = new EntityPlayerMP( mcServer, mcServer.worldServerForDimension( iNewDimension ), oldPlayer.username, worldManager );
+        
+        newPlayer.playerNetServerHandler = oldPlayer.playerNetServerHandler;
+        
+        oldPlayer.dimension = iNewDimension;        
+        newPlayer.clonePlayer( oldPlayer, bPlayerLeavingTheEnd );
+        newPlayer.entityId = oldPlayer.entityId;
+        
+        WorldServer newWorldServer = mcServer.worldServerForDimension( oldPlayer.dimension );
+        
+        func_72381_a( newPlayer, oldPlayer, newWorldServer ); // initializes the game type
+        
+        if ( verifiedRespawnCoords != null )
+        {
+            newPlayer.setLocationAndAngles((double)((float)verifiedRespawnCoords.posX + 0.5F), (double)((float)verifiedRespawnCoords.posY + 0.1F), (double)((float)verifiedRespawnCoords.posZ + 0.5F), 0.0F, 0.0F);
+            
+            bRetainPreviousSpawn = true;
+            
+        }
+        else if ( !bPlayerLeavingTheEnd )
+        {
+    		FCUtilsHardcoreSpawn.HandleHardcoreSpawn( mcServer, oldPlayer, newPlayer );
+        }
+        
+        if ( bRetainPreviousSpawn )
+        {
+            newPlayer.setSpawnChunk( oldPlayer.getBedLocation(), oldPlayer.isSpawnForced(), oldPlayer.m_iSpawnDimension );
+        }
+        
+        if ( sSpawnFailMessage != null )
+        {
+            FCUtilsWorld.SendPacketToPlayer( newPlayer.playerNetServerHandler, new Packet3Chat( sSpawnFailMessage ) );
+        }
+        
+        newWorldServer.theChunkProviderServer.loadChunk((int)newPlayer.posX >> 4, (int)newPlayer.posZ >> 4);
+
+        while (!newWorldServer.getCollidingBoundingBoxes(newPlayer, newPlayer.boundingBox).isEmpty())
+        {
+            newPlayer.setPosition(newPlayer.posX, newPlayer.posY + 1.0D, newPlayer.posZ);
+        }
+
+        newPlayer.playerNetServerHandler.sendPacketToPlayer(new Packet9Respawn(newPlayer.dimension, (byte)newPlayer.worldObj.difficultySetting, newPlayer.worldObj.getWorldInfo().getTerrainType(), newPlayer.worldObj.getHeight(), newPlayer.theItemInWorldManager.getGameType()));
+        verifiedRespawnCoords = newWorldServer.getSpawnPoint();
+        newPlayer.playerNetServerHandler.sendPacketToPlayer(new Packet6SpawnPosition(verifiedRespawnCoords.posX, verifiedRespawnCoords.posY, verifiedRespawnCoords.posZ));
+        newPlayer.playerNetServerHandler.sendPacketToPlayer(new Packet43Experience(newPlayer.experience, newPlayer.experienceTotal, newPlayer.experienceLevel));
+        this.updateTimeAndWeatherForPlayer(newPlayer, newWorldServer);
+        newWorldServer.GetChunkTracker().AddPlayer(newPlayer);
+        newWorldServer.spawnEntityInWorld(newPlayer);
+        this.playerEntityList.add(newPlayer);
+        newPlayer.addSelfToInternalCraftingInventory();
+        newPlayer.setEntityHealth(newPlayer.getHealth());
+        
+        // Code moved relative to vanilla version so that some loading occurs before loading screen dissapears
+        newPlayer.playerNetServerHandler.setPlayerLocation(newPlayer.posX, newPlayer.posY, newPlayer.posZ, newPlayer.rotationYaw, newPlayer.rotationPitch);
+        
+        return newPlayer;
+    }
+    
+    private void FlagChunksAroundTeleportingEntityForCheckForUnload( WorldServer world, Entity entity )
+    {
+        // flag area checked for teleport for unload check as the Teleporter 
+        // class potentially loads a whole bunch of chunks in the placeInPortal() call.
+    	
+    	int iChunkX = MathHelper.floor_double( entity.posX / 16D ); 
+    	int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
+    	
+    	// Teleporter.placeInExistingPortal() checks out to 128 blocks, or 8 chunks
+    	
+    	int iChunkRange = 9;
+    	
+    	world.AddChunkRangeToCheckForUnloadList( iChunkX - iChunkRange, iChunkZ - iChunkRange,
+    		iChunkX + iChunkRange, iChunkZ + iChunkRange );        
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ShapedRecipes.java b/minecraft/net/minecraft/src/ShapedRecipes.java
index 9f198cd..840696f 100644
--- a/minecraft/net/minecraft/src/ShapedRecipes.java
+++ b/minecraft/net/minecraft/src/ShapedRecipes.java
@@ -37,10 +37,18 @@ public class ShapedRecipes implements IRecipe
      */
     public boolean matches(InventoryCrafting par1InventoryCrafting, World par2World)
     {
+    	// FCMOD: Changed the following to support 4X4 crafting grid
+    	/*
         for (int var3 = 0; var3 <= 3 - this.recipeWidth; ++var3)
         {
             for (int var4 = 0; var4 <= 3 - this.recipeHeight; ++var4)
             {
+        */    	
+        for (int var3 = 0; var3 <= 4 - this.recipeWidth; ++var3)
+        {
+            for (int var4 = 0; var4 <= 4 - this.recipeHeight; ++var4)
+            {
+    	// END FCMOD
                 if (this.checkMatch(par1InventoryCrafting, var3, var4, true))
                 {
                     return true;
@@ -61,10 +69,18 @@ public class ShapedRecipes implements IRecipe
      */
     private boolean checkMatch(InventoryCrafting par1InventoryCrafting, int par2, int par3, boolean par4)
     {
+    	// FCMOD: Changed the following to support 4X4 crafting grid
+    	/*
         for (int var5 = 0; var5 < 3; ++var5)
         {
             for (int var6 = 0; var6 < 3; ++var6)
             {
+        */
+        for (int var5 = 0; var5 < 4; ++var5)
+        {
+            for (int var6 = 0; var6 < 4; ++var6)
+            {
+    	// END FCMOD
                 int var7 = var5 - par2;
                 int var8 = var6 - par3;
                 ItemStack var9 = null;
@@ -83,6 +99,13 @@ public class ShapedRecipes implements IRecipe
 
                 ItemStack var10 = par1InventoryCrafting.getStackInRowAndColumn(var5, var6);
 
+                // FCMOD: Code added to ignore Moulds                
+                if ( var10 != null && var10.itemID == FCBetterThanWolves.fcItemMould.itemID )
+                {
+                	var10 = null;
+                }
+                // END FCMOD
+                
                 if (var10 != null || var9 != null)
                 {
                     if (var10 == null && var9 != null || var10 != null && var9 == null)
@@ -142,4 +165,63 @@ public class ShapedRecipes implements IRecipe
         this.field_92101_f = true;
         return this;
     }
+
+    // FCMOD: Added
+    private boolean m_bHasSecondaryOutput = false;
+    
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	if ( recipe instanceof ShapedRecipes )
+    	{
+    		ShapedRecipes shapedRecipe = (ShapedRecipes)recipe;
+    		
+    		if ( recipeWidth == shapedRecipe.recipeWidth  && recipeHeight == shapedRecipe.recipeHeight )
+    		{
+    			if ( recipeOutputItemID == shapedRecipe.recipeOutputItemID &&
+    				recipeOutput.stackSize == shapedRecipe.recipeOutput.stackSize && 
+    				recipeOutput.getItemDamage() == shapedRecipe.recipeOutput.getItemDamage() )
+    			{
+    				if ( recipeItems.length == shapedRecipe.recipeItems.length )
+    				{
+	    				for ( int iTempIndex = 0; iTempIndex < recipeItems.length; iTempIndex++ )
+	    				{
+	    					ItemStack item1 = recipeItems[iTempIndex];
+	    					ItemStack item2 = shapedRecipe.recipeItems[iTempIndex]; 
+	    						
+	    					if ( item1 == null || item2 == null )
+	    					{
+	    						if ( item1 != null || item2 != null )
+	    						{
+	    							return false;
+	    						}
+	    					}
+	    					else if ( item1.getItem().itemID != item2.getItem().itemID ||
+	    							item1.stackSize != item2.stackSize ||
+	    							item1.getItemDamage() != item2.getItemDamage() )
+	    					{
+	    						return false;
+	    					}
+	    				}
+	    				
+	    				return true;
+    				}
+    			}
+    		}
+    	}
+    	
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return m_bHasSecondaryOutput;
+    }
+    
+    public void SetHasSecondaryOutput( boolean bHasSecondaryOutput )
+    {
+    	m_bHasSecondaryOutput = bHasSecondaryOutput;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/ShapelessRecipes.java b/minecraft/net/minecraft/src/ShapelessRecipes.java
index 246e439..8ea034d 100644
--- a/minecraft/net/minecraft/src/ShapelessRecipes.java
+++ b/minecraft/net/minecraft/src/ShapelessRecipes.java
@@ -30,14 +30,29 @@ public class ShapelessRecipes implements IRecipe
     {
         ArrayList var3 = new ArrayList(this.recipeItems);
 
+    	// FCMOD: Changed to support 4X4 crafting
+		/*
         for (int var4 = 0; var4 < 3; ++var4)
         {
             for (int var5 = 0; var5 < 3; ++var5)
             {
+        */
+        for (int var4 = 0; var4 < 4; ++var4)
+        {
+            for (int var5 = 0; var5 < 4; ++var5)
+            {
+    	// END FCMOD
                 ItemStack var6 = par1InventoryCrafting.getStackInRowAndColumn(var5, var4);
 
                 if (var6 != null)
                 {
+                    // FCMOD: Code added to ignore Moulds                
+                    if ( var6.itemID == FCBetterThanWolves.fcItemMould.itemID )
+                    {
+                    	continue;
+                    }
+                    // END FCMOD
+                    
                     boolean var7 = false;
                     Iterator var8 = var3.iterator();
 
@@ -79,4 +94,60 @@ public class ShapelessRecipes implements IRecipe
     {
         return this.recipeItems.size();
     }
-}
+    
+    // FCMOD: Added
+    private boolean m_bHasSecondaryOutput = false;
+    
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	if ( recipe instanceof ShapelessRecipes )
+    	{
+    		ShapelessRecipes shapelessRecipe = (ShapelessRecipes)recipe;
+    		
+			if ( recipeOutput.getItem().itemID == shapelessRecipe.recipeOutput.getItem().itemID &&
+				recipeOutput.stackSize == shapelessRecipe.recipeOutput.stackSize && 
+				recipeOutput.getItemDamage() == shapelessRecipe.recipeOutput.getItemDamage() )
+			{
+				if ( recipeItems.size() == shapelessRecipe.recipeItems.size() )
+				{
+    				for ( int iTempIndex = 0; iTempIndex < recipeItems.size(); iTempIndex++ )
+    				{
+    					ItemStack item1 = (ItemStack)recipeItems.get( iTempIndex );
+    					ItemStack item2 = (ItemStack)shapelessRecipe.recipeItems.get( iTempIndex ); 
+    						
+    					if ( item1 == null || item2 == null )
+    					{
+    						if ( item1 != null || item2 != null )
+    						{
+    							return false;
+    						}
+    					}
+    					else if ( item1.getItem().itemID != item2.getItem().itemID ||
+    							item1.stackSize != item2.stackSize ||
+    							item1.getItemDamage() != item2.getItemDamage() )
+    					{
+    						return false;
+    					}
+    				}
+    				
+    				return true;
+				}
+    		}
+    	}
+    	
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return m_bHasSecondaryOutput;
+    }
+    
+    public void SetHasSecondaryOutput( boolean bHasSecondaryOutput )
+    {
+    	m_bHasSecondaryOutput = bHasSecondaryOutput;
+    }
+    // END FCMOD    
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/SlotCrafting.java b/minecraft/net/minecraft/src/SlotCrafting.java
index 02079e8..b792a38 100644
--- a/minecraft/net/minecraft/src/SlotCrafting.java
+++ b/minecraft/net/minecraft/src/SlotCrafting.java
@@ -112,12 +112,45 @@ public class SlotCrafting extends Slot
 
             if (var4 != null)
             {
+            	// FCMOD: Added            	
+            	var4.getItem().OnUsedInCrafting( var4.getItemDamage(), par1EntityPlayer, 
+            		par2ItemStack );
+            	
+            	if ( !var4.getItem().IsConsumedInCrafting() )
+            	{
+            		continue;
+            	}
+            	else if ( var4.getItem().IsDamagedInCrafting() )
+            	{
+            		if ( var4.getItemDamage() >= var4.getMaxDamage() - 1 )
+            		{
+            			var4.getItem().OnBrokenInCrafting( par1EntityPlayer );
+            			
+                        craftMatrix.decrStackSize(var3, 1);
+            		}
+            		else
+            		{
+            			var4.getItem().OnDamagedInCrafting( par1EntityPlayer );
+            			
+            			var4.damageItem( 1, par1EntityPlayer );
+            		}
+
+            		continue;
+            	}            	
+        		// END FCMOD
                 this.craftMatrix.decrStackSize(var3, 1);
 
                 if (var4.getItem().hasContainerItem())
                 {
-                    ItemStack var5 = new ItemStack(var4.getItem().getContainerItem());
+                    // FCMOD: Code added
+                    if ( par2ItemStack.getItem().DoesConsumeContainerItemWhenCrafted( var4.getItem().getContainerItem() ) )
+                    {
+                    	continue;
+                    }
+                    // END FCMOD
 
+                    ItemStack var5 = new ItemStack(var4.getItem().getContainerItem());
+                    
                     if (!var4.getItem().doesContainerItemLeaveCraftingGrid(var4) || !this.thePlayer.inventory.addItemStackToInventory(var5))
                     {
                         if (this.craftMatrix.getStackInSlot(var3) == null)
@@ -132,5 +165,9 @@ public class SlotCrafting extends Slot
                 }
             }
         }
+        
+        // FCMOD: Code added
+        par1EntityPlayer.m_iTimesCraftedThisTick++;
+        // END FCMOD
     }
 }
diff --git a/minecraft/net/minecraft/src/SlotFurnace.java b/minecraft/net/minecraft/src/SlotFurnace.java
index 263670a..20be13f 100644
--- a/minecraft/net/minecraft/src/SlotFurnace.java
+++ b/minecraft/net/minecraft/src/SlotFurnace.java
@@ -79,12 +79,16 @@ public class SlotFurnace extends Slot
                 var2 = var4;
             }
 
+            // FCMOD: Code removed
+            /*
             while (var2 > 0)
             {
                 var4 = EntityXPOrb.getXPSplit(var2);
                 var2 -= var4;
                 this.thePlayer.worldObj.spawnEntityInWorld(new EntityXPOrb(this.thePlayer.worldObj, this.thePlayer.posX, this.thePlayer.posY + 0.5D, this.thePlayer.posZ + 0.5D, var4));
             }
+            */
+            // END FCMOD
         }
 
         this.field_75228_b = 0;
@@ -98,5 +102,13 @@ public class SlotFurnace extends Slot
         {
             this.thePlayer.addStat(AchievementList.cookFish, 1);
         }
+        
+        // FCMOD: Code added
+		if ( par1ItemStack.getItem().itemID == Item.bread.itemID )
+		{
+            thePlayer.addStat( AchievementList.makeBread, 1 );
+		}
+		// END FCMOD
+        
     }
 }
diff --git a/minecraft/net/minecraft/src/SlotMerchantResult.java b/minecraft/net/minecraft/src/SlotMerchantResult.java
index 56c22cc..a5eb880 100644
--- a/minecraft/net/minecraft/src/SlotMerchantResult.java
+++ b/minecraft/net/minecraft/src/SlotMerchantResult.java
@@ -112,5 +112,5 @@ public class SlotMerchantResult extends Slot
         }
 
         return false;
-    }
-}
+    }    
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/SoundManager.java b/minecraft/net/minecraft/src/SoundManager.java
index cc42f6d..d74d0c5 100644
--- a/minecraft/net/minecraft/src/SoundManager.java
+++ b/minecraft/net/minecraft/src/SoundManager.java
@@ -13,6 +13,11 @@ import paulscode.sound.codecs.CodecJOrbis;
 import paulscode.sound.codecs.CodecWav;
 import paulscode.sound.libraries.LibraryLWJGLOpenAL;
 
+// FCMOD: Code added (client only)
+import java.util.HashMap;
+import java.util.Map;
+// END FCMOD
+
 public class SoundManager
 {
     /** A reference to the sound system. */
@@ -206,6 +211,9 @@ public class SoundManager
                 float var16 = 0.0F;
                 float var17 = 1.0F;
                 float var18 = 0.0F;
+                // FCMOD: Code added, client only
+                Update3DSoundTrackerForNewPosition((float)var5, (float)var7, (float)var9);
+                // END FCMOD
                 sndSystem.setListenerPosition((float)var5, (float)var7, (float)var9);
                 sndSystem.setListenerOrientation(var13, var14, var15, var16, var17, var18);
             }
@@ -454,6 +462,10 @@ public class SoundManager
 
                 sndSystem.setVolume(var8, par5 * this.options.soundVolume);
                 sndSystem.play(var8);
+                
+                // FCMOD: Code added, client only
+                Add3DSoundToTracker( var8, par2, par3, par4, var9 );
+                // END FCMOD
             }
         }
     }
@@ -539,4 +551,49 @@ public class SoundManager
     {
         this.field_92072_h.add(new ScheduledSound(par1Str, par2, par3, par4, par5, par6, par7));
     }
+    
+    // FCMOD: Code added, client only
+    private Map m_Tracked3DSoundsHashMap = new HashMap();
+    
+    private void Add3DSoundToTracker( String name, float x, float y, float z, float fRange )
+    {
+    	// note that hash maps automatically remove any previous entry with the same name
+    	
+    	m_Tracked3DSoundsHashMap.put( name, new FCClientSoundTrackerEntry( name, x, y, z, fRange ) );
+    }
+    
+    private void Update3DSoundTrackerForNewPosition( float x, float y, float z )
+    {
+        Iterator soundIterator = m_Tracked3DSoundsHashMap.values().iterator();
+
+        while (soundIterator.hasNext())
+        {
+            FCClientSoundTrackerEntry tempSoundEntry = (FCClientSoundTrackerEntry)soundIterator.next();
+            
+            if ( sndSystem.playing( tempSoundEntry.m_sName ) )
+            {
+            	float fDeltaX = x - tempSoundEntry.m_fXPos;
+            	float fDeltaY = y - tempSoundEntry.m_fYPos;
+            	float fDeltaZ = z - tempSoundEntry.m_fZPos;
+            	
+            	float distSqToSound = ( fDeltaX * fDeltaX ) + ( fDeltaY * fDeltaY ) + ( fDeltaZ * fDeltaZ );
+            	
+            	if ( distSqToSound >= tempSoundEntry.m_fMaxRangeSq )
+            	{
+            		// the sound has gone out of range and should stop
+            		
+            		sndSystem.stop( tempSoundEntry.m_sName );
+            		
+                	soundIterator.remove();
+            	}
+            }
+            else
+            {
+            	// the sound is done playing, remove it from the map
+            	
+            	soundIterator.remove();
+            }
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/SoundPool.java b/minecraft/net/minecraft/src/SoundPool.java
index 4d5a78c..e924cca 100644
--- a/minecraft/net/minecraft/src/SoundPool.java
+++ b/minecraft/net/minecraft/src/SoundPool.java
@@ -40,6 +40,23 @@ public class SoundPool
 
             if (this.isGetRandomSound)
             {
+            	// FCMOD: Code added to also add the file independently so that it may be called specifically (client only) 
+                if (Character.isDigit(par1Str.charAt(par1Str.length() - 1)))
+                {
+	                par1Str = par1Str.replaceAll("/", ".");
+	
+	                if (!this.nameToSoundPoolEntriesMapping.containsKey(par1Str))
+	                {
+	                    this.nameToSoundPoolEntriesMapping.put(par1Str, new ArrayList());
+	                }
+	
+	                SoundPoolEntry var4 = new SoundPoolEntry(var3, par2File.toURI().toURL());
+	                ((List)this.nameToSoundPoolEntriesMapping.get(par1Str)).add(var4);
+	                this.allSoundPoolEntries.add(var4);
+	                ++this.numberOfSoundPoolEntries;
+                }
+                // END FCMOD
+            	
                 while (Character.isDigit(par1Str.charAt(par1Str.length() - 1)))
                 {
                     par1Str = par1Str.substring(0, par1Str.length() - 1);
diff --git a/minecraft/net/minecraft/src/SpawnerAnimals.java b/minecraft/net/minecraft/src/SpawnerAnimals.java
index 75ec4f5..3058add 100644
--- a/minecraft/net/minecraft/src/SpawnerAnimals.java
+++ b/minecraft/net/minecraft/src/SpawnerAnimals.java
@@ -1,42 +1,51 @@
 package net.minecraft.src;
 
+import java.lang.reflect.InvocationTargetException;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 
 public final class SpawnerAnimals
 {
-    /** The 17x17 area around the player where mobs can spawn */
-    private static HashMap eligibleChunksForSpawning = new HashMap();
-
-    /** An array of entity classes that spawn at night. */
-    protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
-
-    /**
-     * Given a chunk, find a random position in it.
-     */
-    protected static ChunkPosition getRandomSpawningPointInChunk(World par0World, int par1, int par2)
-    {
-        Chunk var3 = par0World.getChunkFromChunkCoords(par1, par2);
-        int var4 = par1 * 16 + par0World.rand.nextInt(16);
-        int var5 = par2 * 16 + par0World.rand.nextInt(16);
-        int var6 = par0World.rand.nextInt(var3 == null ? par0World.getActualHeight() : var3.getTopFilledSegment() + 16 - 1);
-        return new ChunkPosition(var4, var6, var5);
-    }
-
-    /**
-     * adds all chunks within the spawn radius of the players to eligibleChunksForSpawning. pars: the world,
-     * hostileCreatures, passiveCreatures. returns number of eligible chunks.
-     */
-    public static final int findChunksForSpawning(WorldServer par0WorldServer, boolean par1, boolean par2, boolean par3)
-    {
-        if (!par1 && !par2)
-        {
-            return 0;
-        }
-        else
-        {
+	/** The 17x17 area around the player where mobs can spawn */
+	// FCMOD: Removed in favor of using the world's active chunk list	
+	//private static HashMap eligibleChunksForSpawning = new HashMap();
+	// END FCMOD
+
+	/** An array of entity classes that spawn at night. */
+	// FCMOD: Removed due to deprecation
+	//protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
+	// END FCMOD
+
+	/**
+	 * Given a chunk, find a random position in it.
+	 */
+	protected static ChunkPosition getRandomSpawningPointInChunk(World par0World, int par1, int par2)
+	{
+		Chunk var3 = par0World.getChunkFromChunkCoords(par1, par2);
+		int var4 = par1 * 16 + par0World.rand.nextInt(16);
+		int var5 = par2 * 16 + par0World.rand.nextInt(16);
+		int var6 = par0World.rand.nextInt(var3 == null ? par0World.getActualHeight() : var3.getTopFilledSegment() + 16 - 1);
+		return new ChunkPosition(var4, var6, var5);
+	}
+
+	/**
+	 * adds all chunks within the spawn radius of the players to eligibleChunksForSpawning. pars: the world,
+	 * hostileCreatures, passiveCreatures. returns number of eligible chunks.
+	 */
+	public static final int findChunksForSpawning(WorldServer par0WorldServer, boolean par1, boolean par2, boolean par3)
+	{
+		if (!par1 && !par2)
+		{
+			return 0;
+		}
+		else
+		{
+			// FCMOD: Changed
+			/*
             eligibleChunksForSpawning.clear();
             int var4;
             int var7;
@@ -66,134 +75,179 @@ public final class SpawnerAnimals
                     }
                 }
             }
-
-            var4 = 0;
-            ChunkCoordinates var32 = par0WorldServer.getSpawnPoint();
-            EnumCreatureType[] var33 = EnumCreatureType.values();
-            var7 = var33.length;
-
-            for (int var34 = 0; var34 < var7; ++var34)
-            {
-                EnumCreatureType var35 = var33[var34];
-
-                if ((!var35.getPeacefulCreature() || par2) && (var35.getPeacefulCreature() || par1) && (!var35.getAnimal() || par3) && par0WorldServer.countEntities(var35.getCreatureClass()) <= var35.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256)
-                {
-                    Iterator var36 = eligibleChunksForSpawning.keySet().iterator();
-                    label110:
-
-                    while (var36.hasNext())
-                    {
-                        ChunkCoordIntPair var37 = (ChunkCoordIntPair)var36.next();
-
-                        if (!((Boolean)eligibleChunksForSpawning.get(var37)).booleanValue())
-                        {
-                            ChunkPosition var38 = getRandomSpawningPointInChunk(par0WorldServer, var37.chunkXPos, var37.chunkZPos);
-                            int var13 = var38.x;
-                            int var14 = var38.y;
-                            int var15 = var38.z;
-
-                            if (!par0WorldServer.isBlockNormalCube(var13, var14, var15) && par0WorldServer.getBlockMaterial(var13, var14, var15) == var35.getCreatureMaterial())
-                            {
-                                int var16 = 0;
-                                int var17 = 0;
-
-                                while (var17 < 3)
-                                {
-                                    int var18 = var13;
-                                    int var19 = var14;
-                                    int var20 = var15;
-                                    byte var21 = 6;
-                                    SpawnListEntry var22 = null;
-                                    int var23 = 0;
-
-                                    while (true)
-                                    {
-                                        if (var23 < 4)
-                                        {
-                                            label103:
-                                            {
-                                                var18 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
-                                                var19 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
-                                                var20 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
-
-                                                if (canCreatureTypeSpawnAtLocation(var35, par0WorldServer, var18, var19, var20))
-                                                {
-                                                    float var24 = (float)var18 + 0.5F;
-                                                    float var25 = (float)var19;
-                                                    float var26 = (float)var20 + 0.5F;
-
-                                                    if (par0WorldServer.getClosestPlayer((double)var24, (double)var25, (double)var26, 24.0D) == null)
-                                                    {
+			 */
+			LinkedList<ChunkCoordIntPair> activeChunks = par0WorldServer.GetActiveChunksCoordsList();
+
+			int var4;
+			int var7;
+			// END FCMOD
+
+			var4 = 0;
+			// FCMOD: Removed
+			//ChunkCoordinates var32 = par0WorldServer.getSpawnPoint();
+			// END FCMOD
+			EnumCreatureType[] var33 = EnumCreatureType.values();
+			var7 = var33.length;
+
+			for (int var34 = 0; var34 < var7; ++var34)
+			{
+				EnumCreatureType var35 = var33[var34];
+
+				// FCMOD: Changed to use custom spawn cap counting
+				//if ((!var35.getPeacefulCreature() || par2) && (var35.getPeacefulCreature() || par1) && (!var35.getAnimal() || par3) && par0WorldServer.countEntities(var35.getCreatureClass()) <= var35.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256)
+				if ( ( !var35.getPeacefulCreature() || par2 ) && 
+						( var35.getPeacefulCreature() || par1 ) && 
+						( !var35.getAnimal() || par3 ) && 
+						par0WorldServer.CountEntitiesThatApplyToSpawnCap( var35.getCreatureClass() ) <= 
+						var35.getMaxNumberOfCreature() * activeChunks.size() / 256 )
+					// END FCMOD
+				{
+					// FCMOD: Changed
+					//Iterator var37 = eligibleChunksForSpawning.keySet().iterator();
+					Iterator var37 = activeChunks.iterator();                    
+					// END FCMOD
+					label110:
+
+						while (var37.hasNext())
+						{
+							ChunkCoordIntPair var36 = (ChunkCoordIntPair)var37.next();
+
+							// FCMOD: Removed
+							//if (!((Boolean)eligibleChunksForSpawning.get(var36)).booleanValue())
+							// END FCMOD
+							{
+								ChunkPosition var38 = getRandomSpawningPointInChunk(par0WorldServer, var36.chunkXPos, var36.chunkZPos);
+								int var13 = var38.x;
+								int var14 = var38.y;
+								int var15 = var38.z;
+
+								// FCMOD: Changed as this was preventing spawns in weird circumstances
+								// like superflat worlds with snow cover.
+								//if (!par0WorldServer.isBlockNormalCube(var13, var14, var15) && par0WorldServer.getBlockMaterial(var13, var14, var15) == var35.getCreatureMaterial())
+								if ( !par0WorldServer.isBlockNormalCube(var13, var14, var15) && 
+										CanCreatureTypeSpawnInMaterial( var35, 
+												par0WorldServer.getBlockMaterial( var13, var14, var15 ) ) )
+									// END FCMOD
+								{
+									int var16 = 0;
+									int var17 = 0;
+
+									while (var17 < 3)
+									{
+										int var18 = var13;
+										int var19 = var14;
+										int var20 = var15;
+										byte var21 = 6;
+										SpawnListEntry var22 = null;
+										int var23 = 0;
+
+										while (true)
+										{
+											if (var23 < 4)
+											{
+												label103:
+												{
+												var18 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
+												// FCNOTE: The following results in 0 all the time.  
+												// Bug?  Check if leaves world bounds if fix?
+												var19 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
+												var20 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
+
+												if (canCreatureTypeSpawnAtLocation(var35, par0WorldServer, var18, var19, var20))
+												{
+													float var24 = (float)var18 + 0.5F;
+													float var25 = (float)var19;
+													// FCMOD: Added
+													var25 += GetVerticalOffsetForPos( var35, par0WorldServer, var18, var19, var20 );
+													var25 += 0.01F; // wiggle
+													// END FCMOD
+													float var26 = (float)var20 + 0.5F;
+
+													if (par0WorldServer.getClosestPlayer((double)var24, (double)var25, (double)var26, 24.0D) == null)
+													{
+														// FCCHUNK: Decide on updates around original spawn
+														// FCMOD: Removed distance check from creature to 
+														// original spawn which prevents spawning 
+														// within 24 blocks (root of 576)
+														/*
                                                         float var27 = var24 - (float)var32.posX;
                                                         float var28 = var25 - (float)var32.posY;
                                                         float var29 = var26 - (float)var32.posZ;
                                                         float var30 = var27 * var27 + var28 * var28 + var29 * var29;
 
                                                         if (var30 >= 576.0F)
-                                                        {
-                                                            if (var22 == null)
-                                                            {
-                                                                var22 = par0WorldServer.spawnRandomCreature(var35, var18, var19, var20);
-
-                                                                if (var22 == null)
-                                                                {
-                                                                    break label103;
-                                                                }
-                                                            }
-
-                                                            EntityLiving var39;
-
-                                                            try
-                                                            {
-                                                                var39 = (EntityLiving)var22.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0WorldServer});
-                                                            }
-                                                            catch (Exception var31)
-                                                            {
-                                                                var31.printStackTrace();
-                                                                return var4;
-                                                            }
-
-                                                            var39.setLocationAndAngles((double)var24, (double)var25, (double)var26, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
-
-                                                            if (var39.getCanSpawnHere())
-                                                            {
-                                                                ++var16;
-                                                                par0WorldServer.spawnEntityInWorld(var39);
-                                                                creatureSpecificInit(var39, par0WorldServer, var24, var25, var26);
-
-                                                                if (var16 >= var39.getMaxSpawnedInChunk())
-                                                                {
-                                                                    continue label110;
-                                                                }
-                                                            }
-
-                                                            var4 += var16;
-                                                        }
-                                                    }
-                                                }
-
-                                                ++var23;
-                                                continue;
-                                            }
-                                        }
-
-                                        ++var17;
-                                        break;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            return var4;
-        }
-    }
-
-    /**
-     * Returns whether or not the specified creature type can spawn at the specified location.
-     */
+														 */
+														// END FCMOD
+														{
+															if (var22 == null)
+															{
+																var22 = par0WorldServer.spawnRandomCreature(var35, var18, var19, var20);
+
+																if (var22 == null)
+																{
+																	break label103;
+																}
+															}
+
+															EntityLiving var39;
+
+															try
+															{
+																var39 = (EntityLiving)var22.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0WorldServer});
+															}
+															catch (Exception var31)
+															{
+																var31.printStackTrace();
+																return var4;
+															}
+
+															// FCMOD: Added
+															var39.PreInitCreature();
+															// END FCMOD
+
+															var39.setLocationAndAngles((double)var24, (double)var25, (double)var26, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
+
+															if (var39.getCanSpawnHere())
+															{
+																++var16;
+																par0WorldServer.spawnEntityInWorld(var39);
+																creatureSpecificInit(var39, par0WorldServer, var24, var25, var26);
+
+																if (var16 >= var39.getMaxSpawnedInChunk())
+																{
+																	continue label110;
+																}
+															}
+
+															var4 += var16;
+														}
+													}
+												}
+
+												++var23;
+												continue;
+												}
+											}
+
+											++var17;
+											break;
+										}
+									}
+								}
+							}
+						}
+				}
+			}
+
+			return var4;
+		}
+	}
+
+	/**
+	 * Returns whether or not the specified creature type can spawn at the specified location.
+	 */
+	// FCMOD: Removed and replaced
+	/*
     public static boolean canCreatureTypeSpawnAtLocation(EnumCreatureType par0EnumCreatureType, World par1World, int par2, int par3, int par4)
     {
         if (par0EnumCreatureType.getCreatureMaterial() == Material.water)
@@ -210,73 +264,212 @@ public final class SpawnerAnimals
             return var5 != Block.bedrock.blockID && !par1World.isBlockNormalCube(par2, par3, par4) && !par1World.getBlockMaterial(par2, par3, par4).isLiquid() && !par1World.isBlockNormalCube(par2, par3 + 1, par4);
         }
     }
-
-    /**
-     * determines if a skeleton spawns on a spider, and if a sheep is a different color
-     */
-    private static void creatureSpecificInit(EntityLiving par0EntityLiving, World par1World, float par2, float par3, float par4)
-    {
-        par0EntityLiving.initCreature();
+	 */
+	// END FCMOD
+
+	/**
+	 * determines if a skeleton spawns on a spider, and if a sheep is a different color
+	 */
+	private static void creatureSpecificInit(EntityLiving par0EntityLiving, World par1World, float par2, float par3, float par4)
+	{
+		par0EntityLiving.initCreature();
+	}
+
+	/**
+	 * Called during chunk generation to spawn initial creatures.
+	 */
+	public static void performWorldGenSpawning(World par0World, BiomeGenBase par1BiomeGenBase, int par2, int par3, int par4, int par5, Random par6Random)
+	{
+		List var7 = par1BiomeGenBase.getSpawnableList(EnumCreatureType.creature);
+
+		if (!var7.isEmpty())
+		{
+			while (par6Random.nextFloat() < par1BiomeGenBase.getSpawningChance())
+			{
+				SpawnListEntry var8 = (SpawnListEntry)WeightedRandom.getRandomItem(par0World.rand, var7);
+				int var9 = var8.minGroupCount + par6Random.nextInt(1 + var8.maxGroupCount - var8.minGroupCount);
+				int var10 = par2 + par6Random.nextInt(par4);
+				int var11 = par3 + par6Random.nextInt(par5);
+				int var12 = var10;
+				int var13 = var11;
+
+				for (int var14 = 0; var14 < var9; ++var14)
+				{
+					boolean var15 = false;
+
+					for (int var16 = 0; !var15 && var16 < 4; ++var16)
+					{
+						int var17 = par0World.getTopSolidOrLiquidBlock(var10, var11);
+
+						if (checkIfAnimalCanSpawn(var8, par0World, var10, var17, var11))
+						{
+							float var18 = (float)var10 + 0.5F;
+							float var19 = (float)var17;
+							float var20 = (float)var11 + 0.5F;
+							EntityLiving var21;
+
+							try
+							{
+								var21 = (EntityLiving)var8.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0World});
+							}
+							catch (Exception var23)
+							{
+								var23.printStackTrace();
+								continue;
+							}
+
+							// FCMOD: Added
+							var21.PreInitCreature();
+							// END FCMOD
+							var21.setLocationAndAngles((double)var18, (double)var19, (double)var20, par6Random.nextFloat() * 360.0F, 0.0F);
+							par0World.spawnEntityInWorld(var21);
+							creatureSpecificInit(var21, par0World, var18, var19, var20);
+							var15 = true;
+						}
+
+						var10 += par6Random.nextInt(5) - par6Random.nextInt(5);
+
+						for (var11 += par6Random.nextInt(5) - par6Random.nextInt(5); var10 < par2 || var10 >= par2 + par4 || var11 < par3 || var11 >= par3 + par4; var11 = var13 + par6Random.nextInt(5) - par6Random.nextInt(5))
+						{
+							var10 = var12 + par6Random.nextInt(5) - par6Random.nextInt(5);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public static boolean checkIfAnimalCanSpawn(SpawnListEntry entry, World world, int x, int y, int z) {
+		return canEntitySpawnDuringWorldGen(entry.entityClass, world, x, y, z);
+	}
+
+	public static boolean canCreatureTypeSpawnAtLocation( EnumCreatureType type, 
+			World world, int i, int j, int k )
+	{
+		if ( type.getCreatureMaterial() == Material.water )
+		{
+			return world.getBlockMaterial( i, j, k ).isLiquid() && 
+					world.getBlockMaterial( i, j - 1, k ).isLiquid() && 
+					!world.isBlockNormalCube( i, j + 1, k );
+		}
+
+		if ( !world.isBlockNormalCube( i, j, k ) && 
+				!world.getBlockMaterial( i, j, k ).isLiquid() )
+		{
+			Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+
+			return blockBelow != null && blockBelow.CanMobsSpawnOn( world, i, j - 1, k );
+		}
+
+		return false;
+	}
+
+	public static float GetVerticalOffsetForPos( EnumCreatureType type, 
+			World world, int i, int j, int k )
+	{
+		if ( type.getCreatureMaterial() != Material.water )
+		{
+			Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+
+			if ( blockBelow != null )
+			{
+				return blockBelow.MobSpawnOnVerticalOffset( world, i, j - 1, k );
+			}
+		}
+
+		return 0F;
+	}
+
+	public static boolean CanCreatureTypeSpawnInMaterial( EnumCreatureType type, Material material ) 
+	{
+		if ( material == Material.water )
+		{
+			return type.getCreatureMaterial() == Material.water;
+		}
+		else
+		{
+			return type.getCreatureMaterial() != Material.water;
+		}
+	}
+    
+    //------ World Gen Spawning Behavior ------//
+    private static SpawnBehavior defaultSpawnBehavior;
+    private static Map<Class<? extends EntityLiving>, SpawnBehavior> worldGenSpawnBehaviors = new HashMap();
+    
+    static {
+    	defaultSpawnBehavior = new SpawnBehavior() {
+			@Override
+			public boolean canSpawnAtLocationDuringWorldGen(World world, int x, int y, int z) {
+				// modified and trimmed down version of canCreatureTypeSpawnAtLocation() so that animals 
+		    	// don't initially spawn buried in leaves and to reduce the overall number of tests 
+		    	// performed
+		    	
+		    	int blockID = world.getBlockId(x, y, z);
+		    	
+		    	if (!Block.isNormalCube(blockID) && !world.getBlockMaterial(x, y, z).isLiquid() && blockID != Block.leaves.blockID)
+		    	{
+		    		int blockAboveID = world.getBlockId(x, y + 1, z);
+		    		
+		    		if (!Block.isNormalCube(blockAboveID) && blockAboveID != Block.leaves.blockID)
+		    		{
+			            int blockBelowID = world.getBlockId(x, y - 1, z);
+			            
+			            return Block.isNormalCube(blockBelowID) && blockBelowID != Block.bedrock.blockID;
+		    		}
+		    	}
+		        
+		        return false;
+			}
+		};
+		
+		setWorldGenSpawnBehavior(FCEntityWitch.class, new SpawnBehavior() {
+			@Override
+			public boolean canSpawnAtLocationDuringWorldGen(World world, int x, int y, int z) {
+				// modified version of default spawn behavior that allows
+				// witches to spawn over water and leaves to maximize chances they'll find a spot
+				// around generated witch huts
+		    	
+		    	int blockID = world.getBlockId(x, y, z);
+		    	
+		    	if (!Block.isNormalCube(blockID) && !world.getBlockMaterial(x, y, z).isLiquid() && blockID != Block.leaves.blockID)
+		    	{
+		    		int blockAboveID = world.getBlockId(x, y + 1, z);
+		    		
+		    		if (!Block.isNormalCube(blockAboveID) && blockAboveID != Block.leaves.blockID)
+		    		{
+			            int blockBelowID = world.getBlockId(x, y - 1, z);
+			            
+			            return blockBelowID != Block.bedrock.blockID && (Block.isNormalCube(blockBelowID) || world.getBlockMaterial(x, y - 1, z) == Material.water || blockBelowID == Block.leaves.blockID);
+		    		}
+		    	}
+		        
+		        return false;
+			}
+		});
     }
-
-    /**
-     * Called during chunk generation to spawn initial creatures.
-     */
-    public static void performWorldGenSpawning(World par0World, BiomeGenBase par1BiomeGenBase, int par2, int par3, int par4, int par5, Random par6Random)
-    {
-        List var7 = par1BiomeGenBase.getSpawnableList(EnumCreatureType.creature);
-
-        if (!var7.isEmpty())
-        {
-            while (par6Random.nextFloat() < par1BiomeGenBase.getSpawningChance())
-            {
-                SpawnListEntry var8 = (SpawnListEntry)WeightedRandom.getRandomItem(par0World.rand, var7);
-                int var9 = var8.minGroupCount + par6Random.nextInt(1 + var8.maxGroupCount - var8.minGroupCount);
-                int var10 = par2 + par6Random.nextInt(par4);
-                int var11 = par3 + par6Random.nextInt(par5);
-                int var12 = var10;
-                int var13 = var11;
-
-                for (int var14 = 0; var14 < var9; ++var14)
-                {
-                    boolean var15 = false;
-
-                    for (int var16 = 0; !var15 && var16 < 4; ++var16)
-                    {
-                        int var17 = par0World.getTopSolidOrLiquidBlock(var10, var11);
-
-                        if (canCreatureTypeSpawnAtLocation(EnumCreatureType.creature, par0World, var10, var17, var11))
-                        {
-                            float var18 = (float)var10 + 0.5F;
-                            float var19 = (float)var17;
-                            float var20 = (float)var11 + 0.5F;
-                            EntityLiving var21;
-
-                            try
-                            {
-                                var21 = (EntityLiving)var8.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0World});
-                            }
-                            catch (Exception var23)
-                            {
-                                var23.printStackTrace();
-                                continue;
-                            }
-
-                            var21.setLocationAndAngles((double)var18, (double)var19, (double)var20, par6Random.nextFloat() * 360.0F, 0.0F);
-                            par0World.spawnEntityInWorld(var21);
-                            creatureSpecificInit(var21, par0World, var18, var19, var20);
-                            var15 = true;
-                        }
-
-                        var10 += par6Random.nextInt(5) - par6Random.nextInt(5);
-
-                        for (var11 += par6Random.nextInt(5) - par6Random.nextInt(5); var10 < par2 || var10 >= par2 + par4 || var11 < par3 || var11 >= par3 + par4; var11 = var13 + par6Random.nextInt(5) - par6Random.nextInt(5))
-                        {
-                            var10 = var12 + par6Random.nextInt(5) - par6Random.nextInt(5);
-                        }
-                    }
-                }
-            }
-        }
+    
+    public static boolean canEntitySpawnDuringWorldGen(Class<? extends EntityLiving> entityClass, World world, int x, int y, int z) {
+    	SpawnBehavior spawnBehavior = worldGenSpawnBehaviors.get(entityClass);
+    	
+    	if (spawnBehavior != null) {
+    		return spawnBehavior.canSpawnAtLocationDuringWorldGen(world, x, y, z);
+    	}
+    	else {
+    		return defaultSpawnBehavior.canSpawnAtLocationDuringWorldGen(world, x, y, z);
+    	}
+    }
+    
+    public static void setWorldGenSpawnBehavior(Class<? extends EntityLiving> entityClass, SpawnBehavior spawnBehavior) {
+    	worldGenSpawnBehaviors.put(entityClass, spawnBehavior);
+    }
+    
+    public static void removeCustomWorldGenSpawnBehavior(Class<? extends EntityLiving> entityClass) {
+    	worldGenSpawnBehaviors.remove(entityClass);
     }
-}
+	
+	public static abstract class SpawnBehavior {
+		public abstract boolean canSpawnAtLocationDuringWorldGen(World world, int x, int y, int z);
+	}
+	
+	// END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft/net/minecraft/src/StatList.java b/minecraft/net/minecraft/src/StatList.java
index e000042..5cc1e22 100644
--- a/minecraft/net/minecraft/src/StatList.java
+++ b/minecraft/net/minecraft/src/StatList.java
@@ -173,9 +173,16 @@ public class StatList
      */
     private static StatBase[] initMinableStats(String par0Str, int par1)
     {
+    	// FCMOD: Change to accomodate extended block IDs 
+    	/*
         StatBase[] var2 = new StatBase[256];
 
         for (int var3 = 0; var3 < 256; ++var3)
+        */
+        StatBase[] var2 = new StatBase[4096];
+
+        for (int var3 = 0; var3 < 4096; ++var3)
+    	// END FCMOD
         {
             if (Block.blocksList[var3] != null && Block.blocksList[var3].getEnableStats())
             {
diff --git a/minecraft/net/minecraft/src/StringTranslate.java b/minecraft/net/minecraft/src/StringTranslate.java
index f6ea997..aae458d 100644
--- a/minecraft/net/minecraft/src/StringTranslate.java
+++ b/minecraft/net/minecraft/src/StringTranslate.java
@@ -10,6 +10,8 @@ import java.util.IllegalFormatException;
 import java.util.Properties;
 import java.util.TreeMap;
 
+import net.minecraft.client.Minecraft;
+
 public class StringTranslate
 {
     /** Is the private singleton instance of StringTranslate. */
@@ -154,6 +156,10 @@ public class StringTranslate
 
             this.currentLanguage = par1Str;
             this.translateTable = var3;
+            
+            // FCMOD: Code added
+            FCAddOnHandler.OnLanguageLoaded( this );
+            // END FCMOD
         }
     }
 
@@ -226,4 +232,49 @@ public class StringTranslate
             this.setLanguage(this.currentLanguage, true);
         }
     }
+    
+    // FCMOD
+    public Properties GetTranslateTable()
+    {
+    	return translateTable;
+    }
+    
+    public void LoadAddonLanguageExtension( String sAddonPrefix )
+    {
+    	SafeLoadLanguage( sAddonPrefix + "_" + "en_US" );
+    	
+        SafeLoadLanguage( sAddonPrefix + "_" + currentLanguage );
+    }
+    
+    private void SafeLoadLanguage( String sLanguageName )
+    {
+        if ( StringTranslate.class.getResource( "/lang/" + sLanguageName + ".lang" ) != null )
+        {
+	        try
+	        {
+	            loadLanguage( translateTable, sLanguageName );
+	        }
+	        catch ( IOException exception )
+	        {
+	            ;
+	        }
+        }
+    }
+    
+    public void DebugOutputCurrentLanguage()
+    {
+        Enumeration var4 = translateTable.propertyNames();
+
+        while ( var4.hasMoreElements() )
+        {
+            Object var5 = var4.nextElement();
+            Object var6 = translateTable.get(var5);
+
+            if (var6 != null)
+            {
+                System.out.println( var5.toString() + "=" + var6.toString() );
+            }
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/StructureComponent.java b/minecraft/net/minecraft/src/StructureComponent.java
index 4a875dc..4dd7bee 100644
--- a/minecraft/net/minecraft/src/StructureComponent.java
+++ b/minecraft/net/minecraft/src/StructureComponent.java
@@ -210,7 +210,10 @@ public abstract class StructureComponent
                 return 1;
             }
         }
-        else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID)
+        // FCMOD: Changed
+        //else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID)
+        else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID && par1 != FCBetterThanWolves.fcBlockDoorWood.blockID)
+    	// END FCMOD
         {
             if (par1 != Block.stairsCobblestone.blockID && par1 != Block.stairsWoodOak.blockID && par1 != Block.stairsNetherBrick.blockID && par1 != Block.stairsStoneBrick.blockID && par1 != Block.stairsSandStone.blockID)
             {
@@ -770,9 +773,17 @@ public abstract class StructureComponent
         int var10 = this.getYWithOffset(par5);
         int var11 = this.getZWithOffset(par4, par6);
 
+        // FCMOD: Changed
+        /*
         if (par2StructureBoundingBox.isVecInside(var9, var10, var11) && par1World.getBlockId(var9, var10, var11) != Block.chest.blockID)
         {
             par1World.setBlock(var9, var10, var11, Block.chest.blockID, 0, 2);
+        */
+        if (par2StructureBoundingBox.isVecInside(var9, var10, var11) && 
+        	par1World.getBlockId(var9, var10, var11) != FCBetterThanWolves.fcBlockChest.blockID)
+        {
+            par1World.setBlock(var9, var10, var11, FCBetterThanWolves.fcBlockChest.blockID, 0, 2);
+        // END FCMOD
             TileEntityChest var12 = (TileEntityChest)par1World.getBlockTileEntity(var9, var10, var11);
 
             if (var12 != null)
@@ -823,7 +834,10 @@ public abstract class StructureComponent
 
         if (par2StructureBoundingBox.isVecInside(var8, var9, var10))
         {
-            ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, Block.doorWood);
+            // FCMOD: Changed
+            //ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, Block.doorWood);
+            ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, FCBetterThanWolves.fcBlockDoorWood);
+            // END FCMOD
         }
     }
 }
diff --git a/minecraft/net/minecraft/src/Texture.java b/minecraft/net/minecraft/src/Texture.java
index 1f2e387..7d58ee8 100644
--- a/minecraft/net/minecraft/src/Texture.java
+++ b/minecraft/net/minecraft/src/Texture.java
@@ -1,9 +1,11 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.Wrapper15;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
 import javax.imageio.ImageIO;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
@@ -21,12 +23,12 @@ public class Texture
     /** Height of this texture in pixels. */
     private final int height;
     private final int textureDepth;
-    private final int textureFormat;
+    public int textureFormat;
     private final int textureTarget;
-    private final int textureMinFilter;
+    public int textureMinFilter;
     private final int textureMagFilter;
     private final int textureWrap;
-    private final boolean mipmapActive;
+    public boolean mipmapActive;
     private final String textureName;
     private Rect2i textureRect;
     private boolean transferred;
@@ -41,7 +43,9 @@ public class Texture
      * False if the texture has been modified since it was last uploaded to the GPU.
      */
     private boolean textureNotModified;
-    private ByteBuffer textureData;
+    public ByteBuffer textureData;
+    public int border;
+    public IntBuffer[] mipmapData;
 
     private Texture(String par1Str, int par2, int par3, int par4, int par5, int par6, int par7, int par8, int par9)
     {
@@ -213,7 +217,11 @@ public class Texture
 
     public void copyFrom(int par1, int par2, Texture par3Texture, boolean par4)
     {
-        if (this.textureTarget != 32879)
+    	if (this.textureNotModified)
+        {
+            Wrapper15.copySubTexture(this, par3Texture, par1, par2, par4);
+        }
+        else if (this.textureTarget != 32879)
         {
             ByteBuffer var5 = par3Texture.getTextureData();
             this.textureData.position(0);
@@ -262,9 +270,16 @@ public class Texture
 
     public void func_104062_b(int par1, int par2, Texture par3Texture)
     {
-        GL11.glBindTexture(this.textureTarget, this.glTextureId);
-        GL11.glTexSubImage2D(this.textureTarget, 0, par1, par2, par3Texture.getWidth(), par3Texture.getHeight(), this.textureFormat, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)par3Texture.getTextureData().position(0));
-        this.textureNotModified = true;
+    	if (this.textureNotModified)
+        {
+            Wrapper15.copySubTexture(this, par3Texture, par1, par2, false);
+        }
+        else
+        {
+            GL11.glBindTexture(this.textureTarget, this.glTextureId);
+            GL11.glTexSubImage2D(this.textureTarget, 0, par1, par2, par3Texture.getWidth(), par3Texture.getHeight(), this.textureFormat, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)par3Texture.getTextureData().position(0));
+            this.textureNotModified = true;
+        }
     }
 
     public void transferFromImage(BufferedImage par1BufferedImage)
@@ -373,7 +388,7 @@ public class Texture
         }
         else if (this.height != 1)
         {
-            GL11.glTexImage2D(this.textureTarget, 0, this.textureFormat, this.width, this.height, 0, this.textureFormat, GL11.GL_UNSIGNED_BYTE, this.textureData);
+        	Wrapper15.setupTexture(this, this.getTextureName());
         }
         else
         {
@@ -387,4 +402,13 @@ public class Texture
     {
         return this.textureData;
     }
+    
+    // FCMOD: Code added
+    public void UploadByteBufferToGPU( int iDestX, int iDestY, ByteBuffer buffer, int iBufferWidth, int iBufferHeight )
+    {
+        GL11.glBindTexture(this.textureTarget, this.glTextureId);
+        GL11.glTexSubImage2D(this.textureTarget, 0, iDestX, iDestY, iBufferWidth, iBufferHeight, this.textureFormat, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)buffer.position(0) );
+        this.textureNotModified = true;
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TextureClock.java b/minecraft/net/minecraft/src/TextureClock.java
index a3b0857..95b3fab 100644
--- a/minecraft/net/minecraft/src/TextureClock.java
+++ b/minecraft/net/minecraft/src/TextureClock.java
@@ -1,15 +1,20 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.FancyDial;
 import net.minecraft.client.Minecraft;
 
 public class TextureClock extends TextureStitched
 {
-    private double field_94239_h;
+	public double field_94239_h;
     private double field_94240_i;
 
     public TextureClock()
     {
         super("compass");
+        FancyDial.setup(this);
+        // FCMOD: Code added
+        m_clockTexture = this;
+        // END FCMOD
     }
 
     public void updateAnimation()
@@ -25,7 +30,7 @@ public class TextureClock extends TextureStitched
             if (!var1.theWorld.provider.isSurfaceWorld())
             {
                 var2 = Math.random();
-            }
+            }            
         }
 
         double var7;
@@ -53,17 +58,30 @@ public class TextureClock extends TextureStitched
         this.field_94240_i += var7 * 0.1D;
         this.field_94240_i *= 0.8D;
         this.field_94239_h += this.field_94240_i;
-        int var6;
-
-        for (var6 = (int)((this.field_94239_h + 1.0D) * (double)this.textureList.size()) % this.textureList.size(); var6 < 0; var6 = (var6 + this.textureList.size()) % this.textureList.size())
+        if (!FancyDial.update(this, false))
         {
-            ;
-        }
+        	int var6;
 
-        if (var6 != this.frameCounter)
-        {
-            this.frameCounter = var6;
-            this.textureSheet.copyFrom(this.originX, this.originY, (Texture)this.textureList.get(this.frameCounter), this.rotated);
+        	for (var6 = (int)((this.field_94239_h + 1.0D) * (double)this.textureList.size()) % this.textureList.size(); var6 < 0; var6 = (var6 + this.textureList.size()) % this.textureList.size())
+            {
+                ;
+            }
+
+            if (var6 != this.frameCounter)
+            {
+                this.frameCounter = var6;
+                this.textureSheet.copyFrom(this.originX, this.originY, (Texture)this.textureList.get(this.frameCounter), this.rotated);
+            }
         }
     }
+    
+    // FCMOD: Code added
+    public static TextureClock m_clockTexture;
+    
+    public void UpdateInert()
+    {
+        this.frameCounter = 0;
+        this.textureSheet.copyFrom(this.originX, this.originY, (Texture)this.textureList.get(this.frameCounter), this.rotated);
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TextureCompass.java b/minecraft/net/minecraft/src/TextureCompass.java
index f5b9a69..ab69fc5 100644
--- a/minecraft/net/minecraft/src/TextureCompass.java
+++ b/minecraft/net/minecraft/src/TextureCompass.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.FancyDial;
 import net.minecraft.client.Minecraft;
 
 public class TextureCompass extends TextureStitched
@@ -11,15 +12,22 @@ public class TextureCompass extends TextureStitched
 
     /** Speed and direction of compass rotation */
     public double angleDelta;
+    
+    // FCMOD: Added
+    private boolean m_bDirectionUpdated = false;
+    // END FCMOD
 
     public TextureCompass()
     {
         super("compass");
         compassTexture = this;
+        FancyDial.setup(this);
     }
 
     public void updateAnimation()
     {
+    	// FCMOD: Changed
+    	/*
         Minecraft var1 = Minecraft.getMinecraft();
 
         if (var1.theWorld != null && var1.thePlayer != null)
@@ -30,17 +38,29 @@ public class TextureCompass extends TextureStitched
         {
             this.updateCompass((World)null, 0.0D, 0.0D, 0.0D, true, false);
         }
+        */
+    	UpdateInert();
+    	
+    	m_bDirectionUpdated = false;
+    	// END FCMOD
     }
 
     /**
      * Updates the compass based on the given x,z coords and camera direction
      */
+    // FCMOD: Changed to add player param (client only)
+    /*
     public void updateCompass(World par1World, double par2, double par4, double par6, boolean par8, boolean par9)
+    */
+    private void updateCompass(World par1World, double par2, double par4, double par6, boolean par8, boolean par9, EntityPlayer player )
+    // END FCMOD
     {
         double var10 = 0.0D;
 
         if (par1World != null && !par8)
         {
+        	// FCMOD: Code change (client only)
+        	/*
             ChunkCoordinates var12 = par1World.getSpawnPoint();
             double var13 = (double)var12.posX - par2;
             double var15 = (double)var12.posZ - par4;
@@ -51,13 +71,18 @@ public class TextureCompass extends TextureStitched
             {
                 var10 = Math.random() * Math.PI * 2.0D;
             }
+            */
+        	var10 = ComputeCompassAngle( par2, par4, par6, par9, player );
+    		// END FCMOD
         }
 
         if (par9)
         {
             this.currentAngle = var10;
         }
-        else
+        // FCMOD: Changed
+        else if ( !m_bDirectionUpdated )
+    	// END FCMOD
         {
             double var17;
 
@@ -84,19 +109,75 @@ public class TextureCompass extends TextureStitched
             this.angleDelta += var17 * 0.1D;
             this.angleDelta *= 0.8D;
             this.currentAngle += this.angleDelta;
+            // FCMOD: Added
+            m_bDirectionUpdated = true;
+            // END FCMOD
         }
 
-        int var18;
-
-        for (var18 = (int)((this.currentAngle / (Math.PI * 2D) + 1.0D) * (double)this.textureList.size()) % this.textureList.size(); var18 < 0; var18 = (var18 + this.textureList.size()) % this.textureList.size())
+        if (!FancyDial.update(this, par9))
         {
-            ;
+        	int var18;
+
+        	for (var18 = (int)((this.currentAngle / (Math.PI * 2D) + 1.0D) * (double)this.textureList.size()) % this.textureList.size(); var18 < 0; var18 = (var18 + this.textureList.size()) % this.textureList.size())
+            {
+                ;
+            }
+
+            if (var18 != this.frameCounter)
+            {
+                this.frameCounter = var18;
+                this.textureSheet.copyFrom(this.originX, this.originY, (Texture)this.textureList.get(this.frameCounter), this.rotated);
+            }
         }
+    }
+    
+    // FCMOD: Added (client only)
+    public void UpdateActive()
+    {
+        Minecraft mc = Minecraft.getMinecraft();
 
-        if (var18 != this.frameCounter)
+        if ( mc.theWorld != null && mc.thePlayer != null )
         {
-            this.frameCounter = var18;
-            this.textureSheet.copyFrom(this.originX, this.originY, (Texture)this.textureList.get(this.frameCounter), this.rotated);
+            updateCompass( mc.theWorld, mc.thePlayer.posX, mc.thePlayer.posZ, 
+            	mc.thePlayer.rotationYaw, false, false, mc.thePlayer );
         }
+        else
+        {
+            updateCompass( null, 0.0D, 0.0D, 0.0D, true, false, null );
+        }
+    }
+    
+    public void UpdateInert()
+    {
+        this.frameCounter = textureList.size() / 2;
+        this.textureSheet.copyFrom(this.originX, this.originY, (Texture)this.textureList.get(this.frameCounter), this.rotated);
     }
+    
+	private double ComputeCompassAngle( double dSourceX, double dSourceZ, double dSourceYaw, boolean bIsInFrame, EntityPlayer player )
+	{
+		double angle = Math.PI;
+		
+        if ( !bIsInFrame && player != null )
+		{
+            if ( !player.HasValidMagneticPointForLocation() )
+            {
+                angle = Math.random() * Math.PI * 2.0D;
+            }
+            else
+            {
+		        int iTargetI = player.GetStongestMagneticPointForLocationI();
+		        int iTargetK = player.GetStongestMagneticPointForLocationK();
+		        
+		        double dDeltaX = (double)iTargetI + 0.5D - dSourceX;
+		        double dDeltaZ = (double)iTargetK + 0.5D - dSourceZ;
+		        
+		        dSourceYaw %= 360D;
+		        
+		        angle = -(( dSourceYaw - 90.0D ) * Math.PI / 180.0D - Math.atan2( dDeltaZ, dDeltaX ));
+            }
+		}
+        
+		return angle;
+	}
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TextureManager.java b/minecraft/net/minecraft/src/TextureManager.java
index 6d8f40c..8fdb0e1 100644
--- a/minecraft/net/minecraft/src/TextureManager.java
+++ b/minecraft/net/minecraft/src/TextureManager.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.AAHelper;
+import com.prupe.mcpatcher.hd.Wrapper15;
+import com.prupe.mcpatcher.mal.tile.TileLoader;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -70,7 +73,7 @@ public class TextureManager
             BufferedImage var9 = ImageIO.read(var3.getResourceAsStream("/" + par1Str));
             int var10 = var9.getHeight();
             int var11 = var9.getWidth();
-            String var12 = this.getBasename(par1Str);
+            String var12 = TileLoader.getOverrideBasename(this, par1Str);
 
             if (this.hasAnimationTxt(par1Str, var3))
             {
@@ -128,7 +131,16 @@ public class TextureManager
 
     public Texture makeTexture(String par1Str, int par2, int par3, int par4, int par5, int par6, int par7, int par8, boolean par9, BufferedImage par10BufferedImage)
     {
+    	par10BufferedImage = Wrapper15.addAABorder(par1Str, par10BufferedImage);
+
+        if (par10BufferedImage != null)
+        {
+            par3 = par10BufferedImage.getWidth();
+            par4 = par10BufferedImage.getHeight();
+        }
+        
         Texture var11 = new Texture(par1Str, par2, par3, par4, par5, par6, par7, par8, par10BufferedImage);
+        var11.border = AAHelper.lastBorder;
         this.registerTexture(var11);
         return var11;
     }
diff --git a/minecraft/net/minecraft/src/TextureMap.java b/minecraft/net/minecraft/src/TextureMap.java
index 75f3366..8172994 100644
--- a/minecraft/net/minecraft/src/TextureMap.java
+++ b/minecraft/net/minecraft/src/TextureMap.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.Wrapper15;
+import com.prupe.mcpatcher.mal.tile.TileLoader;
 import java.awt.image.BufferedImage;
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -18,7 +20,7 @@ public class TextureMap implements IconRegister
     /** 0 = terrain.png, 1 = items.png */
     private final int textureType;
     private final String textureName;
-    private final String basePath;
+    public final String basePath;
     private final String textureExt;
     private final HashMap mapTexturesStiched = new HashMap();
     private BufferedImage missingImage = new BufferedImage(64, 64, 2);
@@ -38,6 +40,7 @@ public class TextureMap implements IconRegister
 
     public void refreshTextures()
     {
+    	Wrapper15.currentAtlas = this;
         this.textureStichedMap.clear();
         int var2;
         int var3;
@@ -66,11 +69,11 @@ public class TextureMap implements IconRegister
 
         for (var3 = 0; var3 < var2; ++var3)
         {
-            Item var23 = var19[var3];
+            Item var22 = var19[var3];
 
-            if (var23 != null && var23.getSpriteNumber() == this.textureType)
+            if (var22 != null && var22.getSpriteNumber() == this.textureType)
             {
-                var23.registerIcons(this);
+                var22.registerIcons(this);
             }
         }
 
@@ -78,16 +81,17 @@ public class TextureMap implements IconRegister
         Stitcher var21 = TextureManager.instance().createStitcher(this.textureName);
         this.mapTexturesStiched.clear();
         this.listTextureStiched.clear();
-        Texture var22 = TextureManager.instance().makeTexture("missingno", 2, this.missingImage.getWidth(), this.missingImage.getHeight(), 10496, 6408, 9728, 9728, false, this.missingImage);
-        StitchHolder var24 = new StitchHolder(var22);
+        TileLoader.registerIcons(this, this.basePath, this.textureStichedMap);
+        Texture var23 = TextureManager.instance().makeTexture("missingno", 2, this.missingImage.getWidth(), this.missingImage.getHeight(), 10496, 6408, 9728, 9728, false, this.missingImage);
+        StitchHolder var24 = new StitchHolder(var23);
         var21.addStitchHolder(var24);
-        var20.put(var24, Arrays.asList(new Texture[] {var22}));
+        var20.put(var24, Arrays.asList(new Texture[] {var23}));
         Iterator var5 = this.textureStichedMap.keySet().iterator();
 
         while (var5.hasNext())
         {
             String var6 = (String)var5.next();
-            String var7 = this.basePath + var6 + this.textureExt;
+            String var7 = TileLoader.getOverridePath("", this.basePath, var6, this.textureExt);
             List var8 = TextureManager.instance().createTexture(var7);
 
             if (!var8.isEmpty())
@@ -112,8 +116,8 @@ public class TextureMap implements IconRegister
 
         while (var5.hasNext())
         {
-            StitchSlot var25 = (StitchSlot)var5.next();
-            StitchHolder var27 = var25.getStitchHolder();
+            StitchSlot var26 = (StitchSlot)var5.next();
+            StitchHolder var27 = var26.getStitchHolder();
             Texture var28 = var27.func_98150_a();
             String var29 = var28.getTextureName();
             List var10 = (List)var20.get(var27);
@@ -131,7 +135,7 @@ public class TextureMap implements IconRegister
                 }
             }
 
-            var11.init(this.atlasTexture, var10, var25.getOriginX(), var25.getOriginY(), var27.func_98150_a().getWidth(), var27.func_98150_a().getHeight(), var27.isRotated());
+            var11.init(this.atlasTexture, var10, var26.getOriginX(), var26.getOriginY(), var27.func_98150_a().getWidth(), var27.func_98150_a().getHeight(), var27.isRotated());
             this.mapTexturesStiched.put(var29, var11);
 
             if (!var12)
@@ -142,14 +146,16 @@ public class TextureMap implements IconRegister
             if (var10.size() > 1)
             {
                 this.listTextureStiched.add(var11);
-                String var13 = this.basePath + var29 + ".txt";
+                String var13 = TileLoader.getOverridePath("", this.basePath, var29, ".txt");
                 ITexturePack var14 = Minecraft.getMinecraft().texturePackList.getSelectedTexturePack();
-                boolean var15 = !var14.func_98138_b("/" + this.basePath + var29 + ".png", false);
+                boolean var15 = !var14.func_98138_b(TileLoader.getOverridePath("/", this.basePath, var29, ".png"), false);
 
                 try
                 {
                     InputStream var16 = var14.func_98137_a("/" + var13, var15);
-                    Minecraft.getMinecraft().getLogAgent().logInfo("Found animation info for: " + var13);
+                    // FCMOD: Removed (client only) to reduce console spam
+                    //Minecraft.getMinecraft().getLogAgent().logInfo("Found animation info for: " + var13);
+                    // END FCMOD
                     var11.readAnimationInfo(new BufferedReader(new InputStreamReader(var16)));
                 }
                 catch (IOException var17)
@@ -157,6 +163,12 @@ public class TextureMap implements IconRegister
                     ;
                 }
             }
+            // FCMOD: Added (client only)
+            else if ( var11.IsProcedurallyAnimated() )
+            {
+                listTextureStiched.add(var11);
+            }
+            // END FCMOD
         }
 
         this.missingTextureStiched = (TextureStitched)this.mapTexturesStiched.get("missingno");
@@ -164,8 +176,8 @@ public class TextureMap implements IconRegister
 
         while (var5.hasNext())
         {
-            TextureStitched var26 = (TextureStitched)var5.next();
-            var26.copyFrom(this.missingTextureStiched);
+            TextureStitched var25 = (TextureStitched)var5.next();
+            var25.copyFrom(this.missingTextureStiched);
         }
 
         this.atlasTexture.writeImage("debug.stitched_" + this.textureName + ".png");
@@ -174,6 +186,10 @@ public class TextureMap implements IconRegister
 
     public void updateAnimations()
     {
+    	// FCMOD: Added (client only)
+    	FCClientAnimationFire.UpdateInstances();
+    	// END FCMOD
+    	
         Iterator var1 = this.listTextureStiched.iterator();
 
         while (var1.hasNext())
@@ -205,9 +221,31 @@ public class TextureMap implements IconRegister
 
         return var2;
     }
-
+    
     public Icon getMissingIcon()
     {
         return this.missingTextureStiched;
     }
+
+    // FCMOD: Added New (client only)
+    public Icon registerIcon( String sName, TextureStitched textureHandler )
+    {
+    	// overloaded function to allow specifying a custom handler
+    	
+        if ( sName == null)
+        {
+            (new RuntimeException("Don\'t register null!")).printStackTrace();
+        }
+
+        TextureStitched icon = (TextureStitched)this.textureStichedMap.get( sName );
+
+        if ( icon == null )
+        {
+            icon = textureHandler;
+            this.textureStichedMap.put( sName, icon );
+        }
+
+        return icon;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TexturePackCustom.java b/minecraft/net/minecraft/src/TexturePackCustom.java
index 0fa0cbc..cc4acd1 100644
--- a/minecraft/net/minecraft/src/TexturePackCustom.java
+++ b/minecraft/net/minecraft/src/TexturePackCustom.java
@@ -12,7 +12,7 @@ import java.util.zip.ZipFile;
 public class TexturePackCustom extends TexturePackImplementation
 {
     /** ZipFile object used to access the texture pack file's contents. */
-    private ZipFile texturePackZipFile;
+    public ZipFile texturePackZipFile;
 
     public TexturePackCustom(String par1Str, File par2File, ITexturePack par3ITexturePack)
     {
diff --git a/minecraft/net/minecraft/src/TexturePackImplementation.java b/minecraft/net/minecraft/src/TexturePackImplementation.java
index a2732be..f242f79 100644
--- a/minecraft/net/minecraft/src/TexturePackImplementation.java
+++ b/minecraft/net/minecraft/src/TexturePackImplementation.java
@@ -24,7 +24,7 @@ public abstract class TexturePackImplementation implements ITexturePack
     /**
      * File object for the texture pack's zip file in TexturePackCustom or the directory in TexturePackFolder.
      */
-    protected final File texturePackFile;
+    public final File texturePackFile;
 
     /**
      * First line of texture pack description (from /pack.txt) displayed in the GUI
diff --git a/minecraft/net/minecraft/src/TextureStitched.java b/minecraft/net/minecraft/src/TextureStitched.java
index d8d6643..e556a9a 100644
--- a/minecraft/net/minecraft/src/TextureStitched.java
+++ b/minecraft/net/minecraft/src/TextureStitched.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.hd.Wrapper15;
 import java.io.BufferedReader;
 import java.util.ArrayList;
 import java.util.List;
@@ -36,10 +37,10 @@ public class TextureStitched implements Icon
 
     public static TextureStitched makeTextureStitched(String par0Str)
     {
-        return (TextureStitched)("clock".equals(par0Str) ? new TextureClock() : ("compass".equals(par0Str) ? new TextureCompass() : new TextureStitched(par0Str)));
+    	return (TextureStitched)("clock".equals(par0Str) ? new TextureClock() : ("compass".equals(par0Str) ? new TextureCompass() : Wrapper15.createSprite(par0Str)));
     }
 
-    protected TextureStitched(String par1)
+    public TextureStitched(String par1)
     {
         this.textureName = par1;
     }
@@ -233,4 +234,11 @@ public class TextureStitched implements Icon
             this.listAnimationTuples = var2;
         }
     }
+    
+    // FCMOD: Code added
+    public boolean IsProcedurallyAnimated()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/ThreadDownloadImage.java b/minecraft/net/minecraft/src/ThreadDownloadImage.java
index 7762173..913d32d 100644
--- a/minecraft/net/minecraft/src/ThreadDownloadImage.java
+++ b/minecraft/net/minecraft/src/ThreadDownloadImage.java
@@ -1,11 +1,20 @@
 package net.minecraft.src;
 
+import java.io.File;
+import java.io.InputStreamReader;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+
 import javax.imageio.ImageIO;
 
+import argo.jdom.JdomParser;
+import argo.jdom.JsonRootNode;
+
 class ThreadDownloadImage extends Thread
 {
+	final static Map<String, String> uuids = new HashMap<String, String>();
     /** The URL of the image to download. */
     final String location;
 
@@ -22,13 +31,66 @@ class ThreadDownloadImage extends Thread
         this.buffer = par3IImageBuffer;
     }
 
+    private String fetchUuid(String userName) {
+        if (uuids.containsKey(userName))
+            return uuids.get(userName);
+
+        HttpURLConnection profileConn = null;
+        String id = null;
+
+        try {
+            URL profileUrl = new URL("https://api.mojang.com/users/profiles/minecraft/" + userName);
+            profileConn = (HttpURLConnection) profileUrl.openConnection();
+            profileConn.setDoInput(true);
+            profileConn.setDoOutput(false);
+            profileConn.connect();
+
+            if (profileConn.getResponseCode() / 100 == 4) {
+                return null;
+            }
+
+            JsonRootNode json = (new JdomParser())
+                    .parse(new InputStreamReader(profileConn.getInputStream()));
+
+            String name = json.getStringValue("name");
+            id = json.getStringValue("id");
+
+            if (userName.equals(name)) {
+                uuids.put(userName, id);
+            } else {
+                id = null;
+            }
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+        }
+        finally {
+            if (profileConn != null)
+                profileConn.disconnect();
+        }
+        return id;
+    }
+
     public void run()
     {
         HttpURLConnection var1 = null;
+        String urlLocation = this.location;
 
         try
         {
-            URL var2 = new URL(this.location);
+            if (this.location.startsWith("http://skins.minecraft.net/")) {
+                String userName = new File(this.location, "")
+                        .getName()
+                        .replaceFirst("[.][^.]+$", "");
+
+                String uuid = fetchUuid(userName);
+                if (this.location.startsWith("http://skins.minecraft.net/MinecraftSkins"))
+                    urlLocation = "http://crafatar.com/skins/" + uuid;
+                if (this.location.startsWith("http://skins.minecraft.net/MinecraftCloaks"))
+                    urlLocation = "http://crafatar.com/capes/" + uuid;
+            }
+
+            URL var2 = new URL(urlLocation);
             var1 = (HttpURLConnection)var2.openConnection();
             var1.setDoInput(true);
             var1.setDoOutput(false);
diff --git a/minecraft/net/minecraft/src/TileEntity.java b/minecraft/net/minecraft/src/TileEntity.java
index 97d7623..309fdf2 100644
--- a/minecraft/net/minecraft/src/TileEntity.java
+++ b/minecraft/net/minecraft/src/TileEntity.java
@@ -36,7 +36,12 @@ public class TileEntity
     /**
      * Adds a new two-way mapping between the class and its string name in both hashmaps.
      */
+    // FCMOD: Code change
+    /*
     private static void addMapping(Class par0Class, String par1Str)
+    */
+    public static void addMapping(Class par0Class, String par1Str)
+    // END FCMOD
     {
         if (nameToClassMap.containsKey(par1Str))
         {
@@ -283,4 +288,19 @@ public class TileEntity
         addMapping(TileEntityHopper.class, "Hopper");
         addMapping(TileEntityComparator.class, "Comparator");
     }
+    
+    // FCMOD: Code added
+    public static void ReplaceVanillaMapping( Class vanillaClass, Class newClass, String name )
+    {
+    	removeTileEntityMapping( vanillaClass, name );
+    	
+    	addMapping( newClass, name );
+    }
+    
+    public static void removeTileEntityMapping( Class className, String sTileEntityName )
+    {
+        nameToClassMap.remove( sTileEntityName );
+        classToNameMap.remove( className );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TileEntityBeacon.java b/minecraft/net/minecraft/src/TileEntityBeacon.java
index 7c0ddae..1322912 100644
--- a/minecraft/net/minecraft/src/TileEntityBeacon.java
+++ b/minecraft/net/minecraft/src/TileEntityBeacon.java
@@ -396,4 +396,31 @@ public class TileEntityBeacon extends TileEntity implements IInventory
     {
         return par2ItemStack.itemID == Item.emerald.itemID || par2ItemStack.itemID == Item.diamond.itemID || par2ItemStack.itemID == Item.ingotGold.itemID || par2ItemStack.itemID == Item.ingotIron.itemID;
     }
+    
+    // FCMOD: Code added
+    protected boolean IsOn()
+    {
+    	return isBeaconActive;
+    }
+    
+    protected void SetIsOn( boolean bOn )
+    {
+    	isBeaconActive = bOn;
+    }
+    
+    protected void SetPrimaryEffect( int iEffect )
+    {
+    	primaryEffect = iEffect;
+    }
+    
+    public void setLevelsServerSafe(int par1)
+    {
+        levels = par1;
+    }
+    
+    public boolean IsHomeBeacon()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TileEntityBeaconRenderer.java b/minecraft/net/minecraft/src/TileEntityBeaconRenderer.java
index 9767827..4df56ff 100644
--- a/minecraft/net/minecraft/src/TileEntityBeaconRenderer.java
+++ b/minecraft/net/minecraft/src/TileEntityBeaconRenderer.java
@@ -14,7 +14,19 @@ public class TileEntityBeaconRenderer extends TileEntitySpecialRenderer
         if (var9 > 0.0F)
         {
             Tessellator var10 = Tessellator.instance;
-            this.bindTextureByName("/misc/beam.png");
+            // FCMOD: Change
+            /*
+            //this.bindTextureByName("/misc/beam.png");
+            */
+            if ( par1TileEntityBeacon.IsHomeBeacon() )
+            {
+            	bindTextureByName( "/btwmodtex/fcBeam.png" );
+            }
+            else
+            {
+            	bindTextureByName( "/misc/beam.png" );
+            }
+            // END FCMOD
             GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, 10497.0F);
             GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, 10497.0F);
             GL11.glDisable(GL11.GL_LIGHTING);
@@ -22,13 +34,19 @@ public class TileEntityBeaconRenderer extends TileEntitySpecialRenderer
             GL11.glDisable(GL11.GL_BLEND);
             GL11.glDepthMask(true);
             GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE);
-            float var11 = (float)par1TileEntityBeacon.getWorldObj().getTotalWorldTime() + par8;
+            float var11 = (float)(par1TileEntityBeacon.getWorldObj().getTotalWorldTime() % 8388471L) + par8;
             float var12 = -var11 * 0.2F - (float)MathHelper.floor_float(-var11 * 0.1F);
             byte var13 = 1;
             double var14 = (double)var11 * 0.025D * (1.0D - (double)(var13 & 1) * 2.5D);
             var10.startDrawingQuads();
             var10.setColorRGBA(255, 255, 255, 32);
             double var16 = (double)var13 * 0.2D;
+            // FCMOD: Code added
+            if ( par1TileEntityBeacon.IsHomeBeacon() )
+            {
+            	var16 *= 1.5D;
+            }
+            // END FCMOD
             double var18 = 0.5D + Math.cos(var14 + 2.356194490192345D) * var16;
             double var20 = 0.5D + Math.sin(var14 + 2.356194490192345D) * var16;
             double var22 = 0.5D + Math.cos(var14 + (Math.PI / 4D)) * var16;
@@ -65,13 +83,26 @@ public class TileEntityBeaconRenderer extends TileEntitySpecialRenderer
             var10.startDrawingQuads();
             var10.setColorRGBA(255, 255, 255, 32);
             double var44 = 0.2D;
-            double var15 = 0.2D;
-            double var17 = 0.8D;
+            double var15 = 0.2D;            
+            double var17 = 0.8D;            
             double var19 = 0.2D;
-            double var21 = 0.2D;
+            double var21 = 0.2D;            
             double var23 = 0.8D;
             double var25 = 0.8D;
             double var27 = 0.8D;
+            // FCMOD: Code added
+            if ( par1TileEntityBeacon.IsHomeBeacon() )
+            {
+	            var44 = 0D;
+	            var15 = 0D;            
+	            var17 = 1.0D;            
+	            var19 = 0D;
+	            var21 = 0D;            
+	            var23 = 1.0D;
+	            var25 = 1.0D;
+	            var27 = 1.0D;
+            }
+            // END FCMOD            
             double var29 = (double)(256.0F * var9);
             double var31 = 0.0D;
             double var33 = 1.0D;
diff --git a/minecraft/net/minecraft/src/TileEntityFurnace.java b/minecraft/net/minecraft/src/TileEntityFurnace.java
index 344c00c..8a2397e 100644
--- a/minecraft/net/minecraft/src/TileEntityFurnace.java
+++ b/minecraft/net/minecraft/src/TileEntityFurnace.java
@@ -9,7 +9,10 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
     /**
      * The ItemStacks that hold the items currently being used in the furnace
      */
-    private ItemStack[] furnaceItemStacks = new ItemStack[3];
+    // FCMOD: Changed
+    //private ItemStack[] furnaceItemStacks = new ItemStack[3];
+    protected ItemStack[] furnaceItemStacks = new ItemStack[3];
+    // END FCMOD
 
     /** The number of ticks that the furnace will keep burning */
     public int furnaceBurnTime = 0;
@@ -154,6 +157,19 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
         {
             this.field_94130_e = par1NBTTagCompound.getString("CustomName");
         }
+        
+        // FCMOD: Code added to track extended burn times
+        if ( par1NBTTagCompound.hasKey( "fcBurnTimeEx" ) )
+        {
+	        furnaceBurnTime = par1NBTTagCompound.getInteger( "fcBurnTimeEx" );
+	        furnaceCookTime = par1NBTTagCompound.getInteger( "fcCookTimeEx" );
+	        
+	        if ( par1NBTTagCompound.hasKey( "fcItemBurnTimeEx" ) )
+	        {
+	            currentItemBurnTime = par1NBTTagCompound.getInteger( "fcItemBurnTimeEx" );
+	        }
+        }
+        // END FCMOD
     }
 
     /**
@@ -183,6 +199,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
         {
             par1NBTTagCompound.setString("CustomName", this.field_94130_e);
         }
+        
+        // FCMOD: Code added to track extended burn times
+        par1NBTTagCompound.setInteger( "fcBurnTimeEx", furnaceBurnTime );
+        par1NBTTagCompound.setInteger( "fcCookTimeEx", furnaceCookTime );
+        par1NBTTagCompound.setInteger( "fcItemBurnTimeEx", currentItemBurnTime );
+        // END FCMOD
     }
 
     /**
@@ -200,7 +222,19 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
      */
     public int getCookProgressScaled(int par1)
     {
+    	// FCMOD: Client only. Change to adjust burn times relative to item cooked and have minimum value on indicator
+    	/*
         return this.furnaceCookTime * par1 / 200;
+        */
+    	int iCookProgress = this.furnaceCookTime * par1 / GetCookTimeForCurrentItem();
+    	
+    	if ( iCookProgress == 0 && isBurning() && canSmelt() )
+    	{
+    		iCookProgress = 1;
+    	}
+    	
+        return iCookProgress;
+        // END FCMOD
     }
 
     /**
@@ -241,7 +275,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
 
         if (!this.worldObj.isRemote)
         {
+        	// FCMOD: Code change to consume fuel regardless of whether you can smelt
+        	/*
             if (this.furnaceBurnTime == 0 && this.canSmelt())
+            */
+            if (this.furnaceBurnTime == 0)
+        	// END FCMOD
             {
                 this.currentItemBurnTime = this.furnaceBurnTime = getItemBurnTime(this.furnaceItemStacks[1]);
 
@@ -266,7 +305,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
             {
                 ++this.furnaceCookTime;
 
+            	// FCMOD: Change to double burn times
+                /*
                 if (this.furnaceCookTime == 200)
+                */
+                if (this.furnaceCookTime >= GetCookTimeForCurrentItem())
+            	// END FCMOD
                 {
                     this.furnaceCookTime = 0;
                     this.smeltItem();
@@ -278,11 +322,34 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
                 this.furnaceCookTime = 0;
             }
 
+            // FCMOD: Added
+            boolean bHasVisibleContents = furnaceItemStacks[0] != null || furnaceItemStacks[2] != null;
+            
+            FCBlockFurnace furnaceBlock = (FCBlockFurnace)Block.blocksList[worldObj.getBlockId( xCoord, yCoord, zCoord )];            
+            // END FCMOD
+
             if (var1 != this.furnaceBurnTime > 0)
             {
                 var2 = true;
+                
+                // FCMOD: Changed
+                /*
                 BlockFurnace.updateFurnaceBlockState(this.furnaceBurnTime > 0, this.worldObj, this.xCoord, this.yCoord, this.zCoord);
+                */
+                furnaceBlock.updateFurnaceBlockState( furnaceBurnTime > 0, worldObj, xCoord, yCoord, zCoord, bHasVisibleContents );
+                // END FCMOD
+            }
+            // FCMOD: Added
+            else
+            {
+            	boolean bPreviousContentsState = ( worldObj.getBlockMetadata( xCoord, yCoord, zCoord ) & 8 ) != 0;
+            	
+            	if ( bPreviousContentsState != bHasVisibleContents )
+            	{
+            		furnaceBlock.updateFurnaceBlockState( furnaceBurnTime > 0, worldObj, xCoord, yCoord, zCoord, bHasVisibleContents );
+            	}
             }
+            // END FCMOD
         }
 
         if (var2)
@@ -294,7 +361,10 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
     /**
      * Returns true if the furnace can smelt an item, i.e. has a source item, destination stack isn't full, etc.
      */
-    private boolean canSmelt()
+    // FCMOD: Changed    
+    //private boolean canSmelt()
+    protected boolean canSmelt()
+    // END FCMOD
     {
         if (this.furnaceItemStacks[0] == null)
         {
@@ -303,7 +373,36 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
         else
         {
             ItemStack var1 = FurnaceRecipes.smelting().getSmeltingResult(this.furnaceItemStacks[0].getItem().itemID);
+            // FCMOD: Change to take into account variable output stack sizes
+            /*
             return var1 == null ? false : (this.furnaceItemStacks[2] == null ? true : (!this.furnaceItemStacks[2].isItemEqual(var1) ? false : (this.furnaceItemStacks[2].stackSize < this.getInventoryStackLimit() && this.furnaceItemStacks[2].stackSize < this.furnaceItemStacks[2].getMaxStackSize() ? true : this.furnaceItemStacks[2].stackSize < var1.getMaxStackSize())));
+            */
+            if ( var1 == null )
+            {
+            	return false;
+            }
+            else if ( this.furnaceItemStacks[2] == null )
+            {
+            	return true;
+            }
+            else if ( !this.furnaceItemStacks[2].isItemEqual(var1) )
+            {
+            	return false;
+            }
+            else 
+            {
+            	int iOutputStackSizeIfCooked = furnaceItemStacks[2].stackSize + var1.stackSize;
+            	
+            	if ( iOutputStackSizeIfCooked <= getInventoryStackLimit() && iOutputStackSizeIfCooked <= furnaceItemStacks[2].getMaxStackSize()  )
+            	{
+            		return true;
+            	}
+                else
+                {            	
+                	return iOutputStackSizeIfCooked <= var1.getMaxStackSize();
+                }
+            }            
+            // END FCMOD
         }
     }
 
@@ -322,7 +421,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
             }
             else if (this.furnaceItemStacks[2].itemID == var1.itemID)
             {
+            	// FCMOD: Code change so that output can be greater than 1
+            	/*
                 ++this.furnaceItemStacks[2].stackSize;
+                */
+                furnaceItemStacks[2].stackSize += var1.stackSize;
+                // END FCMOD
             }
 
             --this.furnaceItemStacks[0].stackSize;
@@ -338,6 +442,8 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
      * Returns the number of ticks that the supplied fuel item will keep the furnace burning, or 0 if the item isn't
      * fuel
      */
+    // FCMOD: Removed and replaced
+    /*
     public static int getItemBurnTime(ItemStack par0ItemStack)
     {
         if (par0ItemStack == null)
@@ -364,16 +470,21 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
                 }
             }
 
-            return var2 instanceof ItemTool && ((ItemTool)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemSword && ((ItemSword)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemHoe && ((ItemHoe)var2).getMaterialName().equals("WOOD") ? 200 : (var1 == Item.stick.itemID ? 100 : (var1 == Item.coal.itemID ? 1600 : (var1 == Item.bucketLava.itemID ? 20000 : (var1 == Block.sapling.blockID ? 100 : (var1 == Item.blazeRod.itemID ? 2400 : 0)))))));
+            return var2 instanceof ItemTool && ((ItemTool)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemSword && ((ItemSword)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemHoe && ((ItemHoe)var2).getMaterialName().equals("WOOD") ? 200 : (var1 == Item.stick.itemID ? 100 : (var1 == Item.coal.itemID ? 1600 : (var1 == Item.bucketLava.itemID ? 20000 : (var1 == Block.sapling.blockID ? 100 : (var1 == Item.blazeRod.itemID ? 2400 : 0)))))));            
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Return true if item is a fuel source (getItemBurnTime() > 0).
      */
     public static boolean isItemFuel(ItemStack par0ItemStack)
     {
-        return getItemBurnTime(par0ItemStack) > 0;
+    	// FCMOD: Changed
+        //return getItemBurnTime(par0ItemStack) > 0;
+    	return par0ItemStack.getItem().GetFurnaceBurnTime( par0ItemStack.getItemDamage() ) > 0;
+    	// END FCMOD
     }
 
     /**
@@ -422,4 +533,33 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
     {
         return par3 != 0 || par1 != 1 || par2ItemStack.itemID == Item.bucketEmpty.itemID;
     }
+
+    // FCMOD: Added
+    public static final int m_iDefaultCookTime = 400;
+    public static final int m_iBaseBurnTimeMultiplier = 2;
+    
+    protected int GetCookTimeForCurrentItem()
+    {
+    	int iCookTimeShift = 0;
+    	
+    	if ( furnaceItemStacks[0] != null )
+    	{
+    		iCookTimeShift = FurnaceRecipes.smelting().GetCookTimeBinaryShift( 
+    			furnaceItemStacks[0].getItem().itemID );    		
+    	}
+    	
+    	return m_iDefaultCookTime << iCookTimeShift;
+    }
+    
+    public int getItemBurnTime( ItemStack stack )
+    {
+        if ( stack != null )
+        {
+        	return stack.getItem().GetFurnaceBurnTime( stack.getItemDamage() ) * 
+        		m_iBaseBurnTimeMultiplier;            
+        }
+        
+        return 0;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TileEntityPiston.java b/minecraft/net/minecraft/src/TileEntityPiston.java
index 800252b..d3cc528 100644
--- a/minecraft/net/minecraft/src/TileEntityPiston.java
+++ b/minecraft/net/minecraft/src/TileEntityPiston.java
@@ -20,6 +20,17 @@ public class TileEntityPiston extends TileEntity
     /** the progress in (de)extending */
     private float lastProgress;
     private List pushedObjects = new ArrayList();
+    
+    // FCMOD: Added
+    private boolean m_bShoveledBlock = false;
+    
+    public TileEntityPiston( int iBlockID, int iMetadata, int iFacing, boolean bExtending, boolean bShouldHeadBeRendered, boolean bShoveledBlock )
+    {
+    	this( iBlockID, iMetadata, iFacing, bExtending, bShouldHeadBeRendered );
+    	
+    	m_bShoveledBlock = true;    	
+    }
+    // END FCMOD
 
     public TileEntityPiston() {}
 
@@ -141,6 +152,15 @@ public class TileEntityPiston extends TileEntity
 
             if (this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord) == Block.pistonMoving.blockID)
             {
+            	// FCMOD: Added
+            	if ( DestroyAndDropIfShoveled() )
+            	{
+            		return;
+            	}
+            	
+            	PreBlockPlaced();
+            	// END FCMOD
+            	
                 this.worldObj.setBlock(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID, this.storedMetadata, 3);
                 this.worldObj.notifyBlockOfNeighborChange(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID);
             }
@@ -158,11 +178,25 @@ public class TileEntityPiston extends TileEntity
         if (this.lastProgress >= 1.0F)
         {
             this.updatePushedObjects(1.0F, 0.25F);
+            
+            // FCMOD: Added
+            AttemptToPackItems();
+            // END FCMOD
+            
             this.worldObj.removeBlockTileEntity(this.xCoord, this.yCoord, this.zCoord);
             this.invalidate();
 
             if (this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord) == Block.pistonMoving.blockID)
             {
+            	// FCMOD: Added
+            	if ( DestroyAndDropIfShoveled() )
+            	{
+            		return;
+            	}
+            	
+            	PreBlockPlaced();
+            	// END FCMOD
+            	
                 this.worldObj.setBlock(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID, this.storedMetadata, 3);
                 this.worldObj.notifyBlockOfNeighborChange(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID);
             }
@@ -194,6 +228,13 @@ public class TileEntityPiston extends TileEntity
         this.storedOrientation = par1NBTTagCompound.getInteger("facing");
         this.lastProgress = this.progress = par1NBTTagCompound.getFloat("progress");
         this.extending = par1NBTTagCompound.getBoolean("extending");
+
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcShovel" ) )
+        {
+        	m_bShoveledBlock = par1NBTTagCompound.getBoolean( "fcShovel" );
+        }
+        // END FCMOD        
     }
 
     /**
@@ -207,5 +248,238 @@ public class TileEntityPiston extends TileEntity
         par1NBTTagCompound.setInteger("facing", this.storedOrientation);
         par1NBTTagCompound.setFloat("progress", this.lastProgress);
         par1NBTTagCompound.setBoolean("extending", this.extending);
+        
+        // FCMOD: Added
+        par1NBTTagCompound.setBoolean( "fcShovel", m_bShoveledBlock );
+        // END FCMOD        
+    }
+    
+    // FCMOD: Added
+    private void AttemptToPackItems()
+    {
+    	if ( !worldObj.isRemote && isExtending() && ( storedBlockID == Block.pistonExtension.blockID || Block.isNormalCube( storedBlockID ) || storedBlockID == Block.glass.blockID ) )
+    	{
+	    	FCUtilsBlockPos targetPos = new FCUtilsBlockPos( xCoord, yCoord, zCoord, storedOrientation );
+	    	
+	    	if ( IsLocationSuitableForPacking( targetPos.i, targetPos.j, targetPos.k, Block.GetOppositeFacing( storedOrientation ) ) )
+			{
+	    		AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB((double)targetPos.i, (double)targetPos.j, (double)targetPos.k, 
+	    			(double)targetPos.i + 1D, (double)targetPos.j + 1D, (double)targetPos.k + 1D );
+	    		
+	    		List itemsWithinBox = worldObj.getEntitiesWithinAABB( EntityItem.class, targetBox );
+	    		
+	    		if ( !itemsWithinBox.isEmpty() )
+	    		{
+	                Iterator itemIterator = itemsWithinBox.iterator();
+	
+	                while ( itemIterator.hasNext() )
+	                {
+	        			EntityItem tempItem = (EntityItem)itemIterator.next();
+	        			
+	        			if ( !tempItem.isDead )
+	        			{
+		        			ItemStack tempStack = tempItem.getEntityItem();
+		        			
+		        			if ( IsPackableItem( tempStack ) )
+		        			{
+		        				int iRequiredCount = GetItemCountToPack( tempStack );
+		        				int iCountOfItems = CountItemsOfTypeInList( tempStack, itemsWithinBox );
+		        				
+		        				if ( iCountOfItems >= iRequiredCount )
+		        				{
+		        					RemoveItemsOfTypeFromList( tempStack, iRequiredCount, itemsWithinBox );
+		        					
+		        					CreatePackedBlockOfTypeAtLocation( tempStack, targetPos.i, targetPos.j, targetPos.k );
+		        					
+		        					break;
+		        				}
+		        			}
+	        			}
+	                }
+	    		}
+			}
+    	}
+    }
+    
+    private boolean IsLocationSuitableForPacking( int i, int j, int k, int iPistonDirection )
+	{
+    	if ( worldObj.isAirBlock( i, j, k ) )
+    	{
+	    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+	    	{
+	    		if ( iTempFacing != iPistonDirection )
+	    		{
+	    			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iTempFacing );
+	    			
+	    			if ( !IsBlockSuitableForPackingToFacing ( tempPos.i, tempPos.j, tempPos.k, Block.GetOppositeFacing( iTempFacing ) ) )
+    				{
+	    				return false;
+    				}
+	    				
+	    		}
+	    	}
+	    	
+	    	return true;
+    	}
+    	
+    	return false;
+	}
+    
+    private boolean IsBlockSuitableForPackingToFacing( int i, int j, int k, int iFacing )
+    {
+    	Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
+    	
+    	if ( block != null )
+    	{
+    		return block.CanContainPistonPackingToFacing( worldObj, i, j, k, iFacing );
+    	}
+    	
+    	return false;    	
+    }
+    
+    private boolean IsPackableItem( ItemStack stack )
+    {
+    	return stack.getItem().IsPistonPackable( stack );    	
+    }
+    
+    private int GetItemCountToPack( ItemStack stack )
+    {
+    	return stack.getItem().GetRequiredItemCountToPistonPack( stack );
+    }
+    
+    private void CreatePackedBlockOfTypeAtLocation( ItemStack stack, int i, int j, int k )
+    {
+    	int iBlockID = stack.getItem().GetResultingBlockIDOnPistonPack( stack );;
+    	int iBlockMetadata = stack.getItem().GetResultingBlockMetadataOnPistonPack( stack );
+    	
+    	worldObj.setBlockAndMetadataWithNotify( i, j, k, iBlockID, iBlockMetadata );
+    	
+        worldObj.playAuxSFX( FCBetterThanWolves.m_iBlockPlaceAuxFXID, i, j, k, iBlockID );                            
+    }
+    
+    private int CountItemsOfTypeInList( ItemStack stack, List list )
+    {
+        Iterator itemIterator = list.iterator();
+        int iCount = 0;
+
+        while ( itemIterator.hasNext() )
+        {
+			EntityItem tempItem = (EntityItem)itemIterator.next();
+			
+			if ( !tempItem.isDead )
+			{
+				ItemStack tempStack = tempItem.getEntityItem();
+				
+				if ( tempStack.itemID == stack.itemID )
+				{
+					iCount += tempStack.stackSize;
+				}
+			}
+        }
+        
+        return iCount;
+    }
+    
+    private void RemoveItemsOfTypeFromList( ItemStack stack, int iCount, List list )
+    {
+        Iterator itemIterator = list.iterator();
+
+        while ( itemIterator.hasNext() )
+        {
+			EntityItem tempItem = (EntityItem)itemIterator.next();
+			
+			if ( !tempItem.isDead )
+			{
+				ItemStack tempStack = tempItem.getEntityItem();
+				
+				if ( tempStack.itemID == stack.itemID )
+				{
+					if ( tempStack.stackSize > iCount )
+					{
+						tempStack.stackSize -= iCount;
+						
+						break;
+					}
+					else
+					{
+						iCount -= tempStack.stackSize;
+						
+						tempStack.stackSize = 0;
+						
+						tempItem.setDead();
+						
+						if ( iCount <= 0 )
+						{
+							break;
+						}
+					}
+				}
+			}
+        }
+        
+    }
+    
+    private boolean DestroyAndDropIfShoveled()
+    {
+    	if ( m_bShoveledBlock )
+    	{
+            Block tempBlock = Block.blocksList[storedBlockID];
+            
+            if ( tempBlock != null && !worldObj.isRemote )
+            {
+            	ItemStack tempStack = null;
+            	
+	        	if ( tempBlock.canSilkHarvest( storedMetadata ) )
+	        	{
+	                tempStack = tempBlock.createStackedBlock( storedMetadata );
+	        	}
+	            else
+	            {
+	            	tempStack = new ItemStack( tempBlock.idDropped( storedMetadata, worldObj.rand, 0 ), 
+	            		tempBlock.quantityDropped( worldObj.rand ), tempBlock.damageDropped( storedMetadata ) );
+	            }
+	        	
+	        	if ( tempStack != null )
+	        	{
+	        		EjectStackOnShoveled( tempStack );
+	        	}
+            }
+        	
+            worldObj.setBlockToAir( xCoord, yCoord, zCoord );
+            worldObj.notifyBlockOfNeighborChange( xCoord, yCoord, zCoord, storedBlockID );
+            
+            return true;
+    	}
+    	
+    	return false;
+    }
+    
+    private void EjectStackOnShoveled( ItemStack stack )
+    {
+    	FCUtilsBlockPos sourcePos = new FCUtilsBlockPos( xCoord, yCoord, zCoord, Block.GetOppositeFacing( storedOrientation ) );
+    	
+    	FCUtilsItem.EjectStackFromBlockTowardsFacing( worldObj, sourcePos.i, sourcePos.j, sourcePos.k, stack, storedOrientation ); 
+    }
+    
+    private void PreBlockPlaced()
+    {
+        Block tempBlock = Block.blocksList[storedBlockID];
+        
+        if ( tempBlock != null && !worldObj.isRemote )
+        {
+	    	storedMetadata = tempBlock.OnPreBlockPlacedByPiston( worldObj, xCoord, yCoord, zCoord, 
+	    		storedMetadata, GetDirectionMoving() );
+        }
+    }
+    
+    private int GetDirectionMoving()
+    {
+    	if ( !extending )
+    	{
+    		return Block.GetOppositeFacing( storedOrientation );
+    	}
+    	
+		return storedOrientation;
     }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/TileEntityRenderer.java b/minecraft/net/minecraft/src/TileEntityRenderer.java
index ddfe8c9..44b802a 100644
--- a/minecraft/net/minecraft/src/TileEntityRenderer.java
+++ b/minecraft/net/minecraft/src/TileEntityRenderer.java
@@ -56,6 +56,13 @@ public class TileEntityRenderer
         this.specialRendererMap.put(TileEntityEndPortal.class, new RenderEndPortal());
         this.specialRendererMap.put(TileEntityBeacon.class, new TileEntityBeaconRenderer());
         this.specialRendererMap.put(TileEntitySkull.class, new TileEntitySkullRenderer());
+        // FCMOD: Added (client Only)
+        specialRendererMap.put( FCTileEntityCampfire.class, new FCTileEntityCampfireRenderer() );
+        specialRendererMap.put( FCTileEntityFurnaceBrick.class, new FCTileEntityFurnaceBrickRenderer() );
+        specialRendererMap.put( FCTileEntityToolPlaced.class, new FCTileEntityToolPlacedRenderer() );
+        specialRendererMap.put( FCTileEntityBasketWicker.class, new FCTileEntityBasketWickerRenderer() );
+        specialRendererMap.put( FCTileEntityHamper.class, new FCTileEntityBasketRenderer() );
+        // END FCMOD
         Iterator var1 = this.specialRendererMap.values().iterator();
 
         while (var1.hasNext())
@@ -182,4 +189,11 @@ public class TileEntityRenderer
     {
         return this.fontRenderer;
     }
+    
+    // FCMOD: Added
+    public Map GetSpecialRendererMap()
+    {
+    	return specialRendererMap;
+    }    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TileEntityRendererPiston.java b/minecraft/net/minecraft/src/TileEntityRendererPiston.java
index c85dc8d..217a66d 100644
--- a/minecraft/net/minecraft/src/TileEntityRendererPiston.java
+++ b/minecraft/net/minecraft/src/TileEntityRendererPiston.java
@@ -48,7 +48,27 @@ public class TileEntityRendererPiston extends TileEntitySpecialRenderer
             }
             else
             {
+            	// FCMOD: Changed (Client only)
+            	/*
                 this.blockRenderer.renderBlockAllFaces(var9, par1TileEntityPiston.xCoord, par1TileEntityPiston.yCoord, par1TileEntityPiston.zCoord);
+                */
+            	
+            	// I get the impression that under rare circumstances metadata can get out of sync
+            	// resulting in blocks attempting to render with erroneous data, which
+            	// would explain what's happening here: 
+            	// http://www.sargunster.com/btwforum/viewtopic.php?f=7&t=9630
+            	if ( par1TileEntityPiston.getBlockMetadata() == 
+            		par1TileEntityPiston.worldObj.getBlockMetadata(
+        			par1TileEntityPiston.xCoord,
+        			par1TileEntityPiston.yCoord,
+        			par1TileEntityPiston.zCoord ) )
+    			{
+	            	var9.m_currentBlockRenderer = blockRenderer;
+	            	
+	        		var9.RenderBlockMovedByPiston( blockRenderer, par1TileEntityPiston.xCoord, 
+	        			par1TileEntityPiston.yCoord, par1TileEntityPiston.zCoord );
+    			}
+        		// END FCMOD
             }
 
             var10.setTranslation(0.0D, 0.0D, 0.0D);
diff --git a/minecraft/net/minecraft/src/TileEntitySignRenderer.java b/minecraft/net/minecraft/src/TileEntitySignRenderer.java
index e9c8a2d..c895eda 100644
--- a/minecraft/net/minecraft/src/TileEntitySignRenderer.java
+++ b/minecraft/net/minecraft/src/TileEntitySignRenderer.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
 import org.lwjgl.opengl.GL11;
 
 public class TileEntitySignRenderer extends TileEntitySpecialRenderer
@@ -58,7 +59,7 @@ public class TileEntitySignRenderer extends TileEntitySpecialRenderer
         GL11.glScalef(var12, -var12, var12);
         GL11.glNormal3f(0.0F, 0.0F, -1.0F * var12);
         GL11.glDepthMask(false);
-        byte var13 = 0;
+        int var13 = ColorizeWorld.colorizeSignText();
 
         for (int var14 = 0; var14 < par1TileEntitySign.signText.length; ++var14)
         {
diff --git a/minecraft/net/minecraft/src/TileEntitySkull.java b/minecraft/net/minecraft/src/TileEntitySkull.java
index de58b8e..76239e6 100644
--- a/minecraft/net/minecraft/src/TileEntitySkull.java
+++ b/minecraft/net/minecraft/src/TileEntitySkull.java
@@ -84,4 +84,11 @@ public class TileEntitySkull extends TileEntity
     {
         return this.extraType;
     }
+    
+    // FCMOD: Code added
+    public int GetSkullRotationServerSafe()
+    {
+    	return this.skullRotation;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/TileEntitySkullRenderer.java b/minecraft/net/minecraft/src/TileEntitySkullRenderer.java
index 648c378..6e8745b 100644
--- a/minecraft/net/minecraft/src/TileEntitySkullRenderer.java
+++ b/minecraft/net/minecraft/src/TileEntitySkullRenderer.java
@@ -8,6 +8,10 @@ public class TileEntitySkullRenderer extends TileEntitySpecialRenderer
     public static TileEntitySkullRenderer skullRenderer;
     private ModelSkeletonHead field_82396_c = new ModelSkeletonHead(0, 0, 64, 32);
     private ModelSkeletonHead field_82395_d = new ModelSkeletonHead(0, 0, 64, 64);
+    // FCMOD: Added
+    private ModelSkeletonHead m_InfusedModel = new ModelSkeletonHead(0, 0, 32, 16);
+    // END FCMOD
+
 
     /**
      * Render a skull tile entity.
@@ -48,8 +52,11 @@ public class TileEntitySkullRenderer extends TileEntitySpecialRenderer
 
             case 3:
                 if (par7Str != null && par7Str.length() > 0)
-                {
-                    String var9 = "http://skins.minecraft.net/MinecraftSkins/" + StringUtils.stripControlCodes(par7Str) + ".png";
+                {                
+                	// FCMOD: Changed, client only        	
+                    //String var9 = "http://skins.minecraft.net/MinecraftSkins/" + StringUtils.stripControlCodes(par7Str) + ".png";
+                    String var9 = FCBetterThanWolves.fcPlayerSkinURL + StringUtils.stripControlCodes(par7Str) + ".png";
+                    // END FCMOD
 
                     if (!skullRenderer.tileEntityRenderer.renderEngine.hasImageData(var9))
                     {
@@ -67,6 +74,13 @@ public class TileEntitySkullRenderer extends TileEntitySpecialRenderer
 
             case 4:
                 this.bindTextureByName("/mob/creeper.png");
+            // FCMOD: Added
+                break;
+            case 5:
+                this.bindTextureByName("/btwmodtex/fcInfusedSkull.png");
+                var8 = m_InfusedModel;
+                break;
+            // END FCMOD
         }
 
         GL11.glPushMatrix();
@@ -106,6 +120,12 @@ public class TileEntitySkullRenderer extends TileEntitySpecialRenderer
         GL11.glScalef(-1.0F, -1.0F, 1.0F);
         GL11.glEnable(GL11.GL_ALPHA_TEST);
         var8.render((Entity)null, 0.0F, 0.0F, 0.0F, par5, 0.0F, var10);
+        // FCMOD: Added
+        if ( par6 == 5 )
+        {
+        	RenderInfusedEyes( var8, par5);
+        }
+        // END FCMOD
         GL11.glPopMatrix();
     }
 
@@ -113,4 +133,28 @@ public class TileEntitySkullRenderer extends TileEntitySpecialRenderer
     {
         this.renderTileEntitySkullAt((TileEntitySkull)par1TileEntity, par2, par4, par6, par8);
     }
+    
+    // FCMOD: Added
+    private void RenderInfusedEyes( ModelSkeletonHead model, float fYaw )
+    {
+        bindTextureByName("/btwmodtex/fcInfusedSkullEyes.png");
+        float var4 = 1.0F;
+        GL11.glEnable(GL11.GL_BLEND);
+        GL11.glDisable(GL11.GL_ALPHA_TEST);
+        GL11.glBlendFunc(GL11.GL_ONE, GL11.GL_ONE);
+        GL11.glDisable(GL11.GL_LIGHTING);
+        GL11.glDepthMask(true);
+        char var5 = 61680;
+        int var6 = var5 % 65536;
+        int var7 = var5 / 65536;
+        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)var6 / 1.0F, (float)var7 / 1.0F);
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        GL11.glEnable(GL11.GL_LIGHTING);
+        GL11.glEnable(GL11.GL_ALPHA_TEST);
+        GL11.glDisable(GL11.GL_BLEND);
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, var4);
+        
+        model.render((Entity)null, 0.0F, 0.0F, 0.0F, fYaw, 0.0F, 0.0625F);
+    }
+    // END FCMOD    
 }
diff --git a/minecraft/net/minecraft/src/Vec3.java b/minecraft/net/minecraft/src/Vec3.java
index f573a40..4b9e7bf 100644
--- a/minecraft/net/minecraft/src/Vec3.java
+++ b/minecraft/net/minecraft/src/Vec3.java
@@ -252,4 +252,184 @@ public class Vec3
         this.yCoord = var6;
         this.zCoord = var8;
     }
+    
+    // FCMOD: Added
+    public static Vec3 createVectorHelper( Vec3 copyVector )
+    {
+        return new Vec3( fakePool, copyVector.xCoord, copyVector.yCoord, copyVector.zCoord );
+    }
+    
+	/**
+	 * Yaws the vector around the J axis as if it's a local coordinate internal to a block. Assumes that initial facing is along the negative K axis (facing 2)
+	 */
+	public void RotateAsBlockPosAroundJToFacing( int iFacing )
+    {
+		if ( iFacing > 2 )
+		{
+	    	if ( iFacing == 5 ) // i + 1
+	    	{
+	    		double tempZ = xCoord;
+	    		
+	    		xCoord = 1D - zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else if ( iFacing == 4 ) // i - 1
+	    	{
+	    		double tempZ = 1D - xCoord;
+	    		
+	    		xCoord = zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else // if ( iFacing == 3 ) // k + 1
+	    	{
+	    		xCoord = 1D - xCoord;
+	    		zCoord = 1D - zCoord;
+	    	}
+		}    	
+    }
+	
+	/**
+	 * Yaws the vector around the origin of the J axis. Assumes that initial facing is along the negative K axis (facing 2)
+	 */
+	public void RotateAsVectorAroundJToFacing( int iFacing )
+    {
+		if ( iFacing > 2 )
+		{
+	    	if ( iFacing == 5 ) // i + 1
+	    	{
+	    		double tempZ = xCoord;
+	    		
+	    		xCoord = -zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else if ( iFacing == 4 ) // i - 1
+	    	{
+	    		double tempZ = -xCoord;
+	    		
+	    		xCoord = zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else // if ( iFacing == 3 ) // k + 1
+	    	{
+	    		xCoord = -xCoord;
+	    		zCoord = -zCoord;
+	    	}
+		}    	
+    }
+	
+	/**
+	 * "Tilts" the vector towards the desired facing as if it's a local coordinate internal to a block.  Takes the up vector and either yaws or rolls it towards the specified axis.
+	 */	
+	public void TiltAsBlockPosToFacingAlongJ( int iFacing )
+	{
+		if ( iFacing == 0 ) // j - 1
+		{
+			// rotating around k axis here to point downwards
+			
+			yCoord = 1D - yCoord;
+			xCoord = 1D - xCoord;
+		}
+		else if ( iFacing == 2 ) // k - 1
+		{
+			double tempZ = 1D - yCoord;
+			
+			yCoord = zCoord;
+			zCoord = tempZ;
+		}			
+		else if ( iFacing == 3 ) // k + 1
+		{
+			double tempZ = yCoord;
+			
+			yCoord = 1D - zCoord;
+			zCoord = tempZ;
+		}
+		else if ( iFacing == 4 ) // i - 1
+		{
+			double tempY = xCoord;
+			
+			xCoord = 1D - yCoord;
+			yCoord = tempY;
+		}			
+		else if ( iFacing == 5 ) // i + 1
+		{
+			double tempY = 1D - xCoord;
+			
+			xCoord = yCoord;
+			yCoord = tempY;
+		}			
+	}
+	
+	/**
+	 * "Tilts" the vector towards the desired facing as if it's a local coordinate internal to a block.  Takes the up vector and either yaws or rolls it towards the specified axis.
+	 */	
+	public void TiltAsVectorToFacingAlongJ( int iFacing )
+	{
+		if ( iFacing == 0 ) // j - 1
+		{
+			// rotating around k axis here to point downwards
+			
+			yCoord = -yCoord;
+			xCoord = -xCoord;
+		}
+		else if ( iFacing == 2 ) // k - 1
+		{
+			double tempZ = -yCoord;
+			
+			yCoord = zCoord;
+			zCoord = tempZ;
+		}			
+		else if ( iFacing == 3 ) // k + 1
+		{
+			double tempZ = yCoord;
+			
+			yCoord = -zCoord;
+			zCoord = tempZ;
+		}
+		else if ( iFacing == 4 ) // i - 1
+		{
+			double tempY = xCoord;
+			
+			xCoord = -yCoord;
+			yCoord = tempY;
+		}			
+		else if ( iFacing == 5 ) // i + 1
+		{
+			double tempY = -xCoord;
+			
+			xCoord = yCoord;
+			yCoord = tempY;
+		}			
+	}
+	
+	/**
+	 * Alternate name for clarity
+	 */
+    public final Vec3 SubtractFrom( Vec3 vec )
+    {
+    	return subtract( vec );    	
+    }
+    
+    public Vec3 AddVector( Vec3 vec )
+    {
+        return myVec3LocalPool.getVecFromPool( xCoord + vec.xCoord, yCoord + vec.yCoord, zCoord + vec.zCoord );
+    }
+    
+    public void Scale( double dScale )
+    {
+    	xCoord *= dScale;
+    	yCoord *= dScale;
+    	zCoord *= dScale;
+    }
+    
+    /**
+     * Only considers the x and z components
+     */
+    public double DistanceSquareFlat( Vec3 toVec )
+    {
+        double dDeltaX = toVec.xCoord - xCoord;
+        double dDeltaZ = toVec.zCoord - zCoord;
+        
+        return dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/Village.java b/minecraft/net/minecraft/src/Village.java
index 6021b76..b3fae3e 100644
--- a/minecraft/net/minecraft/src/Village.java
+++ b/minecraft/net/minecraft/src/Village.java
@@ -64,6 +64,8 @@ public class Village
             this.updateNumIronGolems();
         }
 
+        // FCMOD: Code removed to get rid of spawning of iron golems
+        /*
         int var2 = this.numVillagers / 10;
 
         if (this.numIronGolems < var2 && this.villageDoorInfoList.size() > 20 && this.worldObj.rand.nextInt(7000) == 0)
@@ -78,6 +80,8 @@ public class Village
                 ++this.numIronGolems;
             }
         }
+        */
+        // END FCMOD
     }
 
     /**
@@ -390,6 +394,14 @@ public class Village
             {
                 var4.resetDoorOpeningRestrictionCounter();
             }
+            
+            // FCMOD: Added to prevent unintentionally loading chunks
+            if ( !worldObj.chunkExists( var4.posX >> 4, var4.posZ >> 4 ) )
+            {
+            	continue;
+            	
+            }
+            // END FCMOD
 
             if (!this.isBlockDoor(var4.posX, var4.posY, var4.posZ) || Math.abs(this.tickCounter - var4.lastActivityTimestamp) > 1200)
             {
@@ -411,7 +423,11 @@ public class Village
     private boolean isBlockDoor(int par1, int par2, int par3)
     {
         int var4 = this.worldObj.getBlockId(par1, par2, par3);
-        return var4 <= 0 ? false : var4 == Block.doorWood.blockID;
+        
+        // FCMOD: Changed
+        //return var4 <= 0 ? false : var4 == Block.doorWood.blockID;
+        return var4 <= 0 ? false : ( var4 == Block.doorWood.blockID || var4 == FCBetterThanWolves.fcBlockDoorWood.blockID );
+    	// END FCMOD
     }
 
     private void updateVillageRadiusAndCenter()
diff --git a/minecraft/net/minecraft/src/VillageCollection.java b/minecraft/net/minecraft/src/VillageCollection.java
index d3d37ac..2ee9f45 100644
--- a/minecraft/net/minecraft/src/VillageCollection.java
+++ b/minecraft/net/minecraft/src/VillageCollection.java
@@ -329,7 +329,11 @@ public class VillageCollection extends WorldSavedData
     private boolean isWoodenDoorAt(int par1, int par2, int par3)
     {
         int var4 = this.worldObj.getBlockId(par1, par2, par3);
-        return var4 == Block.doorWood.blockID;
+        
+        // FCMOD: Changed
+        //return var4 == Block.doorWood.blockID;
+        return var4 == Block.doorWood.blockID || var4 == FCBetterThanWolves.fcBlockDoorWood.blockID;
+        // END FCMOD
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/World.java b/minecraft/net/minecraft/src/World.java
index b7ebb75..47ba70b 100644
--- a/minecraft/net/minecraft/src/World.java
+++ b/minecraft/net/minecraft/src/World.java
@@ -1,14 +1,23 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.cc.Colorizer;
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 
+// FCMOD: Added
+import java.util.LinkedList;
+// END FCMOD
+
 public abstract class World implements IBlockAccess
 {
     /**
@@ -82,7 +91,9 @@ public abstract class World implements IBlockAccess
     public boolean findingSpawnPoint;
     public MapStorage mapStorage;
     public final VillageCollection villageCollectionObj;
-    protected final VillageSiege villageSiegeObj = new VillageSiege(this);
+    // FCMOD: Removed
+    //protected final VillageSiege villageSiegeObj = new VillageSiege(this);
+    // END FCMOD
     public final Profiler theProfiler;
 
     /** The world-local pool of vectors */
@@ -102,7 +113,22 @@ public abstract class World implements IBlockAccess
     protected boolean spawnPeacefulMobs = true;
 
     /** Positions to update */
-    protected Set activeChunkSet = new HashSet();
+    // FCMOD: Changed to use same type as ChunkProviderServer.loadedChunkHashMap, to avoid
+    // duplicate hash values.  Renamed as new type requires existing references to be adapated
+    // appropriately.
+    //protected Set activeChunkSet = new HashSet();
+    /** 
+     * populated by chunks that are within the view distance (default 8 chunks) of any player,
+     * the original spawn, or any other chunk loader
+     */
+    protected LongHashMap m_activeChunksCoordsMap = new LongHashMap();
+    
+    /** 
+     * list of same coords in m_activeChunksCoordsMap
+     */
+    protected LinkedList<ChunkCoordIntPair> m_activeChunksCoordsList = 
+    	new LinkedList<ChunkCoordIntPair>(); 
+    // END FCMOD
 
     /** number of ticks until the next random ambients play */
     private int ambientTickCountdown;
@@ -173,6 +199,11 @@ public abstract class World implements IBlockAccess
 
     public World(ISaveHandler par1ISaveHandler, String par2Str, WorldSettings par3WorldSettings, WorldProvider par4WorldProvider, Profiler par5Profiler, ILogAgent par6ILogAgent)
     {
+        // FCMOD: Added
+    	// function tests internally to make sure this only occurs once
+        FCAddOnHandler.InitializeMods();
+        // END FCMOD
+    	
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.lightUpdateBlockList = new int[32768];
         this.isRemote = false;
@@ -328,7 +359,14 @@ public abstract class World implements IBlockAccess
      */
     public boolean isAirBlock(int par1, int par2, int par3)
     {
+    	// FCMOD: Change
+		/*
         return this.getBlockId(par1, par2, par3) == 0;
+		*/
+    	int iBlockID = getBlockId(par1, par2, par3);
+    	
+        return iBlockID == 0 || Block.blocksList[iBlockID].IsAirBlock(); 
+        // END FCMOD
     }
 
     /**
@@ -425,6 +463,10 @@ public abstract class World implements IBlockAccess
      * cause a block update. Flag 2 will send the change to clients (you almost always want this). Flag 4 prevents the
      * block from being re-rendered, if this is a client world. Flags can be added together.
      */
+    /**
+     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
     public boolean setBlock(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -522,6 +564,10 @@ public abstract class World implements IBlockAccess
      * Sets the blocks metadata and if set will then notify blocks that this block changed, depending on the flag. Args:
      * x, y, z, metadata, flag. See setBlock for flag description
      */
+    /**
+     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
     public boolean setBlockMetadataWithNotify(int par1, int par2, int par3, int par4, int par5)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -1123,6 +1169,8 @@ public abstract class World implements IBlockAccess
         return this.rayTraceBlocks_do_do(par1Vec3, par2Vec3, par3, false);
     }
 
+    // FCMOD: Code removed and replaced later
+    /*
     public MovingObjectPosition rayTraceBlocks_do_do(Vec3 par1Vec3, Vec3 par2Vec3, boolean par3, boolean par4)
     {
         if (!Double.isNaN(par1Vec3.xCoord) && !Double.isNaN(par1Vec3.yCoord) && !Double.isNaN(par1Vec3.zCoord))
@@ -1332,6 +1380,8 @@ public abstract class World implements IBlockAccess
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Plays a sound at the entity's position. Args: entity, sound, volume (relative to 1.0), and frequency (or pitch,
@@ -1417,13 +1467,51 @@ public abstract class World implements IBlockAccess
     /**
      * Called to place all entities as part of a world
      */
-    public boolean spawnEntityInWorld(Entity par1Entity)
-    {
-        int var2 = MathHelper.floor_double(par1Entity.posX / 16.0D);
-        int var3 = MathHelper.floor_double(par1Entity.posZ / 16.0D);
-        boolean var4 = par1Entity.field_98038_p;
-
-        if (par1Entity instanceof EntityPlayer)
+    public boolean spawnEntityInWorld(Entity entity) {
+    	return this.spawnEntityInWorld(entity, false);
+    }
+    
+    private boolean spawnEntityInWorld(Entity entity, boolean hasItemBeenReplaced) {
+    	if (entity instanceof EntityItem && !hasItemBeenReplaced && !this.isRemote) {
+    		EntityItem oldEntity = (EntityItem) entity;
+    		Item item = oldEntity.getEntityItem().getItem();
+    		
+    		if (item.hasCustomItemEntity()) {
+				EntityItem newEntity = item.createItemAsEntityInWorld(this, entity.posX, entity.posY, entity.posZ, oldEntity.getEntityItem());
+				
+    			if (newEntity == null) {
+    				Class entityItem = item.getCustomItemEntity();
+    				
+    				try {
+						newEntity = (EntityItem) entityItem.getConstructor(World.class, double.class, double.class, double.class, ItemStack.class).newInstance(this, entity.posX, entity.posY, entity.posZ, item);
+					} catch (InstantiationException e) {
+						e.printStackTrace();
+					} catch (IllegalAccessException e) {
+						e.printStackTrace();
+					} catch (IllegalArgumentException e) {
+						e.printStackTrace();
+					} catch (InvocationTargetException e) {
+						e.printStackTrace();
+					} catch (NoSuchMethodException e) {
+						e.printStackTrace();
+					} catch (SecurityException e) {
+						e.printStackTrace();
+					}
+    			}
+    			
+    			newEntity.motionX = oldEntity.motionX;
+    			newEntity.motionY = oldEntity.motionY;
+    			newEntity.motionZ = oldEntity.motionZ;
+    			
+    			this.spawnEntityInWorld(newEntity, true);
+    		}
+    	}
+    	
+        int var2 = MathHelper.floor_double(entity.posX / 16.0D);
+        int var3 = MathHelper.floor_double(entity.posZ / 16.0D);
+        boolean var4 = entity.field_98038_p;
+
+        if (entity instanceof EntityPlayer)
         {
             var4 = true;
         }
@@ -1434,20 +1522,20 @@ public abstract class World implements IBlockAccess
         }
         else
         {
-            if (par1Entity instanceof EntityPlayer)
+            if (entity instanceof EntityPlayer)
             {
-                EntityPlayer var5 = (EntityPlayer)par1Entity;
+                EntityPlayer var5 = (EntityPlayer)entity;
                 this.playerEntities.add(var5);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            this.getChunkFromChunkCoords(var2, var3).addEntity(par1Entity);
-            this.loadedEntityList.add(par1Entity);
-            this.obtainEntitySkin(par1Entity);
+            this.getChunkFromChunkCoords(var2, var3).addEntity(entity);
+            this.loadedEntityList.add(entity);
+            this.obtainEntitySkin(entity);
             return true;
         }
     }
-
+    
     /**
      * Start the skin for this entity downloading, if necessary, and increment its reference counter
      */
@@ -1569,18 +1657,29 @@ public abstract class World implements IBlockAccess
         }
 
         double var14 = 0.25D;
-        List var15 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
-
-        for (int var16 = 0; var16 < var15.size(); ++var16)
-        {
-            AxisAlignedBB var13 = ((Entity)var15.get(var16)).getBoundingBox();
+        // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
+		/*
+        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
+		*/
+        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, 2.0, var14));
+        // END FCMOD
+
+        for (int var15 = 0; var15 < var16.size(); ++var15)
+        {
+        	// FCMOD: Code added
+        	if ( !par1Entity.CanCollideWithEntity( (Entity)var16.get( var15 ) ) )
+        	{
+        		continue;
+        	}
+        	// END FCMOD
+            AxisAlignedBB var13 = ((Entity)var16.get(var15)).getBoundingBox();
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
             {
                 this.collidingBoundingBoxes.add(var13);
             }
 
-            var13 = par1Entity.getCollisionBox((Entity)var15.get(var16));
+            var13 = par1Entity.getCollisionBox((Entity)var16.get(var15));
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
             {
@@ -1698,9 +1797,24 @@ public abstract class World implements IBlockAccess
         BiomeGenBase var7 = this.getBiomeGenForCoords(var5, var6);
         float var8 = var7.getFloatTemperature();
         int var9 = var7.getSkyColorByTemp(var8);
-        float var10 = (float)(var9 >> 16 & 255) / 255.0F;
-        float var11 = (float)(var9 >> 8 & 255) / 255.0F;
-        float var12 = (float)(var9 & 255) / 255.0F;
+        ColorizeWorld.setupForFog(par1Entity);
+        float var10;
+        float var11;
+        float var12;
+
+        if (ColorizeWorld.computeSkyColor(this, par2))
+        {
+            var10 = Colorizer.setColor[0];
+            var11 = Colorizer.setColor[1];
+            var12 = Colorizer.setColor[2];
+        }
+        else
+        {
+            var10 = (float)(var9 >> 16 & 255) / 255.0F;
+            var11 = (float)(var9 >> 8 & 255) / 255.0F;
+            var12 = (float)(var9 & 255) / 255.0F;
+        }
+        
         var10 *= var4;
         var11 *= var4;
         var12 *= var4;
@@ -1835,6 +1949,7 @@ public abstract class World implements IBlockAccess
 
     /**
      * Finds the highest block on the x, z coordinate that is solid and returns its y coord. Args x, z
+     * FCNOTE: Despite name, actually returns the block ABOVE the top one, and does not count liquids
      */
     public int getTopSolidOrLiquidBlock(int par1, int par2)
     {
@@ -1955,6 +2070,21 @@ public abstract class World implements IBlockAccess
         }
 
         this.unloadedEntityList.clear();
+        // FCMOD: Code added to prevent jerkiness when one entity pushes another (like on Platforms)
+        for (int l = 0; l < loadedEntityList.size(); l++)
+        {
+            Entity tempEntity = (Entity)loadedEntityList.get(l);
+            
+            if (!tempEntity.isDead)
+            {
+            	tempEntity.lastTickPosX = tempEntity.posX;
+            	tempEntity.lastTickPosY = tempEntity.posY;
+            	tempEntity.lastTickPosZ = tempEntity.posZ;        
+            	tempEntity.prevRotationYaw = tempEntity.rotationYaw;
+            	tempEntity.prevRotationPitch = tempEntity.rotationPitch;
+            }
+        }        
+        // END FCMOD
         this.theProfiler.endStartSection("regular");
 
         for (var1 = 0; var1 < this.loadedEntityList.size(); ++var1)
@@ -2017,7 +2147,12 @@ public abstract class World implements IBlockAccess
         {
             TileEntity var9 = (TileEntity)var14.next();
 
-            if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
+        	// FCCHUNK: Decide on updates around original spawn
+            // FCMOD: Changed
+            //if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
+            if ( !var9.isInvalid() && var9.func_70309_m() && 
+            	IsBlockPosActive( var9.xCoord, var9.yCoord, var9.zCoord ) )            	            	
+        	// END FCMOD
             {
                 try
                 {
@@ -2115,20 +2250,33 @@ public abstract class World implements IBlockAccess
     /**
      * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
      * Args: entity, forceUpdate
+     * FCNOTE: 2nd parameter is more "bOnlyUpdateInLoadedChunks" rather than what is said above
+     * The "OptionalForce" in the function name refers to forcing the update, not a physical force
      */
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
         int var3 = MathHelper.floor_double(par1Entity.posX);
         int var4 = MathHelper.floor_double(par1Entity.posZ);
-        byte var5 = 32;
-
-        if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
-        {
+        // FCMOD: Changed
+        //byte var5 = 32;
+        int var5 = m_iLoadedChunksUpdateRange;
+        // END FCMOD
+
+    	// FCCHUNK: Decide on updates around original spawn
+        // FCMOD: Changed
+        //if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
+        if ( !par2 || IsBlockPosActive( var3, 0, var4 ) )
+    	// END FCMOD
+        {
+            // FCMOD: Removed and moved to a pre-update loop elsewhere in this file
+            /*
             par1Entity.lastTickPosX = par1Entity.posX;
             par1Entity.lastTickPosY = par1Entity.posY;
             par1Entity.lastTickPosZ = par1Entity.posZ;
             par1Entity.prevRotationYaw = par1Entity.rotationYaw;
             par1Entity.prevRotationPitch = par1Entity.rotationPitch;
+		    */
+		    // END FCMOD
 
             if (par2 && par1Entity.addedToChunk)
             {
@@ -2332,8 +2480,15 @@ public abstract class World implements IBlockAccess
     /**
      * Returns whether or not the given bounding box is on fire or not
      */
-    public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    // FCMOD: Changed
+    //public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    public boolean isBoundingBoxBurning( Entity entity )
+    // END FCMOD
     {
+    	// FCMOD: Added
+    	AxisAlignedBB par1AxisAlignedBB = entity.boundingBox.contract(0.001D, 0.001D, 0.001D);
+    	// END FCMOD
+    	
         int var2 = MathHelper.floor_double(par1AxisAlignedBB.minX);
         int var3 = MathHelper.floor_double(par1AxisAlignedBB.maxX + 1.0D);
         int var4 = MathHelper.floor_double(par1AxisAlignedBB.minY);
@@ -2349,9 +2504,16 @@ public abstract class World implements IBlockAccess
                 {
                     for (int var10 = var6; var10 < var7; ++var10)
                     {
+                        // FCMOD: Changed
+						/*
                         int var11 = this.getBlockId(var8, var9, var10);
 
                         if (var11 == Block.fire.blockID || var11 == Block.lavaMoving.blockID || var11 == Block.lavaStill.blockID)
+                        */
+                        Block block = Block.blocksList[getBlockId(var8, var9, var10)];
+                        
+                        if ( block != null && block.GetDoesFireDamageToEntities( this, var8, var9, var10, entity ) )
+                    	// END FCMOD
                         {
                             return true;
                         }
@@ -2585,7 +2747,12 @@ public abstract class World implements IBlockAccess
 
         if (this.getBlockId(par2, par3, par4) == Block.fire.blockID)
         {
+        	// FCMOD: Code change to fix fizz effect
+        	/*
             this.playAuxSFXAtEntity(par1EntityPlayer, 1004, par2, par3, par4, 0);
+            */
+            playAuxSFX( 1004, par2, par3, par4, 0);
+            // END FCMOD
             this.setBlockToAir(par2, par3, par4);
             return true;
         }
@@ -2759,7 +2926,19 @@ public abstract class World implements IBlockAccess
      */
     public boolean isBlockNormalCube(int par1, int par2, int par3)
     {
-        return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+    	// FCMOD: Changed
+        //return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+    	int iBlockID = getBlockId( par1, par2, par3 );
+
+        Block block = Block.blocksList[iBlockID];
+
+        if( block != null)
+        {
+			return block.IsNormalCube( this, par1, par2, par3 );
+        }
+        
+        return false;
+        // END FCMOD
     }
 
     public boolean func_85174_u(int par1, int par2, int par3)
@@ -2780,20 +2959,28 @@ public abstract class World implements IBlockAccess
     /**
      * Returns true if the block at the given coordinate has a solid (buildable) top surface.
      */
+    // FCMOD: Removed (replaced later)
+    /*
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
         Block var4 = Block.blocksList[this.getBlockId(par1, par2, par3)];
         return this.isBlockTopFacingSurfaceSolid(var4, this.getBlockMetadata(par1, par2, par3));
     }
+    */
+    // END FCMOD
 
     /**
      * Performs check to see if the block is a normal, solid block, or if the metadata of the block indicates that its
      * facing puts its solid side upwards. (inverted stairs, for example)
      */
+    // FCMOD: Removed (deprecated)
+    /*
     public boolean isBlockTopFacingSurfaceSolid(Block par1Block, int par2)
     {
         return par1Block == null ? false : (par1Block.blockMaterial.isOpaque() && par1Block.renderAsNormalBlock() ? true : (par1Block instanceof BlockStairs ? (par2 & 4) == 4 : (par1Block instanceof BlockHalfSlab ? (par2 & 8) == 8 : (par1Block instanceof BlockHopper ? true : (par1Block instanceof BlockSnow ? (par2 & 7) == 7 : false)))));
     }
+    */
+    // END FCMOD
 
     /**
      * Checks if the block is a solid, normal cube. If the chunk does not exist, or is not loaded, it returns the
@@ -2808,7 +2995,12 @@ public abstract class World implements IBlockAccess
             if (var5 != null && !var5.isEmpty())
             {
                 Block var6 = Block.blocksList[this.getBlockId(par1, par2, par3)];
+                // FCMOD: Change so that torches will stick to the appropriate blocks
+                /*
                 return var6 == null ? false : var6.blockMaterial.isOpaque() && var6.renderAsNormalBlock();
+                */
+                return ( var6 != null && isBlockNormalCube( par1, par2, par3 ) );
+                // END FCMOD                
             }
             else
             {
@@ -2839,7 +3031,12 @@ public abstract class World implements IBlockAccess
      */
     public void setAllowedSpawnTypes(boolean par1, boolean par2)
     {
+    	// FCMOD: Code change to remove peaceful difficulty.  If animals can spawn, then so can mobs
+    	/*
         this.spawnHostileMobs = par1;
+        */
+        this.spawnHostileMobs = par2;
+    	// END FCMOD
         this.spawnPeacefulMobs = par2;
     }
 
@@ -2848,7 +3045,15 @@ public abstract class World implements IBlockAccess
      */
     public void tick()
     {
+    	// FCMOD: Added
+    	UpdateActiveChunkMap();
+    	// END FCMOD
+    	
         this.updateWeather();
+        
+        // FCMOD: Added
+        ModSpecificTick();
+        // END FCMOD
     }
 
     /**
@@ -2870,6 +3075,8 @@ public abstract class World implements IBlockAccess
     /**
      * Updates all weather states.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     protected void updateWeather()
     {
         if (!this.provider.hasNoSky)
@@ -2965,6 +3172,8 @@ public abstract class World implements IBlockAccess
             }
         }
     }
+    */
+    // END FCMOD
 
     public void toggleRain()
     {
@@ -2973,6 +3182,8 @@ public abstract class World implements IBlockAccess
 
     protected void setActivePlayerChunksAndCheckLight()
     {
+    	// FCMOD: Changed with active chunk functionality replaced elsewhere
+    	/*
         this.activeChunkSet.clear();
         this.theProfiler.startSection("buildList");
         int var1;
@@ -2997,6 +3208,12 @@ public abstract class World implements IBlockAccess
         }
 
         this.theProfiler.endSection();
+        */
+        int var1;
+        EntityPlayer var2;
+        int var3;
+        int var4;    	
+    	// END FCMOD
 
         if (this.ambientTickCountdown > 0)
         {
@@ -3149,10 +3366,16 @@ public abstract class World implements IBlockAccess
         {
             if (par2 >= 0 && par2 < 256 && this.getSavedLightValue(EnumSkyBlock.Block, par1, par2, par3) < 10)
             {
+                // FCMOD: Code change
+                /*
                 int var6 = this.getBlockId(par1, par2 - 1, par3);
                 int var7 = this.getBlockId(par1, par2, par3);
 
                 if (var7 == 0 && Block.snow.canPlaceBlockAt(this, par1, par2, par3) && var6 != 0 && var6 != Block.ice.blockID && Block.blocksList[var6].blockMaterial.blocksMovement())
+                */
+                if ( FCBlockSnowCover.CanSnowCoverReplaceBlock( this, par1, par2, par3 ) && 
+                	Block.snow.canPlaceBlockAt( this, par1, par2, par3 ) )
+            	// END FCMOD
                 {
                     return true;
                 }
@@ -3243,8 +3466,8 @@ public abstract class World implements IBlockAccess
             int var13;
             int var14;
             int var15;
-            int var16;
             int var17;
+            int var16;
 
             if (var8 > var7)
             {
@@ -3383,10 +3606,18 @@ public abstract class World implements IBlockAccess
     public List getEntitiesWithinAABBExcludingEntity(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
         ArrayList var4 = new ArrayList();
+        // FCMOD: Change to increased size of box to be able to handle wind mills extending accross chunk boundaries
+        /*
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        */
+        int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
+        int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
+        int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
+        int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
+        // END FCMOD
 
         for (int var9 = var5; var9 <= var6; ++var9)
         {
@@ -3412,10 +3643,18 @@ public abstract class World implements IBlockAccess
 
     public List selectEntitiesWithinAABB(Class par1Class, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
+        // FCMOD: Increased size of box to be able to handle wind mills extending accross chunk boundaries
+    	/*
         int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        */
+        int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
+        int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
+        int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
+        int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
+    	// END FCMOD
         ArrayList var8 = new ArrayList();
 
         for (int var9 = var4; var9 <= var5; ++var9)
@@ -3484,6 +3723,8 @@ public abstract class World implements IBlockAccess
     /**
      * Counts how many entities of an entity class exist in the world. Args: entityClass
      */
+    // FCMOD: Code removed and replaced by custom function later
+    /*
     public int countEntities(Class par1Class)
     {
         int var2 = 0;
@@ -3500,6 +3741,8 @@ public abstract class World implements IBlockAccess
 
         return var2;
     }
+    */
+    // END FCMOD
 
     /**
      * adds entities to the loaded entities list, and loads thier skins.
@@ -3507,7 +3750,7 @@ public abstract class World implements IBlockAccess
     public void addLoadedEntities(List par1List)
     {
         this.loadedEntityList.addAll(par1List);
-
+        
         for (int var2 = 0; var2 < par1List.size(); ++var2)
         {
             this.obtainEntitySkin((Entity)par1List.get(var2));
@@ -3543,7 +3786,14 @@ public abstract class World implements IBlockAccess
         }
         else
         {
+            // FCMOD: Change
+    		/*
             if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable()))
+            */
+            if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable() ||
+            	var10 == FCBetterThanWolves.fcBlockDetectorLogic || var10 == FCBetterThanWolves.fcBlockDetectorGlowingLogic || 
+            	var10 == FCBetterThanWolves.fcBlockFireStoked ) )
+        	// END FCMOD        	
             {
                 var10 = null;
             }
@@ -3670,6 +3920,22 @@ public abstract class World implements IBlockAccess
     {
         if (this.isBlockNormalCube(par1, par2, par3))
         {
+        	// FCMOD: Code added so solid blocks can act as power sources
+            int iBlockID = getBlockId( par1, par2, par3 );
+            
+        	if ( Block.blocksList[iBlockID].canProvidePower() )
+        	{
+        		int iPowerInput = getBlockPowerInput(par1, par2, par3);
+        		int iPowerProvided = Block.blocksList[iBlockID].isProvidingWeakPower(this, par1, par2, par3, par4);
+        		
+        		if ( iPowerInput > iPowerProvided )
+        		{
+        			return iPowerInput;
+        		}
+        		
+        		return iPowerProvided;
+        	}
+        	// END FCMOD
             return this.getBlockPowerInput(par1, par2, par3);
         }
         else
@@ -3989,8 +4255,15 @@ public abstract class World implements IBlockAccess
         return (double)this.getRainStrength(1.0F) > 0.2D;
     }
 
+    /** 
+     * FCNOTE: Terribly named.  Was actually whether a specific block is currently being rained on
+     * Deprecated through sending message to avoid modifying vanilla classes that use it
+     * while still ensuring that it isn't actually called.
+     */
     public boolean canLightningStrikeAt(int par1, int par2, int par3)
     {
+    	// FCMOD: Changed
+    	/*    	 
         if (!this.isRaining())
         {
             return false;
@@ -4008,6 +4281,18 @@ public abstract class World implements IBlockAccess
             BiomeGenBase var4 = this.getBiomeGenForCoords(par1, par3);
             return var4.getEnableSnow() ? false : var4.canSpawnLightningBolt();
         }
+        */
+    	if ( !m_bCanLightningStrikeAtMessageSent )
+    	{
+	    	FCBetterThanWolves.DebugWarning( (new StringBuilder()).
+	    		append( "Deprecated method World.canLightningStrikeAt() called.  " ).
+	    		append( "Use IsRainingAtPos() or CanLightingStrikeAtPos() instead." ).toString() );
+	    	
+	    	m_bCanLightningStrikeAtMessageSent = true;
+    	}
+    	
+    	return IsRainingAtPos( par1, par2, par3 );
+    	// END FCMOD        
     }
 
     /**
@@ -4046,6 +4331,10 @@ public abstract class World implements IBlockAccess
         return this.mapStorage.getUniqueDataId(par1Str);
     }
 
+    /**
+     * FCNOTE: Sends an auxSFX to all players, regardless of distance to the effect.
+     * Good for stuff like long range wolf howls and thunder claps.  
+     */
     public void func_82739_e(int par1, int par2, int par3, int par4, int par5)
     {
         for (int var6 = 0; var6 < this.worldAccesses.size(); ++var6)
@@ -4240,4 +4529,1148 @@ public abstract class World implements IBlockAccess
     {
         return this.worldLogAgent;
     }
+
+    // FCMOD: Added New
+    private boolean m_bCanLightningStrikeAtMessageSent = false;
+    
+    private long m_lTimeOfLastSquidPossessionCapCount = -1;
+    private int m_iLastSquidPossessionCapCount = 0;
+    
+    public static final int m_iLoadedChunksUpdateRange = 32;
+
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+    
+    public void ModSpecificTick()
+    {
+    }
+    
+    public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
+    {   
+        return false;
+    }
+    
+    /** 
+     * Wrapper function for clarity: while ticks are being processed they are not still scheduled,
+     * but are in a separate list for this tick.
+     */
+    public boolean IsUpdatePendingThisTickForBlock( int i, int j, int k, int iBlockID )
+    {   
+        return isBlockTickScheduled( i, j, k, iBlockID );
+    }
+    
+    public boolean setBlockAndMetadataWithNotify( int i, int j, int k, int iBlockID, int iMetadata )
+    {
+        return this.setBlock( i, j, k, iBlockID, iMetadata, 3 );
+    }
+
+    public boolean setBlockWithNotify( int i, int j, int k, int iBlockID )
+    {
+        return this.setBlock( i, j, k, iBlockID, 0, 3 );
+    }
+    
+    /**
+	 * Alias to avoid inconsistent naming between client and server
+     * Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
+    public boolean SetBlockMetadataWithNotify( int i, int j, int k, int iMetadata, int iNotifyBitField )
+    {
+    	// client
+        return setBlockMetadataWithNotify( i, j, k, iMetadata, iNotifyBitField );
+    	// server
+        //return setBlockMetadata( i, j, k, iMetadata, iNotifyBitField );
+    }
+    
+    public boolean setBlockMetadata( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadataWithNotify( i, j, k, iMetadata, 0 );
+    }
+
+    public boolean setBlockMetadataWithNotify( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadataWithNotify( i, j, k, iMetadata, 3 );
+    }
+    
+    public boolean setBlockMetadataWithClient( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadataWithNotify( i, j, k, iMetadata, 2 );
+    }
+    
+    public boolean setBlockMetadataWithNotifyNoClient( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadataWithNotify( i, j, k, iMetadata, 1 );
+    }
+    
+    public boolean setBlockAndMetadata( int i, int j, int k, int iBlockID, int iMetadata )
+    {
+        return this.setBlock( i, j, k, iBlockID, iMetadata, 2 );
+    }
+    
+    public boolean isBlockGettingPowered( int i, int j, int k )
+    {
+    	return getBlockPowerInput( i, j, k ) > 0;
+    }
+    
+    public MovingObjectPosition rayTraceBlocks_do_do( Vec3 startVec, Vec3 endVec, boolean bHitFluidSources, boolean bIgnoreNonMovementBlockingBlocks )
+    {
+    	// refactored version of vanilla function to try to optimize and correct errors
+    	
+        if ( !Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord) &&
+        	!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord) )
+        {
+        	Vec3 currentVec = getWorldVec3Pool().getVecFromPool( startVec.xCoord, startVec.yCoord, startVec.zCoord );
+        	
+        	double dTotalDeltaX = endVec.xCoord - startVec.xCoord;
+        	double dTotalDeltaY = endVec.yCoord - startVec.yCoord;
+        	double dTotalDeltaZ = endVec.zCoord - startVec.zCoord;
+        	
+            int iEndPosI = MathHelper.floor_double(endVec.xCoord);
+            int iEndPosJ = MathHelper.floor_double(endVec.yCoord);
+            int iEndPosK = MathHelper.floor_double(endVec.zCoord);
+            
+            int iCurrentPosI = MathHelper.floor_double(currentVec.xCoord);
+            int iCurrentPosJ = MathHelper.floor_double(currentVec.yCoord);
+            int iCurrentPosK = MathHelper.floor_double(currentVec.zCoord);
+            
+            double dProportionOfLengthToNextBlockBoundaryX;
+            double dProportionOfLengthToNextBlockBoundaryY;
+            double dProportionOfLengthToNextBlockBoundaryZ;
+            
+        	int iAxisFinishedCount = 0;
+        	
+        	int iIncrementI = -1;
+        	
+        	double dNextBlockBoundaryX = (double)iCurrentPosI;
+        	double dBlockBoundaryIncrementX = -1D; 
+        	
+        	if ( iEndPosI > iCurrentPosI )
+        	{
+        		iIncrementI = 1;
+        		
+            	dNextBlockBoundaryX += 1D;
+            	dBlockBoundaryIncrementX = 1D;                	
+        	}
+        	else if ( iEndPosI == iCurrentPosI )
+        	{
+        		iIncrementI = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+        	int iIncrementJ = -1;
+        	
+        	double dNextBlockBoundaryY = (double)iCurrentPosJ;
+        	double dBlockBoundaryIncrementY = -1D;
+        	
+        	if ( iEndPosJ > iCurrentPosJ )
+        	{
+        		iIncrementJ = 1;
+        		
+            	dNextBlockBoundaryY += 1D;
+            	dBlockBoundaryIncrementY = 1D; 
+        	}
+        	else if ( iEndPosJ == iCurrentPosJ )
+        	{
+        		iIncrementJ = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+        	int iIncrementK = -1;
+        	
+        	double dNextBlockBoundaryZ = (double)iCurrentPosK;
+        	double dBlockBoundaryIncrementZ = -1D;
+        	
+        	if ( iEndPosK > iCurrentPosK )
+        	{
+        		iIncrementK = 1;
+        		
+            	dNextBlockBoundaryZ += 1D;
+            	dBlockBoundaryIncrementZ = 1D; 
+        	}
+        	else if ( iEndPosK == iCurrentPosK )
+        	{
+        		iIncrementK = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+            int iTempCount = 200;
+
+            while ( iTempCount-- >= 0 )
+            {                    
+                int iCurrentBlockID = getBlockId( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
+                
+                if ( iCurrentBlockID > 0 )
+                {
+                    Block currentBlock = Block.blocksList[iCurrentBlockID];
+
+	                if ( !bIgnoreNonMovementBlockingBlocks || currentBlock.getCollisionBoundingBoxFromPool(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK ) != null )
+	                {
+	                    int iFirstBlockMetadata = getBlockMetadata( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
+	                    
+	                	if (  currentBlock.canCollideCheck( iFirstBlockMetadata, bHitFluidSources ) )
+	                	{
+		                    MovingObjectPosition collisionPosition = currentBlock.collisionRayTrace(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK, currentVec, endVec);
+		
+		                    if ( collisionPosition != null )
+		                    {
+		                        return collisionPosition;
+		                    }
+	                	}
+	                }
+                }
+
+                if ( iAxisFinishedCount >= 3 )
+                {
+                    return null;
+                }
+                
+                if ( iIncrementI != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryX = ( dNextBlockBoundaryX - currentVec.xCoord ) / dTotalDeltaX;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryX = 999.0D;
+                }
+                
+                
+                if ( iIncrementJ != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryY = ( dNextBlockBoundaryY - currentVec.yCoord ) / dTotalDeltaY;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryY = 999.0D;
+                }
+                
+                
+                if ( iIncrementK != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryZ = ( dNextBlockBoundaryZ - currentVec.zCoord ) / dTotalDeltaZ;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryZ = 999.0D;
+                }
+                
+                if ( dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryY && 
+                	dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryZ )
+                {
+                    currentVec.xCoord = dNextBlockBoundaryX;
+                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryX;
+                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryX;
+                    
+                    iCurrentPosI += iIncrementI;
+                	dNextBlockBoundaryX += dBlockBoundaryIncrementX;
+                    
+                    if ( iCurrentPosI == iEndPosI )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementI = 0;
+                    }
+                    
+                }
+                else if (dProportionOfLengthToNextBlockBoundaryY < dProportionOfLengthToNextBlockBoundaryZ)
+                {
+                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryY;
+                    currentVec.yCoord = dNextBlockBoundaryY;
+                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryY;
+                    
+                    iCurrentPosJ += iIncrementJ;
+                	dNextBlockBoundaryY += dBlockBoundaryIncrementY;
+                    
+                    if ( iCurrentPosJ == iEndPosJ )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementJ = 0;
+                    }                        
+                }
+                else
+                {
+                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryZ;
+                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryZ;
+                    currentVec.zCoord = dNextBlockBoundaryZ;
+                    
+                    iCurrentPosK += iIncrementK;
+                	dNextBlockBoundaryZ += dBlockBoundaryIncrementZ;
+                	
+                    if ( iCurrentPosK == iEndPosK )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementK = 0;
+                    }                        
+                }
+            }
+        }
+        
+        return null;
+    }
+
+    /**
+     * Ray tracing with consideration for blocks that extend past their vertical bounds, like with
+     * ground cover or weeds.  Should only be used for mouse over at it can result in funky collision
+     * resolution.
+     */
+    public MovingObjectPosition MouseOverRayTrace( Vec3 startVec, Vec3 endVec )
+    {
+        if (!Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord))
+        {
+            if (!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord))
+            {
+                int iEndI = MathHelper.floor_double(endVec.xCoord);
+                int iEndJ = MathHelper.floor_double(endVec.yCoord);
+                int iEndK = MathHelper.floor_double(endVec.zCoord);
+                int iTempI = MathHelper.floor_double(startVec.xCoord);
+                int iTempJ = MathHelper.floor_double(startVec.yCoord);
+                int iTempK = MathHelper.floor_double(startVec.zCoord);
+                
+                MovingObjectPosition tempCollisionPos = 
+                	CheckLocationForMouseOverRayTrace( iTempI, iTempJ, iTempK,
+            		startVec, endVec );
+                
+                if ( tempCollisionPos != null )
+                {
+                	return tempCollisionPos;
+                }                    
+
+                int iTempCount = 200;
+
+                while (iTempCount-- >= 0)
+                {
+                    if (Double.isNaN(startVec.xCoord) || Double.isNaN(startVec.yCoord) || Double.isNaN(startVec.zCoord))
+                    {
+                        return null;
+                    }
+
+                    if (iTempI == iEndI && iTempJ == iEndJ && iTempK == iEndK)
+                    {
+                        return null;
+                    }
+
+                    boolean var39 = true;
+                    boolean var40 = true;
+                    boolean var41 = true;
+                    double var15 = 999.0D;
+                    double var17 = 999.0D;
+                    double var19 = 999.0D;
+
+                    if (iEndI > iTempI)
+                    {
+                        var15 = (double)iTempI + 1.0D;
+                    }
+                    else if (iEndI < iTempI)
+                    {
+                        var15 = (double)iTempI + 0.0D;
+                    }
+                    else
+                    {
+                        var39 = false;
+                    }
+
+                    if (iEndJ > iTempJ)
+                    {
+                        var17 = (double)iTempJ + 1.0D;
+                    }
+                    else if (iEndJ < iTempJ)
+                    {
+                        var17 = (double)iTempJ + 0.0D;
+                    }
+                    else
+                    {
+                        var40 = false;
+                    }
+
+                    if (iEndK > iTempK)
+                    {
+                        var19 = (double)iTempK + 1.0D;
+                    }
+                    else if (iEndK < iTempK)
+                    {
+                        var19 = (double)iTempK + 0.0D;
+                    }
+                    else
+                    {
+                        var41 = false;
+                    }
+
+                    double var21 = 999.0D;
+                    double var23 = 999.0D;
+                    double var25 = 999.0D;
+                    double var27 = endVec.xCoord - startVec.xCoord;
+                    double var29 = endVec.yCoord - startVec.yCoord;
+                    double var31 = endVec.zCoord - startVec.zCoord;
+
+                    if (var39)
+                    {
+                        var21 = (var15 - startVec.xCoord) / var27;
+                    }
+
+                    if (var40)
+                    {
+                        var23 = (var17 - startVec.yCoord) / var29;
+                    }
+
+                    if (var41)
+                    {
+                        var25 = (var19 - startVec.zCoord) / var31;
+                    }
+
+                    boolean var33 = false;
+                    byte var42;
+
+                    if (var21 < var23 && var21 < var25)
+                    {
+                        if (iEndI > iTempI)
+                        {
+                            var42 = 4;
+                        }
+                        else
+                        {
+                            var42 = 5;
+                        }
+
+                        startVec.xCoord = var15;
+                        startVec.yCoord += var29 * var21;
+                        startVec.zCoord += var31 * var21;
+                    }
+                    else if (var23 < var25)
+                    {
+                        if (iEndJ > iTempJ)
+                        {
+                            var42 = 0;
+                        }
+                        else
+                        {
+                            var42 = 1;
+                        }
+
+                        startVec.xCoord += var27 * var23;
+                        startVec.yCoord = var17;
+                        startVec.zCoord += var31 * var23;
+                    }
+                    else
+                    {
+                        if (iEndK > iTempK)
+                        {
+                            var42 = 2;
+                        }
+                        else
+                        {
+                            var42 = 3;
+                        }
+
+                        startVec.xCoord += var27 * var25;
+                        startVec.yCoord += var29 * var25;
+                        startVec.zCoord = var19;
+                    }
+
+                    Vec3 var34 = this.getWorldVec3Pool().getVecFromPool(startVec.xCoord, startVec.yCoord, startVec.zCoord);
+                    iTempI = (int)(var34.xCoord = (double)MathHelper.floor_double(startVec.xCoord));
+
+                    if (var42 == 5)
+                    {
+                        --iTempI;
+                        ++var34.xCoord;
+                    }
+
+                    iTempJ = (int)(var34.yCoord = (double)MathHelper.floor_double(startVec.yCoord));
+
+                    if (var42 == 1)
+                    {
+                        --iTempJ;
+                        ++var34.yCoord;
+                    }
+
+                    iTempK = (int)(var34.zCoord = (double)MathHelper.floor_double(startVec.zCoord));
+
+                    if (var42 == 3)
+                    {
+                        --iTempK;
+                        ++var34.zCoord;
+                    }
+
+                    tempCollisionPos = CheckLocationForMouseOverRayTrace( 
+                    	iTempI, iTempJ, iTempK, startVec, endVec );
+                    
+                    if ( tempCollisionPos != null )
+                    {
+                    	return tempCollisionPos;
+                    }                    
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    public MovingObjectPosition CheckLocationForMouseOverRayTrace( int i, 
+    	int j, int k, Vec3 startVec, Vec3 endVec )
+    {
+    	MovingObjectPosition closestPos = null;
+    	double dClosestDistSq = 0D;
+    	
+    	for ( int iTempJ = j - 1; iTempJ <= j + 1; iTempJ++ )
+    	{
+            int iTempBlockID = getBlockId( i, iTempJ, k );
+
+            if ( iTempBlockID > 0 )
+            {
+                int iTempMetadata = getBlockMetadata( i, iTempJ, k );                    
+                Block tempBlock = Block.blocksList[iTempBlockID];
+
+                if ( tempBlock.canCollideCheck( iTempMetadata, false ) )
+                {
+                    MovingObjectPosition tempCollisionPos = tempBlock.MouseOverRayTrace( 
+                    	this, i, iTempJ, k, startVec, endVec);
+                    
+                    if ( tempCollisionPos != null )
+                    {
+                    	double tempDistSq = tempCollisionPos.hitVec.squareDistanceTo( startVec );
+                    	
+                    	if ( closestPos == null || tempDistSq < dClosestDistSq )
+                    	{
+                    		dClosestDistSq = tempDistSq;
+                    		
+                    		closestPos = tempCollisionPos;
+                    	} 
+                    }
+                }
+            }
+    	}
+    	
+    	return closestPos;
+    }
+    
+    public void playSound(double par1, double par3, double par5, String par7Str, float par8, float par9 ) 
+    {
+        playSound( par1, par3, par5, par7Str, par8, par9, false );    	
+    }
+    
+    public Entity GetClosestEntityMatchingCriteriaWithinRange( double dSourcePosX, double dSourcePosY, double dSourcePosZ, double dRange, FCClosestEntitySelectionCriteria criteria )
+    {
+		int iChunkEntityListMinVerticalIndex = MathHelper.floor_double( ( dSourcePosY - dRange ) / 16.0D );
+		int iChunkEntityListMaxVerticalIndex = MathHelper.floor_double( ( dSourcePosY + dRange ) / 16.0D ) + 1;
+		
+		if ( iChunkEntityListMinVerticalIndex < 0 )
+		{
+			iChunkEntityListMinVerticalIndex = 0;
+			iChunkEntityListMaxVerticalIndex = Math.max( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
+		}
+		
+		if ( iChunkEntityListMaxVerticalIndex > 15 )
+		{
+			iChunkEntityListMaxVerticalIndex = 15;
+			iChunkEntityListMinVerticalIndex = Math.min( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
+		}
+		
+    	FCClosestEntityInfo closestEntityInfo = 
+    		new FCClosestEntityInfo( dSourcePosX, dSourcePosY, dSourcePosZ, dRange * dRange, null, criteria, iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );
+    	
+        int iMinChunkX = MathHelper.floor_double( ( dSourcePosX - dRange ) / 16D  );
+        int iMaxChunkX = MathHelper.floor_double( ( dSourcePosX + dRange ) / 16D  ) + 1;
+        int iMinChunkZ = MathHelper.floor_double( ( dSourcePosZ - dRange ) / 16D  );
+        int iMaxChunkZ = MathHelper.floor_double( ( dSourcePosZ + dRange ) / 16D  ) + 1;
+        
+        for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
+        {
+            for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
+            {
+                if ( chunkExists( iTempChunkX, iTempChunkZ ) )
+                {
+                    getChunkFromChunkCoords( iTempChunkX, iTempChunkZ ).GetClosestEntityMatchingCriteriaWithinRangeSq( closestEntityInfo );
+                }
+            }
+        }
+
+        return closestEntityInfo.m_closestEntity;
+    }
+    
+    public int CountEntitiesThatApplyToSpawnCap( Class classToCount )
+    {
+    	// replacement for CountEntities that is slightly optimized
+    	
+        int iEntityCount = 0;
+
+        for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
+        {
+            Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
+
+            if ( tempEntity.DoesEntityApplyToSpawnCap() && classToCount.isAssignableFrom( tempEntity.getClass() ) )
+            {
+            	// verify that the entity is actually active
+            	
+            	++iEntityCount;
+            }
+        }
+        
+        return iEntityCount;
+    }
+
+    public int GetNumEntitiesThatApplyToSquidPossessionCap()
+    {
+    	long lCurrentTime = getWorldTime();
+    	
+    	if ( lCurrentTime != m_lTimeOfLastSquidPossessionCapCount )
+    	{
+    		m_iLastSquidPossessionCapCount = 0;
+    		m_lTimeOfLastSquidPossessionCapCount = lCurrentTime;
+    		
+            for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
+            {
+                Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
+
+                if ( tempEntity.DoesEntityApplyToSquidPossessionCap() )
+                {
+                	m_iLastSquidPossessionCapCount++;
+                }
+            }            
+    	}
+    	
+		return m_iLastSquidPossessionCapCount;
+    }
+
+	public void NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( EntityPlayer player, Block block, int i, int j, int k )
+	{
+		if ( !isRemote && block.blockMaterial.blocksMovement() && !player.capabilities.isCreativeMode )
+		{
+			double dXBlock = (double)i + 0.5D;
+			double dYBlock = (double)j + 0.5D;
+			double dZBlock = (double)k + 0.5D;
+			
+			AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB( dXBlock - 8D, dYBlock - 4D, dZBlock - 8D, dXBlock + 8D, dYBlock + 4D, dZBlock + 8D );
+			
+	        List animalList = this.getEntitiesWithinAABB( EntityAnimal.class, targetBox );
+	        
+	        Iterator animalIterator = animalList.iterator();
+	
+	        while ( animalIterator.hasNext())
+	        {
+	    		EntityAnimal tempAnimal = (EntityAnimal)animalIterator.next();
+	    		
+		        if ( !tempAnimal.isLivingDead )
+		        {		        	
+		        	tempAnimal.OnNearbyPlayerBlockAddOrRemove( player ); 
+		        }		        
+	        }
+		}
+	}
+	
+    public int GetBlockNaturalLightValue( int i, int j, int k )
+    {
+        return GetBlockNaturalLightValue_do( i, j, k, true, skylightSubtracted );
+    }
+
+    public int GetBlockNaturalLightValueMaximum( int i, int j, int k )
+    {
+        return GetBlockNaturalLightValue_do( i, j, k, true, 0 );
+    }
+
+    public float GetNaturalLightBrightness( int i, int j, int k )
+    {
+        return provider.lightBrightnessTable[GetBlockNaturalLightValue(i, j, k)];
+    }
+
+    private int GetBlockNaturalLightValue_do( int i, int j, int k, boolean bConsiderNeighbors, int iSkylightToSubtract )
+    {
+    	// Version of getBlockLightValue_do modified to only consider natural light    	
+        if ( i >= -30000000 && k >= -30000000 && i < 30000000 && k < 30000000 )
+        {
+            if ( bConsiderNeighbors )
+            {
+                int iBlockID = getBlockId( i, j, k );
+
+                if ( Block.useNeighborBrightness[iBlockID] )
+                {
+                    int iNeighbor1 = GetBlockNaturalLightValue_do( i, j + 1, k, false, iSkylightToSubtract );
+                    int iNeighbor2 = GetBlockNaturalLightValue_do( i + 1, j, k, false, iSkylightToSubtract );
+                    int iNeighbor3 = GetBlockNaturalLightValue_do( i - 1, j, k, false, iSkylightToSubtract );
+                    int iNeighbor4 = GetBlockNaturalLightValue_do( i, j, k + 1, false, iSkylightToSubtract );
+                    int iNeighbor5 = GetBlockNaturalLightValue_do( i, j, k - 1, false, iSkylightToSubtract );
+
+                    if (iNeighbor2 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor2;
+                    }
+
+                    if (iNeighbor3 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor3;
+                    }
+
+                    if (iNeighbor4 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor4;
+                    }
+
+                    if (iNeighbor5 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor5;
+                    }
+
+                    return iNeighbor1;
+                }
+            }
+
+            if (j < 0)
+            {
+                return 0;
+            }
+            else
+            {
+                if (j >= 256)
+                {
+                    j = 255;
+                }
+
+                Chunk chunk = this.getChunkFromChunkCoords(i >> 4, k >> 4);
+                
+                i &= 15;
+                k &= 15;
+                
+                return chunk.GetBlockNaturalLightValue( i, j, k, iSkylightToSubtract );
+            }
+        }
+        else
+        {
+            return 15;
+        }
+    }
+    
+    @Override // client only override
+    public boolean doesBlockHaveSolidTopSurface( int i, int j, int k )
+    {
+        Block block = Block.blocksList[this.getBlockId(i, j, k)];
+        
+        return block != null && block.HasLargeCenterHardPointToFacing( this, i, j, k, 1 );
+    }
+    
+    //------------- Hardcore of Darkness Handling ------------//    
+    
+    static private double[] m_dMoonBrightnessByPhase = new double[] { 1.25D, 0.875, 0.75D, 0.5D, 0D, 0.5D, 0.75D, 1.25D }; 
+	
+    public float ComputeOverworldSunBrightnessWithMoonPhases()
+    {
+		// slight modified version of regular moon phase equation so that phase switches over at noon to avoid sudden jump in lighting at dawn
+		long lOffsetWorldTime = worldInfo.getWorldTime() - 12000L;
+		
+		if ( lOffsetWorldTime < 0L )
+		{
+			lOffsetWorldTime = 0L;
+		}
+		
+		int iMoonPhase = (int)( ( lOffsetWorldTime / 24000L ) % 8L );		
+		double dMoonBrightness = m_dMoonBrightnessByPhase[iMoonPhase];
+		
+        float fCelestialAngle = getCelestialAngle( 1F );
+        
+        // slight modifcation from vanilla calc so that gloom starts to set in on moonless nights the moment the sun drops beneath the horizon, and is removed at the moment of rise
+        //float fSunInvertedBrightness = 1.0F - (MathHelper.cos(fCelestialAngle * (float)Math.PI * 2.0F) * 2.0F + 0.2F);
+        float fSunInvertedBrightness = 1.0F - ( ( MathHelper.cos( fCelestialAngle * (float)Math.PI * 2.0F ) * 2.0F ) + 0.25F );
+
+        if ( fSunInvertedBrightness < 0.0F)
+        {
+        	fSunInvertedBrightness = 0.0F;
+        }
+        else if ( fSunInvertedBrightness > 1.0F)
+        {
+        	fSunInvertedBrightness = 1.0F;
+        }
+
+        double dSunBrightness = 1.0D - fSunInvertedBrightness;
+        
+        double dRainBrightnessModifier = ( 1.0D - (double)( getRainStrength( 1F ) * 5.0F ) / 16.0D );
+        double dStormBrightnessModifier = ( 1.0D - (double)( getWeightedThunderStrength( 1F ) * 5.0F ) / 16.0D );
+        
+        dSunBrightness = dSunBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
+
+        double dMinBrightness = 0.2D;
+        
+        dMinBrightness *= dMoonBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
+        
+        // clamp at a value that causes the world to descend into gloom on a new moon during a storm
+        if ( dMinBrightness < 0.05D )
+        {
+        	dMinBrightness = 0D;
+        }            
+    	
+        return (float)( dSunBrightness * ( 1D - dMinBrightness ) + dMinBrightness );
+    }    
+    
+    public boolean IsTheEndNigh()
+    {
+    	return false;
+    }
+    
+    //------------- Magnetic Point Handling ------------//
+    
+    protected FCMagneticPointList m_MagneticPointList = new FCMagneticPointList();
+    
+    public FCMagneticPointList GetMagneticPointList()
+    {
+    	return m_MagneticPointList;
+    }
+    
+    //------------- Ender Chest Handling ------------//
+    
+    protected InventoryEnderChest m_localEnderChestInventory = new InventoryEnderChest();
+    protected InventoryEnderChest m_localLowPowerEnderChestInventory = new InventoryEnderChest();
+    
+    public InventoryEnderChest GetLocalEnderChestInventory()
+    {
+    	return m_localEnderChestInventory;
+    }
+    
+    public InventoryEnderChest GetLocalLowPowerEnderChestInventory()
+    {
+    	return m_localLowPowerEnderChestInventory;
+    }
+    
+    //------------- Looting Beacon Handling ------------//
+    
+    protected FCBeaconEffectLocationList m_LootingBeaconLocationList = new FCBeaconEffectLocationList();
+    
+    public FCBeaconEffectLocationList GetLootingBeaconLocationList()
+    {
+    	return m_LootingBeaconLocationList;
+    }
+    
+    public int GetAmbientLootingEffectAtLocation( int iLocI, int iLocJ, int iLocK )
+    {
+    	return m_LootingBeaconLocationList.GetMostPowerfulBeaconEffectForLocation( iLocI, iLocK );
+    }
+    
+    //------------- Spawn Location Handling ------------//
+    
+    protected FCSpawnLocationList m_SpawnLocationList = new FCSpawnLocationList();
+    
+    public FCSpawnLocationList GetSpawnLocationList()
+    {
+    	return m_SpawnLocationList;
+    }
+    
+    //------------- Explosion Handling ------------//
+    
+    /**
+     * Copy of newExplosion() that suppresses the audio/visual effects
+     */
+    public Explosion NewExplosionNoFX( Entity par1Entity, double dPosX, double dPosY, double dPosZ, 
+    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
+    {
+        Explosion explosion = new Explosion( this, par1Entity, dPosX, dPosY, dPosZ, fExplosionSize );
+        
+        explosion.isFlaming = bCreatesFlames;
+        explosion.isSmoking = bDestroysBlocks;
+        explosion.m_bSuppressFX = true;
+        
+        explosion.doExplosionA();
+        explosion.doExplosionB( false ); // false tells individual block destruction effects not to play
+        
+        return explosion;
+    }
+    
+    //------------- "View Distance" / Chunk Update Handling ------------//
+    
+    /** 
+     * The "view distance" is actually the range at which chunks are loaded, specified as 
+     * a vanilla server parameter (default is 10 chunks). 
+     */
+    public int GetClampedViewDistanceInChunks()
+    {
+    	return 10;
+    }
+    
+    public int GetMobSpawnRangeInChunks()
+    {
+    	return GetClampedViewDistanceInChunks() - 2;
+    }
+    
+    /** 
+     * "Active" chunks handle stuff like random block updates (grass growing, etc.)
+     * and precipitation
+     */
+    public int GetActiveChunkRangeInChunks()
+    {
+    	int iRange = GetClampedViewDistanceInChunks() - 3;
+    	
+    	if ( iRange < 1 )
+    	{
+    		iRange = 1;
+    	}
+    	
+    	return iRange;
+    }
+    
+    protected void UpdateActiveChunkMap()
+    {
+    	ClearActiveChunkMap();
+    	
+        for ( int iTempIndex = 0; iTempIndex < playerEntities.size(); ++iTempIndex )
+        {
+            EntityPlayer tempPlayer = (EntityPlayer)playerEntities.get( iTempIndex );
+            
+            AddEntityToActiveChunkMap( tempPlayer );
+        }
+    }
+    
+    protected void AddEntityToActiveChunkMap( Entity entity )
+    {
+        int iChunkX = MathHelper.floor_double( entity.posX / 16D );
+        int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
+        
+        AddAreaAroundChunkToActiveChunkMap( iChunkX, iChunkZ );
+    }
+    
+    protected void AddAreaAroundChunkToActiveChunkMap( int iChunkX, int iChunkZ )
+    {
+        int iActiveRange = GetActiveChunkRangeInChunks();
+        
+        for ( int iTempChunkX = iChunkX - iActiveRange; 
+        	iTempChunkX <= iChunkX + iActiveRange; iTempChunkX++ )
+        {
+            for ( int iTempChunkZ = iChunkZ - iActiveRange; 
+            	iTempChunkZ <= iChunkZ + iActiveRange; iTempChunkZ++ )
+            {
+            	AddToActiveChunkMap( iTempChunkX, iTempChunkZ );
+            }
+        }
+    }
+    
+    protected void ClearActiveChunkMap()
+    {
+        Iterator<ChunkCoordIntPair> tempIterator = m_activeChunksCoordsList.iterator();
+
+        while ( tempIterator.hasNext() )
+        {
+        	ChunkCoordIntPair coords = tempIterator.next();
+            Long lTempKey = ChunkCoordIntPair.chunkXZ2Int( coords.chunkXPos, coords.chunkZPos );
+            
+            tempIterator.remove();
+            m_activeChunksCoordsMap.remove( lTempKey ); 
+        }
+    }
+    
+    protected void AddToActiveChunkMap( int iChunkX, int iChunkZ )
+    {
+        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
+        
+        if ( !m_activeChunksCoordsMap.containsItem( lCoordKey ) )
+        {
+	    	ChunkCoordIntPair coords = new ChunkCoordIntPair( iChunkX, iChunkZ );
+	    	
+	        m_activeChunksCoordsList.add( coords );
+	        
+	        m_activeChunksCoordsMap.add( lCoordKey, coords );
+        }
+    }
+    
+    public boolean IsChunkActive( int iChunkX, int iChunkZ )
+    {
+        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
+        
+        return m_activeChunksCoordsMap.containsItem( lCoordKey );
+    }
+    
+    public boolean IsBlockPosActive( int i, int j, int k )
+    {    	
+        if ( j >= 0 && j < 256 )
+        {
+        	return IsChunkActive( i >> 4, k >> 4 );
+        }
+        
+        return false;
+    }
+    
+    public LinkedList<ChunkCoordIntPair> GetActiveChunksCoordsList()
+    {
+    	return m_activeChunksCoordsList;
+    }
+    
+    //------------- Weather Handling ------------//
+    
+    protected void updateWeather()
+    {
+    	// replacement for vanilla code to clean up and ensure that storms only start after it's been raining awhile
+    	
+        if ( !provider.hasNoSky )
+        {
+            int iRainTime = worldInfo.getRainTime();
+
+            if ( iRainTime <= 0 )
+            {
+                if ( worldInfo.isRaining() )
+                {
+                    worldInfo.setRainTime( rand.nextInt( 12000 ) + 12000 );
+                }
+                else
+                {
+                    worldInfo.setRainTime( rand.nextInt( 168000 ) + 12000 );
+                }
+            }
+            else
+            {
+                --iRainTime;
+                
+                worldInfo.setRainTime( iRainTime );
+
+                if ( iRainTime <= 0 )
+                {
+                    worldInfo.setRaining( !worldInfo.isRaining() );
+                    
+                    if ( worldInfo.isRaining() && !worldInfo.isThundering() )
+                    {
+                    	// min of a minute when rain starts before storm.  About a 1/5 chance of rain turning into a storm at some point in its duration
+                    	
+                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
+                    }
+                }
+            }
+
+            if ( worldInfo.isRaining() )
+            {
+	            int iThunderTime = worldInfo.getThunderTime();
+	
+	            if ( iThunderTime <= 0 )
+	            {
+	                if ( worldInfo.isThundering() )
+	                {
+	                    worldInfo.setThunderTime( rand.nextInt( 12000 ) + 3600 );
+	                }
+	                else
+	                {
+                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
+	                }
+	            }
+	            else
+	            {
+	                --iThunderTime;
+	                
+	                worldInfo.setThunderTime( iThunderTime );
+	
+	                if ( iThunderTime <= 0 )
+	                {
+	                    worldInfo.setThundering( !worldInfo.isThundering() );
+	                }
+	            }
+            }
+            else if ( worldInfo.isThundering() )
+        	{
+        		worldInfo.setThundering( false );
+        	}
+
+            // update the rain and thunder strength counters
+            
+            prevRainingStrength = rainingStrength;
+
+            if ( worldInfo.isRaining() )
+            {
+                rainingStrength = rainingStrength + 0.01F;
+                
+                if ( rainingStrength > 1F )
+                {
+                    rainingStrength = 1F;
+                }
+            }
+            else
+            {
+                rainingStrength = rainingStrength - 0.01F;
+                
+                if ( rainingStrength < 0F )
+                {
+                    rainingStrength = 0F;
+                }
+            }
+
+            prevThunderingStrength = thunderingStrength;
+
+            if ( worldInfo.isThundering() )
+            {
+                thunderingStrength = thunderingStrength + 0.01F;
+                
+                if ( thunderingStrength > 1F )
+                {
+                    thunderingStrength = 1F;
+                }
+            }
+            else
+            {
+                thunderingStrength = thunderingStrength - 0.01F;
+                
+                if ( thunderingStrength < 0F )
+                {
+                    thunderingStrength = 0F;
+                }
+            }
+        }
+    }
+    
+    public boolean IsRainingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsSnowingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsPrecipitatingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow() || biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsPrecipitatingAtPos( int i, int k )
+    {
+        if ( isRaining() )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow() || biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean CanLightningStrikeAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.CanLightningStrikeInBiome();
+        }
+        
+        return false;
+    }
+    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/WorldChunkManager.java b/minecraft/net/minecraft/src/WorldChunkManager.java
index dcee4d5..fd5e51d 100644
--- a/minecraft/net/minecraft/src/WorldChunkManager.java
+++ b/minecraft/net/minecraft/src/WorldChunkManager.java
@@ -26,8 +26,10 @@ public class WorldChunkManager
         this.biomesToSpawnIn.add(BiomeGenBase.taiga);
         this.biomesToSpawnIn.add(BiomeGenBase.taigaHills);
         this.biomesToSpawnIn.add(BiomeGenBase.forestHills);
-        this.biomesToSpawnIn.add(BiomeGenBase.jungle);
-        this.biomesToSpawnIn.add(BiomeGenBase.jungleHills);
+        // FCMOD: Removing jungle biomes from the valid spawn locations due to jungle spiders
+        //this.biomesToSpawnIn.add(BiomeGenBase.jungle);
+        //this.biomesToSpawnIn.add(BiomeGenBase.jungleHills);
+        // END FCMOD
     }
 
     public WorldChunkManager(long par1, WorldType par3WorldType)
diff --git a/minecraft/net/minecraft/src/WorldClient.java b/minecraft/net/minecraft/src/WorldClient.java
index e117689..ce4cc1d 100644
--- a/minecraft/net/minecraft/src/WorldClient.java
+++ b/minecraft/net/minecraft/src/WorldClient.java
@@ -2,6 +2,8 @@ package net.minecraft.src;
 
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import net.minecraft.client.Minecraft;
@@ -28,7 +30,11 @@ public class WorldClient extends World
      */
     private Set entitySpawnQueue = new HashSet();
     private final Minecraft mc = Minecraft.getMinecraft();
-    private final Set previousActiveChunkSet = new HashSet();
+    // FCMOD: Changed (client only)
+    //private final Set previousActiveChunkSet = new HashSet();
+    protected LinkedList<ChunkCoordIntPair> m_prevActiveChunksCoordsList = 
+    	new LinkedList<ChunkCoordIntPair>(); 
+    // END FCMOD
 
     public WorldClient(NetClientHandler par1NetClientHandler, WorldSettings par2WorldSettings, int par3, int par4, Profiler par5Profiler, ILogAgent par6ILogAgent)
     {
@@ -67,6 +73,15 @@ public class WorldClient extends World
         this.theProfiler.endStartSection("tiles");
         this.tickBlocksAndAmbiance();
         this.theProfiler.endSection();
+        // FCMOD: Added (client only) so that internal light levels used for 
+        // creature spawning are updated on the client
+        int i = calculateSkylightSubtracted(1.0F);
+
+        if (i != skylightSubtracted)
+        {
+            skylightSubtracted = i;
+        }
+        // END FCMOD        
     }
 
     /**
@@ -91,21 +106,37 @@ public class WorldClient extends World
     protected void tickBlocksAndAmbiance()
     {
         super.tickBlocksAndAmbiance();
+        // FCMOD: Changed (client only)
+        /*
         this.previousActiveChunkSet.retainAll(this.activeChunkSet);
 
         if (this.previousActiveChunkSet.size() == this.activeChunkSet.size())
         {
             this.previousActiveChunkSet.clear();
         }
+        */
+        m_prevActiveChunksCoordsList.retainAll( m_activeChunksCoordsList );
+
+        if ( m_prevActiveChunksCoordsList.size() == m_activeChunksCoordsList.size() )
+        {
+        	m_prevActiveChunksCoordsList.clear();
+        }
+        // END FCMOD
 
         int var1 = 0;
-        Iterator var2 = this.activeChunkSet.iterator();
+        // FCMOD: Changed (client only)
+        //Iterator var2 = this.activeChunkSet.iterator();
+        Iterator var2 = m_activeChunksCoordsList.iterator();
+        // END FCMOD
 
         while (var2.hasNext())
         {
             ChunkCoordIntPair var3 = (ChunkCoordIntPair)var2.next();
 
-            if (!this.previousActiveChunkSet.contains(var3))
+            // FCMOD: Changed (client only)
+            //if (!this.previousActiveChunkSet.contains(var3))
+            if ( !m_prevActiveChunksCoordsList.contains( var3 ) )
+        	// END FCMOD
             {
                 int var4 = var3.chunkXPos * 16;
                 int var5 = var3.chunkZPos * 16;
@@ -113,7 +144,10 @@ public class WorldClient extends World
                 Chunk var6 = this.getChunkFromChunkCoords(var3.chunkXPos, var3.chunkZPos);
                 this.moodSoundAndLightCheck(var4, var5, var6);
                 this.theProfiler.endSection();
-                this.previousActiveChunkSet.add(var3);
+                // FCMOD: Changed (client only)
+                //this.previousActiveChunkSet.add(var3);
+                m_prevActiveChunksCoordsList.add(var3);
+                // END FCMOD
                 ++var1;
 
                 if (var1 >= 10)
@@ -246,6 +280,23 @@ public class WorldClient extends World
     public boolean setBlockAndMetadataAndInvalidate(int par1, int par2, int par3, int par4, int par5)
     {
         this.invalidateBlockReceiveRegion(par1, par2, par3, par1, par2, par3);
+        
+        // FCMOD: Added (client only)
+        int iOldBlockID = getBlockId( par1 , par2, par3 );
+        
+        if ( iOldBlockID == par4 )
+        {
+        	Block block = Block.blocksList[iOldBlockID];
+        	
+        	if ( block != null )
+        	{
+	        	int iOldBlockMetadata = getBlockMetadata( par1, par2, par3 );
+	        	
+        		block.ClientNotificationOfMetadataChange( this, par1, par2, par3, iOldBlockMetadata, par5 );
+        	}        	
+        }
+        // END FCMOD
+        
         return super.setBlock(par1, par2, par3, par4, par5, 3);
     }
 
@@ -339,6 +390,10 @@ public class WorldClient extends World
     /**
      * also releases skins.
      */
+    /** 
+     * FCNOTE: This is not accurately named.  It only removes all entities in the unload
+     * queue, NOT all loaded entities.
+     */
     public void removeAllEntities()
     {
         this.loadedEntityList.removeAll(this.unloadedEntityList);
@@ -455,4 +510,62 @@ public class WorldClient extends World
     {
         return par0WorldClient.entitySpawnQueue;
     }
+    
+    // FCMOD: Added New (client only)
+    @Override
+    protected void UpdateActiveChunkMap()
+    {
+    	ClearActiveChunkMap();
+    	
+    	// only add the local player, so that we don't uselessly update chunks around
+    	// other players on the client in SMP
+    	
+    	if ( mc.thePlayer != null && mc.thePlayer.worldObj == this )
+    	{
+    		AddEntityToActiveChunkMap( mc.thePlayer );
+    	}
+    }
+
+    @Override
+    public void unloadEntities( List entityList )
+    {
+    	// change to immediately remove entities on the client instead of adding them to a list
+    	// to hopefully prevent problems with invisible mobs
+    	// https://bugs.mojang.com/browse/MC-65040
+    	
+        loadedEntityList.removeAll( entityList );
+
+        LinkedList<Entity> removeList = new  LinkedList<Entity>();
+        
+        // need to make this copy as the list passed in can be modified during traversal
+        removeList.addAll( entityList ); 
+        
+        Iterator<Entity> entityIterator = removeList.iterator();
+
+        while ( entityIterator.hasNext() )
+        {
+        	Entity tempEntity = entityIterator.next();
+            
+            int iChunkX = tempEntity.chunkCoordX;
+            int iChunkZ = tempEntity.chunkCoordZ;
+
+            if ( tempEntity.addedToChunk && chunkExists( iChunkX, iChunkZ ) )
+            {
+                getChunkFromChunkCoords( iChunkX, iChunkZ ).removeEntity( tempEntity );
+            }
+            
+            releaseEntitySkin( tempEntity );
+        }
+    }
+    
+    @Override
+    public void markTileEntityForDespawn( TileEntity tileEntity )
+    {
+    	// change to immediately remove entities on the client instead of adding them to a list
+    	// to hopefully prevent problems with invisible mobs
+    	// https://bugs.mojang.com/browse/MC-65040
+    	
+    	loadedTileEntityList.remove( tileEntity );
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/WorldGenBigTree.java b/minecraft/net/minecraft/src/WorldGenBigTree.java
index 340cca9..aa9fa23 100644
--- a/minecraft/net/minecraft/src/WorldGenBigTree.java
+++ b/minecraft/net/minecraft/src/WorldGenBigTree.java
@@ -503,6 +503,19 @@ public class WorldGenBigTree extends WorldGenerator
             this.generateLeaves();
             this.generateTrunk();
             this.generateLeafNodeBases();
+            
+            // FCMOD: Added
+            int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+            
+            if ( iTrunkBlockId == Block.wood.blockID )
+            {
+            	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+            	
+        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+            }
+            // END FCMOD
+            
             return true;
         }
     }
diff --git a/minecraft/net/minecraft/src/WorldGenDesertWells.java b/minecraft/net/minecraft/src/WorldGenDesertWells.java
index e0c3c0d..b9c62cc 100644
--- a/minecraft/net/minecraft/src/WorldGenDesertWells.java
+++ b/minecraft/net/minecraft/src/WorldGenDesertWells.java
@@ -88,8 +88,59 @@ public class WorldGenDesertWells extends WorldGenerator
                 par1World.setBlock(par3 + 1, par4 + var7, par5 - 1, Block.sandStone.blockID, 0, 2);
                 par1World.setBlock(par3 + 1, par4 + var7, par5 + 1, Block.sandStone.blockID, 0, 2);
             }
+            
+            // FCMOD: Added
+            AddModBlocks( par1World, par3, par4, par5);
+            // END FCMOD
 
             return true;
         }
     }
+    
+    // FCMOD: Added
+    private static FCUtilsRandomItemStack[] m_LootBasketContents = null;
+    
+    private void InitContentsArray()
+    {
+    	m_LootBasketContents = new FCUtilsRandomItemStack[] {
+    		new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemHempSeeds.itemID, 0, 1, 4, 5 ),  
+        	new FCUtilsRandomItemStack( Item.glassBottle.itemID, 0, 2, 8, 10 ),  
+        }; 
+    }
+    
+    private void AddModBlocks( World world, int i, int j, int k )
+    {
+    	int iNumBaskets = world.rand.nextInt( 3 );
+    	
+    	for ( int iTempCount = 0; iTempCount < iNumBaskets; iTempCount++ )
+    	{
+	    	int iBasketI = i + ( world.rand.nextInt( 2 ) == 0 ? -2 : 2 );
+	    	int iBasketJ = j + 2;
+	    	int iBasketK = k + ( world.rand.nextInt( 2 ) == 0 ? -2 : 2 );
+	    	
+	    	AddLootBasket( world, iBasketI, iBasketJ, iBasketK );
+    	}
+    }
+    
+    private void AddLootBasket( World world, int i, int j, int k )
+    {
+    	if ( m_LootBasketContents == null )
+    	{
+    		// only initialize array on first use to ensure referenced mod items are intialized
+    		InitContentsArray();
+    	}
+    	
+        if ( world.getBlockId( i, j, k ) != FCBetterThanWolves.fcBlockBasketWicker.blockID )
+        {
+	    	world.setBlock( i, j, k, FCBetterThanWolves.fcBlockBasketWicker.blockID, world.rand.nextInt( 4 ) | 4, 2 );
+	    	
+	    	FCTileEntityBasketWicker tileEntity = (FCTileEntityBasketWicker)world.getBlockTileEntity( i, j, k );
+	    	
+	    	if ( tileEntity != null )
+	    	{
+	    		tileEntity.SetStorageStack( FCUtilsRandomItemStack.GetRandomStack( world.rand, m_LootBasketContents ) );
+	    	}
+        }	    	
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/WorldGenDungeons.java b/minecraft/net/minecraft/src/WorldGenDungeons.java
index e7b174d..369819b 100644
--- a/minecraft/net/minecraft/src/WorldGenDungeons.java
+++ b/minecraft/net/minecraft/src/WorldGenDungeons.java
@@ -81,7 +81,7 @@ public class WorldGenDungeons extends WorldGenerator
                 {
                     if (var11 < 3)
                     {
-                        label113:
+                        label210:
                         {
                             var12 = par3 + par2Random.nextInt(var7 * 2 + 1) - var7;
                             int var14 = par5 + par2Random.nextInt(var8 * 2 + 1) - var8;
@@ -112,7 +112,12 @@ public class WorldGenDungeons extends WorldGenerator
 
                                 if (var15 == 1)
                                 {
+                                    // FCMOD: Changed
+                                    /*
                                     par1World.setBlock(var12, par4, var14, Block.chest.blockID, 0, 2);
+                                    */
+                                    par1World.setBlock(var12, par4, var14, FCBetterThanWolves.fcBlockChest.blockID, 0, 2);
+                                	// END FCMOD
                                     TileEntityChest var16 = (TileEntityChest)par1World.getBlockTileEntity(var12, par4, var14);
 
                                     if (var16 != null)
@@ -128,7 +133,11 @@ public class WorldGenDungeons extends WorldGenerator
                                         }
                                     }
 
-                                    break label113;
+                                    // FCMOD: Code added
+                                    FilterChestContentsForDepth( par1World, var12, par4, var14 );
+                                    // END FCMOD
+
+                                    break label210;
                                 }
                             }
 
@@ -179,4 +188,62 @@ public class WorldGenDungeons extends WorldGenerator
         int var2 = par1Random.nextInt(4);
         return var2 == 0 ? "Skeleton" : (var2 == 1 ? "Zombie" : (var2 == 2 ? "Zombie" : (var2 == 3 ? "Spider" : "")));
     }
+    
+    // FCMOD: Code added
+    private void FilterChestContentsForDepth( World world, int iChestI, int iChestJ, int iChestK )
+    {
+        TileEntityChest chestEnt = (TileEntityChest)world.getBlockTileEntity( iChestI, iChestJ, iChestK );
+        
+        if ( chestEnt != null )
+        {
+            for ( int iSlot = 0; iSlot < chestEnt.getSizeInventory(); iSlot++ )
+            {
+                ItemStack tempStack = chestEnt.getStackInSlot( iSlot );
+                
+                if ( tempStack != null )
+                {
+                	int iItemID = tempStack.itemID;
+
+                	if ( iItemID == Item.ingotIron.itemID )
+                	{
+                		if ( iChestJ > 36 )
+                		{
+                    		chestEnt.setInventorySlotContents( iSlot, null );
+                		}
+                		else
+                		{
+                			tempStack.stackSize = 1;
+                		}
+                	}
+                	else if ( iItemID == Item.bucketEmpty.itemID )
+                	{
+                		chestEnt.setInventorySlotContents( iSlot, null );
+                	}
+                	else if ( iItemID == Item.gunpowder.itemID )
+                	{
+                		if ( iChestJ > 36 )
+                		{
+                    		chestEnt.setInventorySlotContents( iSlot, null );
+                		}
+                		else
+                		{
+                			tempStack.stackSize = 1;
+                		}
+                	}
+                	else if ( iItemID == Item.redstone.itemID )
+                	{
+                		if ( iChestJ > 24 )
+                		{
+                    		chestEnt.setInventorySlotContents( iSlot, null );
+                		}
+                	}
+                	else if ( iItemID == Item.wheat.itemID )
+                	{
+                		chestEnt.setInventorySlotContents( iSlot, null );
+                	}
+                }
+            }
+        }                	
+    }
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/WorldGenFlowers.java b/minecraft/net/minecraft/src/WorldGenFlowers.java
index d1d9852..955588f 100644
--- a/minecraft/net/minecraft/src/WorldGenFlowers.java
+++ b/minecraft/net/minecraft/src/WorldGenFlowers.java
@@ -20,7 +20,13 @@ public class WorldGenFlowers extends WorldGenerator
             int var8 = par4 + par2Random.nextInt(4) - par2Random.nextInt(4);
             int var9 = par5 + par2Random.nextInt(8) - par2Random.nextInt(8);
 
+            // FCMOD: Change
+            /*
             if (par1World.isAirBlock(var7, var8, var9) && (!par1World.provider.hasNoSky || var8 < 127) && Block.blocksList[this.plantBlockId].canBlockStay(par1World, var7, var8, var9))
+            */
+            if (par1World.isAirBlock(var7, var8, var9) && (!par1World.provider.hasNoSky || var8 < 127) && 
+            	Block.blocksList[this.plantBlockId].CanBlockStayDuringGenerate(par1World, var7, var8, var9))
+        	// END FCMOD
             {
                 par1World.setBlock(var7, var8, var9, this.plantBlockId, 0, 2);
             }
diff --git a/minecraft/net/minecraft/src/WorldGenForest.java b/minecraft/net/minecraft/src/WorldGenForest.java
index bef9cbb..8785894 100644
--- a/minecraft/net/minecraft/src/WorldGenForest.java
+++ b/minecraft/net/minecraft/src/WorldGenForest.java
@@ -105,6 +105,24 @@ public class WorldGenForest extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 2 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft/net/minecraft/src/WorldGenHugeTrees.java b/minecraft/net/minecraft/src/WorldGenHugeTrees.java
index 1f06000..8ca0964 100644
--- a/minecraft/net/minecraft/src/WorldGenHugeTrees.java
+++ b/minecraft/net/minecraft/src/WorldGenHugeTrees.java
@@ -184,6 +184,13 @@ public class WorldGenHugeTrees extends WorldGenerator
                             }
                         }
                     }
+                    
+                    // FCMOD: Added
+                    AttemptToPlaceStump( par1World, par3, par4, par5 );
+                    AttemptToPlaceStump( par1World, par3, par4, par5 + 1 );
+                    AttemptToPlaceStump( par1World, par3 + 1, par4, par5 );
+                    AttemptToPlaceStump( par1World, par3 + 1, par4, par5 + 1 );
+                    // END FCMOD
 
                     return true;
                 }
@@ -199,6 +206,24 @@ public class WorldGenHugeTrees extends WorldGenerator
         }
     }
 
+    // FCMOD: Added
+    private void AttemptToPlaceStump( World world, int i, int j, int k )
+    {
+        int iTrunkBlockId = world.getBlockId( i, j, k );
+        
+        if ( iTrunkBlockId == Block.wood.blockID )
+        {
+        	int iTrunkMetadata = world.getBlockMetadata( i, j, k );
+        	
+        	if ( iTrunkMetadata == woodMetadata )
+        	{
+        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+        		world.setBlockMetadataWithClient( i, j, k, iTrunkMetadata | 12 ); 
+        	}
+        }
+    }
+    // END FCMOD
+    
     private void growLeaves(World par1World, int par2, int par3, int par4, int par5, Random par6Random)
     {
         byte var7 = 2;
diff --git a/minecraft/net/minecraft/src/WorldGenMinable.java b/minecraft/net/minecraft/src/WorldGenMinable.java
index 0b9336f..e3d6102 100644
--- a/minecraft/net/minecraft/src/WorldGenMinable.java
+++ b/minecraft/net/minecraft/src/WorldGenMinable.java
@@ -66,7 +66,30 @@ public class WorldGenMinable extends WorldGenerator
 
                                 if (var39 * var39 + var42 * var42 + var45 * var45 < 1.0D && par1World.getBlockId(var38, var41, var44) == this.field_94523_c)
                                 {
+                                	// FCMOD: Code change
+                                	/*
                                     par1World.setBlock(var38, var41, var44, this.minableBlockId, 0, 2);
+                                    */
+                                	int iMetadata = 0;
+                                	Block block = Block.blocksList[minableBlockId];
+                                	
+                                	if ( block.HasStrata() )
+                                	{
+                                		if ( var41 <= 48  + par1World.rand.nextInt( 2 ) )
+                                		{
+                                			int iStrataLevel = 1;
+                                			
+                                			if ( var41 <= 24 + par1World.rand.nextInt( 2 ) )
+                                			{
+                                				iStrataLevel = 2;                                				
+                                			}
+                                			
+                            				iMetadata = block.GetMetadataConversionForStrataLevel( iStrataLevel, 0 );
+                                		}
+                                	}
+                                	
+                                    par1World.setBlock(var38, var41, var44, this.minableBlockId, iMetadata, 2);
+                                    // END FCMOD
                                 }
                             }
                         }
diff --git a/minecraft/net/minecraft/src/WorldGenPumpkin.java b/minecraft/net/minecraft/src/WorldGenPumpkin.java
index d478b3f..10ee0b7 100644
--- a/minecraft/net/minecraft/src/WorldGenPumpkin.java
+++ b/minecraft/net/minecraft/src/WorldGenPumpkin.java
@@ -6,6 +6,13 @@ public class WorldGenPumpkin extends WorldGenerator
 {
     public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
     {
+    	// FCMOD: Added
+        boolean bIsValidBiome = ( par1World.getBiomeGenForCoords( par3, par5 ) == BiomeGenBase.plains );
+        int iPlacedPumpkinCount = 0;
+       
+        boolean bIsFresh = CheckIfFresh( par1World, par3, par5 );
+        // END FCMOD
+
         for (int var6 = 0; var6 < 64; ++var6)
         {
             int var7 = par3 + par2Random.nextInt(8) - par2Random.nextInt(8);
@@ -14,10 +21,47 @@ public class WorldGenPumpkin extends WorldGenerator
 
             if (par1World.isAirBlock(var7, var8, var9) && par1World.getBlockId(var7, var8 - 1, var9) == Block.grass.blockID && Block.pumpkin.canPlaceBlockAt(par1World, var7, var8, var9))
             {
+            	// FCMOD: Changed
+            	/*
                 par1World.setBlock(var7, var8, var9, Block.pumpkin.blockID, par2Random.nextInt(4), 2);
+                */
+            	int iFacing = par2Random.nextInt( 4 ); // must be done regardless of whether the block is placed to avoid disrupting the random number generator
+            	
+            	if ( bIsValidBiome && iPlacedPumpkinCount < 3 )
+            	{
+            		if ( bIsFresh )
+            		{
+            			par1World.setBlock(var7, var8, var9, FCBetterThanWolves.fcBlockPumpkinFresh.blockID, iFacing, 2);
+            		}
+            		else
+            		{
+            			par1World.setBlock(var7, var8, var9, Block.pumpkin.blockID, iFacing, 2);
+            		}
+                    
+                    iPlacedPumpkinCount++;
+            	}
+            	// END FCMOD            		
             }
         }
 
         return true;
     }
+    
+	// FCMOD: Added
+    private final static double m_dDistForFreshPumpkins = 2500D;
+    private final static double m_dDistSquaredForFreshPumpkins = ( m_dDistForFreshPumpkins * m_dDistForFreshPumpkins );
+    
+    public boolean CheckIfFresh( World world, int i, int k )
+    {
+    	int iSpawnX = world.getWorldInfo().getSpawnX();
+    	int iSpawnZ = world.getWorldInfo().getSpawnZ();
+    	
+    	double dDeltaX = (double)( iSpawnX - i );
+    	double dDeltaZ = (double)( iSpawnZ - k );
+    	
+    	double dDistSqFromSpawn = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+    	
+    	return dDistSqFromSpawn > m_dDistSquaredForFreshPumpkins;
+    }    
+    // END FCMOD	
 }
diff --git a/minecraft/net/minecraft/src/WorldGenReed.java b/minecraft/net/minecraft/src/WorldGenReed.java
index d0fe024..9a130b0 100644
--- a/minecraft/net/minecraft/src/WorldGenReed.java
+++ b/minecraft/net/minecraft/src/WorldGenReed.java
@@ -6,6 +6,13 @@ public class WorldGenReed extends WorldGenerator
 {
     public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
     {
+    	// FCMOD: Added
+    	BiomeGenBase currentBiome = par1World.getBiomeGenForCoords( par3, par5 );
+    	
+        boolean bIsValidBiome = currentBiome == BiomeGenBase.swampland || 
+        	currentBiome == BiomeGenBase.jungle || currentBiome == BiomeGenBase.jungleHills;
+        // END FCMOD
+        
         for (int var6 = 0; var6 < 20; ++var6)
         {
             int var7 = par3 + par2Random.nextInt(4) - par2Random.nextInt(4);
@@ -16,6 +23,15 @@ public class WorldGenReed extends WorldGenerator
             {
                 int var10 = 2 + par2Random.nextInt(par2Random.nextInt(3) + 1);
 
+                // FCMOD: Added
+                if ( !bIsValidBiome )
+                {
+                	// must occur after all random number generation to avoid messing up world gen
+                	
+                	continue;
+                }
+                // END FCMOD
+                
                 for (int var11 = 0; var11 < var10; ++var11)
                 {
                     if (Block.reed.canBlockStay(par1World, var7, var8 + var11, var9))
diff --git a/minecraft/net/minecraft/src/WorldGenSwamp.java b/minecraft/net/minecraft/src/WorldGenSwamp.java
index b8e7b25..7065113 100644
--- a/minecraft/net/minecraft/src/WorldGenSwamp.java
+++ b/minecraft/net/minecraft/src/WorldGenSwamp.java
@@ -144,6 +144,24 @@ public class WorldGenSwamp extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 0 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft/net/minecraft/src/WorldGenTaiga1.java b/minecraft/net/minecraft/src/WorldGenTaiga1.java
index 63406ef..c448bde 100644
--- a/minecraft/net/minecraft/src/WorldGenTaiga1.java
+++ b/minecraft/net/minecraft/src/WorldGenTaiga1.java
@@ -104,6 +104,24 @@ public class WorldGenTaiga1 extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 1 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft/net/minecraft/src/WorldGenTaiga2.java b/minecraft/net/minecraft/src/WorldGenTaiga2.java
index 527392f..035d20a 100644
--- a/minecraft/net/minecraft/src/WorldGenTaiga2.java
+++ b/minecraft/net/minecraft/src/WorldGenTaiga2.java
@@ -72,8 +72,8 @@ public class WorldGenTaiga2 extends WorldGenerator
                     var21 = par2Random.nextInt(2);
                     var13 = 1;
                     byte var22 = 0;
-                    int var16;
                     int var17;
+                    int var16;
 
                     for (var15 = 0; var15 <= var8; ++var15)
                     {
@@ -123,6 +123,24 @@ public class WorldGenTaiga2 extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 1 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft/net/minecraft/src/WorldGenTrees.java b/minecraft/net/minecraft/src/WorldGenTrees.java
index 1fdae6e..1a298d6 100644
--- a/minecraft/net/minecraft/src/WorldGenTrees.java
+++ b/minecraft/net/minecraft/src/WorldGenTrees.java
@@ -205,6 +205,24 @@ public class WorldGenTrees extends WorldGenerator
                             }
                         }
                     }
+                    
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == metaWood )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
 
                     return true;
                 }
diff --git a/minecraft/net/minecraft/src/WorldGeneratorBonusChest.java b/minecraft/net/minecraft/src/WorldGeneratorBonusChest.java
index d2cd226..8e077b5 100644
--- a/minecraft/net/minecraft/src/WorldGeneratorBonusChest.java
+++ b/minecraft/net/minecraft/src/WorldGeneratorBonusChest.java
@@ -50,7 +50,7 @@ public class WorldGeneratorBonusChest extends WorldGenerator
 
                     if (var11 != null && var11 != null)
                     {
-                        WeightedRandomChestContent.generateChestContents(par2Random, this.theBonusChestGenerator, var11, this.itemsToGenerateInBonusChest);
+                        WeightedRandomChestContent.generateChestContents(par2Random, this.theBonusChestGenerator, var11, this.itemsToGenerateInBonusChest);                        
                     }
 
                     if (par1World.isAirBlock(var8 - 1, var9, var10) && par1World.doesBlockHaveSolidTopSurface(var8 - 1, var9 - 1, var10))
diff --git a/minecraft/net/minecraft/src/WorldInfo.java b/minecraft/net/minecraft/src/WorldInfo.java
index 96ca190..93cbc89 100644
--- a/minecraft/net/minecraft/src/WorldInfo.java
+++ b/minecraft/net/minecraft/src/WorldInfo.java
@@ -166,6 +166,10 @@ public class WorldInfo
         {
             this.theGameRules.readGameRulesFromNBT(par1NBTTagCompound.getCompoundTag("GameRules"));
         }
+        
+        // FCMOD: Code added
+        LoadModInfoFromNBT( par1NBTTagCompound );
+        // END FCMOD
     }
 
     public WorldInfo(WorldSettings par1WorldSettings, String par2Str)
@@ -213,6 +217,9 @@ public class WorldInfo
         this.allowCommands = par1WorldInfo.allowCommands;
         this.initialized = par1WorldInfo.initialized;
         this.theGameRules = par1WorldInfo.theGameRules;
+        // FCMOD: Code added
+        CopyModInfo( par1WorldInfo );
+        // END FCMOD        
     }
 
     /**
@@ -261,6 +268,10 @@ public class WorldInfo
         par1NBTTagCompound.setBoolean("initialized", this.initialized);
         par1NBTTagCompound.setCompoundTag("GameRules", this.theGameRules.writeGameRulesToNBT());
 
+        // FCMOD: Code added
+        SaveModInfoToNBT( par1NBTTagCompound );
+        // END FCMOD
+
         if (par2NBTTagCompound != null)
         {
             par1NBTTagCompound.setCompoundTag("Player", par2NBTTagCompound);
@@ -325,6 +336,10 @@ public class WorldInfo
         return this.playerTag;
     }
 
+	/** 
+	 * FCNOTE: Be careful calling this function as it can return unexpected results in derived worlds
+	 * You normally want to use world.provider.dimensionId instead
+	 */
     public int getDimension()
     {
         return this.dimension;
@@ -669,4 +684,106 @@ public class WorldInfo
     {
         return par0WorldInfo.allowCommands;
     }
+
+    // FCMOD: Code added
+    private InventoryEnderChest m_globalEnderChestInventory = new InventoryEnderChest();
+    
+    public boolean m_bPreviouslyRaining = false;
+    public boolean m_bPreviouslyThundering = false;
+    
+    private boolean m_bHasNetherBeenAccessed = false;
+    private boolean m_bHasWitherBeenSummoned = false;
+    private boolean m_bHasEndDimensionBeenAccessed = false;
+
+    public InventoryEnderChest GetGlobalEnderChestInventory()
+    {
+    	return m_globalEnderChestInventory;
+    }
+    
+    private void LoadModInfoFromNBT( NBTTagCompound par1NBTTagCompound )
+    {
+	    if ( par1NBTTagCompound.hasKey( "FCEnderItems" ) )
+	    {
+	        NBTTagList nbttaglist1 = par1NBTTagCompound.getTagList( "FCEnderItems" );
+	        
+	    	m_globalEnderChestInventory.loadInventoryFromNBT( nbttaglist1 );
+	    }
+	    
+	    if ( par1NBTTagCompound.hasKey( "FCNetherAccessed" ) )
+	    {
+	    	m_bHasNetherBeenAccessed = par1NBTTagCompound.getBoolean( "FCNetherAccessed" ); 
+	    }
+	    	
+	    if ( par1NBTTagCompound.hasKey( "FCWitherSummoned" ) )
+	    {
+	    	m_bHasWitherBeenSummoned = par1NBTTagCompound.getBoolean( "FCWitherSummoned" ); 
+	    }
+	    	
+	    if ( par1NBTTagCompound.hasKey( "FCEndAccessed" ) )
+	    {
+	    	m_bHasEndDimensionBeenAccessed = par1NBTTagCompound.getBoolean( "FCEndAccessed" ); 
+	    }
+	    	
+	    m_bPreviouslyRaining = raining;
+	    m_bPreviouslyThundering = thundering;
+    }
+    
+    private void SaveModInfoToNBT( NBTTagCompound par1NBTTagCompound )
+    {
+	    if ( m_globalEnderChestInventory != null )
+	    {
+	    	par1NBTTagCompound.setTag( "FCEnderItems", m_globalEnderChestInventory.saveInventoryToNBT() );
+	    }
+	    
+        par1NBTTagCompound.setBoolean( "FCNetherAccessed", m_bHasNetherBeenAccessed );	    
+        par1NBTTagCompound.setBoolean( "FCWitherSummoned", m_bHasWitherBeenSummoned );	    
+        par1NBTTagCompound.setBoolean( "FCEndAccessed", m_bHasEndDimensionBeenAccessed );	    
+    }
+    
+    private void CopyModInfo(WorldInfo par1WorldInfo)
+    {
+	    if ( par1WorldInfo.m_globalEnderChestInventory != null )
+	    {
+	        m_globalEnderChestInventory = par1WorldInfo.m_globalEnderChestInventory;
+	    }
+	    
+	    m_bHasNetherBeenAccessed = par1WorldInfo.m_bHasNetherBeenAccessed;
+	    m_bHasWitherBeenSummoned = par1WorldInfo.m_bHasWitherBeenSummoned;
+	    m_bHasEndDimensionBeenAccessed = par1WorldInfo.m_bHasEndDimensionBeenAccessed;
+	    
+	    m_bPreviouslyRaining = raining;
+	    m_bPreviouslyThundering = thundering;
+    }
+    
+    public boolean HasNetherBeenAccessed()
+    {
+    	return m_bHasNetherBeenAccessed;
+    }
+    
+    public void SetNetherBeenAccessed()
+    {
+    	m_bHasNetherBeenAccessed = true;
+    }
+    
+    public boolean HasWitherBeenSummoned()
+    {
+    	return m_bHasWitherBeenSummoned;
+    }
+    
+    public void SetWitherHasBeenSummoned()
+    {
+    	m_bHasWitherBeenSummoned = true;
+    }
+    
+    public boolean HasEndDimensionBeenAccessed()
+    {
+    	return m_bHasEndDimensionBeenAccessed;
+    }
+    
+    public void SetEndDimensionHasBeenAccessed()
+    {
+    	m_bHasEndDimensionBeenAccessed = true;
+    }
+    
+    // END FCMOD
 }
diff --git a/minecraft/net/minecraft/src/WorldManager.java b/minecraft/net/minecraft/src/WorldManager.java
index 7015380..50fb74e 100644
--- a/minecraft/net/minecraft/src/WorldManager.java
+++ b/minecraft/net/minecraft/src/WorldManager.java
@@ -68,7 +68,10 @@ public class WorldManager implements IWorldAccess
      */
     public void markBlockForUpdate(int par1, int par2, int par3)
     {
-        this.theWorldServer.getPlayerManager().flagChunkForUpdate(par1, par2, par3);
+    	// FCMOD: Changed
+        //this.theWorldServer.getPlayerManager().flagChunkForUpdate(par1, par2, par3);
+        theWorldServer.GetChunkTracker().FlagBlockForClientUpdate( par1, par2, par3 );
+        // END FCMOD
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/WorldProvider.java b/minecraft/net/minecraft/src/WorldProvider.java
index d244195..a42c9a6 100644
--- a/minecraft/net/minecraft/src/WorldProvider.java
+++ b/minecraft/net/minecraft/src/WorldProvider.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.cc.Colorizer;
+
 public abstract class WorldProvider
 {
     /** world object being used */
@@ -171,6 +174,14 @@ public abstract class WorldProvider
         float var4 = 0.7529412F;
         float var5 = 0.84705883F;
         float var6 = 1.0F;
+        
+        if (ColorizeWorld.computeFogColor(this, par1))
+        {
+            var4 = Colorizer.setColor[0];
+            var5 = Colorizer.setColor[1];
+            var6 = Colorizer.setColor[2];
+        }
+        
         var4 *= var3 * 0.94F + 0.06F;
         var5 *= var3 * 0.94F + 0.06F;
         var6 *= var3 * 0.91F + 0.09F;
@@ -247,4 +258,9 @@ public abstract class WorldProvider
      * Returns the dimension's name, e.g. "The End", "Nether", or "Overworld".
      */
     public abstract String getDimensionName();
+    
+    public int getWorldType()
+    {
+        return this.dimensionId;
+    }
 }
diff --git a/minecraft/net/minecraft/src/WorldProviderEnd.java b/minecraft/net/minecraft/src/WorldProviderEnd.java
index 2ec97cc..f36f4c2 100644
--- a/minecraft/net/minecraft/src/WorldProviderEnd.java
+++ b/minecraft/net/minecraft/src/WorldProviderEnd.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+
 public class WorldProviderEnd extends WorldProvider
 {
     /**
@@ -57,10 +59,10 @@ public class WorldProviderEnd extends WorldProvider
         float var5 = (float)(var3 >> 16 & 255) / 255.0F;
         float var6 = (float)(var3 >> 8 & 255) / 255.0F;
         float var7 = (float)(var3 & 255) / 255.0F;
-        var5 *= var4 * 0.0F + 0.15F;
-        var6 *= var4 * 0.0F + 0.15F;
-        var7 *= var4 * 0.0F + 0.15F;
-        return this.worldObj.getWorldVec3Pool().getVecFromPool((double)var5, (double)var6, (double)var7);
+        float var10000 = var5 * (var4 * 0.0F + 0.15F);
+        var10000 = var6 * (var4 * 0.0F + 0.15F);
+        var10000 = var7 * (var4 * 0.0F + 0.15F);
+        return this.worldObj.getWorldVec3Pool().getVecFromPool((double)ColorizeWorld.endFogColor[0], (double)ColorizeWorld.endFogColor[1], (double)ColorizeWorld.endFogColor[2]);
     }
 
     public boolean isSkyColored()
diff --git a/minecraft/net/minecraft/src/WorldProviderHell.java b/minecraft/net/minecraft/src/WorldProviderHell.java
index baf9621..ca0e5b1 100644
--- a/minecraft/net/minecraft/src/WorldProviderHell.java
+++ b/minecraft/net/minecraft/src/WorldProviderHell.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+import com.prupe.mcpatcher.cc.ColorizeWorld;
+
 public class WorldProviderHell extends WorldProvider
 {
     /**
@@ -18,7 +21,7 @@ public class WorldProviderHell extends WorldProvider
      */
     public Vec3 getFogColor(float par1, float par2)
     {
-        return this.worldObj.getWorldVec3Pool().getVecFromPool(0.20000000298023224D, 0.029999999329447746D, 0.029999999329447746D);
+    	return this.worldObj.getWorldVec3Pool().getVecFromPool((double)ColorizeWorld.netherFogColor[0], (double)ColorizeWorld.netherFogColor[1], (double)ColorizeWorld.netherFogColor[2]);
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/WorldRenderer.java b/minecraft/net/minecraft/src/WorldRenderer.java
index 7dbfdad..8f3fb00 100644
--- a/minecraft/net/minecraft/src/WorldRenderer.java
+++ b/minecraft/net/minecraft/src/WorldRenderer.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import com.prupe.mcpatcher.renderpass.RenderPass;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -36,7 +37,7 @@ public class WorldRenderer
     public boolean isInFrustum = false;
 
     /** Should this renderer skip this render pass */
-    public boolean[] skipRenderPass = new boolean[2];
+    public boolean[] skipRenderPass = new boolean[4];
 
     /** Pos X plus */
     public int posXPlus;
@@ -108,7 +109,7 @@ public class WorldRenderer
             this.posZMinus = par3 - this.posZClip;
             float var4 = 6.0F;
             this.rendererBoundingBox = AxisAlignedBB.getBoundingBox((double)((float)par1 - var4), (double)((float)par2 - var4), (double)((float)par3 - var4), (double)((float)(par1 + 16) + var4), (double)((float)(par2 + 16) + var4), (double)((float)(par3 + 16) + var4));
-            GL11.glNewList(this.glRenderList + 2, GL11.GL_COMPILE);
+            GL11.glNewList(this.glRenderList + 4, GL11.GL_COMPILE);
             RenderItem.renderAABB(AxisAlignedBB.getAABBPool().getAABB((double)((float)this.posXClip - var4), (double)((float)this.posYClip - var4), (double)((float)this.posZClip - var4), (double)((float)(this.posXClip + 16) + var4), (double)((float)(this.posYClip + 16) + var4), (double)((float)(this.posZClip + 16) + var4)));
             GL11.glEndList();
             this.markDirty();
@@ -125,7 +126,11 @@ public class WorldRenderer
      */
     public void updateRenderer()
     {
-        if (this.needsUpdate)
+    	if (!this.needsUpdate)
+        {
+            RenderPass.finish();
+        }
+        else
         {
             this.needsUpdate = false;
             int var1 = this.posX;
@@ -135,7 +140,7 @@ public class WorldRenderer
             int var5 = this.posY + 16;
             int var6 = this.posZ + 16;
 
-            for (int var7 = 0; var7 < 2; ++var7)
+            for (int var7 = 0; var7 < 4; ++var7)
             {
                 this.skipRenderPass[var7] = true;
             }
@@ -153,11 +158,12 @@ public class WorldRenderer
                 RenderBlocks var10 = new RenderBlocks(var9);
                 this.bytesDrawn = 0;
 
-                for (int var11 = 0; var11 < 2; ++var11)
+                for (int var11 = 0; var11 < 4; ++var11)
                 {
                     boolean var12 = false;
                     boolean var13 = false;
                     boolean var14 = false;
+                    RenderPass.start(var11);
 
                     for (int var15 = var2; var15 < var5; ++var15)
                     {
@@ -198,12 +204,9 @@ public class WorldRenderer
                                         }
 
                                         int var24 = var23.getRenderBlockPass();
+                                        var12 = RenderPass.checkRenderPasses(var23, var12);
 
-                                        if (var24 != var11)
-                                        {
-                                            var12 = true;
-                                        }
-                                        else if (var24 == var11)
+                                        if (RenderPass.canRenderInThisPass(var24 == var11))
                                         {
                                             var13 |= var10.renderBlockByRenderType(var23, var17, var15, var16);
                                         }
@@ -245,6 +248,7 @@ public class WorldRenderer
             this.tileEntities.removeAll(var21);
             this.isChunkLit = Chunk.isLit;
             this.isInitialized = true;
+            RenderPass.finish();
         }
     }
 
@@ -265,7 +269,7 @@ public class WorldRenderer
      */
     public void setDontDraw()
     {
-        for (int var1 = 0; var1 < 2; ++var1)
+    	for (int var1 = 0; var1 < 4; ++var1)
         {
             this.skipRenderPass[var1] = true;
         }
@@ -298,7 +302,7 @@ public class WorldRenderer
      */
     public void callOcclusionQueryList()
     {
-        GL11.glCallList(this.glRenderList + 2);
+    	GL11.glCallList(this.glRenderList + 4);
     }
 
     /**
@@ -306,7 +310,17 @@ public class WorldRenderer
      */
     public boolean skipAllRenderPasses()
     {
-        return !this.isInitialized ? false : this.skipRenderPass[0] && this.skipRenderPass[1];
+    	// FCMOD: Changed to try and resolve https://bugs.mojang.com/browse/MC-129 as per
+    	// Andrs del Campo Novales' suggested fix in that thread.
+        //original: return !this.isInitialized ? false : this.skipRenderPass[0] && this.skipRenderPass[1];
+        
+    	//return !isInitialized ? false : ( skipRenderPass[0] && skipRenderPass[1] ) && !needsUpdate;
+        
+        // END FCMOD
+    	
+    	//MCPatcher: return !this.isInitialized ? false : RenderPass.skipAllRenderPasses(this.skipRenderPass);
+    	//MCPatcher + fix:
+    	return !this.isInitialized ? false : RenderPass.skipAllRenderPasses(this.skipRenderPass) && !needsUpdate;
     }
 
     /**
diff --git a/minecraft/net/minecraft/src/WorldServer.java b/minecraft/net/minecraft/src/WorldServer.java
index 36ef6b6..2348207 100644
--- a/minecraft/net/minecraft/src/WorldServer.java
+++ b/minecraft/net/minecraft/src/WorldServer.java
@@ -1,9 +1,15 @@
 package net.minecraft.src;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
@@ -11,445 +17,531 @@ import net.minecraft.server.MinecraftServer;
 
 public class WorldServer extends World
 {
-    private final MinecraftServer mcServer;
-    private final EntityTracker theEntityTracker;
-    private final PlayerManager thePlayerManager;
-    private Set field_73064_N;
-
-    /** All work to do in future ticks. */
-    private TreeSet pendingTickListEntries;
-    public ChunkProviderServer theChunkProviderServer;
-
-    /** set by CommandServerSave{all,Off,On} */
-    public boolean canNotSave;
-
-    /** is false if there are no players */
-    private boolean allPlayersSleeping;
-    private int updateEntityTick = 0;
-    private final Teleporter field_85177_Q;
-
-    /**
-     * Double buffer of ServerBlockEventList[] for holding pending BlockEventData's
-     */
-    private ServerBlockEventList[] blockEventCache = new ServerBlockEventList[] {new ServerBlockEventList((ServerBlockEvent)null), new ServerBlockEventList((ServerBlockEvent)null)};
-
-    /**
-     * The index into the blockEventCache; either 0, or 1, toggled in sendBlockEventPackets  where all BlockEvent are
-     * applied locally and send to clients.
-     */
-    private int blockEventCacheIndex = 0;
-    private static final WeightedRandomChestContent[] bonusChestContent = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.stick.itemID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.planks.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.wood.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Item.axeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.axeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.pickaxeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.pickaxeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.appleRed.itemID, 0, 2, 3, 5), new WeightedRandomChestContent(Item.bread.itemID, 0, 2, 3, 3)};
-    private ArrayList field_94579_S = new ArrayList();
-
-    /** An IntHashMap of entity IDs (integers) to their Entity objects. */
-    private IntHashMap entityIdMap;
-
-    public WorldServer(MinecraftServer par1MinecraftServer, ISaveHandler par2ISaveHandler, String par3Str, int par4, WorldSettings par5WorldSettings, Profiler par6Profiler, ILogAgent par7ILogAgent)
-    {
-        super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
-        this.mcServer = par1MinecraftServer;
-        this.theEntityTracker = new EntityTracker(this);
-        this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
-
-        if (this.entityIdMap == null)
-        {
-            this.entityIdMap = new IntHashMap();
-        }
-
-        if (this.field_73064_N == null)
-        {
-            this.field_73064_N = new HashSet();
-        }
-
-        if (this.pendingTickListEntries == null)
-        {
-            this.pendingTickListEntries = new TreeSet();
-        }
-
-        this.field_85177_Q = new Teleporter(this);
-        this.worldScoreboard = new ServerScoreboard(par1MinecraftServer);
-        ScoreboardSaveData var8 = (ScoreboardSaveData)this.mapStorage.loadData(ScoreboardSaveData.class, "scoreboard");
-
-        if (var8 == null)
-        {
-            var8 = new ScoreboardSaveData();
-            this.mapStorage.setData("scoreboard", var8);
-        }
-
-        var8.func_96499_a(this.worldScoreboard);
-        ((ServerScoreboard)this.worldScoreboard).func_96547_a(var8);
-    }
-
-    /**
-     * Runs a single tick for the world
-     */
-    public void tick()
-    {
-        super.tick();
-
-        if (this.getWorldInfo().isHardcoreModeEnabled() && this.difficultySetting < 3)
-        {
-            this.difficultySetting = 3;
-        }
-
-        this.provider.worldChunkMgr.cleanupCache();
-
-        if (this.areAllPlayersAsleep())
-        {
-            boolean var1 = false;
-
-            if (this.spawnHostileMobs && this.difficultySetting >= 1)
-            {
-                ;
-            }
-
-            if (!var1)
-            {
-                long var2 = this.worldInfo.getWorldTime() + 24000L;
-                this.worldInfo.setWorldTime(var2 - var2 % 24000L);
-                this.wakeAllPlayers();
-            }
-        }
-
-        this.theProfiler.startSection("mobSpawner");
-
-        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
-        {
+	private final MinecraftServer mcServer;
+	private final EntityTracker theEntityTracker;
+	// FCMOD: Changed
+	//private final PlayerManager thePlayerManager;
+	private final FCChunkTracker m_chunkTracker;
+	// END FCMOD
+
+	// FCNOTE: Contains NextTickListEntry objects with updates scheduled for blocks
+	private Set field_73064_N;
+
+	/** All work to do in future ticks. */
+	private TreeSet pendingTickListEntries;
+	public ChunkProviderServer theChunkProviderServer;
+
+	/** set by CommandServerSave{all,Off,On} */
+	public boolean canNotSave;
+
+	/** is false if there are no players */
+	private boolean allPlayersSleeping;
+	private int updateEntityTick = 0;
+	private final Teleporter field_85177_Q;
+
+	/**
+	 * Double buffer of ServerBlockEventList[] for holding pending BlockEventData's
+	 */
+	private ServerBlockEventList[] blockEventCache = new ServerBlockEventList[] {new ServerBlockEventList((ServerBlockEvent)null), new ServerBlockEventList((ServerBlockEvent)null)};
+
+	/**
+	 * The index into the blockEventCache; either 0, or 1, toggled in sendBlockEventPackets  where all BlockEvent are
+	 * applied locally and send to clients.
+	 */
+	private int blockEventCacheIndex = 0;
+	private static final WeightedRandomChestContent[] bonusChestContent = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.stick.itemID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.planks.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.wood.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Item.axeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.axeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.pickaxeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.pickaxeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.appleRed.itemID, 0, 2, 3, 5), new WeightedRandomChestContent(Item.bread.itemID, 0, 2, 3, 3)};
+	private ArrayList field_94579_S = new ArrayList();
+
+	/** An IntHashMap of entity IDs (integers) to their Entity objects. */
+	private IntHashMap entityIdMap;
+
+	public WorldServer(MinecraftServer par1MinecraftServer, ISaveHandler par2ISaveHandler, String par3Str, int par4, WorldSettings par5WorldSettings, Profiler par6Profiler, ILogAgent par7ILogAgent)
+	{
+		super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
+		this.mcServer = par1MinecraftServer;
+
+		// FCMOD: Added
+		saveHandler.LoadModSpecificData( this );
+		// END FCMOD
+
+		this.theEntityTracker = new EntityTracker(this);
+
+		// FCMOD: Changed
+		//this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
+		m_chunkTracker = new FCChunkTracker( this, 
+				par1MinecraftServer.getConfigurationManager().getViewDistance());
+		// END FCMOD
+
+		if (this.entityIdMap == null)
+		{
+			this.entityIdMap = new IntHashMap();
+		}
+
+		if (this.field_73064_N == null)
+		{
+			this.field_73064_N = new HashSet();
+		}
+
+		if (this.pendingTickListEntries == null)
+		{
+			this.pendingTickListEntries = new TreeSet();
+		}
+
+		this.field_85177_Q = new Teleporter(this);
+		this.worldScoreboard = new ServerScoreboard(par1MinecraftServer);
+		ScoreboardSaveData var8 = (ScoreboardSaveData)this.mapStorage.loadData(ScoreboardSaveData.class, "scoreboard");
+
+		if (var8 == null)
+		{
+			var8 = new ScoreboardSaveData();
+			this.mapStorage.setData("scoreboard", var8);
+		}
+
+		var8.func_96499_a(this.worldScoreboard);
+		((ServerScoreboard)this.worldScoreboard).func_96547_a(var8);
+	}
+
+	/**
+	 * Runs a single tick for the world
+	 */
+	public void tick()
+	{
+		super.tick();
+
+		if (this.getWorldInfo().isHardcoreModeEnabled() && this.difficultySetting < 3)
+		{
+			this.difficultySetting = 3;
+		}
+		// FCMOD: Added to eliminate peaceful and easy difficulties
+		else if ( difficultySetting < 2 )
+		{
+			difficultySetting = 2;
+		}
+		// END FCMOD
+
+		this.provider.worldChunkMgr.cleanupCache();
+
+		if (this.areAllPlayersAsleep())
+		{
+			boolean var1 = false;
+
+			if (this.spawnHostileMobs && this.difficultySetting >= 1)
+			{
+				;
+			}
+
+			if (!var1)
+			{
+				long var2 = this.worldInfo.getWorldTime() + 24000L;
+				this.worldInfo.setWorldTime(var2 - var2 % 24000L);
+				this.wakeAllPlayers();
+			}
+		}
+
+		this.theProfiler.startSection("mobSpawner");
+
+		if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
+		{
+			// FCMOD: Code change to prevent animal spawning after chunk generation
+			/*
             SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
-        }
-
-        this.theProfiler.endStartSection("chunkSource");
-        this.chunkProvider.unloadQueuedChunks();
-        int var4 = this.calculateSkylightSubtracted(1.0F);
-
-        if (var4 != this.skylightSubtracted)
-        {
-            this.skylightSubtracted = var4;
-        }
-
-        this.worldInfo.incrementTotalWorldTime(this.worldInfo.getWorldTotalTime() + 1L);
-        this.worldInfo.setWorldTime(this.worldInfo.getWorldTime() + 1L);
-        this.theProfiler.endStartSection("tickPending");
-        this.tickUpdates(false);
-        this.theProfiler.endStartSection("tickTiles");
-        this.tickBlocksAndAmbiance();
-        this.theProfiler.endStartSection("chunkMap");
-        this.thePlayerManager.updatePlayerInstances();
-        this.theProfiler.endStartSection("village");
-        this.villageCollectionObj.tick();
-        this.villageSiegeObj.tick();
-        this.theProfiler.endStartSection("portalForcer");
-        this.field_85177_Q.removeStalePortalLocations(this.getTotalWorldTime());
-        this.theProfiler.endSection();
-        this.sendAndApplyBlockEvents();
-    }
-
-    /**
-     * only spawns creatures allowed by the chunkProvider
-     */
-    public SpawnListEntry spawnRandomCreature(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)
-    {
-        List var5 = this.getChunkProvider().getPossibleCreatures(par1EnumCreatureType, par2, par3, par4);
-        return var5 != null && !var5.isEmpty() ? (SpawnListEntry)WeightedRandom.getRandomItem(this.rand, var5) : null;
-    }
-
-    /**
-     * Updates the flag that indicates whether or not all players in the world are sleeping.
-     */
-    public void updateAllPlayersSleepingFlag()
-    {
-        this.allPlayersSleeping = !this.playerEntities.isEmpty();
-        Iterator var1 = this.playerEntities.iterator();
-
-        while (var1.hasNext())
-        {
-            EntityPlayer var2 = (EntityPlayer)var1.next();
-
-            if (!var2.isPlayerSleeping())
-            {
-                this.allPlayersSleeping = false;
-                break;
-            }
-        }
-    }
-
-    protected void wakeAllPlayers()
-    {
-        this.allPlayersSleeping = false;
-        Iterator var1 = this.playerEntities.iterator();
-
-        while (var1.hasNext())
-        {
-            EntityPlayer var2 = (EntityPlayer)var1.next();
-
-            if (var2.isPlayerSleeping())
-            {
-                var2.wakeUpPlayer(false, false, true);
-            }
-        }
-
-        this.resetRainAndThunder();
-    }
-
-    private void resetRainAndThunder()
-    {
-        this.worldInfo.setRainTime(0);
-        this.worldInfo.setRaining(false);
-        this.worldInfo.setThunderTime(0);
-        this.worldInfo.setThundering(false);
-    }
-
-    public boolean areAllPlayersAsleep()
-    {
-        if (this.allPlayersSleeping && !this.isRemote)
-        {
-            Iterator var1 = this.playerEntities.iterator();
-            EntityPlayer var2;
-
-            do
-            {
-                if (!var1.hasNext())
-                {
-                    return true;
-                }
-
-                var2 = (EntityPlayer)var1.next();
-            }
-            while (var2.isPlayerFullyAsleep());
-
-            return false;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    /**
-     * Sets a new spawn location by finding an uncovered block at a random (x,z) location in the chunk.
-     */
-    public void setSpawnLocation()
-    {
-        if (this.worldInfo.getSpawnY() <= 0)
-        {
-            this.worldInfo.setSpawnY(64);
-        }
-
-        int var1 = this.worldInfo.getSpawnX();
-        int var2 = this.worldInfo.getSpawnZ();
-        int var3 = 0;
-
-        while (this.getFirstUncoveredBlock(var1, var2) == 0)
-        {
-            var1 += this.rand.nextInt(8) - this.rand.nextInt(8);
-            var2 += this.rand.nextInt(8) - this.rand.nextInt(8);
-            ++var3;
-
-            if (var3 == 10000)
-            {
-                break;
-            }
-        }
-
-        this.worldInfo.setSpawnX(var1);
-        this.worldInfo.setSpawnZ(var2);
-    }
-
-    /**
-     * plays random cave ambient sounds and runs updateTick on random blocks within each chunk in the vacinity of a
-     * player
-     */
-    protected void tickBlocksAndAmbiance()
-    {
-        super.tickBlocksAndAmbiance();
-        int var1 = 0;
-        int var2 = 0;
-        Iterator var3 = this.activeChunkSet.iterator();
-
-        while (var3.hasNext())
-        {
-            ChunkCoordIntPair var4 = (ChunkCoordIntPair)var3.next();
-            int var5 = var4.chunkXPos * 16;
-            int var6 = var4.chunkZPos * 16;
-            this.theProfiler.startSection("getChunk");
-            Chunk var7 = this.getChunkFromChunkCoords(var4.chunkXPos, var4.chunkZPos);
-            this.moodSoundAndLightCheck(var5, var6, var7);
-            this.theProfiler.endStartSection("tickChunk");
-            var7.updateSkylight();
-            this.theProfiler.endStartSection("thunder");
-            int var8;
-            int var9;
-            int var10;
-            int var11;
-
-            if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
-            {
-                this.updateLCG = this.updateLCG * 3 + 1013904223;
-                var8 = this.updateLCG >> 2;
-                var9 = var5 + (var8 & 15);
-                var10 = var6 + (var8 >> 8 & 15);
-                var11 = this.getPrecipitationHeight(var9, var10);
-
-                if (this.canLightningStrikeAt(var9, var11, var10))
-                {
-                    this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
-                }
-            }
-
-            this.theProfiler.endStartSection("iceandsnow");
-            int var13;
-
-            if (this.rand.nextInt(16) == 0)
-            {
-                this.updateLCG = this.updateLCG * 3 + 1013904223;
-                var8 = this.updateLCG >> 2;
-                var9 = var8 & 15;
-                var10 = var8 >> 8 & 15;
-                var11 = this.getPrecipitationHeight(var9 + var5, var10 + var6);
-
-                if (this.isBlockFreezableNaturally(var9 + var5, var11 - 1, var10 + var6))
-                {
-                    this.setBlock(var9 + var5, var11 - 1, var10 + var6, Block.ice.blockID);
-                }
-
-                if (this.isRaining() && this.canSnowAt(var9 + var5, var11, var10 + var6))
-                {
-                    this.setBlock(var9 + var5, var11, var10 + var6, Block.snow.blockID);
-                }
-
-                if (this.isRaining())
-                {
-                    BiomeGenBase var12 = this.getBiomeGenForCoords(var9 + var5, var10 + var6);
-
-                    if (var12.canSpawnLightningBolt())
-                    {
-                        var13 = this.getBlockId(var9 + var5, var11 - 1, var10 + var6);
-
-                        if (var13 != 0)
-                        {
-                            Block.blocksList[var13].fillWithRain(this, var9 + var5, var11 - 1, var10 + var6);
-                        }
-                    }
-                }
-            }
-
-            this.theProfiler.endStartSection("tickTiles");
-            ExtendedBlockStorage[] var19 = var7.getBlockStorageArray();
-            var9 = var19.length;
-
-            for (var10 = 0; var10 < var9; ++var10)
-            {
-                ExtendedBlockStorage var20 = var19[var10];
-
-                if (var20 != null && var20.getNeedsRandomTick())
-                {
-                    for (int var21 = 0; var21 < 3; ++var21)
-                    {
-                        this.updateLCG = this.updateLCG * 3 + 1013904223;
-                        var13 = this.updateLCG >> 2;
-                        int var14 = var13 & 15;
-                        int var15 = var13 >> 8 & 15;
-                        int var16 = var13 >> 16 & 15;
-                        int var17 = var20.getExtBlockID(var14, var16, var15);
-                        ++var2;
-                        Block var18 = Block.blocksList[var17];
-
-                        if (var18 != null && var18.getTickRandomly())
-                        {
-                            ++var1;
-                            var18.updateTick(this, var14 + var5, var16 + var20.getYLocation(), var15 + var6, this.rand);
-                        }
-                    }
-                }
-            }
-
-            this.theProfiler.endSection();
-        }
-    }
-
-    /**
-     * Returns true if the given block will receive a scheduled tick in the future. Args: X, Y, Z, blockID
-     */
-    public boolean isBlockTickScheduled(int par1, int par2, int par3, int par4)
-    {
-        NextTickListEntry var5 = new NextTickListEntry(par1, par2, par3, par4);
-        return this.field_94579_S.contains(var5);
-    }
-
-    /**
-     * Schedules a tick to a block with a delay (Most commonly the tick rate)
-     */
-    public void scheduleBlockUpdate(int par1, int par2, int par3, int par4, int par5)
-    {
-        this.func_82740_a(par1, par2, par3, par4, par5, 0);
-    }
-
-    public void func_82740_a(int par1, int par2, int par3, int par4, int par5, int par6)
-    {
-        NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
-        byte var8 = 0;
-
-        if (this.scheduledUpdatesAreImmediate && par4 > 0)
-        {
-            if (Block.blocksList[par4].func_82506_l())
-            {
+			 */
+			SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, false);
+			// END FCMOD
+		}
+
+		this.theProfiler.endStartSection("chunkSource");
+		this.chunkProvider.unloadQueuedChunks();
+		int var4 = this.calculateSkylightSubtracted(1.0F);
+
+		if (var4 != this.skylightSubtracted)
+		{
+			this.skylightSubtracted = var4;
+		}
+
+		this.worldInfo.incrementTotalWorldTime(this.worldInfo.getWorldTotalTime() + 1L);
+		this.worldInfo.setWorldTime(this.worldInfo.getWorldTime() + 1L);
+		this.theProfiler.endStartSection("tickPending");
+		this.tickUpdates(false);
+		this.theProfiler.endStartSection("tickTiles");
+		this.tickBlocksAndAmbiance();
+		this.theProfiler.endStartSection("chunkMap");
+		// FCMOD: Changed
+		//this.thePlayerManager.updatePlayerInstances();
+		m_chunkTracker.Update();
+		// END FCMOD
+		this.theProfiler.endStartSection("village");
+		this.villageCollectionObj.tick();
+		// FCMOD: Removed
+		//this.villageSiegeObj.tick();
+		// END FCMOD
+		this.theProfiler.endStartSection("portalForcer");
+		this.field_85177_Q.removeStalePortalLocations(this.getTotalWorldTime());
+		this.theProfiler.endSection();
+		this.sendAndApplyBlockEvents();
+	}
+
+	/**
+	 * only spawns creatures allowed by the chunkProvider
+	 */
+	public SpawnListEntry spawnRandomCreature(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)
+	{
+		List var5 = this.getChunkProvider().getPossibleCreatures(par1EnumCreatureType, par2, par3, par4);
+		return var5 != null && !var5.isEmpty() ? (SpawnListEntry)WeightedRandom.getRandomItem(this.rand, var5) : null;
+	}
+
+	/**
+	 * Updates the flag that indicates whether or not all players in the world are sleeping.
+	 */
+	public void updateAllPlayersSleepingFlag()
+	{
+		this.allPlayersSleeping = !this.playerEntities.isEmpty();
+		Iterator var1 = this.playerEntities.iterator();
+
+		while (var1.hasNext())
+		{
+			EntityPlayer var2 = (EntityPlayer)var1.next();
+
+			if (!var2.isPlayerSleeping())
+			{
+				this.allPlayersSleeping = false;
+				break;
+			}
+		}
+	}
+
+	protected void wakeAllPlayers()
+	{
+		this.allPlayersSleeping = false;
+		Iterator var1 = this.playerEntities.iterator();
+
+		while (var1.hasNext())
+		{
+			EntityPlayer var2 = (EntityPlayer)var1.next();
+
+			if (var2.isPlayerSleeping())
+			{
+				var2.wakeUpPlayer(false, false, true);
+			}
+		}
+
+		this.resetRainAndThunder();
+	}
+
+	private void resetRainAndThunder()
+	{
+		this.worldInfo.setRainTime(0);
+		this.worldInfo.setRaining(false);
+		this.worldInfo.setThunderTime(0);
+		this.worldInfo.setThundering(false);
+	}
+
+	public boolean areAllPlayersAsleep()
+	{
+		if (this.allPlayersSleeping && !this.isRemote)
+		{
+			Iterator var1 = this.playerEntities.iterator();
+			EntityPlayer var2;
+
+			do
+			{
+				if (!var1.hasNext())
+				{
+					return true;
+				}
+
+				var2 = (EntityPlayer)var1.next();
+			}
+			while (var2.isPlayerFullyAsleep());
+
+			return false;
+		}
+		else
+		{
+			return false;
+		}
+	}
+
+	/**
+	 * Sets a new spawn location by finding an uncovered block at a random (x,z) location in the chunk.
+	 */
+	public void setSpawnLocation()
+	{
+		if (this.worldInfo.getSpawnY() <= 0)
+		{
+			this.worldInfo.setSpawnY(64);
+		}
+
+		int var1 = this.worldInfo.getSpawnX();
+		int var2 = this.worldInfo.getSpawnZ();
+		int var3 = 0;
+
+		while (this.getFirstUncoveredBlock(var1, var2) == 0)
+		{
+			var1 += this.rand.nextInt(8) - this.rand.nextInt(8);
+			var2 += this.rand.nextInt(8) - this.rand.nextInt(8);
+			++var3;
+
+			if (var3 == 10000)
+			{
+				break;
+			}
+		}
+
+		this.worldInfo.setSpawnX(var1);
+		this.worldInfo.setSpawnZ(var2);
+	}
+
+	/**
+	 * plays random cave ambient sounds and runs updateTick on random blocks within each chunk in the vacinity of a
+	 * player
+	 */
+	protected void tickBlocksAndAmbiance()
+	{
+		super.tickBlocksAndAmbiance();
+		int var1 = 0;
+		int var2 = 0;
+		// FCMOD: Changed
+		//Iterator var3 = this.activeChunkSet.iterator();
+		Iterator<ChunkCoordIntPair> var3 = m_activeChunksCoordsList.iterator();
+		// END FCMOD
+
+		while (var3.hasNext())
+		{
+			ChunkCoordIntPair var4 = (ChunkCoordIntPair)var3.next();
+			int var5 = var4.chunkXPos * 16;
+			int var6 = var4.chunkZPos * 16;
+			this.theProfiler.startSection("getChunk");
+			Chunk var7 = this.getChunkFromChunkCoords(var4.chunkXPos, var4.chunkZPos);
+			this.moodSoundAndLightCheck(var5, var6, var7);
+			this.theProfiler.endStartSection("tickChunk");
+			var7.updateSkylight();
+			this.theProfiler.endStartSection("thunder");
+			int var8;
+			int var9;
+			int var10;
+			int var11;
+
+			// FCMOD: Changed
+			//if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+			if ( rand.nextInt( 50000 ) == 0 && isRaining() && isThundering() )
+				// END FCMOD 
+			{
+				this.updateLCG = this.updateLCG * 3 + 1013904223;
+				var8 = this.updateLCG >> 2;
+		var9 = var5 + (var8 & 15);
+		var10 = var6 + (var8 >> 8 & 15);
+		var11 = this.getPrecipitationHeight(var9, var10);
+
+		// FCMOD: Changed
+		//if (this.canLightningStrikeAt(var9, var11, var10))
+		if ( CanLightningStrikeAtPos( var9, var11, var10 ) )
+			// END FCMOD
+		{
+			// FCMOD: Changed
+			//this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
+			FCUtilsBlockPos strikePos = new FCUtilsBlockPos( var9, var11, var10 );
+
+			AdjustLightningPosForSurroundings( strikePos );
+
+			if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
+			{
+				addWeatherEffect( new FCEntityLightningBolt( this, (double)strikePos.i + 0.5D, 
+						(double)strikePos.j, (double)strikePos.k + 0.5D ) );
+			}
+			// END FCMOD
+		}
+			}
+
+			this.theProfiler.endStartSection("iceandsnow");
+			int var13;
+
+			if (this.rand.nextInt(16) == 0)
+			{
+				this.updateLCG = this.updateLCG * 3 + 1013904223;
+				var8 = this.updateLCG >> 2;
+				var9 = var8 & 15;
+				var10 = var8 >> 8 & 15;
+				var11 = this.getPrecipitationHeight(var9 + var5, var10 + var6);
+
+				if (this.isBlockFreezableNaturally(var9 + var5, var11 - 1, var10 + var6))
+				{
+					this.setBlock(var9 + var5, var11 - 1, var10 + var6, Block.ice.blockID);
+				}
+
+				if (this.isRaining() && this.canSnowAt(var9 + var5, var11, var10 + var6))
+				{
+					this.setBlock(var9 + var5, var11, var10 + var6, Block.snow.blockID);
+				}
+				// FCMOD: Added
+				else if (this.isRaining() && this.canSnowAt(var9 + var5, var11 + 1, var10 + var6))
+				{
+					setBlock(var9 + var5, var11 + 1, var10 + var6, Block.snow.blockID);
+				}
+				// END FCMOD
+
+				if (this.isRaining())
+				{
+					BiomeGenBase var12 = this.getBiomeGenForCoords(var9 + var5, var10 + var6);
+
+					// FCMOD: Changed for clarity
+					//if (var12.canSpawnLightningBolt())
+					if ( var12.CanRainInBiome() )
+						// END FCMOD
+					{
+						var13 = this.getBlockId(var9 + var5, var11 - 1, var10 + var6);
+
+						if (var13 != 0)
+						{
+							Block.blocksList[var13].fillWithRain(this, var9 + var5, var11 - 1, var10 + var6);
+						}
+					}
+				}
+			}
+
+			this.theProfiler.endStartSection("tickTiles");
+			ExtendedBlockStorage[] var19 = var7.getBlockStorageArray();
+			var9 = var19.length;
+
+			for (var10 = 0; var10 < var9; ++var10)
+			{
+				ExtendedBlockStorage var21 = var19[var10];
+
+				if (var21 != null && var21.getNeedsRandomTick())
+				{
+					for (int var20 = 0; var20 < 3; ++var20)
+					{
+						this.updateLCG = this.updateLCG * 3 + 1013904223;
+						var13 = this.updateLCG >> 2;
+					int var14 = var13 & 15;
+					int var15 = var13 >> 8 & 15;
+					int var16 = var13 >> 16 & 15;
+					int var17 = var21.getExtBlockID(var14, var16, var15);
+					++var2;
+					Block var18 = Block.blocksList[var17];
+
+					if (var18 != null && var18.getTickRandomly())
+					{
+						++var1;
+						// FCMOD: Code changed
+						/*
+                            var18.updateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, this.rand);
+						 */
+						var18.RandomUpdateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, rand);
+						// END FCMOD
+					}
+					}
+				}
+			}
+
+			this.theProfiler.endSection();
+		}
+
+		// FCMOD: Added
+		ModUpdateTick();
+		// END FCMOD
+	}
+
+	/**
+	 * Returns true if the given block will receive a scheduled tick in the future. Args: X, Y, Z, blockID
+	 * FCNOTE: This is actually whether the block is about to be ticked THIS UPDATE.
+	 */
+	public boolean isBlockTickScheduled(int par1, int par2, int par3, int par4)
+	{
+		NextTickListEntry var5 = new NextTickListEntry(par1, par2, par3, par4);
+		return this.field_94579_S.contains(var5);
+	}
+
+	/**
+	 * Schedules a tick to a block with a delay (Most commonly the tick rate)
+	 */
+	public void scheduleBlockUpdate(int par1, int par2, int par3, int par4, int par5)
+	{
+		this.func_82740_a(par1, par2, par3, par4, par5, 0);
+	}
+
+	public void func_82740_a(int par1, int par2, int par3, int par4, int par5, int par6)
+	{
+		NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
+		// FCMOD: Removed
+		//byte var8 = 0;
+		// END FCMOD
+
+		if (this.scheduledUpdatesAreImmediate && par4 > 0)
+		{
+			if (Block.blocksList[par4].func_82506_l())
+			{
+				// FCCHUNK: Decide on updates around original spawn
+				// FCMOD: Changed
+				/*
                 if (this.checkChunksExist(var7.xCoord - var8, var7.yCoord - var8, var7.zCoord - var8, var7.xCoord + var8, var7.yCoord + var8, var7.zCoord + var8))
-                {
-                    int var9 = this.getBlockId(var7.xCoord, var7.yCoord, var7.zCoord);
-
-                    if (var9 == var7.blockID && var9 > 0)
-                    {
-                        Block.blocksList[var9].updateTick(this, var7.xCoord, var7.yCoord, var7.zCoord, this.rand);
-                    }
-                }
-
-                return;
-            }
-
-            par5 = 1;
-        }
-
+				 */
+				if ( IsBlockPosActive( var7.xCoord, var7.yCoord, var7.zCoord ) )
+					// END FCMOD
+				{
+					int var9 = this.getBlockId(var7.xCoord, var7.yCoord, var7.zCoord);
+
+					if (var9 == var7.blockID && var9 > 0)
+					{
+						Block.blocksList[var9].updateTick(this, var7.xCoord, var7.yCoord, var7.zCoord, this.rand);
+					}
+				}
+
+				return;
+			}
+
+			par5 = 1;
+		}
+
+		// FCCHUNK: Decide on updates around original spawn
+		// FCMOD: Changed
+		/*
         if (this.checkChunksExist(par1 - var8, par2 - var8, par3 - var8, par1 + var8, par2 + var8, par3 + var8))
-        {
-            if (par4 > 0)
-            {
-                var7.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
-                var7.func_82753_a(par6);
-            }
-
-            if (!this.field_73064_N.contains(var7))
-            {
-                this.field_73064_N.add(var7);
-                this.pendingTickListEntries.add(var7);
-            }
-        }
-    }
-
-    /**
-     * Schedules a block update from the saved information in a chunk. Called when the chunk is loaded.
-     */
-    public void scheduleBlockUpdateFromLoad(int par1, int par2, int par3, int par4, int par5, int par6)
-    {
-        NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
-        var7.func_82753_a(par6);
-
-        if (par4 > 0)
-        {
-            var7.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
-        }
-
-        if (!this.field_73064_N.contains(var7))
-        {
-            this.field_73064_N.add(var7);
-            this.pendingTickListEntries.add(var7);
-        }
-    }
-
-    /**
-     * Updates (and cleans up) entities and tile entities
-     */
-    public void updateEntities()
-    {
+		 */
+		if ( IsBlockPosActive( par1, par2, par3 ) )
+			// END FCMOD
+		{
+			if (par4 > 0)
+			{
+				var7.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
+				var7.func_82753_a(par6);
+			}
+
+			if (!this.field_73064_N.contains(var7))
+			{
+				this.field_73064_N.add(var7);
+				this.pendingTickListEntries.add(var7);
+			}
+		}
+	}
+
+	/**
+	 * Schedules a block update from the saved information in a chunk. Called when the chunk is loaded.
+	 */
+	public void scheduleBlockUpdateFromLoad(int par1, int par2, int par3, int par4, int par5, int par6)
+	{
+		NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
+		var7.func_82753_a(par6);
+
+		if (par4 > 0)
+		{
+			var7.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
+		}
+
+		if (!this.field_73064_N.contains(var7))
+		{
+			this.field_73064_N.add(var7);
+			this.pendingTickListEntries.add(var7);
+		}
+	}
+
+	/**
+	 * Updates (and cleans up) entities and tile entities
+	 */
+	public void updateEntities()
+	{
+		// FCMOD: Removed pausing of updates when no players in world.  Replaced elsewhere
+		/*
         if (this.playerEntities.isEmpty())
         {
             if (this.updateEntityTick++ >= 1200)
@@ -461,537 +553,600 @@ public class WorldServer extends World
         {
             this.resetUpdateEntityTick();
         }
-
-        super.updateEntities();
-    }
-
-    /**
-     * Resets the updateEntityTick field to 0
-     */
-    public void resetUpdateEntityTick()
-    {
-        this.updateEntityTick = 0;
-    }
-
-    /**
-     * Runs through the list of updates to run and ticks them
-     */
-    public boolean tickUpdates(boolean par1)
-    {
-        int var2 = this.pendingTickListEntries.size();
-
-        if (var2 != this.field_73064_N.size())
-        {
-            throw new IllegalStateException("TickNextTick list out of synch");
-        }
-        else
-        {
-            if (var2 > 1000)
-            {
-                var2 = 1000;
-            }
-
-            this.theProfiler.startSection("cleaning");
-            NextTickListEntry var4;
-
-            for (int var3 = 0; var3 < var2; ++var3)
-            {
-                var4 = (NextTickListEntry)this.pendingTickListEntries.first();
-
-                if (!par1 && var4.scheduledTime > this.worldInfo.getWorldTotalTime())
-                {
-                    break;
-                }
-
-                this.pendingTickListEntries.remove(var4);
-                this.field_73064_N.remove(var4);
-                this.field_94579_S.add(var4);
-            }
-
-            this.theProfiler.endSection();
-            this.theProfiler.startSection("ticking");
-            Iterator var14 = this.field_94579_S.iterator();
-
-            while (var14.hasNext())
-            {
-                var4 = (NextTickListEntry)var14.next();
-                var14.remove();
+		 */
+		// END FCMOD
+
+		super.updateEntities();
+	}
+
+	/**
+	 * Resets the updateEntityTick field to 0
+	 */
+	public void resetUpdateEntityTick()
+	{
+		this.updateEntityTick = 0;
+	}
+
+	/**
+	 * Runs through the list of updates to run and ticks them
+	 */
+	public boolean tickUpdates(boolean par1)
+	{
+		int var2 = this.pendingTickListEntries.size();
+
+		if (var2 != this.field_73064_N.size())
+		{
+			throw new IllegalStateException("TickNextTick list out of synch");
+		}
+		else
+		{
+			if (var2 > 1000)
+			{
+				var2 = 1000;
+			}
+
+			this.theProfiler.startSection("cleaning");
+			NextTickListEntry var4;
+
+			for (int var3 = 0; var3 < var2; ++var3)
+			{
+				var4 = (NextTickListEntry)this.pendingTickListEntries.first();
+
+				if (!par1 && var4.scheduledTime > this.worldInfo.getWorldTotalTime())
+				{
+					break;
+				}
+
+				this.pendingTickListEntries.remove(var4);
+				this.field_73064_N.remove(var4);
+				this.field_94579_S.add(var4);
+			}
+
+			this.theProfiler.endSection();
+			this.theProfiler.startSection("ticking");
+			Iterator var14 = this.field_94579_S.iterator();
+
+			while (var14.hasNext())
+			{
+				var4 = (NextTickListEntry)var14.next();
+				var14.remove();
+				// FCCHUNK: Decide on updates around original spawn
+				// FCMOD: Changed to prevent neighboring chunks inadvertantly being loaded during
+				// updates.  This was causing stuff like fire loading a ton of chunks in the nether.
+				/*
                 byte var5 = 0;
 
                 if (this.checkChunksExist(var4.xCoord - var5, var4.yCoord - var5, var4.zCoord - var5, var4.xCoord + var5, var4.yCoord + var5, var4.zCoord + var5))
-                {
-                    int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
-
-                    if (var6 > 0 && Block.isAssociatedBlockID(var6, var4.blockID))
-                    {
-                        try
-                        {
-                            Block.blocksList[var6].updateTick(this, var4.xCoord, var4.yCoord, var4.zCoord, this.rand);
-                        }
-                        catch (Throwable var13)
-                        {
-                            CrashReport var8 = CrashReport.makeCrashReport(var13, "Exception while ticking a block");
-                            CrashReportCategory var9 = var8.makeCategory("Block being ticked");
-                            int var10;
-
-                            try
-                            {
-                                var10 = this.getBlockMetadata(var4.xCoord, var4.yCoord, var4.zCoord);
-                            }
-                            catch (Throwable var12)
-                            {
-                                var10 = -1;
-                            }
-
-                            CrashReportCategory.func_85068_a(var9, var4.xCoord, var4.yCoord, var4.zCoord, var6, var10);
-                            throw new ReportedException(var8);
-                        }
-                    }
-                }
+				 */
+				if ( IsBlockPosActive( var4.xCoord, var4.yCoord, var4.zCoord ) )
+					// END FCMOD
+				{
+					int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
+
+					if (var6 > 0 && Block.isAssociatedBlockID(var6, var4.blockID))
+					{
+						try
+						{
+							Block.blocksList[var6].updateTick(this, var4.xCoord, var4.yCoord, var4.zCoord, this.rand);
+						}
+						catch (Throwable var13)
+						{
+							CrashReport var8 = CrashReport.makeCrashReport(var13, "Exception while ticking a block");
+							CrashReportCategory var9 = var8.makeCategory("Block being ticked");
+							int var10;
+
+							try
+							{
+								var10 = this.getBlockMetadata(var4.xCoord, var4.yCoord, var4.zCoord);
+							}
+							catch (Throwable var12)
+							{
+								var10 = -1;
+							}
+
+							CrashReportCategory.func_85068_a(var9, var4.xCoord, var4.yCoord, var4.zCoord, var6, var10);
+							throw new ReportedException(var8);
+						}
+					}
+				}
+				// FCCHUNK: Decide on updates around original spawn
+				// FCMOD: Removed to reduce unnecessary overhead of recheduling ticks in inactive chunks
+				/*
                 else
                 {
-                    this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
+                	// FCMOD: Changed to not immediately retick on next update to ease on performance
+                    //this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
+                    scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 
+                    	Block.blocksList[var4.blockID].tickRate( this ) );
+                    // END FCMOD
                 }
-            }
-
-            this.theProfiler.endSection();
-            this.field_94579_S.clear();
-            return !this.pendingTickListEntries.isEmpty();
-        }
-    }
-
-    public List getPendingBlockUpdates(Chunk par1Chunk, boolean par2)
+				 */
+				// END FCMOD
+			}
+
+			this.theProfiler.endSection();
+			this.field_94579_S.clear();
+			return !this.pendingTickListEntries.isEmpty();
+		}
+	}
+
+	public List getPendingBlockUpdates(Chunk par1Chunk, boolean par2)
+	{
+		ArrayList var3 = null;
+		ChunkCoordIntPair var4 = par1Chunk.getChunkCoordIntPair();
+		int var5 = (var4.chunkXPos << 4) - 2;
+		int var6 = var5 + 16 + 2;
+		int var7 = (var4.chunkZPos << 4) - 2;
+		int var8 = var7 + 16 + 2;
+
+		for (int var9 = 0; var9 < 2; ++var9)
+		{
+			Iterator var10;
+
+			if (var9 == 0)
+			{
+				var10 = this.pendingTickListEntries.iterator();
+			}
+			else
+			{
+				var10 = this.field_94579_S.iterator();
+
+				if (!this.field_94579_S.isEmpty())
+				{
+					System.out.println(this.field_94579_S.size());
+				}
+			}
+
+			while (var10.hasNext())
+			{
+				NextTickListEntry var11 = (NextTickListEntry)var10.next();
+
+				if (var11.xCoord >= var5 && var11.xCoord < var6 && var11.zCoord >= var7 && var11.zCoord < var8)
+				{
+					if (par2)
+					{
+						this.field_73064_N.remove(var11);
+						var10.remove();
+					}
+
+					if (var3 == null)
+					{
+						var3 = new ArrayList();
+					}
+
+					var3.add(var11);
+				}
+			}
+		}
+
+		return var3;
+	}
+
+	/**
+	 * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
+	 * Args: entity, forceUpdate
+	 */
+	public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
+	{
+		if (!this.mcServer.getCanSpawnAnimals() && (par1Entity instanceof EntityAnimal || par1Entity instanceof EntityWaterMob))
+		{
+			par1Entity.setDead();
+		}
+
+		if (!this.mcServer.getCanSpawnNPCs() && par1Entity instanceof INpc)
+		{
+			par1Entity.setDead();
+		}
+
+		if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
+		{
+			// Added so that creatures in periphery chunks can still despawn
+			int iEntityI = MathHelper.floor_double( par1Entity.posX );
+			int iEntityK = MathHelper.floor_double( par1Entity.posZ );
+
+			if ( par2 && !IsBlockPosActive( iEntityI, 0, iEntityK ) && par1Entity.addedToChunk  )
+			{
+				if ( par1Entity.ridingEntity == null )
+				{
+					par1Entity.OutOfUpdateRangeUpdate();
+				}
+
+				return; // intentionally skip super call
+			}
+			// END FCMOD
+
+			super.updateEntityWithOptionalForce(par1Entity, par2);
+
+		}
+	}
+
+	/**
+	 * direct call to super.updateEntityWithOptionalForce
+	 */
+	public void uncheckedUpdateEntity(Entity par1Entity, boolean par2)
+	{
+		super.updateEntityWithOptionalForce(par1Entity, par2);
+	}
+
+	/**
+	 * Creates the chunk provider for this world. Called in the constructor. Retrieves provider from worldProvider?
+	 */
+	protected IChunkProvider createChunkProvider()
+	{
+		IChunkLoader var1 = this.saveHandler.getChunkLoader(this.provider);
+		this.theChunkProviderServer = new ChunkProviderServer(this, var1, this.provider.createChunkGenerator());
+		return this.theChunkProviderServer;
+	}
+
+	// FCMOD: Added (server only) alias to match client
+	/*
+    public List getAllTileEntityInBox( int par1, int par2, int par3, int par4, int par5, int par6 )
     {
-        ArrayList var3 = null;
-        ChunkCoordIntPair var4 = par1Chunk.getChunkCoordIntPair();
-        int var5 = (var4.chunkXPos << 4) - 2;
-        int var6 = var5 + 16 + 2;
-        int var7 = (var4.chunkZPos << 4) - 2;
-        int var8 = var7 + 16 + 2;
-
-        for (int var9 = 0; var9 < 2; ++var9)
-        {
-            Iterator var10;
-
-            if (var9 == 0)
-            {
-                var10 = this.pendingTickListEntries.iterator();
-            }
-            else
-            {
-                var10 = this.field_94579_S.iterator();
-
-                if (!this.field_94579_S.isEmpty())
-                {
-                    System.out.println(this.field_94579_S.size());
-                }
-            }
-
-            while (var10.hasNext())
-            {
-                NextTickListEntry var11 = (NextTickListEntry)var10.next();
-
-                if (var11.xCoord >= var5 && var11.xCoord < var6 && var11.zCoord >= var7 && var11.zCoord < var8)
-                {
-                    if (par2)
-                    {
-                        this.field_73064_N.remove(var11);
-                        var10.remove();
-                    }
-
-                    if (var3 == null)
-                    {
-                        var3 = new ArrayList();
-                    }
-
-                    var3.add(var11);
-                }
-            }
-        }
-
-        return var3;
-    }
-
-    /**
-     * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
-     * Args: entity, forceUpdate
-     */
-    public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
-    {
-        if (!this.mcServer.getCanSpawnAnimals() && (par1Entity instanceof EntityAnimal || par1Entity instanceof EntityWaterMob))
-        {
-            par1Entity.setDead();
-        }
-
-        if (!this.mcServer.getCanSpawnNPCs() && par1Entity instanceof INpc)
-        {
-            par1Entity.setDead();
-        }
-
-        if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
-        {
-            super.updateEntityWithOptionalForce(par1Entity, par2);
-        }
-    }
-
-    /**
-     * direct call to super.updateEntityWithOptionalForce
-     */
-    public void uncheckedUpdateEntity(Entity par1Entity, boolean par2)
-    {
-        super.updateEntityWithOptionalForce(par1Entity, par2);
-    }
-
-    /**
-     * Creates the chunk provider for this world. Called in the constructor. Retrieves provider from worldProvider?
-     */
-    protected IChunkProvider createChunkProvider()
-    {
-        IChunkLoader var1 = this.saveHandler.getChunkLoader(this.provider);
-        this.theChunkProviderServer = new ChunkProviderServer(this, var1, this.provider.createChunkGenerator());
-        return this.theChunkProviderServer;
-    }
-
-    /**
-     * pars: min x,y,z , max x,y,z
-     */
-    public List getAllTileEntityInBox(int par1, int par2, int par3, int par4, int par5, int par6)
-    {
-        ArrayList var7 = new ArrayList();
-
-        for (int var8 = 0; var8 < this.loadedTileEntityList.size(); ++var8)
-        {
-            TileEntity var9 = (TileEntity)this.loadedTileEntityList.get(var8);
-
-            if (var9.xCoord >= par1 && var9.yCoord >= par2 && var9.zCoord >= par3 && var9.xCoord < par4 && var9.yCoord < par5 && var9.zCoord < par6)
-            {
-                var7.add(var9);
-            }
-        }
-
-        return var7;
-    }
-
-    /**
-     * Called when checking if a certain block can be mined or not. The 'spawn safe zone' check is located here.
-     */
-    public boolean canMineBlock(EntityPlayer par1EntityPlayer, int par2, int par3, int par4)
-    {
-        return !this.mcServer.func_96290_a(this, par2, par3, par4, par1EntityPlayer);
-    }
-
-    protected void initialize(WorldSettings par1WorldSettings)
-    {
-        if (this.entityIdMap == null)
-        {
-            this.entityIdMap = new IntHashMap();
-        }
-
-        if (this.field_73064_N == null)
-        {
-            this.field_73064_N = new HashSet();
-        }
-
-        if (this.pendingTickListEntries == null)
-        {
-            this.pendingTickListEntries = new TreeSet();
-        }
-
-        this.createSpawnPosition(par1WorldSettings);
-        super.initialize(par1WorldSettings);
-    }
-
-    /**
-     * creates a spawn position at random within 256 blocks of 0,0
-     */
-    protected void createSpawnPosition(WorldSettings par1WorldSettings)
-    {
-        if (!this.provider.canRespawnHere())
-        {
-            this.worldInfo.setSpawnPosition(0, this.provider.getAverageGroundLevel(), 0);
-        }
-        else
-        {
-            this.findingSpawnPoint = true;
-            WorldChunkManager var2 = this.provider.worldChunkMgr;
-            List var3 = var2.getBiomesToSpawnIn();
-            Random var4 = new Random(this.getSeed());
-            ChunkPosition var5 = var2.findBiomePosition(0, 0, 256, var3, var4);
-            int var6 = 0;
-            int var7 = this.provider.getAverageGroundLevel();
-            int var8 = 0;
-
-            if (var5 != null)
-            {
-                var6 = var5.x;
-                var8 = var5.z;
-            }
-            else
-            {
-                this.getWorldLogAgent().logWarning("Unable to find spawn biome");
-            }
-
-            int var9 = 0;
-
-            while (!this.provider.canCoordinateBeSpawn(var6, var8))
-            {
-                var6 += var4.nextInt(64) - var4.nextInt(64);
-                var8 += var4.nextInt(64) - var4.nextInt(64);
-                ++var9;
-
-                if (var9 == 1000)
-                {
-                    break;
-                }
-            }
-
-            this.worldInfo.setSpawnPosition(var6, var7, var8);
-            this.findingSpawnPoint = false;
-
-            if (par1WorldSettings.isBonusChestEnabled())
-            {
-                this.createBonusChest();
-            }
-        }
-    }
-
-    /**
-     * Creates the bonus chest in the world.
-     */
-    protected void createBonusChest()
-    {
-        WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
-
-        for (int var2 = 0; var2 < 10; ++var2)
-        {
-            int var3 = this.worldInfo.getSpawnX() + this.rand.nextInt(6) - this.rand.nextInt(6);
-            int var4 = this.worldInfo.getSpawnZ() + this.rand.nextInt(6) - this.rand.nextInt(6);
-            int var5 = this.getTopSolidOrLiquidBlock(var3, var4) + 1;
-
-            if (var1.generate(this, this.rand, var3, var5, var4))
-            {
-                break;
-            }
-        }
-    }
-
-    /**
-     * Gets the hard-coded portal location to use when entering this dimension.
-     */
-    public ChunkCoordinates getEntrancePortalLocation()
-    {
-        return this.provider.getEntrancePortalLocation();
-    }
-
-    /**
-     * Saves all chunks to disk while updating progress bar.
-     */
-    public void saveAllChunks(boolean par1, IProgressUpdate par2IProgressUpdate) throws MinecraftException
-    {
-        if (this.chunkProvider.canSave())
-        {
-            if (par2IProgressUpdate != null)
-            {
-                par2IProgressUpdate.displayProgressMessage("Saving level");
-            }
-
-            this.saveLevel();
-
-            if (par2IProgressUpdate != null)
-            {
-                par2IProgressUpdate.resetProgresAndWorkingMessage("Saving chunks");
-            }
-
-            this.chunkProvider.saveChunks(par1, par2IProgressUpdate);
-        }
-    }
-
-    public void func_104140_m()
-    {
-        if (this.chunkProvider.canSave())
-        {
-            this.chunkProvider.func_104112_b();
-        }
-    }
-
-    /**
-     * Saves the chunks to disk.
-     */
-    protected void saveLevel() throws MinecraftException
-    {
-        this.checkSessionLock();
-        this.saveHandler.saveWorldInfoWithPlayer(this.worldInfo, this.mcServer.getConfigurationManager().getHostPlayerData());
-        this.mapStorage.saveAllData();
-    }
-
-    /**
-     * Start the skin for this entity downloading, if necessary, and increment its reference counter
-     */
-    protected void obtainEntitySkin(Entity par1Entity)
-    {
-        super.obtainEntitySkin(par1Entity);
-        this.entityIdMap.addKey(par1Entity.entityId, par1Entity);
-        Entity[] var2 = par1Entity.getParts();
-
-        if (var2 != null)
-        {
-            for (int var3 = 0; var3 < var2.length; ++var3)
-            {
-                this.entityIdMap.addKey(var2[var3].entityId, var2[var3]);
-            }
-        }
+    	return getTileEntityList( par1, par2, par3, par4, par5, par6 );
     }
-
-    /**
-     * Decrement the reference counter for this entity's skin image data
-     */
-    protected void releaseEntitySkin(Entity par1Entity)
-    {
-        super.releaseEntitySkin(par1Entity);
-        this.entityIdMap.removeObject(par1Entity.entityId);
-        Entity[] var2 = par1Entity.getParts();
-
-        if (var2 != null)
-        {
-            for (int var3 = 0; var3 < var2.length; ++var3)
-            {
-                this.entityIdMap.removeObject(var2[var3].entityId);
-            }
-        }
-    }
-
-    /**
-     * Returns the Entity with the given ID, or null if it doesn't exist in this World.
-     */
-    public Entity getEntityByID(int par1)
-    {
-        return (Entity)this.entityIdMap.lookup(par1);
-    }
-
-    /**
-     * adds a lightning bolt to the list of lightning bolts in this world.
-     */
-    public boolean addWeatherEffect(Entity par1Entity)
-    {
-        if (super.addWeatherEffect(par1Entity))
-        {
-            this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    /**
-     * sends a Packet 38 (Entity Status) to all tracked players of that entity
-     */
-    public void setEntityState(Entity par1Entity, byte par2)
-    {
-        Packet38EntityStatus var3 = new Packet38EntityStatus(par1Entity.entityId, par2);
-        this.getEntityTracker().sendPacketToAllAssociatedPlayers(par1Entity, var3);
-    }
-
-    /**
-     * returns a new explosion. Does initiation (at time of writing Explosion is not finished)
-     */
-    public Explosion newExplosion(Entity par1Entity, double par2, double par4, double par6, float par8, boolean par9, boolean par10)
-    {
-        Explosion var11 = new Explosion(this, par1Entity, par2, par4, par6, par8);
-        var11.isFlaming = par9;
-        var11.isSmoking = par10;
-        var11.doExplosionA();
-        var11.doExplosionB(false);
-
-        if (!par10)
-        {
-            var11.affectedBlockPositions.clear();
-        }
-
-        Iterator var12 = this.playerEntities.iterator();
-
-        while (var12.hasNext())
-        {
-            EntityPlayer var13 = (EntityPlayer)var12.next();
-
-            if (var13.getDistanceSq(par2, par4, par6) < 4096.0D)
-            {
-                ((EntityPlayerMP)var13).playerNetServerHandler.sendPacketToPlayer(new Packet60Explosion(par2, par4, par6, par8, var11.affectedBlockPositions, (Vec3)var11.func_77277_b().get(var13)));
-            }
-        }
-
-        return var11;
-    }
-
-    /**
-     * Adds a block event with the given Args to the blockEventCache. During the next tick(), the block specified will
-     * have its onBlockEvent handler called with the given parameters. Args: X,Y,Z, BlockID, EventID, EventParameter
-     */
-    public void addBlockEvent(int par1, int par2, int par3, int par4, int par5, int par6)
-    {
-        BlockEventData var7 = new BlockEventData(par1, par2, par3, par4, par5, par6);
-        Iterator var8 = this.blockEventCache[this.blockEventCacheIndex].iterator();
-        BlockEventData var9;
-
-        do
-        {
-            if (!var8.hasNext())
-            {
-                this.blockEventCache[this.blockEventCacheIndex].add(var7);
-                return;
-            }
-
-            var9 = (BlockEventData)var8.next();
-        }
-        while (!var9.equals(var7));
-    }
-
-    /**
-     * Send and apply locally all pending BlockEvents to each player with 64m radius of the event.
-     */
-    private void sendAndApplyBlockEvents()
-    {
-        while (!this.blockEventCache[this.blockEventCacheIndex].isEmpty())
-        {
-            int var1 = this.blockEventCacheIndex;
-            this.blockEventCacheIndex ^= 1;
-            Iterator var2 = this.blockEventCache[var1].iterator();
-
-            while (var2.hasNext())
-            {
-                BlockEventData var3 = (BlockEventData)var2.next();
-
-                if (this.onBlockEventReceived(var3))
-                {
-                    this.mcServer.getConfigurationManager().sendToAllNear((double)var3.getX(), (double)var3.getY(), (double)var3.getZ(), 64.0D, this.provider.dimensionId, new Packet54PlayNoteBlock(var3.getX(), var3.getY(), var3.getZ(), var3.getBlockID(), var3.getEventID(), var3.getEventParameter()));
-                }
-            }
-
-            this.blockEventCache[var1].clear();
-        }
-    }
-
-    /**
-     * Called to apply a pending BlockEvent to apply to the current world.
-     */
-    private boolean onBlockEventReceived(BlockEventData par1BlockEventData)
-    {
-        int var2 = this.getBlockId(par1BlockEventData.getX(), par1BlockEventData.getY(), par1BlockEventData.getZ());
-        return var2 == par1BlockEventData.getBlockID() ? Block.blocksList[var2].onBlockEventReceived(this, par1BlockEventData.getX(), par1BlockEventData.getY(), par1BlockEventData.getZ(), par1BlockEventData.getEventID(), par1BlockEventData.getEventParameter()) : false;
-    }
-
-    /**
-     * Syncs all changes to disk and wait for completion.
-     */
-    public void flush()
-    {
-        this.saveHandler.flush();
-    }
-
-    /**
-     * Updates all weather states.
-     */
+	 */
+	// END FCMOD
+	/**
+	 * pars: min x,y,z , max x,y,z
+	 */
+	public List getAllTileEntityInBox(int par1, int par2, int par3, int par4, int par5, int par6)
+	{
+		ArrayList var7 = new ArrayList();
+
+		for (int var8 = 0; var8 < this.loadedTileEntityList.size(); ++var8)
+		{
+			TileEntity var9 = (TileEntity)this.loadedTileEntityList.get(var8);
+
+			if (var9.xCoord >= par1 && var9.yCoord >= par2 && var9.zCoord >= par3 && var9.xCoord < par4 && var9.yCoord < par5 && var9.zCoord < par6)
+			{
+				var7.add(var9);
+			}
+		}
+
+		return var7;
+	}
+
+	/**
+	 * Called when checking if a certain block can be mined or not. The 'spawn safe zone' check is located here.
+	 */
+	public boolean canMineBlock(EntityPlayer par1EntityPlayer, int par2, int par3, int par4)
+	{
+		return !this.mcServer.func_96290_a(this, par2, par3, par4, par1EntityPlayer);
+	}
+
+	protected void initialize(WorldSettings par1WorldSettings)
+	{
+		if (this.entityIdMap == null)
+		{
+			this.entityIdMap = new IntHashMap();
+		}
+
+		if (this.field_73064_N == null)
+		{
+			this.field_73064_N = new HashSet();
+		}
+
+		if (this.pendingTickListEntries == null)
+		{
+			this.pendingTickListEntries = new TreeSet();
+		}
+
+		this.createSpawnPosition(par1WorldSettings);
+		super.initialize(par1WorldSettings);
+	}
+
+	/**
+	 * creates a spawn position at random within 256 blocks of 0,0
+	 */
+	protected void createSpawnPosition(WorldSettings par1WorldSettings)
+	{
+		if (!this.provider.canRespawnHere())
+		{
+			this.worldInfo.setSpawnPosition(0, this.provider.getAverageGroundLevel(), 0);
+		}
+		else
+		{
+			this.findingSpawnPoint = true;
+			WorldChunkManager var2 = this.provider.worldChunkMgr;
+			List var3 = var2.getBiomesToSpawnIn();
+			Random var4 = new Random(this.getSeed());
+			ChunkPosition var5 = var2.findBiomePosition(0, 0, 256, var3, var4);
+			int var6 = 0;
+			int var7 = this.provider.getAverageGroundLevel();
+			int var8 = 0;
+
+			if (var5 != null)
+			{
+				var6 = var5.x;
+				var8 = var5.z;
+			}
+			else
+			{
+				this.getWorldLogAgent().logWarning("Unable to find spawn biome");
+			}
+
+			int var9 = 0;
+
+			while (!this.provider.canCoordinateBeSpawn(var6, var8))
+			{
+				var6 += var4.nextInt(64) - var4.nextInt(64);
+				var8 += var4.nextInt(64) - var4.nextInt(64);
+				++var9;
+
+				if (var9 == 1000)
+				{
+					break;
+				}
+			}
+
+			this.worldInfo.setSpawnPosition(var6, var7, var8);
+			this.findingSpawnPoint = false;
+
+			if (par1WorldSettings.isBonusChestEnabled())
+			{
+				this.createBonusChest();
+			}
+		}
+	}
+
+	/**
+	 * Creates the bonus chest in the world.
+	 */
+	protected void createBonusChest()
+	{
+		// FCMOD: Changed
+		//WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
+		FCWorldGeneratorBonusBasket var1 = new FCWorldGeneratorBonusBasket();
+		// END FCMOD
+
+		for (int var2 = 0; var2 < 10; ++var2)
+		{
+			int var3 = this.worldInfo.getSpawnX() + this.rand.nextInt(6) - this.rand.nextInt(6);
+			int var4 = this.worldInfo.getSpawnZ() + this.rand.nextInt(6) - this.rand.nextInt(6);
+			int var5 = this.getTopSolidOrLiquidBlock(var3, var4) + 1;
+
+			if (var1.generate(this, this.rand, var3, var5, var4))
+			{
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Gets the hard-coded portal location to use when entering this dimension.
+	 */
+	public ChunkCoordinates getEntrancePortalLocation()
+	{
+		return this.provider.getEntrancePortalLocation();
+	}
+
+	/**
+	 * Saves all chunks to disk while updating progress bar.
+	 */
+	public void saveAllChunks(boolean par1, IProgressUpdate par2IProgressUpdate) throws MinecraftException
+	{
+		if (this.chunkProvider.canSave())
+		{
+			if (par2IProgressUpdate != null)
+			{
+				par2IProgressUpdate.displayProgressMessage("Saving level");
+			}
+
+			this.saveLevel();
+
+			if (par2IProgressUpdate != null)
+			{
+				par2IProgressUpdate.resetProgresAndWorkingMessage("Saving chunks");
+			}
+
+			this.chunkProvider.saveChunks(par1, par2IProgressUpdate);
+
+			// FCMOD: Added
+			saveHandler.SaveModSpecificData( this );
+			// END FCMOD
+		}
+	}
+
+	public void func_104140_m()
+	{
+		if (this.chunkProvider.canSave())
+		{
+			this.chunkProvider.func_104112_b();
+		}
+	}
+
+	/**
+	 * Saves the chunks to disk.
+	 */
+	protected void saveLevel() throws MinecraftException
+	{
+		this.checkSessionLock();
+		this.saveHandler.saveWorldInfoWithPlayer(this.worldInfo, this.mcServer.getConfigurationManager().getHostPlayerData());
+		this.mapStorage.saveAllData();
+	}
+
+	/**
+	 * Start the skin for this entity downloading, if necessary, and increment its reference counter
+	 */
+	protected void obtainEntitySkin(Entity par1Entity)
+	{
+		super.obtainEntitySkin(par1Entity);
+		this.entityIdMap.addKey(par1Entity.entityId, par1Entity);
+		Entity[] var2 = par1Entity.getParts();
+
+		if (var2 != null)
+		{
+			for (int var3 = 0; var3 < var2.length; ++var3)
+			{
+				this.entityIdMap.addKey(var2[var3].entityId, var2[var3]);
+			}
+		}
+	}
+
+	/**
+	 * Decrement the reference counter for this entity's skin image data
+	 */
+	protected void releaseEntitySkin(Entity par1Entity)
+	{
+		super.releaseEntitySkin(par1Entity);
+		this.entityIdMap.removeObject(par1Entity.entityId);
+		Entity[] var2 = par1Entity.getParts();
+
+		if (var2 != null)
+		{
+			for (int var3 = 0; var3 < var2.length; ++var3)
+			{
+				this.entityIdMap.removeObject(var2[var3].entityId);
+			}
+		}
+	}
+
+	/**
+	 * Returns the Entity with the given ID, or null if it doesn't exist in this World.
+	 */
+	public Entity getEntityByID(int par1)
+	{
+		return (Entity)this.entityIdMap.lookup(par1);
+	}
+
+	/**
+	 * adds a lightning bolt to the list of lightning bolts in this world.
+	 */
+	public boolean addWeatherEffect(Entity par1Entity)
+	{
+		if (super.addWeatherEffect(par1Entity))
+		{
+			// FCMOD: Changed to avoid modding Packet71Weather        	
+			//this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+			Packet71Weather packet = new Packet71Weather( par1Entity );
+
+			if ( par1Entity instanceof FCEntityLightningBolt )
+			{
+				packet.isLightningBolt = 1;
+			}
+
+			this.mcServer.getConfigurationManager().sendToAllNear(
+					par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, provider.dimensionId, 
+					packet );
+			// END FCMOD
+			return true;
+		}
+		else
+		{
+			return false;
+		}
+	}
+
+	/**
+	 * sends a Packet 38 (Entity Status) to all tracked players of that entity
+	 */
+	public void setEntityState(Entity par1Entity, byte par2)
+	{
+		Packet38EntityStatus var3 = new Packet38EntityStatus(par1Entity.entityId, par2);
+		this.getEntityTracker().sendPacketToAllAssociatedPlayers(par1Entity, var3);
+	}
+
+	/**
+	 * returns a new explosion. Does initiation (at time of writing Explosion is not finished)
+	 */
+	public Explosion newExplosion(Entity par1Entity, double par2, double par4, double par6, float par8, boolean par9, boolean par10)
+	{
+		Explosion var11 = new Explosion(this, par1Entity, par2, par4, par6, par8);
+		var11.isFlaming = par9;
+		var11.isSmoking = par10;
+		var11.doExplosionA();
+		var11.doExplosionB(false);
+
+		if (!par10)
+		{
+			var11.affectedBlockPositions.clear();
+		}
+
+		Iterator var12 = this.playerEntities.iterator();
+
+		while (var12.hasNext())
+		{
+			EntityPlayer var13 = (EntityPlayer)var12.next();
+
+			if (var13.getDistanceSq(par2, par4, par6) < 4096.0D)
+			{
+				((EntityPlayerMP)var13).playerNetServerHandler.sendPacketToPlayer(new Packet60Explosion(par2, par4, par6, par8, var11.affectedBlockPositions, (Vec3)var11.func_77277_b().get(var13)));
+			}
+		}
+
+		return var11;
+	}
+
+	/**
+	 * Adds a block event with the given Args to the blockEventCache. During the next tick(), the block specified will
+	 * have its onBlockEvent handler called with the given parameters. Args: X,Y,Z, BlockID, EventID, EventParameter
+	 */
+	public void addBlockEvent(int par1, int par2, int par3, int par4, int par5, int par6)
+	{
+		BlockEventData var7 = new BlockEventData(par1, par2, par3, par4, par5, par6);
+		Iterator var8 = this.blockEventCache[this.blockEventCacheIndex].iterator();
+		BlockEventData var9;
+
+		do
+		{
+			if (!var8.hasNext())
+			{
+				this.blockEventCache[this.blockEventCacheIndex].add(var7);
+				return;
+			}
+
+			var9 = (BlockEventData)var8.next();
+		}
+		while (!var9.equals(var7));
+	}
+
+	/**
+	 * Send and apply locally all pending BlockEvents to each player with 64m radius of the event.
+	 */
+	private void sendAndApplyBlockEvents()
+	{
+		while (!this.blockEventCache[this.blockEventCacheIndex].isEmpty())
+		{
+			int var1 = this.blockEventCacheIndex;
+			this.blockEventCacheIndex ^= 1;
+			Iterator var2 = this.blockEventCache[var1].iterator();
+
+			while (var2.hasNext())
+			{
+				BlockEventData var3 = (BlockEventData)var2.next();
+
+				if (this.onBlockEventReceived(var3))
+				{
+					this.mcServer.getConfigurationManager().sendToAllNear((double)var3.getX(), (double)var3.getY(), (double)var3.getZ(), 64.0D, this.provider.dimensionId, new Packet54PlayNoteBlock(var3.getX(), var3.getY(), var3.getZ(), var3.getBlockID(), var3.getEventID(), var3.getEventParameter()));
+				}
+			}
+
+			this.blockEventCache[var1].clear();
+		}
+	}
+
+	/**
+	 * Called to apply a pending BlockEvent to apply to the current world.
+	 */
+	private boolean onBlockEventReceived(BlockEventData par1BlockEventData)
+	{
+		int var2 = this.getBlockId(par1BlockEventData.getX(), par1BlockEventData.getY(), par1BlockEventData.getZ());
+		return var2 == par1BlockEventData.getBlockID() ? Block.blocksList[var2].onBlockEventReceived(this, par1BlockEventData.getX(), par1BlockEventData.getY(), par1BlockEventData.getZ(), par1BlockEventData.getEventID(), par1BlockEventData.getEventParameter()) : false;
+	}
+
+	/**
+	 * Syncs all changes to disk and wait for completion.
+	 */
+	public void flush()
+	{
+		this.saveHandler.flush();
+	}
+
+	/**
+	 * Updates all weather states.
+	 */
+	// FCMOD: Removed and replaced later
+	/*
     protected void updateWeather()
     {
         boolean var1 = this.isRaining();
@@ -1009,30 +1164,479 @@ public class WorldServer extends World
             }
         }
     }
-
-    /**
-     * Gets the MinecraftServer.
-     */
-    public MinecraftServer getMinecraftServer()
-    {
-        return this.mcServer;
-    }
-
-    /**
-     * Gets the EntityTracker
-     */
-    public EntityTracker getEntityTracker()
-    {
-        return this.theEntityTracker;
-    }
-
+	 */
+	// END FCMOD
+
+	/**
+	 * Gets the MinecraftServer.
+	 */
+	public MinecraftServer getMinecraftServer()
+	{
+		return this.mcServer;
+	}
+
+	/**
+	 * Gets the EntityTracker
+	 */
+	public EntityTracker getEntityTracker()
+	{
+		return this.theEntityTracker;
+	}
+
+	// FCMOD: Removed
+	/*
     public PlayerManager getPlayerManager()
     {
         return this.thePlayerManager;
     }
+	 */
+	// END FCMOD
+
+	public Teleporter getDefaultTeleporter()
+	{
+		return this.field_85177_Q;
+	}
+
+	// FCMOD: Added
+	private boolean m_bHasTicked = false;
+
+	protected LinkedList<ChunkCoordIntPair> m_chunksToCheckForUnloadList = 
+			new LinkedList<ChunkCoordIntPair>();
+
+	private long m_lNoPlayersOnServerTickCount = 0;
+
+	// MinecraftServer loads out to 192 blocks, or 12 chunks. One more for wiggle.
+
+	private final int m_iChunksAroundSpawnToCheckForUnload = 13;  
+
+	@Override
+	public void ModSpecificTick()
+	{
+		if ( !m_bHasTicked )
+		{
+			m_bHasTicked = true;
+
+			MarkChunksAroundSpawnToCheckForUnload();
+		}    	    	
+
+		CheckChunksToUnloadList();
+	}    
+
+	public void AddChunkToCheckForUnloadList( int iChunkX, int iChunkZ )
+	{
+		m_chunksToCheckForUnloadList.add( new ChunkCoordIntPair( iChunkX, iChunkZ ) );
+	}
+
+	public void AddChunkRangeToCheckForUnloadList( int iMinChunkX, int iMinChunkZ, 
+			int iMaxChunkX, int iMaxChunkZ )
+	{
+		for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
+		{
+			for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
+			{
+				AddChunkToCheckForUnloadList( iTempChunkX, iTempChunkZ );
+			}
+		}
+	}
+
+	private void CheckChunksToUnloadList()
+	{
+		if ( !m_chunksToCheckForUnloadList.isEmpty() )
+		{
+			Iterator<ChunkCoordIntPair> tempIterator = m_chunksToCheckForUnloadList.iterator();
+
+			while ( tempIterator.hasNext() )
+			{
+				ChunkCoordIntPair tempCoord = tempIterator.next();
+
+				if ( CheckChunkShouldBeUnloaded( tempCoord.chunkXPos, tempCoord.chunkZPos ) )
+				{
+					theChunkProviderServer.ForceAddToChunksToUnload( 
+							tempCoord.chunkXPos, tempCoord.chunkZPos );
+				}
+			}
+
+			m_chunksToCheckForUnloadList.clear();
+		}
+	}
+
+	private boolean CheckChunkShouldBeUnloaded( int iChunkX, int iChunkZ )
+	{
+		return chunkExists( iChunkX, iChunkZ ) && 
+				!m_chunkTracker.IsChunkBeingWatched( iChunkX, iChunkZ  )&&
+				!theChunkProviderServer.IsSpawnChunk( iChunkX, iChunkZ );
+	}
+
+	private void MarkChunksAroundSpawnToCheckForUnload()
+	{
+		// this function cleans up extra useless overworld chunks loaded by 
+		// MinecraftServer.initialWorldChunkLoad()
+
+		if ( provider.canRespawnHere() )
+		{
+			int iSpawnChunkX = worldInfo.getSpawnX() >> 4;
+			int iSpawnChunkZ = worldInfo.getSpawnZ() >> 4;
+
+			AddChunkRangeToCheckForUnloadList( 
+					iSpawnChunkX - m_iChunksAroundSpawnToCheckForUnload, 
+					iSpawnChunkZ - m_iChunksAroundSpawnToCheckForUnload,
+					iSpawnChunkX + m_iChunksAroundSpawnToCheckForUnload, 
+					iSpawnChunkZ + m_iChunksAroundSpawnToCheckForUnload );        
+		}
+	}
+
+	@Override
+	public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
+	{
+		NextTickListEntry tempEntry = new NextTickListEntry( i, j, k, iBlockID );
+
+		return field_73064_N.contains( tempEntry );
+	}
+
+	@Override
+	protected void updateWeather()
+	{
+		// Vanilla code replaced to fix storms not relaying state to clients and a couple of other little oddities like the state
+		// changes for weather not being communicated immeditately
+
+		super.updateWeather();
+
+		if ( worldInfo.m_bPreviouslyRaining != worldInfo.isRaining() )
+		{
+			if ( worldInfo.isRaining() )
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 1, 0 ) );
+			}
+			else
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 2, 0 ) );
+			}
+
+			worldInfo.m_bPreviouslyRaining = worldInfo.isRaining();
+		}
+
+		if ( worldInfo.m_bPreviouslyThundering != worldInfo.isThundering() )
+		{
+			if ( worldInfo.isThundering() )
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 7, 0 ) );
+			}
+			else
+			{
+				mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 8, 0 ) );
+			}
+
+			worldInfo.m_bPreviouslyThundering = worldInfo.isThundering();
+		}
+	}
+
+	private void ModUpdateTick()
+	{
+		ValidateMagneticPointList();
+
+		ValidateLootingBeaconList();
+
+		ValidateSpawnLocationList();
+	}
+
+	private void ValidateMagneticPointList()
+	{
+		// periodically check the magnetic point list for dead points
+
+		int iTimeFactor = (int)getWorldTime();
+
+		if ( ( iTimeFactor & 15 ) == 0 )
+		{
+			int iListLength = m_MagneticPointList.m_MagneticPoints.size();
+
+			if ( iListLength > 0 )
+			{
+				iTimeFactor = iTimeFactor >> 4;
+
+		int iTempIndex = (int)( iTimeFactor % iListLength );
+
+		FCMagneticPoint tempPoint = (FCMagneticPoint)m_MagneticPointList.m_MagneticPoints.get( iTempIndex );
+
+		if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
+		{
+			// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
+
+			if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
+			{
+				m_MagneticPointList.m_MagneticPoints.remove( iTempIndex );
+
+			}
+		}    			
+			}
+		}
+	}
+
+	private void ValidateLootingBeaconList()
+	{
+		// periodically check the looting beacon list for dead points
+
+		int iTimeFactor = (int)getWorldTime();
+
+		if ( ( iTimeFactor & 15 ) == 0 )
+		{
+			int iListLength = m_LootingBeaconLocationList.m_EffectLocations.size();
+
+			if ( iListLength > 0 )
+			{
+				iTimeFactor = iTimeFactor >> 4;
+
+			int iTempIndex = (int)( iTimeFactor % iListLength );
+
+			FCBeaconEffectLocation tempPoint = (FCBeaconEffectLocation)m_LootingBeaconLocationList.m_EffectLocations.get( iTempIndex );
+
+			if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
+			{
+				// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
+
+				if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
+				{
+					m_LootingBeaconLocationList.m_EffectLocations.remove( iTempIndex );
+
+				}
+			}    			
+			}
+		}
+	}
+
+	private void ValidateSpawnLocationList()
+	{
+		// periodically check the list for dead points
+
+		long lWorldTime = getWorldTime();
+
+		if ( ( lWorldTime & 15 ) == 0 )
+		{
+			Iterator tempIterator = m_SpawnLocationList.m_SpawnLocations.iterator();
+
+			while ( tempIterator.hasNext() )
+			{
+				FCSpawnLocation tempPoint = (FCSpawnLocation)tempIterator.next();
+
+				if ( lWorldTime < tempPoint.m_lSpawnTime || lWorldTime - tempPoint.m_lSpawnTime > FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
+				{        			
+					tempIterator.remove();
+				}        		
+			}
+		}
+	}
+
+	protected void AdjustLightningPosForSurroundings( FCUtilsBlockPos strikePos )
+	{
+		int iHighJ = strikePos.j;
+
+		// store bounds variables since strikePos changes during search
+
+		int iMinI = strikePos.i - 16;
+		int iMinK = strikePos.k - 16;
 
-    public Teleporter getDefaultTeleporter()
-    {
-        return this.field_85177_Q;
-    }
+		int iMaxI = strikePos.i + 16;
+		int iMaxK = strikePos.k + 16;
+
+		for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
+		{
+			for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
+			{
+				int iTempJ = getPrecipitationHeight( iTempI, iTempK );
+
+				if ( iTempJ > iHighJ )
+				{
+					if ( CanLightningStrikeAtPos( iTempI, iTempJ, iTempK ) )
+					{
+						strikePos.i = iTempI;
+						iHighJ = strikePos.j = iTempJ;
+						strikePos.k = iTempK;
+					}
+				}
+			}
+		}    	
+
+		// check entities
+
+		List<Entity> entityList = getEntitiesWithinAABB( Entity.class, AxisAlignedBB.getAABBPool().getAABB( 
+				iMinI, iHighJ, iMinK, iMaxI + 1D, 256D, iMaxK + 1D ) );
+
+		Iterator<Entity> entityIterator = entityList.iterator();
+
+		while ( entityIterator.hasNext() )
+		{
+			Entity tempEntity = entityIterator.next();
+
+			if ( tempEntity.isEntityAlive() && tempEntity.AttractsLightning() )
+			{
+				int iEntityMaxJ = (int)tempEntity.boundingBox.maxY + 1;
+
+				if ( iEntityMaxJ > iHighJ )
+				{            	
+					int iEntityI = MathHelper.floor_double( tempEntity.posX );
+					int iEntityK = MathHelper.floor_double( tempEntity.posZ );
+
+					int iPrecipitationJ = getPrecipitationHeight( iEntityI, iEntityK );
+
+					if ( iPrecipitationJ <= iEntityMaxJ &&
+							CanLightningStrikeAtPos( iEntityI, iPrecipitationJ, iEntityK ) )
+					{
+						strikePos.i = iEntityI;
+						iHighJ = strikePos.j = iPrecipitationJ;
+						strikePos.k = iEntityK;
+					}	                
+				}                
+			}
+		}
+
+		// secondary search for lightning rods in a larger area around new strike pos
+
+		if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
+		{
+			iMinI = strikePos.i - 16;
+			iMinK = strikePos.k - 16;
+
+			iMaxI = strikePos.i + 16;
+			iMaxK = strikePos.k + 16;
+
+			for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
+			{
+				for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
+				{
+					int iTempJ = getPrecipitationHeight( iTempI, iTempK );
+
+					if ( iTempJ > iHighJ && getBlockId( iTempI, iTempJ - 1, iTempK ) == 
+							FCBetterThanWolves.fcBlockLightningRod.blockID )
+					{
+						// intentionally don't test CanLightningStrikeAtPos() so that
+						// rods in non-lightning biomes can still attract lightning to them
+
+						strikePos.i = iTempI;
+						iHighJ = strikePos.j = iTempJ;
+						strikePos.k = iTempK;
+					}
+				}
+			}        	
+		}
+	}
+
+	@Override
+	public int GetClampedViewDistanceInChunks()
+	{
+		int iRange = getMinecraftServer().getConfigurationManager().getViewDistance();
+
+		return MathHelper.clamp_int( iRange, 3, 15 );
+	}
+
+	@Override
+	protected void UpdateActiveChunkMap()
+	{
+		super.UpdateActiveChunkMap();
+
+		UpdateServerIdleState();    	
+
+		// FCCHUNK: Decide on updates around original spawn
+
+		if ( provider.dimensionId == 0 && !IsServerIdle() )
+		{
+			ChunkCoordinates originalSpawn = getSpawnPoint();
+
+			AddAreaAroundChunkToActiveChunkMap( originalSpawn.posX >> 4, 
+					originalSpawn.posZ >> 4 );
+		}
+	}
+
+	public FCChunkTracker GetChunkTracker()
+	{
+		return m_chunkTracker;
+	}    
+
+	protected void UpdateServerIdleState()
+	{
+		if ( !AreAnyPlayersOnServer() )
+		{
+			m_lNoPlayersOnServerTickCount++;
+		}
+		else
+		{
+			m_lNoPlayersOnServerTickCount = 0;
+		}
+	}
+
+	protected boolean IsServerIdle()
+	{
+		return m_lNoPlayersOnServerTickCount >= 1200L;
+	}
+
+	protected boolean AreAnyPlayersOnServer()
+	{
+		return mcServer.getCurrentPlayerCount() > 0;
+	}
+
+	//------------ Addon Data Handling -----------//
+
+	private Map<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> addonWorldDataMap = new HashMap();
+
+	public void saveWorldDataToNBT(File dimensionDirectory) {
+		for (Map.Entry<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> entry : addonWorldDataMap.entrySet()) {
+			NBTTagCompound modData = new NBTTagCompound();
+	        
+			entry.getValue().saveWorldDataToNBT(this, modData);
+	        
+	        NBTTagCompound fileData = new NBTTagCompound();
+	        
+	        fileData.setTag( "Data", modData );
+
+	        try {
+	            File modSaveFile = new File(dimensionDirectory, entry.getValue().getFilename() + ".dat");
+	            
+	            if (modSaveFile.exists()) {
+	            	modSaveFile.delete();
+	            }
+	            
+	            CompressedStreamTools.writeCompressed( fileData, new FileOutputStream(modSaveFile) );
+
+	        }
+	        catch (Exception e) {
+	            e.printStackTrace();
+	        }
+		}
+	}
+
+	public void loadWorldDataFromNBT(File dimensionDirectory) {
+		addonWorldDataMap = FCAddOnHandler.initWorldDataForAddon();
+		
+		for (Map.Entry<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> entry : addonWorldDataMap.entrySet()) {
+			File modSaveFile = null;
+			
+			try {
+				modSaveFile = new File(dimensionDirectory, entry.getValue().getFilename() + ".dat");
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+
+			if (modSaveFile != null && modSaveFile.exists()) {
+				try {
+					NBTTagCompound fileTag = CompressedStreamTools.readCompressed( new FileInputStream(modSaveFile));
+					NBTTagCompound dataTag = fileTag.getCompoundTag("Data");
+
+					entry.getValue().loadWorldDataFromNBT(this, dataTag);
+				}
+				catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	public FCAddOnUtilsWorldData getWorldDataForMod(Class<? extends FCAddOn> mod) {
+		if (addonWorldDataMap.containsKey(mod))
+			return addonWorldDataMap.get(mod);
+		else
+			return null;
+	}
+
+	public void setWorldDataForMod(Class<? extends FCAddOn> mod, FCAddOnUtilsWorldData data) {
+		addonWorldDataMap.put(mod, data);
+	}
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/AxisAlignedBB.java b/minecraft_server/net/minecraft/src/AxisAlignedBB.java
index f3d92e4..ce4ec67 100644
--- a/minecraft_server/net/minecraft/src/AxisAlignedBB.java
+++ b/minecraft_server/net/minecraft/src/AxisAlignedBB.java
@@ -1,6 +1,11 @@
 package net.minecraft.src;
 
-public class AxisAlignedBB
+import java.util.List;
+
+// FCMOD: Changed
+//public class AxisAlignedBB
+public class AxisAlignedBB extends FCUtilsPrimitiveGeometric
+// END FCMOD
 {
     /** ThreadLocal AABBPool */
     private static final ThreadLocal theAABBLocalPool = new AABBLocalPool();
@@ -475,4 +480,111 @@ public class AxisAlignedBB
     {
         return "box[" + this.minX + ", " + this.minY + ", " + this.minZ + " -> " + this.maxX + ", " + this.maxY + ", " + this.maxZ + "]";
     }
+    
+    // FCMOD: Added New
+	/**
+	 * Yaws the box around the J axis. Assumes that the box's initial facing is along the negative K axis (facing 2)
+	 */
+    @Override
+	public void RotateAroundJToFacing( int iFacing )
+    {
+		if ( iFacing > 2 )
+		{
+	    	if ( iFacing == 5 ) // i + 1
+	    	{
+	        	setBounds( 1.0D - maxZ, minY, 1.0D - maxX, 1.0D - minZ, maxY, 1.0D - minX );
+	    	}
+	    	else if ( iFacing == 4 ) // i - 1
+	    	{
+	        	setBounds( minZ, minY, minX, maxZ, maxY, maxX );
+	    	}
+	    	else // if ( iFacing == 3 ) // k + 1
+	    	{
+	        	setBounds( 1.0D - maxX, minY, 1.0D - maxZ, 1.0D - minX, maxY, 1.0D - minZ );
+	    	}
+		}    	
+    }
+	
+	/**
+	 * "Tilts" the box towards the desired facing.  Takes the up vector and either yaws or rolls it towards the specified axis.
+	 */	
+    @Override
+	public void TiltToFacingAlongJ( int iFacing )
+    {
+    	double newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ;
+    	
+		if ( iFacing == 0 ) // j - 1
+		{
+			// rotating around k axis here to point downwards
+			
+	    	setBounds( 1D - maxX, 1D - maxY, minZ, 1D - minX, 1D - minY, maxZ );
+		}
+		else if ( iFacing == 2 ) // k - 1
+		{
+			setBounds( minX, minZ, 1D - maxY, maxX, maxZ, 1D - minY );
+		}			
+		else if ( iFacing == 3 ) // k + 1
+		{
+			setBounds( minX, 1D - maxZ, minY, maxX, 1D - minZ, maxY );
+		}
+		else if ( iFacing == 4 ) // i - 1
+		{
+			setBounds( 1D - maxY, minX, minZ, 1D - minY, maxX, maxZ );
+		}			
+		else if ( iFacing == 5 ) // i + 1
+		{
+			setBounds( minY, 1D - maxX, minZ, maxY, 1D - minX, maxZ );
+		}			
+    }
+
+    @Override
+	public void Translate( double dDeltaX, double dDeltaY, double dDeltaZ )
+    {
+    	offset( dDeltaX, dDeltaY, dDeltaZ );
+    }
+    
+    @Override
+	public void AddToRayTrace( FCUtilsRayTraceVsComplexBlock rayTrace )
+    {
+    	rayTrace.AddBoxWithLocalCoordsToIntersectionList( minX, minY, minZ, maxX, maxY, maxZ );
+    }
+	
+    @Override
+	public AxisAlignedBB MakeTemporaryCopy()
+	{
+		return getAABBPool().getAABB( minX, minY, minZ, maxX, maxY, maxZ );
+	}
+	
+    @Override
+    public void AddIntersectingBoxesToCollisionList( World world, int i, int j, int k, AxisAlignedBB boxToIntersect, List collisionList )
+    {
+    	AxisAlignedBB offsetBox = MakeTemporaryCopy().offset( i, j, k );
+    	
+    	offsetBox.AddToListIfIntersects( boxToIntersect, collisionList );
+    }
+	
+    //------------- Class Specific Methods ------------//	
+    
+    public void ExpandToInclude( AxisAlignedBB box )
+    {
+    	minX = Math.min( minX, box.minX );
+    	maxX = Math.max( maxX, box.maxX );
+    	
+    	minY = Math.min( minY, box.minY );
+    	maxY = Math.max( maxY, box.maxY );
+    	
+    	minZ = Math.min( minZ, box.minZ );
+    	maxZ = Math.max( maxZ, box.maxZ );
+    }
+    
+    public void AddToListIfIntersects( AxisAlignedBB intersectingBox, List list )
+    {
+    	if ( intersectsWith( intersectingBox ) )
+    	{
+    		list.add( this );
+    	}
+    }
+	
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BehaviorDispenseArmor.java b/minecraft_server/net/minecraft/src/BehaviorDispenseArmor.java
index 3e9d104..205bf16 100644
--- a/minecraft_server/net/minecraft/src/BehaviorDispenseArmor.java
+++ b/minecraft_server/net/minecraft/src/BehaviorDispenseArmor.java
@@ -7,6 +7,8 @@ final class BehaviorDispenseArmor extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -33,4 +35,6 @@ final class BehaviorDispenseArmor extends BehaviorDefaultDispenseItem
             return super.dispenseStack(par1IBlockSource, par2ItemStack);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BehaviorDispenseMinecart.java b/minecraft_server/net/minecraft/src/BehaviorDispenseMinecart.java
index 0698a00..235c70d 100644
--- a/minecraft_server/net/minecraft/src/BehaviorDispenseMinecart.java
+++ b/minecraft_server/net/minecraft/src/BehaviorDispenseMinecart.java
@@ -7,6 +7,8 @@ final class BehaviorDispenseMinecart extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -39,12 +41,18 @@ final class BehaviorDispenseMinecart extends BehaviorDefaultDispenseItem
         par2ItemStack.splitStack(1);
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+	// FCMOD: Code removed
+    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         par1IBlockSource.getWorld().playAuxSFX(1000, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BiomeGenBase.java b/minecraft_server/net/minecraft/src/BiomeGenBase.java
index ba9d41c..e971d6a 100644
--- a/minecraft_server/net/minecraft/src/BiomeGenBase.java
+++ b/minecraft_server/net/minecraft/src/BiomeGenBase.java
@@ -10,41 +10,57 @@ public abstract class BiomeGenBase
     public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];
     public static final BiomeGenBase ocean = (new BiomeGenOcean(0)).setColor(112).setBiomeName("Ocean").setMinMaxHeight(-1.0F, 0.4F);
     public static final BiomeGenBase plains = (new BiomeGenPlains(1)).setColor(9286496).setBiomeName("Plains").setTemperatureRainfall(0.8F, 0.4F);
-    public static final BiomeGenBase desert = (new BiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
-    public static final BiomeGenBase extremeHills = (new BiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
-    public static final BiomeGenBase forest = (new BiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
-    public static final BiomeGenBase taiga = (new BiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase desert = (new BiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
+    //public static final BiomeGenBase extremeHills = (new BiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
+    //public static final BiomeGenBase forest = (new BiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
+    //public static final BiomeGenBase taiga = (new BiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
+    public static final BiomeGenBase desert = (new FCBiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
+    public static final BiomeGenBase extremeHills = (new FCBiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
+    public static final BiomeGenBase forest = (new FCBiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
+    public static final BiomeGenBase taiga = (new FCBiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
+    // END FCMOD
     public static final BiomeGenBase swampland = (new BiomeGenSwamp(6)).setColor(522674).setBiomeName("Swampland").func_76733_a(9154376).setMinMaxHeight(-0.2F, 0.1F).setTemperatureRainfall(0.8F, 0.9F);
     public static final BiomeGenBase river = (new BiomeGenRiver(7)).setColor(255).setBiomeName("River").setMinMaxHeight(-0.5F, 0.0F);
-    public static final BiomeGenBase hell = (new BiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase hell = (new BiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
+    public static final BiomeGenBase hell = (new FCBiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
+    // END FCMOD
 
     /** Is the biome used for sky world. */
-    public static final BiomeGenBase sky = (new BiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
+    // FCMOD: Changed
+    //public static final BiomeGenBase sky = (new BiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
+    public static final BiomeGenBase sky = (new FCBiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
+    // END FCMOD
     public static final BiomeGenBase frozenOcean = (new BiomeGenOcean(10)).setColor(9474208).setBiomeName("FrozenOcean").setEnableSnow().setMinMaxHeight(-1.0F, 0.5F).setTemperatureRainfall(0.0F, 0.5F);
     public static final BiomeGenBase frozenRiver = (new BiomeGenRiver(11)).setColor(10526975).setBiomeName("FrozenRiver").setEnableSnow().setMinMaxHeight(-0.5F, 0.0F).setTemperatureRainfall(0.0F, 0.5F);
-    public static final BiomeGenBase icePlains = (new BiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
-    public static final BiomeGenBase iceMountains = (new BiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase icePlains = (new BiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
+    //public static final BiomeGenBase iceMountains = (new BiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
+    public static final BiomeGenBase icePlains = (new FCBiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
+    public static final BiomeGenBase iceMountains = (new FCBiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
+    // END FCMOD
     public static final BiomeGenBase mushroomIsland = (new BiomeGenMushroomIsland(14)).setColor(16711935).setBiomeName("MushroomIsland").setTemperatureRainfall(0.9F, 1.0F).setMinMaxHeight(0.2F, 1.0F);
     public static final BiomeGenBase mushroomIslandShore = (new BiomeGenMushroomIsland(15)).setColor(10486015).setBiomeName("MushroomIslandShore").setTemperatureRainfall(0.9F, 1.0F).setMinMaxHeight(-1.0F, 0.1F);
 
     /** Beach biome. */
     public static final BiomeGenBase beach = (new BiomeGenBeach(16)).setColor(16440917).setBiomeName("Beach").setTemperatureRainfall(0.8F, 0.4F).setMinMaxHeight(0.0F, 0.1F);
 
-    /** Desert Hills biome. */
-    public static final BiomeGenBase desertHills = (new BiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
-
-    /** Forest Hills biome. */
-    public static final BiomeGenBase forestHills = (new BiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
-
-    /** Taiga Hills biome. */
-    public static final BiomeGenBase taigaHills = (new BiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
-
-    /** Extreme Hills Edge biome. */
-    public static final BiomeGenBase extremeHillsEdge = (new BiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
-
-    /** Jungle biome identifier */
-    public static final BiomeGenBase jungle = (new BiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
-    public static final BiomeGenBase jungleHills = (new BiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
+    // FCMOD: Changed
+    //public static final BiomeGenBase desertHills = (new BiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
+    //public static final BiomeGenBase forestHills = (new BiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
+    //public static final BiomeGenBase taigaHills = (new BiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
+    //public static final BiomeGenBase extremeHillsEdge = (new BiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
+    //public static final BiomeGenBase jungle = (new BiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
+    //public static final BiomeGenBase jungleHills = (new BiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
+    public static final BiomeGenBase desertHills = (new FCBiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
+    public static final BiomeGenBase forestHills = (new FCBiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
+    public static final BiomeGenBase taigaHills = (new FCBiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
+    public static final BiomeGenBase extremeHillsEdge = (new FCBiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
+    public static final BiomeGenBase jungle = (new FCBiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
+    public static final BiomeGenBase jungleHills = (new FCBiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
+    // END FCMOD
+    
     public String biomeName;
     public int color;
 
@@ -134,18 +150,35 @@ public abstract class BiomeGenBase
         this.biomeID = par1;
         biomeList[par1] = this;
         this.theBiomeDecorator = this.createBiomeDecorator();
-        this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
-        this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
-        this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
-        this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
-        this.spawnableCaveCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
+        // FCMOD: Changed 
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
+        //this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
+        //this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
+        //this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
+        //this.spawnableCaveCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
+        spawnableCreatureList.add( new SpawnListEntry( FCEntitySheep.class, 12, 4, 4 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityPig.class, 10, 4, 4 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityChicken.class, 10, 4, 4 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityCow.class, 8, 4, 4 ) );
+        
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySpider.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityZombie.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySkeleton.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityCreeper.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySlime.class, 10, 4, 4 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityEnderman.class, 1, 1, 4 ) );
+        
+        spawnableWaterCreatureList.add( new SpawnListEntry( FCEntitySquid.class, 10, 4, 4 ) );
+        
+        spawnableCaveCreatureList.add( new SpawnListEntry( FCEntityBat.class, 10, 8, 8 ) );
+        // END FCMOD
     }
 
     /**
@@ -254,10 +287,15 @@ public abstract class BiomeGenBase
     /**
      * Return true if the biome supports lightning bolt spawn, either by have the bolts enabled and have rain enabled.
      */
+    // FCMOD: Removed and replaced due to ambiguous naming and use.  It was used in vanilla
+    // both for determining whether lightning could strike in a biome, and whether it could rain there.
+    /*
     public boolean canSpawnLightningBolt()
     {
         return this.enableSnow ? false : this.enableRain;
     }
+    */
+    // END FCMOD
 
     /**
      * Checks to see if the rainfall level of the biome is extremely high
@@ -303,4 +341,16 @@ public abstract class BiomeGenBase
     {
         this.theBiomeDecorator.decorate(par1World, par2Random, par3, par4);
     }
+    
+    // FCMOD: Added
+    public boolean CanRainInBiome()
+    {
+        return enableSnow ? false : enableRain;
+    }
+    
+    public boolean CanLightningStrikeInBiome()
+    {
+    	return CanRainInBiome();
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BiomeGenHell.java b/minecraft_server/net/minecraft/src/BiomeGenHell.java
index 3970cf1..832411e 100644
--- a/minecraft_server/net/minecraft/src/BiomeGenHell.java
+++ b/minecraft_server/net/minecraft/src/BiomeGenHell.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/28/2018
+
 package net.minecraft.src;
 
 public class BiomeGenHell extends BiomeGenBase
diff --git a/minecraft_server/net/minecraft/src/BiomeGenMushroomIsland.java b/minecraft_server/net/minecraft/src/BiomeGenMushroomIsland.java
index a62759e..313f3c5 100644
--- a/minecraft_server/net/minecraft/src/BiomeGenMushroomIsland.java
+++ b/minecraft_server/net/minecraft/src/BiomeGenMushroomIsland.java
@@ -11,7 +11,11 @@ public class BiomeGenMushroomIsland extends BiomeGenBase
         this.theBiomeDecorator.mushroomsPerChunk = 1;
         this.theBiomeDecorator.bigMushroomsPerChunk = 1;
         this.topBlock = (byte)Block.mycelium.blockID;
+        // FCMOD: Code removed so mobs can spawn in mushroom biomes
+        /*
         this.spawnableMonsterList.clear();
+        */
+        // END FCMOD
         this.spawnableCreatureList.clear();
         this.spawnableWaterCreatureList.clear();
         this.spawnableCreatureList.add(new SpawnListEntry(EntityMooshroom.class, 8, 4, 8));
diff --git a/minecraft_server/net/minecraft/src/BiomeGenSwamp.java b/minecraft_server/net/minecraft/src/BiomeGenSwamp.java
index 65a26bf..4cfd049 100644
--- a/minecraft_server/net/minecraft/src/BiomeGenSwamp.java
+++ b/minecraft_server/net/minecraft/src/BiomeGenSwamp.java
@@ -15,7 +15,21 @@ public class BiomeGenSwamp extends BiomeGenBase
         this.theBiomeDecorator.clayPerChunk = 1;
         this.theBiomeDecorator.waterlilyPerChunk = 4;
         this.waterColorMultiplier = 14745518;
+        
+        // FCMOD: Changed
+        /*
         this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 1, 1, 1));
+        */
+        spawnableMonsterList.add( new SpawnListEntry( FCEntitySlime.class, 1, 1, 1 ) );
+        spawnableMonsterList.add( new SpawnListEntry( FCEntityWitch.class, 1, 1, 1 ) );
+        
+        // get rid of cows and sheep and cause other animals to spawn in lower numbers
+        
+        spawnableCreatureList.clear();
+        
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityChicken.class, 10, 2, 2 ) );
+        spawnableCreatureList.add( new SpawnListEntry( FCEntityPig.class, 10, 2, 2 ) );
+        // END FCMOD
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/Block.java b/minecraft_server/net/minecraft/src/Block.java
index b3a44ec..7274eb0 100644
--- a/minecraft_server/net/minecraft/src/Block.java
+++ b/minecraft_server/net/minecraft/src/Block.java
@@ -3,6 +3,10 @@ package net.minecraft.src;
 import java.util.List;
 import java.util.Random;
 
+//FCMOD: Added
+//import net.minecraft.client.Minecraft; //client only
+// END FCMOD
+
 public class Block
 {
     /**
@@ -33,7 +37,9 @@ public class Block
     /** How much light is subtracted for going through this block */
     public static final int[] lightOpacity = new int[4096];
 
-    /** Array of booleans that tells if a block can grass */
+    /** Array of booleans that tells if a block can grass
+     * FCNOTE: Misleading name.  This is actually wether grass can grow under the block
+     */
     public static final boolean[] canBlockGrass = new boolean[4096];
 
     /** Amount of light emitted */
@@ -41,178 +47,173 @@ public class Block
 
     /**
      * Flag if block ID should use the brightest neighbor light value as its own
-     */
+     * FCNOTE: Misleading name in that this does not apply to the neighbor below the block,
+     * only to sides and top
+     */ 
     public static boolean[] useNeighborBrightness = new boolean[4096];
-    public static final Block stone = (new BlockStone(1)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stone");
-    public static final BlockGrass grass = (BlockGrass)(new BlockGrass(2)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("grass");
-    public static final Block dirt = (new BlockDirt(3)).setHardness(0.5F).setStepSound(soundGravelFootstep).setUnlocalizedName("dirt");
-    public static final Block cobblestone = (new Block(4, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block planks = (new BlockWood(5)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("wood");
-    public static final Block sapling = (new BlockSapling(6)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
-    public static final Block bedrock = (new Block(7, Material.rock)).setBlockUnbreakable().setResistance(6000000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("bedrock").disableStats().setCreativeTab(CreativeTabs.tabBlock);
-    public static final BlockFluid waterMoving = (BlockFluid)(new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final Block waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final BlockFluid lavaMoving = (BlockFluid)(new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-
-    /** Stationary lava source block */
-    public static final Block lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-    public static final Block sand = (new BlockSand(12)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("sand");
-    public static final Block gravel = (new BlockGravel(13)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("gravel");
-    public static final Block oreGold = (new BlockOre(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
-    public static final Block oreIron = (new BlockOre(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
-    public static final Block oreCoal = (new BlockOre(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
-    public static final Block wood = (new BlockLog(17)).setHardness(2.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("log");
-    public static final BlockLeaves leaves = (BlockLeaves)(new BlockLeaves(18)).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep).setUnlocalizedName("leaves");
-    public static final Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
-    public static final Block glass = (new BlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
-    public static final Block oreLapis = (new BlockOre(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
-    public static final Block blockLapis = (new Block(22, Material.rock)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dispenser = (new BlockDispenser(23)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dispenser");
-    public static final Block sandStone = (new BlockSandStone(24)).setStepSound(soundStoneFootstep).setHardness(0.8F).setUnlocalizedName("sandStone");
-    public static final Block music = (new BlockNote(25)).setHardness(0.8F).setUnlocalizedName("musicBlock");
-    public static final Block bed = (new BlockBed(26)).setHardness(0.2F).setUnlocalizedName("bed").disableStats();
-    public static final Block railPowered = (new BlockRailPowered(27)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
-    public static final Block railDetector = (new BlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
-    public static final BlockPistonBase pistonStickyBase = (BlockPistonBase)(new BlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
-    public static final Block web = (new BlockWeb(30)).setLightOpacity(1).setHardness(4.0F).setUnlocalizedName("web");
-    public static final BlockTallGrass tallGrass = (BlockTallGrass)(new BlockTallGrass(31)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tallgrass");
-    public static final BlockDeadBush deadBush = (BlockDeadBush)(new BlockDeadBush(32)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("deadbush");
-    public static final BlockPistonBase pistonBase = (BlockPistonBase)(new BlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
-    public static final BlockPistonExtension pistonExtension = new BlockPistonExtension(34);
-    public static final Block cloth = (new BlockCloth()).setHardness(0.8F).setStepSound(soundClothFootstep).setUnlocalizedName("cloth");
-    public static final BlockPistonMoving pistonMoving = new BlockPistonMoving(36);
-    public static final BlockFlower plantYellow = (BlockFlower)(new BlockFlower(37)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("flower");
-    public static final BlockFlower plantRed = (BlockFlower)(new BlockFlower(38)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("rose");
-    public static final BlockFlower mushroomBrown = (BlockFlower)(new BlockMushroom(39, "mushroom_brown")).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(0.125F).setUnlocalizedName("mushroom");
-    public static final BlockFlower mushroomRed = (BlockFlower)(new BlockMushroom(40, "mushroom_red")).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
-    public static final Block blockGold = (new BlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
-    public static final Block blockIron = (new BlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
-
-    /** stoneDoubleSlab */
-    public static final BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-
-    /** stoneSingleSlab */
-    public static final BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-    public static final Block brick = (new Block(45, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block tnt = (new BlockTNT(46)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tnt");
-    public static final Block bookShelf = (new BlockBookshelf(47)).setHardness(1.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("bookshelf");
-    public static final Block cobblestoneMossy = (new Block(48, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneMoss").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block obsidian = (new BlockObsidian(49)).setHardness(50.0F).setResistance(2000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("obsidian");
-    public static final Block torchWood = (new BlockTorch(50)).setHardness(0.0F).setLightValue(0.9375F).setStepSound(soundWoodFootstep).setUnlocalizedName("torch");
-    public static final BlockFire fire = (BlockFire)(new BlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
-    public static final Block mobSpawner = (new BlockMobSpawner(52)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("mobSpawner").disableStats();
-    public static final Block stairsWoodOak = (new BlockStairs(53, planks, 0)).setUnlocalizedName("stairsWood");
-    public static final BlockChest chest = (BlockChest)(new BlockChest(54, 0)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("chest");
-    public static final BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new BlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
-    public static final Block oreDiamond = (new BlockOre(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
-    public static final Block blockDiamond = (new BlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
-    public static final Block workbench = (new BlockWorkbench(58)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("workbench");
-    public static final Block crops = (new BlockCrops(59)).setUnlocalizedName("crops");
-    public static final Block tilledField = (new BlockFarmland(60)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("farmland");
-    public static final Block furnaceIdle = (new BlockFurnace(61, false)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("furnace").setCreativeTab(CreativeTabs.tabDecorations);
-    public static final Block furnaceBurning = (new BlockFurnace(62, true)).setHardness(3.5F).setStepSound(soundStoneFootstep).setLightValue(0.875F).setUnlocalizedName("furnace");
-    public static final Block signPost = (new BlockSign(63, TileEntitySign.class, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("sign").disableStats();
-    public static final Block doorWood = (new BlockDoor(64, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("doorWood").disableStats();
-    public static final Block ladder = (new BlockLadder(65)).setHardness(0.4F).setStepSound(soundLadderFootstep).setUnlocalizedName("ladder");
-    public static final Block rail = (new BlockRail(66)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("rail");
-    public static final Block stairsCobblestone = (new BlockStairs(67, cobblestone, 0)).setUnlocalizedName("stairsStone");
-    public static final Block signWall = (new BlockSign(68, TileEntitySign.class, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("sign").disableStats();
-    public static final Block lever = (new BlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
-    public static final Block pressurePlateStone = (new BlockPressurePlate(70, "stone", Material.rock, EnumMobType.mobs)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("pressurePlate");
-    public static final Block doorIron = (new BlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
-    public static final Block pressurePlatePlanks = (new BlockPressurePlate(72, "wood", Material.wood, EnumMobType.everything)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("pressurePlate");
-    public static final Block oreRedstone = (new BlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block oreRedstoneGlowing = (new BlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone");
-    public static final Block torchRedstoneIdle = (new BlockRedstoneTorch(75, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("notGate");
-    public static final Block torchRedstoneActive = (new BlockRedstoneTorch(76, true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block stoneButton = (new BlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
-    public static final Block snow = (new BlockSnow(78)).setHardness(0.1F).setStepSound(soundSnowFootstep).setUnlocalizedName("snow").setLightOpacity(0);
-    public static final Block ice = (new BlockIce(79)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
-    public static final Block blockSnow = (new BlockSnowBlock(80)).setHardness(0.2F).setStepSound(soundSnowFootstep).setUnlocalizedName("snow");
-    public static final Block cactus = (new BlockCactus(81)).setHardness(0.4F).setStepSound(soundClothFootstep).setUnlocalizedName("cactus");
-    public static final Block blockClay = (new BlockClay(82)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("clay");
-    public static final Block reed = (new BlockReed(83)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
-    public static final Block jukebox = (new BlockJukeBox(84)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("jukebox");
-    public static final Block fence = (new BlockFence(85, "wood", Material.wood)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fence");
-    public static final Block pumpkin = (new BlockPumpkin(86, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkin");
-    public static final Block netherrack = (new BlockNetherrack(87)).setHardness(0.4F).setStepSound(soundStoneFootstep).setUnlocalizedName("hellrock");
-    public static final Block slowSand = (new BlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
-    public static final Block glowStone = (new BlockGlowStone(89, Material.glass)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F).setUnlocalizedName("lightgem");
-
-    /** The purple teleport blocks inside the obsidian circle */
-    public static final BlockPortal portal = (BlockPortal)(new BlockPortal(90)).setHardness(-1.0F).setStepSound(soundGlassFootstep).setLightValue(0.75F).setUnlocalizedName("portal");
-    public static final Block pumpkinLantern = (new BlockPumpkin(91, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setLightValue(1.0F).setUnlocalizedName("litpumpkin");
-    public static final Block cake = (new BlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterIdle = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(93, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterActive = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(94, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
+    
+    public static Block stone = new FCBlockStone( 1 );
+    public static BlockGrass grass = new FCBlockGrass( 2 );
+    public static Block dirt = new FCBlockDirt( 3 );
+    public static Block cobblestone = (new FCBlockCobblestone(4)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block planks = new FCBlockPlanks( 5 );
+    public static Block sapling = (new FCBlockSapling(6)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
+    public static Block bedrock = new FCBlockBedrock( 7 );
+    public static BlockFluid waterMoving = (BlockFluid)(new FCBlockWaterFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
+    public static Block waterStill = (new FCBlockWaterStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
+    public static BlockFluid lavaMoving = (BlockFluid)(new FCBlockLavaFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
+    public static Block lavaStill = (new FCBlockLavaStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
+    public static Block sand = new FCBlockSand( 12 );
+    public static Block gravel = new FCBlockGravel( 13 );
+    public static Block oreGold = (new FCBlockOreGold(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
+    public static Block oreIron = (new FCBlockOreIron(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
+    public static Block oreCoal = (new FCBlockOreCoal(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
+    public static Block wood = new FCBlockLog( 17 );
+    public static BlockLeaves leaves = new FCBlockLeaves( 18 );
+    public static Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
+    public static Block glass = (new FCBlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
+    public static Block oreLapis = (new FCBlockOreLapis(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
+    public static Block blockLapis = (new Block(22, Material.rock)).SetPicksEffectiveOn().setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block dispenser = new FCBlockDispenserVanilla( 23 );
+    public static Block sandStone = new FCBlockSandStone( 24 );
+    public static Block music = new FCBlockNote( 25 );
+    public static Block bed = (new FCBlockBed(26)).setHardness(0.2F).SetBuoyant().setUnlocalizedName("bed").disableStats();
+    public static Block railPowered = (new BlockRailPowered(27)).SetPicksEffectiveOn().setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
+    public static Block railDetector = (new FCBlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
+    public static BlockPistonBase pistonStickyBase = (BlockPistonBase)(new FCBlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
+    public static Block web = new FCBlockWeb( 30 );
+    public static BlockTallGrass tallGrass = new FCBlockTallGrass( 31 );
+    public static BlockDeadBush deadBush = new FCBlockDeadBush( 32 );
+    public static BlockPistonBase pistonBase = (BlockPistonBase)(new FCBlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
+    public static BlockPistonExtension pistonExtension = new FCBlockPistonExtension(34);
+    public static Block cloth = new FCBlockCloth(); // sets own blockID of 35
+    public static BlockPistonMoving pistonMoving = new FCBlockPistonMoving( 36 );
+    public static BlockFlower plantYellow = (BlockFlower)(new FCBlockFlowerBlossom( 37 )).setUnlocalizedName("flower");
+    public static BlockFlower plantRed = (BlockFlower)(new FCBlockFlowerBlossom( 38 )).setUnlocalizedName("rose");
+    public static BlockFlower mushroomBrown = (BlockFlower)(new FCBlockMushroomBrown(39, "mushroom_brown")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
+    public static BlockFlower mushroomRed = (BlockFlower)(new FCBlockMushroom(40, "mushroom_red")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
+    public static Block blockGold = (new FCBlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
+    public static Block blockIron = (new FCBlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
+    public static BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new FCBlockStep(43, true)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+    public static BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new FCBlockStep(44, false)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+    public static Block brick = (new FCBlockBrick(45)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block tnt = new FCBlockPowderKeg( 46 );
+    public static Block bookShelf = new FCBlockBookshelf( 47 );
+    public static Block cobblestoneMossy = new FCBlockCobblestoneMossy( 48 ); 
+    public static Block obsidian = new FCBlockObsidian( 49 );
+    public static Block torchWood = new FCBlockTorchLegacy( 50 );
+    public static BlockFire fire = (BlockFire)(new FCBlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
+    public static Block mobSpawner = new FCBlockMobSpawner( 52 );
+    public static Block stairsWoodOak = (new FCBlockStairsWood( 53, planks, 0 ) ).setUnlocalizedName( "stairsWood" );
+    public static BlockChest chest = (BlockChest)( new FCBlockChest( 54 ) ).setCreativeTab( null );
+    public static BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new FCBlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
+    public static Block oreDiamond = (new FCBlockOreDiamond(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
+    public static Block blockDiamond = (new FCBlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
+    public static Block workbench = new FCBlockWorkbench( 58 );
+    public static Block crops = (new FCBlockWheatLegacy(59)).SetBuoyant().setUnlocalizedName("crops");
+    public static Block tilledField = new FCBlockFarmlandLegacyUnfertilized( 60 );
+    public static Block furnaceIdle = new FCBlockFurnace( 61, false );
+    public static Block furnaceBurning = new FCBlockFurnace( 62, true );
+    public static Block signPost = new FCBlockSign( 63, true );
+    public static Block doorWood = new FCBlockDoorWood( 64 );
+    public static Block ladder = new FCBlockLegacyLadder( 65 );
+    public static Block rail = new FCBlockRailRegular( 66 );
+    public static Block stairsCobblestone = new FCBlockStairsCobblestone( 67 );
+    public static Block signWall = new FCBlockSignWall( 68 );
+    public static Block lever = (new FCBlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
+    public static Block pressurePlateStone = new FCBlockPressurePlateStone( 70 );
+    public static Block doorIron = (new FCBlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
+    public static Block pressurePlatePlanks = new FCBlockPressurePlatePlanks( 72 );
+    public static Block oreRedstone = (new FCBlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block oreRedstoneGlowing = (new FCBlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(null);
+    public static Block torchRedstoneIdle = (new BlockRedstoneTorch( 75, false )).setUnlocalizedName("notGate");
+    public static Block torchRedstoneActive = (new BlockRedstoneTorch( 76, true )).setLightValue(0.5F).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
+    public static Block stoneButton = (new FCBlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
+    public static Block snow = new FCBlockSnowCover( 78 );
+    public static Block ice = (new FCBlockIce(79)).setHardness(0.5F).SetBuoyant().setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
+    public static Block blockSnow = new FCBlockSnowLegacy( 80 );
+    public static Block cactus = new FCBlockCactus( 81 );
+    public static Block blockClay = (new FCBlockClay(82)).setHardness(0.6F).setUnlocalizedName("clay");
+    public static Block reed = (new FCBlockReed(83)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
+    public static Block jukebox = new FCBlockJukebox( 84 );
+    public static Block fence = new FCBlockFenceWood( 85 );
+    public static Block pumpkin = new FCBlockPumpkinCarved( 86 );
+    public static Block netherrack = new FCBlockNetherrack( 87 );
+    public static Block slowSand = (new FCBlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
+    public static Block glowStone = new FCBlockGlowStone( 89 );
+    public static BlockPortal portal = new FCBlockPortal( 90 );
+    public static Block pumpkinLantern = new FCBlockJackOLantern( 91 );
+    public static Block cake = (new FCBlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
+    public static BlockRedstoneRepeater redstoneRepeaterIdle = new FCBlockRedstoneRepeater( 93, false );
+    public static BlockRedstoneRepeater redstoneRepeaterActive = new FCBlockRedstoneRepeater( 94, true );
 
     /**
      * April fools secret locked chest, only spawns on new chunks on 1st April.
      */
-    public static final Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
-    public static final Block trapdoor = (new BlockTrapDoor(96, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("trapdoor").disableStats();
-    public static final Block silverfish = (new BlockSilverfish(97)).setHardness(0.75F).setUnlocalizedName("monsterStoneEgg");
-    public static final Block stoneBrick = (new BlockStoneBrick(98)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebricksmooth");
-    public static final Block mushroomCapBrown = (new BlockMushroomCap(99, Material.wood, 0)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("mushroom");
-    public static final Block mushroomCapRed = (new BlockMushroomCap(100, Material.wood, 1)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("mushroom");
-    public static final Block fenceIron = (new BlockPane(101, "fenceIron", "fenceIron", Material.iron, true)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("fenceIron");
-    public static final Block thinGlass = (new BlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
-    public static final Block melon = (new BlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
-    public static final Block pumpkinStem = (new BlockStem(104, pumpkin)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkinStem");
-    public static final Block melonStem = (new BlockStem(105, melon)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("pumpkinStem");
-    public static final Block vine = (new BlockVine(106)).setHardness(0.2F).setStepSound(soundGrassFootstep).setUnlocalizedName("vine");
-    public static final Block fenceGate = (new BlockFenceGate(107)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fenceGate");
-    public static final Block stairsBrick = (new BlockStairs(108, brick, 0)).setUnlocalizedName("stairsBrick");
-    public static final Block stairsStoneBrick = (new BlockStairs(109, stoneBrick, 0)).setUnlocalizedName("stairsStoneBrickSmooth");
-    public static final BlockMycelium mycelium = (BlockMycelium)(new BlockMycelium(110)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("mycel");
-    public static final Block waterlily = (new BlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
-    public static final Block netherBrick = (new Block(112, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherBrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block netherFence = (new BlockFence(113, "netherBrick", Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
-    public static final Block stairsNetherBrick = (new BlockStairs(114, netherBrick, 0)).setUnlocalizedName("stairsNetherBrick");
-    public static final Block netherStalk = (new BlockNetherStalk(115)).setUnlocalizedName("netherStalk");
-    public static final Block enchantmentTable = (new BlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
-    public static final Block brewingStand = (new BlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
-    public static final BlockCauldron cauldron = (BlockCauldron)(new BlockCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
-    public static final Block endPortal = (new BlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
-    public static final Block endPortalFrame = (new BlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
-    public static final Block whiteStone = (new Block(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dragonEgg = (new BlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
-    public static final Block redstoneLampIdle = (new BlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block redstoneLampActive = (new BlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
-    public static final BlockHalfSlab woodDoubleSlab = (BlockHalfSlab)(new BlockWoodSlab(125, true)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("woodSlab");
-    public static final BlockHalfSlab woodSingleSlab = (BlockHalfSlab)(new BlockWoodSlab(126, false)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("woodSlab");
-    public static final Block cocoaPlant = (new BlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
-    public static final Block stairsSandStone = (new BlockStairs(128, sandStone, 0)).setUnlocalizedName("stairsSandStone");
-    public static final Block oreEmerald = (new BlockOre(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
-    public static final Block enderChest = (new BlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
-    public static final BlockTripWireSource tripWireSource = (BlockTripWireSource)(new BlockTripWireSource(131)).setUnlocalizedName("tripWireSource");
-    public static final Block tripWire = (new BlockTripWire(132)).setUnlocalizedName("tripWire");
-    public static final Block blockEmerald = (new BlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
-    public static final Block stairsWoodSpruce = (new BlockStairs(134, planks, 1)).setUnlocalizedName("stairsWoodSpruce");
-    public static final Block stairsWoodBirch = (new BlockStairs(135, planks, 2)).setUnlocalizedName("stairsWoodBirch");
-    public static final Block stairsWoodJungle = (new BlockStairs(136, planks, 3)).setUnlocalizedName("stairsWoodJungle");
-    public static final Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
-    public static final BlockBeacon beacon = (BlockBeacon)(new BlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
-    public static final Block cobblestoneWall = (new BlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
-    public static final Block flowerPot = (new BlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
-    public static final Block carrot = (new BlockCarrot(141)).setUnlocalizedName("carrots");
-    public static final Block potato = (new BlockPotato(142)).setUnlocalizedName("potatoes");
-    public static final Block woodenButton = (new BlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
-    public static final Block skull = (new BlockSkull(144)).setHardness(1.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("skull");
-    public static final Block anvil = (new BlockAnvil(145)).setHardness(5.0F).setStepSound(soundAnvilFootstep).setResistance(2000.0F).setUnlocalizedName("anvil");
-    public static final Block chestTrapped = (new BlockChest(146, 1)).setHardness(2.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("chestTrap");
-    public static final Block pressurePlateGold = (new BlockPressurePlateWeighted(147, "blockGold", Material.iron, 64)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("weightedPlate_light");
-    public static final Block pressurePlateIron = (new BlockPressurePlateWeighted(148, "blockIron", Material.iron, 640)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("weightedPlate_heavy");
-    public static final BlockComparator redstoneComparatorIdle = (BlockComparator)(new BlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockComparator redstoneComparatorActive = (BlockComparator)(new BlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new BlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
-    public static final Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone");
-    public static final Block oreNetherQuartz = (new BlockOre(153)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherquartz");
-    public static final BlockHopper hopperBlock = (BlockHopper)(new BlockHopper(154)).setHardness(3.0F).setResistance(8.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("hopper");
-    public static final Block blockNetherQuartz = (new BlockQuartz(155)).setStepSound(soundStoneFootstep).setHardness(0.8F).setUnlocalizedName("quartzBlock");
-    public static final Block stairsNetherQuartz = (new BlockStairs(156, blockNetherQuartz, 0)).setUnlocalizedName("stairsQuartz");
-    public static final Block railActivator = (new BlockRailPowered(157)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("activatorRail");
-    public static final Block dropper = (new BlockDropper(158)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dropper");
+    public static Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
+    public static Block trapdoor = new FCBlockTrapDoor( 96 );
+    public static Block silverfish = new FCBlockSilverfish( 97 );
+    public static Block stoneBrick = new FCBlockStoneBrick( 98 );
+    public static Block mushroomCapBrown = new FCBlockMushroomCapLegacy( 99, 0 );
+    public static Block mushroomCapRed = new FCBlockMushroomCapLegacy( 100, 1 );
+    public static Block fenceIron = new FCBlockIronBars( 101 );
+    public static Block thinGlass = (new FCBlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).SetPicksEffectiveOn().setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
+    public static Block melon = (new FCBlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
+    public static Block pumpkinStem = new FCBlockStem( 104, pumpkin );
+    public static Block melonStem = new FCBlockStem( 105, melon );
+    public static Block vine = new FCBlockVine( 106 );
+    public static Block fenceGate = new FCBlockFenceGate( 107 );
+    public static Block stairsBrick = (new FCBlockStairsBrick(108)).setUnlocalizedName("stairsBrick");
+    public static Block stairsStoneBrick = new FCBlockStairsStoneBrick( 109 );
+    public static BlockMycelium mycelium = new FCBlockMycelium( 110 );
+    public static Block waterlily = (new FCBlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
+    public static Block netherBrick = new FCBlockNetherBrick( 112 );
+    public static Block netherFence = (new FCBlockFence( 113, "netherBrick", FCBetterThanWolves.fcMaterialNetherRock )).setHardness(2F).setResistance(10F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
+    public static Block stairsNetherBrick = new FCBlockStairsNetherBrick( 114 );
+    public static Block netherStalk = (new FCBlockNetherStalk(115)).setUnlocalizedName("netherStalk");
+    public static Block enchantmentTable = (new FCBlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
+    public static Block brewingStand = (new FCBlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
+    public static BlockCauldron cauldron = (BlockCauldron)(new FCBlockVanillaCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
+    public static Block endPortal = (new FCBlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
+    public static Block endPortalFrame = (new FCBlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
+    public static Block whiteStone = (new FCBlockEndStone(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
+    public static Block dragonEgg = (new FCBlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
+    public static Block redstoneLampIdle = (new FCBlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
+    public static Block redstoneLampActive = (new FCBlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
+    public static BlockHalfSlab woodDoubleSlab = new FCBlockWoodSlab( 125, true );
+    public static BlockHalfSlab woodSingleSlab = new FCBlockWoodSlab( 126, false );
+    public static Block cocoaPlant = (new FCBlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).SetBuoyant().setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
+    public static Block stairsSandStone = (new FCBlockStairsSandStone(128)).setUnlocalizedName("stairsSandStone");
+    public static Block oreEmerald = (new FCBlockOreEmerald(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
+    public static Block enderChest = (new FCBlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
+    public static BlockTripWireSource tripWireSource = new FCBlockTripWireSource( 131 );
+    public static Block tripWire = (new FCBlockTripWire(132)).setUnlocalizedName("tripWire");
+    public static Block blockEmerald = (new FCBlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
+    public static Block stairsWoodSpruce = ( new FCBlockStairsWood( 134, planks, 1 ) ).setUnlocalizedName( "stairsWoodSpruce" );
+    public static Block stairsWoodBirch = ( new FCBlockStairsWood( 135, planks, 2 ) ).setUnlocalizedName( "stairsWoodBirch" );
+    public static Block stairsWoodJungle = ( new FCBlockStairsWood( 136, planks, 3 ) ).setUnlocalizedName( "stairsWoodJungle" );
+    public static Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
+    public static BlockBeacon beacon = (BlockBeacon)(new FCBlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
+    public static Block cobblestoneWall = (new FCBlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
+    public static Block flowerPot = (new FCBlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
+    public static Block carrot = (new FCBlockCarrot(141)).setUnlocalizedName("carrots");
+    public static Block potato = (new FCBlockPotato(142)).setUnlocalizedName("potatoes");
+    public static Block woodenButton = (new FCBlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
+    public static Block skull = new FCBlockSkull( 144 );
+    public static Block anvil = new FCBlockAnvil( 145 );
+    public static Block chestTrapped = new FCBlockStub( 146 ).setUnlocalizedName( "chestTrap" );
+    public static Block pressurePlateGold = new FCBlockStub( 147 ).setUnlocalizedName( "weightedPlate_light" );
+    public static Block pressurePlateIron = new FCBlockStub( 148 ).setUnlocalizedName( "weightedPlate_heavy" );
+    public static BlockComparator redstoneComparatorIdle = (BlockComparator)(new FCBlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
+    public static BlockComparator redstoneComparatorActive = (BlockComparator)(new FCBlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
+    public static BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new FCBlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
+    public static Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone").setLightValue(0.75F);
+    public static Block oreNetherQuartz = new FCBlockNetherQuartzOre( 153 );
+    public static BlockHopper hopperBlock = new FCBlockVanillaHopper( 154 );
+    public static Block blockNetherQuartz = new FCBlockBlackStone( 155 );
+    public static Block stairsNetherQuartz = new FCBlockBlackStoneStairs( 156 );
+    public static Block railActivator = new FCBlockStub( 157 ).setUnlocalizedName( "activatorRail" );
+    public static Block dropper = new FCBlockStub( 158 ).setUnlocalizedName( "dropper" );
 
     /** ID of the block. */
     public final int blockID;
@@ -242,31 +243,26 @@ public class Block
     /** true if the Block contains a Tile Entity */
     protected boolean isBlockContainer;
 
-    /** minimum X for the block bounds (local coordinates) */
-    protected double minX;
-
-    /** minimum Y for the block bounds (local coordinates) */
-    protected double minY;
-
-    /** minimum Z for the block bounds (local coordinates) */
-    protected double minZ;
-
-    /** maximum X for the block bounds (local coordinates) */
-    protected double maxX;
-
-    /** maximum Y for the block bounds (local coordinates) */
-    protected double maxY;
-
-    /** maximum Z for the block bounds (local coordinates) */
-    protected double maxZ;
+    /** FCNOTE: DEPRECATED */
+    protected double minX = 0D;
+    /** FCNOTE: DEPRECATED */
+    protected double minY = 0D;
+    /** FCNOTE: DEPRECATED */
+    protected double minZ = 0D;
+    /** FCNOTE: DEPRECATED */
+    protected double maxX = 1D;
+    /** FCNOTE: DEPRECATED */
+    protected double maxY = 1D;
+    /** FCNOTE: DEPRECATED */
+    protected double maxZ = 1D;
 
     /** Sound of stepping on the block */
     public StepSound stepSound;
     public float blockParticleGravity;
 
     /** Block material definition. */
-    public final Material blockMaterial;
-
+    public Material blockMaterial;
+    
     /**
      * Determines how much velocity is maintained while moving on top of this block
      */
@@ -274,6 +270,14 @@ public class Block
 
     /** The unlocalized name of this block. */
     private String unlocalizedName;
+    protected Icon blockIcon;
+    
+    public static final boolean[] blockReplaced = new boolean[4096];
+    
+    private int idDroppedOnStonecut = -1;
+    private int countDroppedOnStonecut = 0;
+    private int metaDroppedOnStonecut = 0;
+    private MapColor[] mapColorsForMetadata;
 
     protected Block(int par1, Material par2Material)
     {
@@ -294,6 +298,10 @@ public class Block
             opaqueCubeLookup[par1] = this.isOpaqueCube();
             lightOpacity[par1] = this.isOpaqueCube() ? 255 : 0;
             canBlockGrass[par1] = !par2Material.getCanBlockGrass();
+            // FCMOD: Added
+            useNeighborBrightness[par1] = false;
+            SetFilterableProperties( Item.m_iFilterable_SolidBlock );
+            // END FCMOD
         }
     }
 
@@ -343,7 +351,12 @@ public class Block
     public static boolean isNormalCube(int par0)
     {
         Block var1 = blocksList[par0];
+        // FCMOD: Changed this to not care about providing power (this is the way it used to work)
+        /*
         return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock() && !var1.canProvidePower();
+        */
+        return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock();
+        // END FCMOD
     }
 
     /**
@@ -354,6 +367,9 @@ public class Block
         return true;
     }
 
+	/**
+	 * FCNOTE: This is misnamed and returns true if the block *doesn't* block movement
+	 */	
     public boolean getBlocksMovement(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         return !this.blockMaterial.blocksMovement();
@@ -423,16 +439,20 @@ public class Block
     }
 
     /**
-     * Sets the bounds of the block.  minX, minY, minZ, maxX, maxY, maxZ
+     * FCNOTE: DEPRECATED 
      */
     protected final void setBlockBounds(float par1, float par2, float par3, float par4, float par5, float par6)
     {
+    	// FCMOD: Removed due to deprecating these variables to eliminate client/server race conditions
+    	/*
         this.minX = (double)par1;
         this.minY = (double)par2;
         this.minZ = (double)par3;
         this.maxX = (double)par4;
         this.maxY = (double)par5;
         this.maxZ = (double)par6;
+        */
+    	// END FCMOD
     }
 
     /**
@@ -447,6 +467,7 @@ public class Block
     /**
      * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
      * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
+     * FCNOTE: The "mask" referred to above is just the bounding box to check for intersection with
      */
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
@@ -462,10 +483,14 @@ public class Block
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
      * cleared to be reused)
      */
+    // FCMOD: Removed and replaced
+    /*
     public AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
     {
         return AxisAlignedBB.getAABBPool().getAABB((double)par2 + this.minX, (double)par3 + this.minY, (double)par4 + this.minZ, (double)par2 + this.maxX, (double)par3 + this.maxY, (double)par4 + this.maxZ);
     }
+    */
+    // END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -494,17 +519,20 @@ public class Block
 
     /**
      * Ticks the block if it's been scheduled
+     * FCNOTE: Called on server only
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random) {}
 
     /**
      * Called right before the block is destroyed by a player.  Args: world, x, y, z, metaData
+     * FCNOTE: Called AFTER block is set to air, not before
      */
     public void onBlockDestroyedByPlayer(World par1World, int par2, int par3, int par4, int par5) {}
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
+     * FCNOTE: Only called on server
      */
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5) {}
 
@@ -518,11 +546,13 @@ public class Block
 
     /**
      * Called whenever the block is added into the world. Args: world, x, y, z
+     * FCNOTE: Called on server only
      */
     public void onBlockAdded(World par1World, int par2, int par3, int par4) {}
 
     /**
      * ejects contained items into the world, and notifies neighbours of an update, as appropriate
+     * FCNOTE: Called on server only.  Called AFTER block is set, so it is no longer valid at pos.
      */
     public void breakBlock(World par1World, int par2, int par3, int par4, int par5, int par6) {}
 
@@ -546,11 +576,15 @@ public class Block
      * Gets the hardness of block at the given coordinates in the given world, relative to the ability of the given
      * EntityPlayer.
      */
+    // FCMOD: Removed and replaced later
+    /*
     public float getPlayerRelativeBlockHardness(EntityPlayer par1EntityPlayer, World par2World, int par3, int par4, int par5)
     {
         float var6 = this.getBlockHardness(par2World, par3, par4, par5);
         return var6 < 0.0F ? 0.0F : (!par1EntityPlayer.canHarvestBlock(this) ? par1EntityPlayer.getCurrentPlayerStrVsBlock(this, false) / var6 / 100.0F : par1EntityPlayer.getCurrentPlayerStrVsBlock(this, true) / var6 / 30.0F);
     }
+    */
+    // END FCMOD
 
     /**
      * Drops the specified block items
@@ -606,6 +640,8 @@ public class Block
      */
     protected void dropXpOnBlockBreak(World par1World, int par2, int par3, int par4, int par5)
     {
+    	// FCMOD: Code removed
+    	/*
         if (!par1World.isRemote)
         {
             while (par5 > 0)
@@ -615,6 +651,8 @@ public class Block
                 par1World.spawnEntityInWorld(new EntityXPOrb(par1World, (double)par2 + 0.5D, (double)par3 + 0.5D, (double)par4 + 0.5D, var6));
             }
         }
+        */
+    	// END FCMOD
     }
 
     /**
@@ -637,6 +675,8 @@ public class Block
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
+    // FCMOD: Removed and replaced
+    /*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
@@ -753,29 +793,22 @@ public class Block
         }
     }
 
-    /**
-     * Checks if a vector is within the Y and Z bounds of the block.
-     */
     private boolean isVecInsideYZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
-    /**
-     * Checks if a vector is within the X and Z bounds of the block.
-     */
     private boolean isVecInsideXZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
-    /**
-     * Checks if a vector is within the X and Y bounds of the block.
-     */
     private boolean isVecInsideXYBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY;
     }
+    */
+    // END FCMOD 
 
     /**
      * Called upon the block being destroyed by an explosion
@@ -835,9 +868,7 @@ public class Block
      */
     public void velocityToAddToEntity(World par1World, int par2, int par3, int par4, Entity par5Entity, Vec3 par6Vec3) {}
 
-    /**
-     * Updates the blocks bounds based on its current state. Args: world, x, y, z
-     */
+    /** FCNOTE: DEPRECATED */
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4) {}
 
     /**
@@ -928,13 +959,22 @@ public class Block
     /**
      * Called when the player destroys a block with an item that can harvest it. (i, j, k) are the coordinates of the
      * block and l is the block's subtype/damage.
+     * FCNOTE: Only called on server
      */
     public void harvestBlock(World par1World, EntityPlayer par2EntityPlayer, int par3, int par4, int par5, int par6)
     {
         par2EntityPlayer.addStat(StatList.mineBlockStatArray[this.blockID], 1);
+        
+        // FCMOD: Changed
+        /*
         par2EntityPlayer.addExhaustion(0.025F);
 
         if (this.canSilkHarvest() && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
+        */
+        par2EntityPlayer.AddHarvestBlockExhaustion( blockID, par3, par4, par5, par6 );        
+        
+        if ( this.canSilkHarvest( par6 ) && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
+    	// END FCMOD
         {
             ItemStack var8 = this.createStackedBlock(par6);
 
@@ -961,6 +1001,7 @@ public class Block
     /**
      * Returns an item stack containing a single instance of the current block type. 'i' is the block's subtype/damage
      * and is ignored for blocks which do not support subtypes. Blocks which cannot be harvested should return null.
+     * FCNOTE: This is the function used to create the silk-touch drop
      */
     protected ItemStack createStackedBlock(int par1)
     {
@@ -992,6 +1033,7 @@ public class Block
 
     /**
      * Called when the block is placed in the world.
+     * FCNOTE: Called AFTER the block is placed, unlike onBlockPlaced()
      */
     public void onBlockPlacedBy(World par1World, int par2, int par3, int par4, EntityLiving par5EntityLiving, ItemStack par6ItemStack) {}
 
@@ -1051,6 +1093,7 @@ public class Block
     /**
      * Returns the mobility information of the block, 0 = free, 1 = can't push but can move over, 2 = total immobility
      * and stop pistons
+     * FCMOD: 3 = can be piston shoveled, but free otherwise 
      */
     public int getMobilityFlag()
     {
@@ -1069,6 +1112,13 @@ public class Block
     {
         return this.damageDropped(par1World.getBlockMetadata(par2, par3, par4));
     }
+    
+    // FCMOD: Added from client to avoid nuisance
+    public CreativeTabs getCreativeTabToDisplayOn()
+    {
+        return this.displayOnCreativeTab;
+    }
+    // END FCMOD    
 
     /**
      * Sets the CreativeTab to display this block on.
@@ -1176,8 +1226,12 @@ public class Block
                     blocksList[var0].initializeBlock();
                 }
 
+                // FCMOD: Changed to not overwrite settings in block classes and to instead set
+                // useNeighborBrightness[] in block classes for most cases instead.
+                /*
                 boolean var1 = false;
 
+                // FCNOTE: renderType 10 is used by vanilla stairs
                 if (var0 > 0 && blocksList[var0].getRenderType() == 10)
                 {
                     var1 = true;
@@ -1204,10 +1258,2194 @@ public class Block
                 }
 
                 useNeighborBrightness[var0] = var1;
+                */
+                if ( canBlockGrass[var0] || lightOpacity[var0] == 0 )
+                {
+                	useNeighborBrightness[var0] = true;
+                }
+                // END FCMOD
             }
         }
 
         canBlockGrass[0] = true;
         StatList.initBreakableStats();
     }
+    
+ // FCMOD: Added New
+ 	private static final int[] m_iRotatedFacingsAroundJClockwise = 
+ 		new int[] { 0, 1, 4, 5, 3, 2 };
+ 	
+ 	private static final int[] m_iRotatedFacingsAroundJCounterclockwise = 
+ 		new int[] { 0, 1, 5, 4, 2, 3 };
+ 	
+ 	private static final int[] m_iCycledFacings = 
+ 		new int[] { 4, 0, 1, 5, 3, 2 };
+ 	
+ 	private static final int[] m_iCycledFacingsReversed = 
+ 		new int[] { 1, 2, 5, 4, 0, 3 };
+ 	
+     public boolean IsNormalCube( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return blockMaterial.isOpaque() && renderAsNormalBlock();
+     }
+     
+     /**
+      * Similar to onBlockPlacedBy() but called before the block is placed rather than after
+      */
+     public int PreBlockPlacedBy( World world, int i, int j, int k, int iMetadata, EntityLiving entityBy ) 
+     {
+     	return iMetadata;    	
+     }
+
+     public void SetBlockMaterial( Material material )
+     {
+     	blockMaterial = material;
+     	
+         canBlockGrass[blockID] = !material.getCanBlockGrass();    	
+     }
+     
+     /**
+      * Called on server only
+      */
+     public void RandomUpdateTick( World world, int i, int j, int k, Random rand )
+     {
+     	updateTick( world, i, j, k, rand );
+     }
+     
+ 	public void ClientNotificationOfMetadataChange( World world, int i, int j, int k, int iOldMetadata, int iNewMetadata )
+ 	{
+ 	}
+ 	
+     public void OnArrowImpact( World world, int i, int j, int k, EntityArrow arrow )
+     {
+     }
+     
+     public void OnArrowCollide( World world, int i, int j, int k, EntityArrow arrow )
+     {
+     }
+     
+     public float GetMovementModifier( World world, int i, int j, int k )
+     {
+     	float fModifier = 1.0F;
+     	
+ 		if ( blockMaterial != Material.ground && blockMaterial != Material.grass )
+ 		{
+ 			fModifier *= 1.2F;
+ 		}
+     	
+     	return fModifier;
+     }
+     
+     public void OnPlayerWalksOnBlock( World world, int i, int j, int k, EntityPlayer player )
+     {    	
+ 		// Disabled Hardcore sinkholes
+     	/*
+     	if ( IsFallingBlock( world, i, j, k ) )
+     	{
+     		CheckForUnstableGround( world, i, j, k );
+     	}
+     	*/
+     }
+     
+     /**
+      * Applies to Hopper ejecting items into the world, not inserting into the block itself
+      */
+     public boolean DoesBlockHopperEject( World world, int i, int j, int k )
+     {
+     	return blockMaterial.isSolid();
+     }
+
+     /**
+      * Applies to Hopper inserting items directly into the block's inventory.  This
+      * does not ensure the block has a valid inventory, it's just a first-pass chance
+      * to block such behavior.
+      */
+     public boolean DoesBlockHopperInsert( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     /**
+      * Returns true if the block is warm enough to melt nearby snow or ice
+      */
+     public boolean GetIsBlockWarm( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public StepSound GetStepSound( World world, int i, int j, int k )
+     {
+     	return stepSound;
+     }
+     
+     public void ClientBreakBlock( World world, int i, int j, int k, int iBlockID, int iMetadata )
+     {
+     }
+     
+     public void ClientBlockAdded( World world, int i, int j, int k )
+     {
+     }
+     
+     public boolean HasStrata()
+     {
+     	return false;
+     }
+     
+     public int GetMetadataConversionForStrataLevel( int iLevel, int iMetadata )
+     {
+     	return iMetadata;
+     }
+     
+     public float getExplosionResistance( Entity entity, World world, int i, int j, int k )
+     {
+         return getExplosionResistance( entity );
+     }
+     
+     public boolean CanBlockStayDuringGenerate( World world, int i, int j, int k )
+     {
+     	// breaking this off into a separate function so that we can prevent certain blocks (like mushrooms) spawning under certain conditions without messing up worldgen or
+     	// its usual growth conditions
+     	
+     	// NOTE: This function isn't called for all types of WorldGen to avoid excessive base class changes where not needed.  If you want to override it, make sure it is called
+     	// appropriately for the block in question first.
+     	
+     	return canBlockStay( world, i, j, k );
+     }
+     
+     /**
+      * Used to determine if this is a stair block for purposes of connecting visually to others
+      */
+     public boolean IsStairBlock()
+     {
+     	return false;
+     }
+     
+     public boolean ShouldDeleteTileEntityOnBlockChange( int iNewBlockID )
+     {
+     	return true;
+     }
+
+     /** 
+      * Determines whether other stone will "connect" to this block for purposes of determing whether
+      * a stone block can be individually harvested without breaking apart
+      */
+     public boolean IsNaturalStone( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+
+     static public AxisAlignedBB GetFulBlockBoundingBoxFromPool( World world, int i, int j, int k )
+     {
+     	return AxisAlignedBB.getAABBPool().getAABB(
+     		(float)i, (float)j, (float)k, 
+     		(float)i + 1.0F, (float)j + 1.0F, (float)k + 1.0F );	    	
+     }
+     
+     public boolean CanSpitWebReplaceBlock( World world, int i, int j, int k )
+     {
+     	return IsGroundCover( ) || IsAirBlock();
+     }
+     
+     public boolean IsAirBlock()
+     {
+     	return false;
+     }
+     
+     public boolean IsReplaceableVegetation( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+ 	public boolean HasWaterToSidesOrTop( World world, int i, int j, int k )
+ 	{
+ 		for ( int iFacing = 1; iFacing <= 5; iFacing++ )
+ 		{		
+ 			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iFacing );
+ 		
+ 			int iTempBlockID = world.getBlockId( tempPos.i, tempPos.j, tempPos.k );
+ 			Block tempBlock = Block.blocksList[iTempBlockID];
+ 			
+ 			if ( tempBlock != null && tempBlock.blockMaterial == Material.water )
+ 			{
+ 				return true;
+ 			}			
+ 		}
+ 		
+ 		return false;
+ 	}
+ 	
+ 	public boolean GetPreventsFluidFlow( World world, int i, int j, int k, Block fluidBlock )
+ 	{
+         return blockMaterial == Material.portal ? true : blockMaterial.blocksMovement();
+ 	}
+
+ 	public void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid fluidBlock )
+ 	{
+         dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+ 	}
+
+ 	public boolean IsBlockClimbable( World world, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+
+ 	/** 
+ 	 * Whether or not the block sets off Buddy Blocks.  Set to false for stuff like redstone blocks
+ 	 * that can cause feedback loops.
+ 	 */
+ 	public boolean TriggersBuddy()
+ 	{
+ 		return true;
+ 	}
+ 	
+     //------------ Addon interfacing related functionality ----------//
+ 	
+     /**
+      * Replaces a reference to an existing block (vanilla or btw)
+      * @param id The block id to be replaced
+      * @param newClass The class of the new block
+      * @param parameters Optional additional parameters to pass to the block, not including the id.
+      */
+     public static Block replaceBlock(int id, Class newClass, Object ... parameters) {
+     	if (blockReplaced[id]) {
+     		throw new RuntimeException("Multiple addons attempting to replace block " + blocksList[id]);
+     	}
+     	else {
+     		Block newBlock = null;
+     		
+     		Class[] parameterTypes = new Class[parameters.length + 1];
+     		Object[] parameterValues = new Object[parameters.length + 1];
+     		
+     		parameterTypes[0] = Integer.TYPE;
+     		parameterValues[0] = id;
+
+     		Block original = blocksList[id];
+     		blocksList[id] = null;
+     		
+     		for (int i = 0; i < parameters.length; i++) {
+     			Class<?> type = parameters[i].getClass();
+     			
+     			if (type == Integer.class) {
+     				type = Integer.TYPE;
+     			}
+     			else if (type == Boolean.class) {
+     				type = Boolean.TYPE;
+     			}
+     			else if (type == Float.class) {
+     				type = Float.TYPE;
+     			}
+     			else if (type == Double.class) {
+     				type = Double.TYPE;
+     			}
+     			else if (Block.class.isAssignableFrom(type)) {
+     				type = Block.class;
+     			}
+     			else if (Item.class.isAssignableFrom(type)) {
+     				type = Item.class;
+     			}
+     			else if (Material.class.isAssignableFrom(type)) {
+     				type = Material.class;
+     			}
+     			
+     			parameterTypes[i + 1] = type;
+     			parameterValues[i + 1] = parameters[i];
+     		}
+     		
+     		try {
+     			newBlock = (Block) newClass.getConstructor(parameterTypes).newInstance(parameterValues);
+     		} catch (InstantiationException e) {
+     			throw new RuntimeException("A problem has occured attempting to instantiate replacement for " + blocksList[id]);
+     		} catch (IllegalArgumentException e) {
+     			throw new RuntimeException("Incompatible types passed to specified constructor for " + blocksList[id]);
+     		} catch (NoSuchMethodException e) {
+     			throw new RuntimeException("No appropriate constructor found for " + blocksList[id] + ". Constructors must be public to be used in replacement.");
+     		} catch (Exception e) {
+     			e.printStackTrace();
+     		}
+     		
+     		blockReplaced[id] = true;
+     		
+     		newBlock.setHardness(original.blockHardness).setResistance(original.blockResistance).setStepSound(original.stepSound).setUnlocalizedName(original.unlocalizedName).setCreativeTab(original.getCreativeTabToDisplayOn());
+     		if (!original.enableStats)
+     			newBlock.disableStats();
+     		
+     		blocksList[id] = newBlock;
+     		
+     		return newBlock;
+     	}
+     }
+ 	
+     //------------ Harvesting related functionality ----------//
+     
+     protected boolean canSilkHarvest( int iMetadata )
+     {
+     	return canSilkHarvest();
+     }
+     
+     /**
+      * Called on server only, after the block is removed from the world
+      */
+     public void OnBlockDestroyedWithImproperTool( World world, EntityPlayer player, int i, int j, int k, int iMetadata )
+     {
+         world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyedWithImproperToolAuxFXID, i, j, k, blockID + ( iMetadata << 12 ) );
+     	
+     	DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, 1F );
+     }
+     
+     protected void DropItemsIndividualy( World world, int i, int j, int k, int iIDDropped, int iPileCount, int iDamageDropped, float fChanceOfPileDrop )
+ 	{
+     	for ( int iTempCount = 0; iTempCount < iPileCount; iTempCount++ )
+     	{
+     		if ( world.rand.nextFloat() <= fChanceOfPileDrop )
+     		{
+ 	    		ItemStack stack = new ItemStack( iIDDropped, 1, iDamageDropped );
+ 	    		
+ 	            dropBlockAsItem_do( world, i, j, k, stack );
+     		}
+     	}
+ 	}
+     
+     /**
+      * Called by explosions and improper tool use.  
+      * Should return true if the block processes its own drops through this method, false otherwise
+      * Note that the block may no longer be at the specified position when this is called
+      */
+     public boolean DropComponentItemsOnBadBreak( World world, int i, int j, int k, int iMetadata, float fChanceOfDrop )
+     {
+     	return false;
+     }
+     
+     /**
+      * Explosion may be null if this is called by a mining charge
+      */
+     public void DropItemsOnDestroyedByExplosion( World world, int i, int j, int k, Explosion explosion )
+     {
+         if ( !world.isRemote && canDropFromExplosion( explosion ) )
+         {
+         	float fChance = 1F;
+         	
+         	if ( explosion != null )
+         	{
+         		fChance /= explosion.explosionSize;
+         	}
+         	
+         	int iMetadata = world.getBlockMetadata( i, j, k );
+
+         	if ( !DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, fChance ) )
+         	{
+         		dropBlockAsItemWithChance( world, i, j, k, iMetadata, fChance, 0 );
+         	}
+         }
+     }
+
+     /**
+      * Notifies neighbors of dirt blocks that they should be loosened
+      */
+     protected void OnDirtDugWithImproperTool( World world, int i, int j, int k )
+     {
+     	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+     	{
+     		NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );    		    		
+     	}
+     }
+     
+     protected void OnDirtSlabDugWithImproperTool( World world, int i, int j, int k, 
+     	boolean bUpsideDown )
+     {
+     	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+     	{
+ 	        if ( !( bUpsideDown && iTempFacing == 0 ) && !( !bUpsideDown && iTempFacing == 1 ) )
+ 	        {
+ 	        	NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );
+ 	        }
+     	}
+     }
+     
+     protected void NotifyNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
+     	int iToFacing )
+     {
+ 		FCUtilsBlockPos neighborPos = new FCUtilsBlockPos( i, j, k, iToFacing );
+ 		
+ 		int iTargetBlockID = world.getBlockId( neighborPos.i, neighborPos.j, neighborPos.k );
+ 		
+ 		Block targetBlock = blocksList[iTargetBlockID];
+ 		
+ 		if ( targetBlock != null )
+ 		{    	
+ 			targetBlock.OnNeighborDirtDugWithImproperTool( world, 
+ 				neighborPos.i, neighborPos.j, neighborPos.k, GetOppositeFacing( iToFacing ) );
+ 		}    		
+     }
+     
+     protected void OnNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
+     	int iToFacing )
+     {
+     }
+     
+     //------------ Hard Point related functionality ----------//
+     
+ 	/**
+ 	 * small attachment surfaces, like those required for the bottom of a torch (approx 1/8 block width)
+ 	 */
+ 	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+ 	{
+ 		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+ 	}
+ 	
+ 	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+ 	{
+ 		return HasSmallCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+ 	}
+
+ 	/**
+ 	 * medium sized attachment points like the top of fence posts (approx 1/4 block width)
+ 	 */
+ 	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+ 	{
+ 		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+ 	}
+
+ 	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+ 	{
+ 		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+ 	}
+
+ 	/**
+ 	 * large attachment points that can support a full block width
+ 	 */	
+ 	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+ 	{
+ 		return blockAccess.isBlockNormalCube( i, j, k );
+ 	}
+
+ 	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+ 	{
+ 		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
+ 	}
+ 	
+ 	/**
+ 	 * returns true if the block is sitting on the one below, like a torch resting on the ground
+ 	 */
+ 	public boolean IsBlockRestingOnThatBelow( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+
+ 	/**
+ 	 * returns true if block is attached to a block in a particular direction.  Example: pumpkins attached to stems
+ 	 */
+ 	public boolean IsBlockAttachedToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+ 	{
+ 		return false;
+ 	}
+ 	
+ 	public void AttachToFacing( World world, int i, int j, int k, int iFacing )
+ 	{
+ 	}
+ 	
+ 	public boolean HasContactPointToFullFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+ 	{
+ 		return blockAccess.isBlockNormalCube( i, j, k );
+ 	}
+ 	
+ 	public boolean HasContactPointToSlabSideFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIsSlabUpsideDown )
+ 	{
+ 		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+ 	}
+ 	
+ 	/**
+ 	 * This method refers to the 'L' shaped sides of stair blocks.  Other stair facings will refernce either the full face, stair top,
+ 	 * or slab methods, depending on their shape
+ 	 */
+ 	public boolean HasContactPointToStairShapedFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+ 	{
+ 		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+ 	}
+ 	
+ 	/**
+ 	 * This method refers to the half-block shaped top or bottom of stair blocks.
+ 	 */
+ 	public boolean HasContactPointToStairNarrowVerticalFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, int iStairFacing )
+ 	{
+ 		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
+ 	}
+ 	
+ 	/**
+ 	 * Should return true if mortar has been successfully applied to block.
+ 	 */
+ 	public boolean OnMortarApplied( World world, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+ 	
+ 	public boolean HasMortar( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+ 	
+     public boolean HasNeighborWithMortarInContact( World world, int i, int j, int k )
+     {
+     	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+     	{
+     		if ( FCUtilsWorld.HasNeighborWithMortarInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
+ 			{
+ 				return true;
+ 			}
+     	}
+     	
+     	return false;
+     }
+     
+ 	public boolean IsStickyToSnow( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+ 	
+     public boolean HasStickySnowNeighborInContact( World world, int i, int j, int k )
+     {
+     	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+     	{
+     		if ( FCUtilsWorld.HasStickySnowNeighborInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
+ 			{
+ 				return true;
+ 			}
+     	}
+     	
+     	return false;
+     }
+     
+     //--------------- Fire related functionality -------------//
+     
+     private int m_iDefaultFurnaceBurnTime = 0;    
+     
+     public int GetFurnaceBurnTime( int iItemDamage )
+     {
+     	return m_iDefaultFurnaceBurnTime;
+     }
+     
+     public void SetFurnaceBurnTime( int iBurnTime )
+     {
+     	m_iDefaultFurnaceBurnTime = iBurnTime;
+     }
+     
+     public void SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
+     {
+     	SetFurnaceBurnTime( burnTime.m_iBurnTime );
+     }
+     
+     public boolean DoesInfiniteBurnToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
+     {
+     	return false;
+     }
+     
+     public boolean DoesExtinguishFireAbove( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public void OnDestroyedByFire( World world, int i, int j, int k, int iFireAge, boolean bForcedFireSpread )
+     {
+         if ( bForcedFireSpread || ( world.rand.nextInt( iFireAge + 10 ) < 5 && 
+         	!world.IsRainingAtPos( i, j, k ) ) )
+         {
+             int iNewFireMetadata = iFireAge + world.rand.nextInt( 5 ) / 4;
+
+             if ( iNewFireMetadata > 15 )
+             {
+                 iNewFireMetadata = 15;
+             }
+
+             world.setBlockAndMetadataWithNotify( i, j, k, Block.fire.blockID, iNewFireMetadata );
+         }
+         else
+         {
+             world.setBlockWithNotify( i, j, k, 0 );
+         }
+     }    
+     
+     public Block SetFireProperties( int iChanceToEncourageFire, int iAbilityToCatchFire )
+     {
+     	BlockFire.chanceToEncourageFire[blockID] = iChanceToEncourageFire;
+     	BlockFire.abilityToCatchFire[blockID] = iAbilityToCatchFire;
+     	
+     	return this;
+     }
+     
+     public Block SetFireProperties( FCEnumFlammability flammability )
+     {
+     	return SetFireProperties( flammability.m_iChanceToEncourageFire, 
+     		flammability.m_iAbilityToCatchFire );
+     }
+     
+     /**
+      * Whether the block itself can be set on fire, rather than a neighboring block being set to a fire block
+      */
+     public boolean GetCanBeSetOnFireDirectly( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean GetCanBeSetOnFireDirectlyByItem( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return GetCanBeSetOnFireDirectly( blockAccess, i, j, k );
+     }
+     
+     public boolean SetOnFireDirectly( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public int GetChanceOfFireSpreadingDirectlyTo( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return 0;
+     }
+     
+     public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k, Entity entity )
+     {
+     	return GetDoesFireDamageToEntities( world, i, j, k );
+     }
+     
+     public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     /**
+      * Used by Hibachi to determine if it can remove the block above it when lit
+      */
+     public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
+     {
+ 		return Block.fire.canBlockCatchFire( world, i, j, k ) || !blockMaterial.blocksMovement();
+     }
+     
+     /** 
+      * Whether a fire block can be directly placed over this one, without first burning or catching fire, as if it were air.
+      */
+     public boolean GetCanBlockBeReplacedByFire( World world, int i, int j, int k )
+     {
+     	return IsAirBlock();
+     }
+     
+     public boolean IsIncineratedInCrucible()
+     {
+     	return FCBlockFire.CanBlockBeDestroyedByFire( blockID );
+     }
+     
+     //------------- Pathing related functionality ------------//
+     
+     public boolean CanPathThroughBlock( IBlockAccess blockAccess, int i, int j, int k, 
+     	Entity entity, PathFinder pathFinder )
+     {
+ 		// note: getBlocksMovement() is misnamed and returns if the block *doesn't* block movement
+     	
+     	return getBlocksMovement( blockAccess, i, j, k );
+     }
+
+     /**
+      * Used to determine if entities who start their pathing from within this block
+      * should instead start pathing from a neighbor block instead, to prevent getting stuck
+      * in this one.  Mostly applies to stuff like chickens getting stuck in fences.
+      */
+     public boolean ShouldOffsetPositionIfPathingOutOf( IBlockAccess blockAccess, 
+     	int i, int j, int k, Entity entity, PathFinder pathFinder )
+     {
+     	return !CanPathThroughBlock( blockAccess, i, j, k, entity, pathFinder );
+     }
+     
+     public int GetWeightOnPathBlocked( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return 0;
+     }    
+     
+     public int AdjustPathWeightOnNotBlocked( int iPreviousWeight )
+     {
+     	return iPreviousWeight;
+     }
+     
+     public boolean IsBreakableBarricade( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+
+     public boolean IsBreakableBarricadeOpen( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     //------------- Kiln related functionality ------------//
+     
+     private boolean m_bCanBeCookedByKiln = false;
+     private int m_iItemIndexDroppedWhenCookedByKiln = -1;
+     private int m_iItemDamageDroppedWhenCookedByKiln = 0;
+     
+     public Block SetCanBeCookedByKiln( boolean bCanBeCooked )
+     {
+     	m_bCanBeCookedByKiln = bCanBeCooked;
+     	
+     	return this;
+     }
+     
+     public boolean GetCanBeCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return m_bCanBeCookedByKiln;
+     }    
+     
+     public int GetCookTimeMultiplierInKiln( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return 1;
+     }    
+     
+     public Block SetItemIndexDroppedWhenCookedByKiln( int iItemIndex )
+     {
+     	m_iItemIndexDroppedWhenCookedByKiln = iItemIndex;
+     	
+     	return this;
+     }
+     
+     public int GetItemIndexDroppedWhenCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return m_iItemIndexDroppedWhenCookedByKiln;
+     }
+     
+     public Block SetItemDamageDroppedWhenCookedByKiln( int iItemDamage )
+     {
+     	m_iItemDamageDroppedWhenCookedByKiln = iItemDamage;
+     	
+     	return this;
+     }
+     
+     public int GetItemDamageDroppedWhenCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return m_iItemDamageDroppedWhenCookedByKiln;
+     }
+     
+     public void OnCookedByKiln( World world, int i, int j, int k )
+     {
+     	int iItemDropped = GetItemIndexDroppedWhenCookedByKiln( world, i, j, k );
+     	
+     	if ( iItemDropped >= 0 )
+     	{
+     		int iDamageDropped = GetItemDamageDroppedWhenCookedByKiln( world, i, j, k );
+     		
+         	world.setBlockToAir( i, j, k );
+
+         	if ( iItemDropped > 0 )
+         	{
+         		FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j, k, iItemDropped, iDamageDropped );
+         	}
+     	}
+     }
+     
+     //------------- Saw related functionality ------------//
+     
+     public boolean DoesBlockBreakSaw( World world, int i, int j, int k )
+     {
+     	if ( blockMaterial.isSolid() )
+     	{
+ 	    	if ( blockMaterial != Material.wood && 
+ 	    		blockMaterial != Material.cactus && 
+ 	    		blockMaterial != Material.pumpkin &&
+ 	    		blockMaterial != Material.leaves &&
+ 	    		blockMaterial != Material.plants &&
+ 	    		blockMaterial != Material.vine &&
+ 	    		blockMaterial != Material.snow &&
+ 	    		blockMaterial != Material.craftedSnow &&
+ 	    		blockMaterial != FCBetterThanWolves.fcMaterialLog &&
+ 	    		blockMaterial != FCBetterThanWolves.fcMaterialPlanks &&
+ 	    		blockMaterial != FCBetterThanWolves.fcMaterialAsh
+ 			)
+ 	    	{
+ 				return true;
+ 	    	}
+     	}
+     	
+     	return false;
+     }
+
+     /*
+      * returns true if the block has been sawed, false otherwise
+      */
+     public boolean OnBlockSawed( World world, int i, int j, int k, int iSawPosI, int iSawPosJ, int iSawPosK )
+     {
+     	return OnBlockSawed( world, i, j, k );
+     }
+     
+     /*
+      * returns true if the block has been sawed, false otherwise
+      */
+     public boolean OnBlockSawed( World world, int i, int j, int k )
+     {		
+     	int iItemIDDropped = GetItemIDDroppedOnSaw( world, i, j, k ); 
+     	
+     	if (  iItemIDDropped >= 0 )
+     	{
+     		int iItemCountDropped = GetItemCountDroppedOnSaw( world, i, j, k );
+     		int iItemDamageDropped = GetItemDamageDroppedOnSaw( world, i, j, k );
+     		
+     		for ( int iTempCount = 0; iTempCount < iItemCountDropped; iTempCount++ )
+     		{
+ 				FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j, k, 
+ 					iItemIDDropped, iItemDamageDropped );
+     		}
+     	}
+     	else
+     	{
+     		if ( !DoesBlockDropAsItemOnSaw( world, i, j, k ) )
+         	{
+     			return false;
+         	}
+         	
+ 			dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+     	}
+     	
+     	world.setBlockToAir( i, j, k );
+     	
+     	return true;
+     }
+     
+     public int GetItemIDDroppedOnSaw( World world, int i, int j, int k )
+     {
+     	return -1;
+     }
+     
+     public int GetItemCountDroppedOnSaw( World world, int i, int j, int k )
+     {
+     	return 0;
+     }
+     
+     public int GetItemDamageDroppedOnSaw( World world, int i, int j, int k )
+     {
+     	return 0;
+     }
+     
+     public boolean DoesBlockDropAsItemOnSaw( World world, int i, int j, int k )
+     {
+     	return blockMaterial.isSolid();
+     }
+     
+     //------------- Stonecutter related functionality ------------//
+     // Only called by Automation+ addon
+     // Can be used by other addons to interface
+     
+     public void setItemIDDroppedOnStonecutter(int id) {
+     	this.idDroppedOnStonecut = id;
+     }
+     
+     public void setItemCountDroppedOnStonecutter(int count) {
+     	this.countDroppedOnStonecut = count;
+     }
+
+     public void setItemDamageDroppedOnStonecutter(int meta) {
+     	this.metaDroppedOnStonecut = meta;
+     }
+
+     public int getItemIDDroppedOnStonecutter(World world, int x, int y, int z) {
+         return this.idDroppedOnStonecut;
+     }
+
+     public int getItemCountDroppedOnStonecutter(World world, int x, int y, int z) {
+         return this.countDroppedOnStonecut;
+     }
+
+     public int getItemDamageDroppedOnStonecutter(World world, int x, int y, int z)  {
+         return this.metaDroppedOnStonecut;
+     }
+
+     public boolean doesBlockDropAsItemOnStonecutter(World world, int x, int y, int z)  {
+         return this.blockMaterial.isSolid();
+     }
+
+     public boolean doesBlockBreakStonecutter(World world, int x, int y, int z) {
+         return this.blockMaterial.isSolid() && this.blockMaterial != Material.rock && this.blockMaterial != Material.snow && this.blockMaterial != Material.craftedSnow && this.blockMaterial != FCBetterThanWolves.fcMaterialAsh && this.blockMaterial != FCBetterThanWolves.fcMaterialNetherRock;
+     }
+
+     public boolean onBlockStonecut(World world, int x, int y, int z, int stonecutterX, int stonecutterY, int stonecutterZ) {
+         return this.onBlockStonecut(world, x, y, z);
+     }
+
+     /**
+      * Override this method to provide finer control over stonecutter behavior.
+      * @param world
+      * @param x
+      * @param y
+      * @param z
+      * @return
+      */
+     public boolean onBlockStonecut(World world, int x, int y, int z){
+         int id = this.getItemIDDroppedOnStonecutter(world, x, y, z);
+
+         if (id >= 0) {
+             int count = this.getItemCountDroppedOnStonecutter(world, x, y, z);
+             int meta = this.getItemDamageDroppedOnStonecutter(world, x, y, z);
+
+             for (int i = 0; i < count; i++) {
+                 FCUtilsItem.EjectSingleItemWithRandomOffset(world, x, y, z, id, meta);
+             }
+         }
+         else {
+             if (!this.doesBlockDropAsItemOnStonecutter(world, x, y, z)) {
+                 return false;
+             }
+
+             this.dropBlockAsItem(world, x, y, z, world.getBlockMetadata(x, y, z), 0);
+         }
+
+         world.setBlockToAir(x, y, z);
+         return true;
+     }
+     
+     //------------- Mechanical power related functionality ------------//
+     
+     public int GetMechanicalPowerLevelProvidedToAxleAtFacing( World world, int i, int j, int k, int iFacing )
+     {
+     	return 0;
+     }
+     
+     //------------- Tool effectiveness functionality ------------//
+     
+     private boolean m_bShovelsEffectiveOn = false;
+     private boolean m_bPicksEffectiveOn = false;
+     private boolean m_bAxesEffectiveOn = false;
+     private boolean m_bHoesEffectiveOn = false;
+     
+     private boolean m_bChiselsEffectiveOn = false;
+     private boolean m_bChiselsCanHarvest = false;
+     
+     public boolean AreShovelsEffectiveOn()
+     {
+     	return m_bShovelsEffectiveOn;
+     }
+     
+     public boolean ArePicksEffectiveOn()
+     {
+     	return m_bPicksEffectiveOn;
+     }
+     
+     public boolean AreAxesEffectiveOn()
+     {
+     	return m_bAxesEffectiveOn;
+     }
+     
+     public boolean AreHoesEffectiveOn()
+     {
+     	return m_bHoesEffectiveOn;
+     }
+     
+     public boolean AreChiselsEffectiveOn()
+     {
+     	return m_bChiselsEffectiveOn;
+     }
+     
+     public boolean AreChiselsEffectiveOn( World world, int i, int j, int k )
+     {
+     	return AreChiselsEffectiveOn();
+     }
+     
+     public boolean CanChiselsHarvest()
+     {
+     	return m_bChiselsCanHarvest;
+     }
+     
+     public Block SetShovelsEffectiveOn() { return SetShovelsEffectiveOn( true ); }
+     public Block SetShovelsEffectiveOn( boolean bEffective )
+     {
+     	m_bShovelsEffectiveOn = bEffective;
+     	
+     	return this;
+     }
+     
+     public Block SetPicksEffectiveOn() { return SetPicksEffectiveOn( true ); }
+     public Block SetPicksEffectiveOn( boolean bEffective )
+     {
+     	m_bPicksEffectiveOn = bEffective;
+     	
+     	return this;
+     }
+     
+     public Block SetAxesEffectiveOn() { return SetAxesEffectiveOn( true ); }
+     public Block SetAxesEffectiveOn( boolean bEffective )
+     {
+     	m_bAxesEffectiveOn = bEffective;
+     	
+     	return this;
+     }
+     
+     public Block SetHoesEffectiveOn() { return SetHoesEffectiveOn( true ); }
+     public Block SetHoesEffectiveOn( boolean bEffective )
+     {
+     	m_bHoesEffectiveOn = bEffective;
+     	
+     	return this;
+     }
+     
+     public Block SetChiselsEffectiveOn() { return SetChiselsEffectiveOn( true ); }
+     public Block SetChiselsEffectiveOn( boolean bEffective )
+     {
+     	m_bChiselsEffectiveOn = bEffective;
+     	
+     	return this;
+     }
+     
+     public Block SetChiselsCanHarvest() { return SetChiselsCanHarvest( true ); }
+     public Block SetChiselsCanHarvest( boolean bCanHarvest )
+     {
+     	m_bChiselsCanHarvest = bCanHarvest;
+     	
+     	return this;
+     }
+     
+     public float getPlayerRelativeBlockHardness( EntityPlayer player, World world, int i, int j, int k )
+     {
+         float fBlockHardness = getBlockHardness( world, i, j, k );
+         
+         if ( fBlockHardness >= 0F )
+         {
+             float fRelativeHardness = player.getCurrentPlayerStrVsBlock( this, i, j, k ) / fBlockHardness;
+             
+         	if ( player.IsCurrentToolEffectiveOnBlock( this, i, j, k ) )
+         	{
+         		return fRelativeHardness / 30F;
+         	}
+         	else
+         	{
+         		return fRelativeHardness / 200F;
+         	}
+         }
+         else
+         {
+         	return 0F; 
+         }
+     }
+     
+     public boolean CanConvertBlock( ItemStack stack, World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     /**
+      * Returns false if the block has not been replaced with another, and should be removed
+      */
+     public boolean ConvertBlock( ItemStack stack, World world, int i, int j, int k, int iFromSide )
+     {
+     	return false;
+     }
+     
+     public int GetEfficientToolLevel( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return 0;
+     }
+     
+     public int GetHarvestToolLevel( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return GetEfficientToolLevel( blockAccess, i, j, k );
+     }
+     
+     /**
+      * The following is for stumps and such, which are a pain to remove regardless of whether their overall block has
+      * relevant tool effeciencies
+      */
+     public boolean GetIsProblemToRemove( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean GetDoesStumpRemoverWorkOnBlock( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean CanToolsStickInBlock( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return true;
+     }
+     
+     //------------- Buoyancy related functionality ------------//
+     
+ 	private float m_fBuoyancy = -1.0F;
+ 	
+     public Block SetBuoyancy( float fBuoyancy )
+     {
+     	m_fBuoyancy = fBuoyancy;
+     	
+     	return this;
+     }
+     
+     public Block SetBuoyant() { return SetBuoyancy( 1F ); }
+     public Block SetNonBuoyant() { return SetBuoyancy( -1F ); }
+     public Block SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
+     
+     public float GetBuoyancy( int iMetadata )
+     {
+     	return m_fBuoyancy;
+     }
+     
+     //------------- Ground cover related functionality ------------//
+     
+     public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
+     {
+     	if ( world.doesBlockHaveSolidTopSurface( i, j, k ) )
+     	{
+     		return true;
+     	}
+     	
+     	return false;
+     }
+     
+     public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return 0F;
+     }
+     
+     public boolean IsGroundCover()
+     {
+     	return false;
+     }
+     
+     public boolean AttempToSpreadGrassToBlock( World world, int i, int j, int k )
+     {
+     	if ( GetCanGrassSpreadToBlock( world, i, j, k ) &&
+         	world.GetBlockNaturalLightValueMaximum( i, j + 1, k ) >= 
+     		FCBlockGrass.m_iGrassSpreadToLightLevel && 
+         	Block.lightOpacity[world.getBlockId( i, j + 1, k )] <= 2 &&
+     		!FCBlockGroundCover.IsGroundCoverRestingOnBlock( world, i, j, k ) )    		
+     	{
+     		return SpreadGrassToBlock( world, i, j, k );
+     	}
+     	
+     	return false;
+     }
+     
+     public boolean GetCanGrassSpreadToBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean SpreadGrassToBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean GetCanGrassGrowUnderBlock( World world, int i, int j, int k, boolean bGrassOnHalfSlab )
+     {
+     	if ( !bGrassOnHalfSlab )
+     	{
+     		return !HasLargeCenterHardPointToFacing( world, i, j, k, 0 );
+     	}
+     	
+     	return true;
+     }
+     
+     public boolean AttempToSpreadMyceliumToBlock( World world, int i, int j, int k )
+     {
+     	if ( GetCanMyceliumSpreadToBlock( world, i, j, k ) &&
+     		world.getBlockLightValue( i, j + 1, k ) >= 
+     		FCBlockMycelium.m_iMyceliumSpreadToMinimumLightLevel &&
+     		Block.lightOpacity[world.getBlockId( i, j + 1, k )] <= 2 &&
+     		!FCBlockGroundCover.IsGroundCoverRestingOnBlock( world, i, j, k ) )    		
+     	{
+ 			return SpreadMyceliumToBlock( world, i, j, k );
+     	}
+     	
+     	return false;
+     }
+     
+     public boolean GetCanMyceliumSpreadToBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean SpreadMyceliumToBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean GetCanBlightSpreadToBlock( World world, int i, int j, int k, int iBlightLevel )
+     {
+     	return false;
+     }
+
+     /**
+      * Used by blocks like grass and mycellium to determine if they should use a snow side
+      * texture.  Note that this refers to the top visible surface, not just the top facing,
+      * which means that stuff like half-slabs should only return true if they have ground cover
+      * actually on the top surface halfway up the block vertically.
+      */ 
+     public boolean IsSnowCoveringTopSurface( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	int iBlockAboveID = blockAccess.getBlockId( i, j + 1, k );
+     	
+     	if ( iBlockAboveID != 0 )
+     	{
+     		Block blockAbove = blocksList[iBlockAboveID];
+     		
+     		Material aboveMaterial = blockAbove.blockMaterial;
+     		
+ 	        if ( aboveMaterial == Material.snow || aboveMaterial == Material.craftedSnow && 
+ 	        	blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 ) )
+ 	        {
+ 	        	return true;
+ 	        }
+ 	        else if ( 
+ 	        	blockAbove.GroundCoverRestingOnVisualOffset( blockAccess, i, j + 1, k ) < -0.99F && 
+ 	        	blockAccess.getBlockId( i, j + 2, k ) == snow.blockID )
+ 	        {
+ 	        	// consider snow resting on tall grass and such
+ 	        	
+ 	        	return true;
+ 	        }
+     	}
+     	
+     	return false;
+     }
+     
+     //---------- Piston Related Functionality ---------//
+     
+     /**
+      * Returns the metadata that will be placed
+      */
+     public int OnPreBlockPlacedByPiston( World world, int i, int j, int k, int iMetadata, int iDirectionMoved )
+     {
+     	return iMetadata;
+     }
+     
+     public boolean CanBlockBePulledByPiston( World world, int i, int j, int k, int iToFacing )
+     {
+     	if ( getMobilityFlag() != 1 ) // blocks destroyed on push can not be pulled
+     	{
+     		return CanBlockBePushedByPiston( world, i, j, k, iToFacing );
+     	}
+     	
+     	return false;    	                         
+     }
+     
+     public boolean CanBlockBePushedByPiston( World world, int i, int j, int k, int iToFacing )
+     {
+         int iMobility = getMobilityFlag();
+         
+         return iMobility == 1 || ( iMobility != 2 && !( this instanceof ITileEntityProvider ) );
+     }
+     
+     public boolean CanBePistonShoveled( World world, int i, int j, int k )
+     {
+     	return AreShovelsEffectiveOn();
+     }
+     
+     /**
+      * returns the direction the shoveled block will go in if this block is moving towards iToFacing.  
+      * return -1 if it's no shoveling is taking place.
+      */
+     public int GetPistonShovelEjectDirection( World world, int i, int j, int k, int iToFacing )
+     {
+     	return -1;
+     }
+     
+     public AxisAlignedBB GetAsPistonMovingBoundingBox( World world, int i, int j, int k )
+     {
+     	return getCollisionBoundingBoxFromPool( world, i, j, k );
+     }
+     
+     public int AdjustMetadataForPistonMove( int iMetadata )
+     {
+     	return iMetadata;
+     }
+     
+     public boolean CanContainPistonPackingToFacing( World world, int i, int j, int k, int iFacing )
+     {
+     	return HasLargeCenterHardPointToFacing( world, i, j, k, iFacing, true );
+     }    
+     
+     public boolean IsPistonPackable( ItemStack stack )
+     {
+     	return false;
+     }
+     
+     public int GetRequiredItemCountToPistonPack( ItemStack stack )
+     {
+     	return 0;
+     }
+     
+     public int GetResultingBlockIDOnPistonPack( ItemStack stack )
+     {
+     	return 0;
+     }
+     
+     public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
+     {
+     	return 0;
+     }
+     
+     public void OnBrokenByPistonPush( World world, int i, int j, int k, int iMetadata )
+     {
+     	dropBlockAsItem( world, i, j, k, iMetadata, 0 );
+     }
+     
+     //------------- Hopper Filtering Functionality -----------//
+     
+     protected int m_iFilterablePropertiesBitfield = 0;
+     
+     public boolean CanItemPassIfFilter( ItemStack filteredItem )
+     {
+     	return true;
+     }
+     
+     public int GetFilterableProperties( ItemStack stack )
+     {
+     	return m_iFilterablePropertiesBitfield;
+     }
+     
+     public void SetFilterableProperties( int iProperties )
+     {
+     	m_iFilterablePropertiesBitfield = iProperties;
+     }
+     
+     public boolean CanTransformItemIfFilter( ItemStack filteredItem )
+     {
+     	return false;
+     }
+     
+     //---------- Falling Block Functionality ----------//
+     
+     private static final int m_iLoadedRangeToCheckFalling = 32;
+     
+     public boolean IsFallingBlock()
+     {
+     	return false;
+     }
+     
+     protected boolean CheckForFall( World world, int i, int j, int k)
+     {
+         if ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j >= 0 )
+         {
+             if ( !BlockSand.fallInstantly && world.checkChunksExist( 
+             	i - m_iLoadedRangeToCheckFalling, j - m_iLoadedRangeToCheckFalling, k - m_iLoadedRangeToCheckFalling, 
+             	i + m_iLoadedRangeToCheckFalling, j + m_iLoadedRangeToCheckFalling, k + m_iLoadedRangeToCheckFalling ) )
+             {
+                 if ( !world.isRemote )
+                 {
+                 	FCEntityFallingBlock fallingEntity = new FCEntityFallingBlock( world, (double)i + 0.5D, (double)j + 0.5D, (double)k + 0.5D, 
+                     	blockID, world.getBlockMetadata( i, j, k ) );
+                     
+                     onStartFalling( fallingEntity );
+                     
+                     world.spawnEntityInWorld( fallingEntity );
+                 }
+                 
+                 return true;
+             }
+             else
+             {
+                 world.setBlockToAir( i, j, k );
+
+                 while ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j > 0 )
+                 {
+                     j--;
+                 }
+
+                 if ( j > 0 )
+                 {
+                     world.setBlock( i, j, k, blockID );
+                 }
+                 
+                 return true;
+             }
+         }
+         
+         return false;
+     }
+
+     /**
+      * Only called on server
+      */
+     protected void onStartFalling( EntityFallingSand entity ) {}
+     
+     /**
+      * This is actually called when a block lands safely.  Do not rename as BlockSand has a child method off of this
+      */
+     public void onFinishFalling( World world, int i, int j, int k, int iMetadata )
+     {
+     	NotifyNearbyAnimalsFinishedFalling( world, i, j, k );
+     }
+
+     protected void OnFallingUpdate( FCEntityFallingBlock entity ) {}
+     
+     public void NotifyNearbyAnimalsFinishedFalling( World world, int i, int j, int k )
+     {
+     	if ( !world.isRemote )
+     	{
+             EntityPlayer entityPlayer = world.getClosestPlayer((float)i + 0.5F, (float)j + 0.5F, (float)k + 0.5F, 64D );
+             
+             if ( entityPlayer != null )
+             {
+             	world.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( entityPlayer, this, i, j, k );
+             }
+     	}
+     }
+     
+ 	/** 
+ 	 * returns true if the block still exists
+ 	 */
+     public boolean OnFinishedFalling( EntityFallingSand entity, float fFallDistance )
+     {
+     	return true;
+     }
+     
+     /**
+      * returns true if the block has combined with the entity
+      */
+     public boolean AttemptToCombineWithFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+     {
+     	return false;
+     }
+     
+     public boolean CanBeCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+     {
+     	return false;
+     }
+     
+     public void OnCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
+     {
+     }
+     
+     protected boolean CanFallIntoBlockAtPos( World world, int i, int j, int k )
+     {
+     	Block targetBlock = Block.blocksList[world.getBlockId( i, j, k )];
+
+     	return targetBlock == null || !targetBlock.CanSupportFallingBlocks( world, i, j, k );
+     }
+     
+     public boolean CanSupportFallingBlocks( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return HasCenterHardPointToFacing( blockAccess, i, j, k, 1, true );    	
+     }
+     
+     protected void CheckForUnstableGround( World world, int i, int j, int k )
+     {
+     	for ( int iJOffset = 1; iJOffset <= 16; iJOffset++ )
+     	{
+     		int iTempJ = j - iJOffset;
+     		
+     		if ( iTempJ <= 0 )
+     		{
+     			break;
+     		}
+     		else
+     		{
+     	        if( world.isAirBlock( i, iTempJ, k ) )
+     	        {
+     	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+     	        	
+     	        	break;
+     	        }
+     	        else
+     	        {    	        	
+     	        	int iTempBlockID = world.getBlockId( i, iTempJ, k );
+     	        	
+     	        	if ( iTempBlockID == Block.fire.blockID )
+     	        	{
+         	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+         	        	
+         	        	break;
+     	        	}
+     	        	else
+     	        	{
+     	        		Block tempBlock = Block.blocksList[iTempBlockID];
+     	        		
+     	        		if ( tempBlock.blockMaterial == Material.water || tempBlock.blockMaterial == Material.lava )
+     	        		{
+             	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
+             	        	
+             	        	break;
+     	        		}
+     	        		else if ( !tempBlock.IsFallingBlock() )
+     	        		{
+     	        			break;
+     	        		}
+     	        	}
+     	        }    			
+     		}
+     	}
+     }
+     
+     protected void ScheduleCheckForFall( World world, int i, int j, int k )
+     {
+         world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+     }
+
+     /**
+      * Called on server only
+      */
+     public void OnBlockDestroyedLandingFromFall( World world, int i, int j, int k, int iMetadata )
+     {
+     	OnBlockDestroyedWithImproperTool( world, null, i, j, k, iMetadata );
+     }
+     
+     public boolean HasFallingBlockRestingOn( IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	Block blockAbove = Block.blocksList[blockAccess.getBlockId( i, j + 1, k )];
+     	                                    
+         return blockAbove != null && blockAbove.IsFallingBlock() && 
+         	blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 );
+     }
+     
+ 	//----------- Block Facing Functionality ----------//
+ 	
+ 	public int GetFacing( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return GetFacing( blockAccess.getBlockMetadata( i, j, k ) );
+ 	}
+ 	
+ 	public int GetFacing( int iMetadata )
+ 	{
+ 		return 0;
+ 	}
+ 	
+ 	public void SetFacing( World world, int i, int j, int k, int iFacing )
+ 	{
+ 		int iMetadata = world.getBlockMetadata( i, j, k );
+ 		
+ 		int iNewMetadata = SetFacing( iMetadata, iFacing );
+ 		
+ 		if ( iNewMetadata != iMetadata )
+ 		{
+ 			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
+ 		}
+ 	}
+ 	
+ 	public int SetFacing( int iMetadata, int iFacing )
+ 	{
+ 		return iMetadata;
+ 	}
+ 	
+ 	/**
+ 	 * Cycle through all the possible facings for a block 
+ 	 * returns true if the facing has actually changed as a result of this call
+ 	 */
+ 	public boolean ToggleFacing( World world, int i, int j, int k, boolean bReverse )
+ 	{
+ 		return RotateAroundJAxis( world, i, j, k, bReverse );
+ 	}
+ 	
+     public int ConvertFacingToTopTextureRotation( int iFacing )
+     {
+     	if ( iFacing >= 2 )
+     	{
+     		if ( iFacing <= 3 )
+     		{
+     			if ( iFacing == 3 )
+     			{
+     				return 3;
+     			}
+     		}
+     		else
+     		{
+     			if ( iFacing == 4 )
+     			{
+     				return 2;
+     			}
+     			else // iFacing == 5
+     			{
+     				return 1;
+     			}
+     		}
+     	}
+     	
+     	return 0;
+     }
+     
+     public int ConvertFacingToBottomTextureRotation( int iFacing )
+     {
+     	if ( iFacing >= 2 )
+     	{
+     		if ( iFacing <= 3 )
+     		{
+     			if ( iFacing == 3 )
+     			{
+     				return 3;
+     			}
+     		}
+     		else
+     		{
+     			if ( iFacing == 4 )
+     			{
+     				return 1;
+     			}
+     			else // iFacing == 5
+     			{
+     				return 2;
+     			}
+     		}
+     	}
+     	
+     	return 0;
+     }
+     
+ 	static public int GetOppositeFacing( int iFacing )
+ 	{
+ 		return iFacing ^ 1;
+ 	}
+ 	
+ 	static public int RotateFacingAroundJ( int iFacing, boolean bReverse )
+ 	{
+ 		if ( bReverse )
+ 		{
+ 			return m_iRotatedFacingsAroundJCounterclockwise[iFacing];
+ 		}
+ 		
+ 		return m_iRotatedFacingsAroundJClockwise[iFacing];
+ 	}
+
+ 	static public int CycleFacing( int iFacing, boolean bReverse )
+ 	{
+ 		if ( bReverse )
+ 		{
+ 			return m_iCycledFacingsReversed[iFacing];
+ 		}
+ 		
+ 		return m_iCycledFacings[iFacing];
+ 	}
+
+     //-------- Turntable Related Functionality --------//
+     
+ 	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return blockAccess.isBlockNormalCube( i, j, k );
+ 	}	
+ 	
+ 	public boolean CanTransmitRotationHorizontallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return blockAccess.isBlockNormalCube( i, j, k );
+ 	}
+ 	
+ 	public boolean CanTransmitRotationVerticallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return blockAccess.isBlockNormalCube( i, j, k );
+ 	}
+ 	
+ 	/**
+ 	 * Returns the new crafting counter after rotation.  It is unmodified if no crafting has taken place, 
+ 	 * incremented or reset on completion if it has.
+ 	 */
+ 	public int RotateOnTurntable( World world, int i, int j, int k, boolean bReverse, int iCraftingCounter )
+ 	{
+ 		OnRotatedOnTurntable( world, i, j, k );
+ 		
+ 		if ( !RotateAroundJAxis( world, i, j, k, bReverse ) )
+ 		{
+ 			// notify the surrounding blocks of a change if no facing change actually takes place, so that buddy can pick up on it
+ 			// this is because solid blocks still "rotate" even if their facing doesn't change
+ 			
+ 	    	world.notifyBlocksOfNeighborChange( i, j, k, blockID );	    	
+ 		}
+ 		
+ 		return iCraftingCounter;
+ 	}
+
+ 	/*
+ 	 * Intended to play block specific FX and such
+ 	 */
+ 	protected void OnRotatedOnTurntable( World world, int i, int j, int k )
+ 	{
+ 	}
+
+ 	protected int TurntableCraftingRotation( World world, int i, int j, int k, boolean bReverse, int iCraftingCounter )
+ 	{
+ 		iCraftingCounter++;
+ 		
+ 		if ( iCraftingCounter >= GetRotationsToCraftOnTurntable( world, i, j, k ) )
+ 		{
+ 			OnCraftedOnTurntable( world, i, j, k );
+ 			
+ 			int iNewBlockID = GetNewBlockIDCraftedOnTurntable( world, i, j, k );
+ 			int iNewBlockMetadata = GetNewMetadataCraftedOnTurntable( world, i, j, k );
+ 			int iItemIDDropped = GetItemIDCraftedOnTurntable( world, i, j, k );
+ 			int iItemCountDropped = GetItemCountCraftedOnTurntable( world, i, j, k );
+ 			int iItemDamageDropped = GetItemDamageCraftedOnTurntable( world, i, j, k );
+ 			
+ 			for ( int tempCount = 0; tempCount < iItemCountDropped; tempCount++ )
+ 			{
+ 				FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j + 1, k, iItemIDDropped, iItemDamageDropped );			
+ 			}
+
+ 			world.setBlockAndMetadataWithNotify( i, j, k, iNewBlockID, iNewBlockMetadata );			
+ 			
+ 			iCraftingCounter = 0;
+ 		}
+ 		
+ 		return iCraftingCounter;
+ 	}
+ 	
+ 	public int GetRotationsToCraftOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return 1;
+ 	}
+ 	
+ 	public void OnCraftedOnTurntable( World world, int i, int j, int k )
+ 	{
+         world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
+         	i, j, k, world.getBlockId( i, j, k ) + ( world.getBlockMetadata( i, j, k ) << 12 ) );        
+ 	}
+ 	
+ 	public int GetNewBlockIDCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return 0;
+ 	}
+ 	
+ 	public int GetNewMetadataCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return 0;
+ 	}
+ 	
+ 	public int GetItemIDCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return Item.clay.itemID;
+ 	}
+ 	
+ 	public int GetItemCountCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return 1;
+ 	}
+ 	
+ 	public int GetItemDamageCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return 0;
+ 	}
+ 	
+ 	/**
+ 	 * Returns true if the facing has actually changed as a result of this call
+ 	 */
+ 	public boolean RotateAroundJAxis( World world, int i, int j, int k, boolean bReverse )
+ 	{
+ 		int iMetadata = world.getBlockMetadata( i, j, k );
+ 		
+ 		int iNewMetadata = RotateMetadataAroundJAxis( iMetadata, bReverse );
+ 		
+ 		if ( iNewMetadata != iMetadata )
+ 		{
+ 			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
+ 			
+ 			return true;
+ 		}
+ 		
+ 		return false;
+ 	}
+
+ 	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
+ 	{
+ 		int iFacing = GetFacing( iMetadata );
+ 		
+ 		int iNewFacing = RotateFacingAroundJ( iFacing, bReverse );
+ 		
+ 		return SetFacing( iMetadata, iNewFacing );
+ 	}
+
+     public boolean CanRotateAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
+     {
+     	return false;
+     }
+     
+     /**
+      * Returns false if the block was destroyed and should not be rotated
+      */
+     public boolean OnRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
+     {
+     	return true;
+     }
+     
+     public int GetNewMetadataRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iInitialFacing, int iRotatedFacing )
+     {
+     	return 0;
+     }
+     
+     //----- Block Dispenser Related Functionality -----//
+     
+     /**
+      * If the stack returned is null, the block will not be retrieved
+      */
+     public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
+     {
+     	int iMetadata = world.getBlockMetadata( i, j, k );
+     	
+     	if ( canSilkHarvest( iMetadata ) )
+     	{
+     		return createStackedBlock( iMetadata );
+     	}
+     	
+     	int iIdDropped = idDropped( iMetadata, world.rand, 0 );
+     	
+     	if ( iIdDropped > 0 )
+     	{
+     		return new ItemStack( iIdDropped, 1, damageDropped( iMetadata ) );
+     	}
+     	
+     	return null;
+     }
+     
+     /**
+      * Whether a block is destroyed by the dispenser, even if no item is collected
+      */
+     public boolean IsBlockDestroyedByBlockDispenser( int iMetadata )
+     {
+     	return false;
+     }
+     
+     public void OnRemovedByBlockDispenser( World world, int i, int j, int k )
+     {
+         world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
+         	i, j, k, blockID + ( world.getBlockMetadata( i, j, k ) << 12 ) );
+         
+     	world.setBlockWithNotify( i, j, k, 0 );
+     }
+     
+ 	//---------- Weather Related Functionality --------//
+     
+     /**
+      * Called on server only
+      */
+     public void OnStruckByLightning( World world, int i, int j, int k )
+     {
+     }
+     
+ 	//------- Mob Spawning Related Functionality ------//
+     
+     /**
+      * This is only a first-pass indicator as to whether ANY mobs can spawn on top of the block,
+      * so stuff like leaves where only Jungle Spiders can spawn on them, should still return true.
+      */
+     public boolean CanMobsSpawnOn( World world, int i, int j, int k )
+     {
+         return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId ) &&
+     		getCollisionBoundingBoxFromPool( world, i, j, k ) != null;
+     }
+
+     public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
+     {
+     	return 0F;
+     }
+     
+ 	//-------- Collision Handling Functionality -------//
+     
+     /**
+      * This should never be modified after a block is initialized to avoid multithreading issues
+      * that occurred with the old min/max bounds variables.
+      */
+     private AxisAlignedBB m_fixedBlockBounds = new AxisAlignedBB( 0D, 0D, 0D, 1D, 1D, 1D );
+     private boolean m_bFixedBlockBoundsSet = false;
+     
+     /**
+      * Should only ever be called once for a block.  Repeated calls will silently fail without
+      * changing the bounds.
+      */
+     protected void InitBlockBounds( double dMinX, double dMinY, double dMinZ, 
+     	double dMaxX, double dMaxY, double dMaxZ )
+     {
+     	if ( !m_bFixedBlockBoundsSet )
+     	{
+     		// only allow the bounds to be set before they're ever accessed to 
+     		// discourage the kind of errors that necessitated it in the first 
+     		// place: client and server threads modifying the min/max values 
+     		// resulting in race conditions.
+     		
+     		m_fixedBlockBounds.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );    		
+     	}
+     }
+
+     protected void InitBlockBounds( AxisAlignedBB bounds )
+     {
+     	if ( !m_bFixedBlockBoundsSet )
+     	{
+     		m_fixedBlockBounds.setBB( bounds );
+     	}
+     }
+     
+     protected AxisAlignedBB GetFixedBlockBoundsFromPool()
+     {
+ 		m_bFixedBlockBoundsSet = true;
+ 		
+     	return m_fixedBlockBounds.MakeTemporaryCopy();
+     }
+
+     public AxisAlignedBB getCollisionBoundingBoxFromPool( World world, int i, int j, int k )
+     {
+     	return GetBlockBoundsFromPoolBasedOnState( world, i, j, k ).offset( i, j, k );
+     }
+     
+     public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+     	IBlockAccess blockAccess, int i, int j, int k )
+     {
+     	return GetFixedBlockBoundsFromPool();
+     }
+     
+     public MovingObjectPosition collisionRayTrace( World world, int i, int j, int k, 
+     	Vec3 startRay, Vec3 endRay )
+     {
+     	return CollisionRayTraceVsBlockBounds( world, i, j, k, startRay, endRay );
+     }
+
+     public MovingObjectPosition MouseOverRayTrace( World world, int i, int j, int k, 
+     	Vec3 startRay, Vec3 endRay )
+     {
+     	return collisionRayTrace( world, i, j, k, startRay, endRay );
+     }
+
+     public MovingObjectPosition CollisionRayTraceVsBlockBounds( World world, int i, int j, int k, 
+     	Vec3 startRay, Vec3 endRay )
+     {
+     	AxisAlignedBB collisionBox = GetBlockBoundsFromPoolBasedOnState( 
+     		world, i, j, k ).offset( i, j, k );
+     	
+     	MovingObjectPosition collisionPoint = collisionBox.calculateIntercept( startRay, endRay );
+     	
+     	if ( collisionPoint != null )
+     	{
+     		collisionPoint.blockX = i;
+     		collisionPoint.blockY = j;
+     		collisionPoint.blockZ = k;
+     	}
+     	
+     	return collisionPoint;
+     }
+     
+ 	//------------- Grazing Functionality -------------//
+     
+     private int m_iHerbivoreItemFoodValue = 0;
+     private int m_iBirdItemFoodValue = 0;
+     private int m_iPigItemFoodValue = 0;
+     
+     public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+     	EntityAnimal byAnimal )
+     {
+     	return false;
+     }
+     
+     public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
+     {
+         world.setBlockToAir( i, j, k );
+
+         Block blockBelow = blocksList[world.getBlockId( i, j - 1, k )];
+         
+         if ( blockBelow != null )
+         {
+         	blockBelow.OnVegetationAboveGrazed( world, i, j - 1, k, animal );
+         }
+     }
+     
+ 	public void OnVegetationAboveGrazed( World world, int i, int j, int k, EntityAnimal animal )
+ 	{
+ 	}
+ 	
+ 	/** 
+ 	 * Used when pigs dig up dirt to let any attached neighbors know that they should break loose
+ 	 */
+ 	public void NotifyNeighborsBlockDisrupted( World world, int i, int j, int k )
+ 	{
+ 		FCUtilsBlockPos pos = new FCUtilsBlockPos( i, j, k );
+ 		FCUtilsBlockPos tempPos = new FCUtilsBlockPos();
+ 		
+ 		for ( int iTempFacing = 0; iTempFacing <= 5; iTempFacing++ )
+ 		{
+ 			tempPos.Set( pos );			
+ 			tempPos.AddFacingAsOffset( iTempFacing );
+ 			
+ 			Block tempBlock = Block.blocksList[world.getBlockId( tempPos.i, tempPos.j, tempPos.k )];
+ 			
+ 			if ( tempBlock != null )
+ 			{
+ 				tempBlock.OnNeighborDisrupted( world, tempPos.i, tempPos.j, tempPos.k, 
+ 					GetOppositeFacing( iTempFacing ) );
+ 			}
+ 		}
+ 	}
+ 	
+ 	public void OnNeighborDisrupted( World world, int i, int j, int k, int iToFacing )
+ 	{
+ 	}
+ 	
+     public int GetHerbivoreItemFoodValue( int iItemDamage )
+     {
+     	return m_iHerbivoreItemFoodValue;
+     }
+     
+     public void SetHerbivoreItemFoodValue( int iFoodValue )
+     {
+     	m_iHerbivoreItemFoodValue = iFoodValue;
+     }
+     
+     public int GetChickenItemFoodValue( int iItemDamage )
+     {
+     	return m_iBirdItemFoodValue;
+     }
+     
+     public void SetChickenItemFoodValue( int iFoodValue )
+     {
+     	m_iBirdItemFoodValue = iFoodValue;
+     }
+     
+     public int GetPigItemFoodValue( int iItemDamage )
+     {
+     	return m_iPigItemFoodValue;
+     }
+     
+     public void SetPigItemFoodValue( int iFoodValue )
+     {
+     	m_iPigItemFoodValue = iFoodValue;
+     }
+     
+ 	//----------- Plant Growth Functionality ----------//
+     
+     public boolean CanDomesticatedCropsGrowOnBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean CanReedsGrowOnBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean CanSaplingsGrowOnBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     /**
+      * Covers stuff like flowers and tall grass
+      */
+     public boolean CanWildVegetationGrowOnBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean CanNetherWartGrowOnBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+     public boolean CanCactusGrowOnBlock( World world, int i, int j, int k )
+     {
+     	return false;
+     }
+     
+ 	public boolean IsBlockHydratedForPlantGrowthOn( World world, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+
+ 	public boolean IsConsideredNeighbouringWaterForReedGrowthOn( World world, int i, int j, int k )
+ 	{
+ 		for ( int iTempI = i - 1; iTempI <= i + 1; iTempI++ )
+ 		{		
+ 			for ( int iTempK = k - 1; iTempK <= k + 1; iTempK++ )
+ 			{				
+ 				if ( world.getBlockMaterial( iTempI, j, iTempK ) == Material.water )
+ 				{
+ 					return true;
+ 				}
+ 			}
+ 		}
+
+ 		return false;
+ 	}
+ 	
+ 	/** 
+ 	 * This is used by old style non-daily plant growth
+ 	 */
+ 	public float GetPlantGrowthOnMultiplier( World world, int i, int j, int k, Block plantBlock )
+ 	{
+ 		return 1F;
+ 	}
+ 	
+ 	public boolean GetIsFertilizedForPlantGrowth( World world, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+ 	
+ 	/** 
+ 	 * Called when a plant hits a full growth stage, like wheat fully grown, 
+ 	 * or each full block of Hemp.  Used to clear fertilizer.
+ 	 */
+ 	public void NotifyOfFullStagePlantGrowthOn( World world, int i, int j, int k, Block plantBlock )
+ 	{
+ 	}
+ 	
+ 	/**
+ 	 * Called server only.  Called AFTER the plant is removed, so it's no longer valid.  
+ 	 */
+ 	public void NotifyOfPlantAboveRemoved( World world, int i, int j, int k, Block plantBlock )
+ 	{
+ 	}
+ 	
+ 	/**
+ 	 * This determines whether weeds can share space with crop blocks, or grow
+ 	 * within their own independent weed blocks
+ 	 */
+ 	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+
+ 	/**
+ 	 * The growth level of weeds growing out of this block.  Range of 0 to 7 
+ 	 */
+ 	public int GetWeedsGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return 0;
+ 	}
+ 	
+ 	public void RemoveWeeds( World world, int i, int j, int k )
+ 	{
+ 	}
+ 	
+ 	public boolean AttemptToApplyFertilizerTo( World world, int i, int j, int k )
+ 	{
+ 		return false;
+ 	}
+ 	
+ 	public boolean GetConvertsLegacySoil( IBlockAccess blockAccess, int i, int j, int k )
+ 	{
+ 		return false;		
+ 	}
+ 	
+ 	//----------------- Map related functionality ----------------//
+     
+     /**
+      * Gets the color used in map rendering for this block with the specified metadata
+      * @param meta
+      * @return
+      */
+     public MapColor getMapColor(int meta) {
+     	if (mapColorsForMetadata == null) {
+     		return this.blockMaterial.materialMapColor;
+     	}
+     	else {
+     		try {
+     			return mapColorsForMetadata[meta];
+     		}
+     		catch (Exception e) {
+     			FCAddOnHandler.LogMessage("Map color not found for metadata " + meta + " of block " + this);
+         		return this.blockMaterial.materialMapColor;
+     		}
+     	}
+     }
+     
+     /**
+      * Set the array of map colors to use per metadata for this block. Make sure you include ALL possible metadata when using this method!
+      * @param mapColors Array of mapcolor objects which is referenced when rendering maps
+      * @return
+      */
+     public Block setMapColorsForMetadata(MapColor[] mapColors) {
+     	this.mapColorsForMetadata = mapColors;
+     	return this;
+     }
+ 	
+ 	//----------------- Integrity Test ----------------//
+     
+     static public boolean InstallationIntegrityTest()
+     {
+     	return true;
+     }
 }
diff --git a/minecraft_server/net/minecraft/src/BlockCrops.java b/minecraft_server/net/minecraft/src/BlockCrops.java
index b64c606..8af5815 100644
--- a/minecraft_server/net/minecraft/src/BlockCrops.java
+++ b/minecraft_server/net/minecraft/src/BlockCrops.java
@@ -9,7 +9,10 @@ public class BlockCrops extends BlockFlower
         super(par1);
         this.setTickRandomly(true);
         float var2 = 0.5F;
-        this.setBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
+        InitBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
+        //END FCMOD
         this.setCreativeTab((CreativeTabs)null);
         this.setHardness(0.0F);
         this.setStepSound(soundGrassFootstep);
@@ -20,14 +23,20 @@ public class BlockCrops extends BlockFlower
      * Gets passed in the blockID of the block below and supposed to return true if its allowed to grow on the type of
      * blockID passed in. Args: blockID
      */
+    // FCMOD: Removed as deprecated
+    /*
     protected boolean canThisPlantGrowOnThisBlockID(int par1)
     {
         return par1 == Block.tilledField.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * Ticks the block if it's been scheduled
      */
+    // FCMOD: Removed and replaced
+    /*
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
         super.updateTick(par1World, par2, par3, par4, par5Random);
@@ -48,6 +57,8 @@ public class BlockCrops extends BlockFlower
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Apply bonemeal to the crops.
@@ -69,6 +80,8 @@ public class BlockCrops extends BlockFlower
      * different sides that aren't opposing, and by adding growth for every crop next to this one (and for crop below
      * this one). Args: x, y, z
      */
+    // FCMOD: Removed as deprecated
+    /*
     private float getGrowthRate(World par1World, int par2, int par3, int par4)
     {
         float var5 = 1.0F;
@@ -117,6 +130,8 @@ public class BlockCrops extends BlockFlower
 
         return var5;
     }
+    */
+    // END FCMOD
 
     /**
      * The type of render function that is called for this block
@@ -153,6 +168,8 @@ public class BlockCrops extends BlockFlower
         {
             if (par5 >= 7)
             {
+            	// FCMOD: Change
+            	/*
                 int var8 = 3 + par7;
 
                 for (int var9 = 0; var9 < var8; ++var9)
@@ -162,6 +179,9 @@ public class BlockCrops extends BlockFlower
                         this.dropBlockAsItem_do(par1World, par2, par3, par4, new ItemStack(this.getSeedItem(), 1, 0));
                     }
                 }
+                */
+            	DropSeeds( par1World, par2, par3, par4, par5, par6, par7);
+            	// END FCMOD
             }
         }
     }
@@ -169,10 +189,14 @@ public class BlockCrops extends BlockFlower
     /**
      * Returns the ID of the items to drop on destruction.
      */
+    // FCMOD: Removed and replaced
+    /*
     public int idDropped(int par1, Random par2Random, int par3)
     {
         return par1 == 7 ? this.getCropItem() : this.getSeedItem();
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the quantity of items to drop on block destruction.
@@ -181,4 +205,147 @@ public class BlockCrops extends BlockFlower
     {
         return 1;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public int idDropped( int iMetadata, Random random, int iFortuneModifier )
+    {
+    	if ( iMetadata == 7 )
+    	{
+    		return getCropItem();
+    	}
+    	
+        return 0;
+    }
+    
+    @Override
+    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+    	EntityAnimal animal )
+    {
+		return true;
+    }
+    
+    @Override
+    public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
+    {
+    	// drop the block as an item so that animals can get the base graze value + eat
+    	// any tasties that drop
+    	
+        dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
+        
+        super.OnGrazed( world, i, j, k, animal );    
+    }
+    
+    @Override
+    public void updateTick( World world, int i, int j, int k, Random rand )
+    {
+        super.updateTick( world, i, j, k, rand );
+
+    	// make sure parent update didn't destroy the block, and prevent crops growing in the end
+    	// note that CanGrowOnBlock() has already been confirmed in parent method    	
+    	
+        if ( world.provider.dimensionId != 1 && 
+        	world.getBlockId( i, j, k ) == blockID )
+        {
+        	AttemptToGrow( world, i, j, k, rand );
+        }
+    }
+
+    @Override
+    protected boolean CanGrowOnBlock( World world, int i, int j, int k )
+    {
+    	Block blockOn = Block.blocksList[world.getBlockId( i, j, k )];
+    	
+    	return blockOn != null && blockOn.CanDomesticatedCropsGrowOnBlock( world, i, j, k );
+    }
+    
+	@Override
+	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return true;
+	}
+	
+    //------------- Class Specific Methods ------------//
+    
+    protected void AttemptToGrow( World world, int i, int j, int k, Random rand )
+    {
+    	if ( GetWeedsGrowthLevel( world, i, j, k ) == 0 && 
+    		GetGrowthLevel( world, i, j, k ) < 7 && 
+	    	world.getBlockLightValue( i, j + 1, k ) >= 9 )
+	    {
+	        Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+	        
+	        if ( blockBelow != null && 
+	        	blockBelow.IsBlockHydratedForPlantGrowthOn( world, i, j - 1, k ) )
+	        {
+	    		float fGrowthChance = GetBaseGrowthChance( world, i, j, k ) *
+	    			blockBelow.GetPlantGrowthOnMultiplier( world, i, j - 1, k, this );
+	    		
+	            if ( rand.nextFloat() <= fGrowthChance )
+	            {
+	            	IncrementGrowthLevel( world, i, j, k );
+	            }
+	        }
+	    }
+    }
+    
+    public void DropSeeds( World world, int i, int j, int k, int iMetadata, 
+    	float fChance, int iFortuneModifier )
+    {
+        dropBlockAsItem_do(world, i, j, k, new ItemStack( getSeedItem(), 1, 0 ) );
+        
+        if ( world.rand.nextInt( 16 ) - iFortuneModifier < 4 )
+        {
+            dropBlockAsItem_do(world, i, j, k, new ItemStack( getSeedItem(), 1, 0 ) );
+        }
+    }
+    
+    public float GetBaseGrowthChance( World world, int i, int j, int k )
+    {
+    	return 0.05F;
+    }
+    
+    protected void IncrementGrowthLevel( World world, int i, int j, int k )
+    {
+    	int iGrowthLevel = GetGrowthLevel( world, i, j, k ) + 1;
+    	
+        SetGrowthLevel( world, i, j, k, iGrowthLevel );
+        
+        if ( iGrowthLevel == 7 )
+        {
+        	Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+        	
+        	if ( blockBelow != null )
+        	{
+        		blockBelow.NotifyOfFullStagePlantGrowthOn( world, i, j - 1, k, this );
+        	}
+        }
+    }
+    
+    protected int GetGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetGrowthLevel( blockAccess.getBlockMetadata( i, j, k ) );
+    }
+    
+    protected int GetGrowthLevel( int iMetadata )
+    {
+    	return iMetadata & 7;
+    }
+    
+    protected void SetGrowthLevel( World world, int i, int j, int k, int iLevel )
+    {
+    	int iMetadata = world.getBlockMetadata( i, j, k ) & (~7); // filter out old level   	
+    	
+    	world.setBlockMetadataWithNotify( i, j, k, iMetadata | iLevel );
+    }
+    
+    protected void SetGrowthLevelNoNotify( World world, int i, int j, int k, int iLevel )
+    {
+    	int iMetadata = world.getBlockMetadata( i, j, k ) & (~7); // filter out old level   	
+    	
+    	world.setBlockMetadata( i, j, k, iMetadata | iLevel );
+    }
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockDoor.java b/minecraft_server/net/minecraft/src/BlockDoor.java
index 93d804c..7b733c7 100644
--- a/minecraft_server/net/minecraft/src/BlockDoor.java
+++ b/minecraft_server/net/minecraft/src/BlockDoor.java
@@ -365,4 +365,11 @@ public class BlockDoor extends Block
             par1World.setBlockToAir(par2, par3 - 1, par4);
         }
     }
+    
+    // FCMOD: Code added
+    public void OnAIOpenDoor( World world, int i, int j, int k, boolean bOpen )
+    {
+    	onPoweredBlockChange( world, i, j, k, bOpen );    	
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockFire.java b/minecraft_server/net/minecraft/src/BlockFire.java
index 53a967b..63e7c50 100644
--- a/minecraft_server/net/minecraft/src/BlockFire.java
+++ b/minecraft_server/net/minecraft/src/BlockFire.java
@@ -5,13 +5,25 @@ import java.util.Random;
 public class BlockFire extends Block
 {
     /** The chance this block will encourage nearby blocks to catch on fire */
+	// FCMOD: Change to static, public, and extended block IDs
+	/*
     private int[] chanceToEncourageFire = new int[256];
+    */
+    static public int[] chanceToEncourageFire = new int[4096];
+    // END FCMOD
 
     /**
      * This is an array indexed by block ID the larger the number in the array the more likely a block type will catch
      * fires
      */
+	// FCMOD: Change to static, public, and extended block IDs
+    // FCNOTE: This is actually the chance of a block being DESTROYED by fire, and potentially converted to a fire block
+	/*
     private int[] abilityToCatchFire = new int[256];
+    */
+    static public int[] abilityToCatchFire = new int[4096];
+    // END FCMOD
+    private Icon[] iconArray;
 
     protected BlockFire(int par1)
     {
@@ -23,6 +35,8 @@ public class BlockFire extends Block
      * This method is called on a block after all other blocks gets already created. You can use it to reference and
      * configure something on the block that needs the others ones.
      */
+	// FCMOD: Removed in favor of the block classes themselves setting their own fire properties
+    /*
     public void initializeBlock()
     {
         this.setBurnRate(Block.planks.blockID, 5, 20);
@@ -41,6 +55,8 @@ public class BlockFire extends Block
         this.setBurnRate(Block.cloth.blockID, 30, 60);
         this.setBurnRate(Block.vine.blockID, 15, 100);
     }
+    */
+    // END FCMOD
 
     /**
      * Sets the burn rate for a block. The larger abilityToCatchFire the more easily it will catch. The larger
@@ -106,6 +122,8 @@ public class BlockFire extends Block
     /**
      * Ticks the block if it's been scheduled
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
         if (par1World.getGameRules().getGameRuleBooleanValue("doFireTick"))
@@ -211,6 +229,8 @@ public class BlockFire extends Block
             }
         }
     }
+    */
+    // END FCMOD
 
     public boolean func_82506_l()
     {
@@ -225,7 +245,10 @@ public class BlockFire extends Block
         {
             boolean var9 = par1World.getBlockId(par2, par3, par4) == Block.tnt.blockID;
 
-            if (par6Random.nextInt(par7 + 10) < 5 && !par1World.canLightningStrikeAt(par2, par3, par4))
+            // FCMOD: Changed
+            //if (par6Random.nextInt(par7 + 10) < 5 && !par1World.canLightningStrikeAt(par2, par3, par4))
+            if ( par6Random.nextInt( par7 + 10 ) < 5 && !par1World.IsRainingAtPos( par2, par3, par4 ) )
+        	// END FCMOD
             {
                 int var10 = par7 + par6Random.nextInt(5) / 4;
 
@@ -251,7 +274,12 @@ public class BlockFire extends Block
     /**
      * Returns true if at least one block next to this one can burn.
      */
+	// FCMOD: Changed to protected
+	/*
     private boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
+    */
+    protected boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
+    // END FCMOD
     {
         return this.canBlockCatchFire(par1World, par2 + 1, par3, par4) ? true : (this.canBlockCatchFire(par1World, par2 - 1, par3, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3 - 1, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3 + 1, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3, par4 - 1) ? true : this.canBlockCatchFire(par1World, par2, par3, par4 + 1)))));
     }
@@ -259,6 +287,8 @@ public class BlockFire extends Block
     /**
      * Gets the highest chance of a neighbor block encouraging this block to catch fire
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     private int getChanceOfNeighborsEncouragingFire(World par1World, int par2, int par3, int par4)
     {
         byte var5 = 0;
@@ -278,6 +308,8 @@ public class BlockFire extends Block
             return var6;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns if this block is collidable (only used by Fire). Args: x, y, z
@@ -300,11 +332,15 @@ public class BlockFire extends Block
      * current number passed in it will return its number instead of the passed in one.  Args: world, x, y, z,
      * curChanceToEncourageFire
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public int getChanceToEncourageFire(World par1World, int par2, int par3, int par4, int par5)
     {
         int var6 = this.chanceToEncourageFire[par1World.getBlockId(par2, par3, par4)];
         return var6 > par5 ? var6 : par5;
     }
+    */
+    // END FCMOD
 
     /**
      * Checks to see if its valid to put this block at the specified coordinates. Args: world, x, y, z
@@ -343,4 +379,9 @@ public class BlockFire extends Block
             }
         }
     }
+    
+    // FCMOD: Added New
+    
+	//----------- Client Side Functionality -----------//
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockFlower.java b/minecraft_server/net/minecraft/src/BlockFlower.java
index 410afc9..4d96a49 100644
--- a/minecraft_server/net/minecraft/src/BlockFlower.java
+++ b/minecraft_server/net/minecraft/src/BlockFlower.java
@@ -2,14 +2,24 @@ package net.minecraft.src;
 
 import java.util.Random;
 
-public class BlockFlower extends Block
+// FCMOD: Changed
+//public class BlockFlower extends Block
+public class BlockFlower extends FCBlockPlants
+// END FCMOD
 {
+	/**
+	 * FCNOTE: This class would be better called BlockPlants, as it acts as a common base class
+	 * for vegetation and crops.
+	 */
     protected BlockFlower(int par1, Material par2Material)
     {
         super(par1, par2Material);
         this.setTickRandomly(true);
         float var3 = 0.2F;
-        this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3);
+        InitBlockBounds( 0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3 );
+        // END FCMOD
         this.setCreativeTab(CreativeTabs.tabDecorations);
     }
 
@@ -21,19 +31,27 @@ public class BlockFlower extends Block
     /**
      * Checks to see if its valid to put this block at the specified coordinates. Args: world, x, y, z
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean canPlaceBlockAt(World par1World, int par2, int par3, int par4)
     {
         return super.canPlaceBlockAt(par1World, par2, par3, par4) && this.canThisPlantGrowOnThisBlockID(par1World.getBlockId(par2, par3 - 1, par4));
     }
+    */
+    // END FCMOD
 
     /**
      * Gets passed in the blockID of the block below and supposed to return true if its allowed to grow on the type of
      * blockID passed in. Args: blockID
      */
+    // FCMOD: Removed as deprecated
+    /*
     protected boolean canThisPlantGrowOnThisBlockID(int par1)
     {
         return par1 == Block.grass.blockID || par1 == Block.dirt.blockID || par1 == Block.tilledField.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
@@ -65,10 +83,14 @@ public class BlockFlower extends Block
     /**
      * Can this block stay at this position.  Similar to canPlaceBlockAt except gets checked often with plants.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean canBlockStay(World par1World, int par2, int par3, int par4)
     {
         return (par1World.getFullBlockLightValue(par2, par3, par4) >= 8 || par1World.canBlockSeeTheSky(par2, par3, par4)) && this.canThisPlantGrowOnThisBlockID(par1World.getBlockId(par2, par3 - 1, par4));
     }
+    */
+    // END FCMOD
 
     /**
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
@@ -103,4 +125,24 @@ public class BlockFlower extends Block
     {
         return 1;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public boolean canBlockStay( World world, int i, int j, int k )
+    {
+        return ( world.getFullBlockLightValue( i, j, k ) >= 8 || 
+        	world.canBlockSeeTheSky( i, j, k ) ) && super.canBlockStay( world, i, j, k ); 
+    }
+    
+    @Override
+    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
+    	EntityAnimal animal )
+    {
+		return animal.CanGrazeOnRoughVegetation();
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockFlowing.java b/minecraft_server/net/minecraft/src/BlockFlowing.java
index 8dd2c01..8287be1 100644
--- a/minecraft_server/net/minecraft/src/BlockFlowing.java
+++ b/minecraft_server/net/minecraft/src/BlockFlowing.java
@@ -65,6 +65,12 @@ public class BlockFlowing extends BlockFluid
             var12 = this.getSmallestFlowDecay(par1World, par2 + 1, par3, par4, var12);
             var12 = this.getSmallestFlowDecay(par1World, par2, par3, par4 - 1, var12);
             var12 = this.getSmallestFlowDecay(par1World, par2, par3, par4 + 1, var12);
+            
+            // FCMOD: Code added
+        	var12 = GetSmallestFlowDecayFromCustomSources( par1World, par2, par3, par4, var12 );            	
+        	int iTickRate = tickRate(par1World);
+            // END FCMOD
+        	
             var10 = var12 + var7;
 
             if (var10 >= 8 || var12 < 0)
@@ -98,11 +104,19 @@ public class BlockFlowing extends BlockFluid
                 }
             }
 
+        	// FCMOD: Code change to import 1.6 lava flow fix with additional variability so it doesn't look as weird
+            /*
             if (this.blockMaterial == Material.lava && var6 < 8 && var10 < 8 && var10 > var6 && par5Random.nextInt(4) != 0)
             {
                 var10 = var6;
                 var8 = false;
             }
+            */
+            if ( this.blockMaterial == Material.lava && var6 < 8 && var10 < 8 && var10 > var6 )
+            {
+            	iTickRate += iTickRate * ( 1 + par5Random.nextInt( 4 ) );
+            }
+            // END FCMOD
 
             if (var10 == var6)
             {
@@ -122,7 +136,12 @@ public class BlockFlowing extends BlockFluid
                 else
                 {
                     par1World.setBlockMetadata(par2, par3, par4, var10, 2);
+                	// FCMOD: Code change to import 1.6 lava flow fix with additional variability so it doesn't look as weird
+                    /*
                     par1World.scheduleBlockUpdate(par2, par3, par4, this.blockID, this.tickRate(par1World));
+                    */
+                    par1World.scheduleBlockUpdate( par2, par3, par4, this.blockID, iTickRate );
+                    // END FCMOD
                     par1World.notifyBlocksOfNeighborChange(par2, par3, par4, this.blockID);
                 }
             }
@@ -136,7 +155,11 @@ public class BlockFlowing extends BlockFluid
         {
             if (this.blockMaterial == Material.lava && par1World.getBlockMaterial(par2, par3 - 1, par4) == Material.water)
             {
-                par1World.setBlock(par2, par3 - 1, par4, Block.stone.blockID);
+            	// FCMOD: Changed
+                //par1World.setBlock(par2, par3 - 1, par4, Block.stone.blockID);
+                par1World.setBlock( par2, par3 - 1, par4, 
+                	FCBetterThanWolves.fcBlockLavaPillow.blockID );
+                // END FCMOD
                 this.triggerLavaMixEffects(par1World, par2, par3 - 1, par4);
                 return;
             }
@@ -205,7 +228,10 @@ public class BlockFlowing extends BlockFluid
                 }
                 else
                 {
-                    Block.blocksList[var6].dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
+                	// FCMOD: Changed                	
+                    //Block.blocksList[var6].dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
+                	Block.blocksList[var6].OnFluidFlowIntoBlock( par1World, par2, par3, par4, this );
+                	// END FCMOD
                 }
             }
 
@@ -342,10 +368,12 @@ public class BlockFlowing extends BlockFluid
     /**
      * Returns true if block at coords blocks fluids
      */
+    // FCMOD: Removed and replaced later
+    /*
     private boolean blockBlocksFlow(World par1World, int par2, int par3, int par4)
     {
         int var5 = par1World.getBlockId(par2, par3, par4);
-
+        
         if (var5 != Block.doorWood.blockID && var5 != Block.doorIron.blockID && var5 != Block.signPost.blockID && var5 != Block.ladder.blockID && var5 != Block.reed.blockID)
         {
             if (var5 == 0)
@@ -363,6 +391,8 @@ public class BlockFlowing extends BlockFluid
             return true;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * getSmallestFlowDecay(World world, intx, int y, int z, int currentSmallestFlowDecay) - Looks up the flow decay at
@@ -420,4 +450,58 @@ public class BlockFlowing extends BlockFluid
     {
         return false;
     }
+    
+    // FCMOD: Added New   
+    @Override
+    public void onNeighborBlockChange( World world, int i, int j, int k, int iNeighborBlockID )
+    {
+    	super.onNeighborBlockChange( world, i, j, k, iNeighborBlockID );
+    	
+    	// these blocks normally have an update scheduled, and randomly get ticked to 
+    	// ensure they don't get stalled on chunk load, but can sit there for extend periods
+    	// until that happens, so this ensures player interaction will get them going again
+    	
+    	if ( !world.IsUpdatePendingThisTickForBlock( i, j, k, blockID ) )
+    	{
+    		world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+    	}
+    }
+
+	private int GetSmallestFlowDecayFromCustomSources( World world, int i, int j, int k, int iSmallestFlowDecay )
+	{
+		// note that this function doesn't update numAdjacentSources as that is used for new source block creation
+		
+        if ( iSmallestFlowDecay != 0 )
+        {
+        	for ( int iFacing = 0; iFacing < 6; iFacing++ )
+        	{
+        		int iTargetDecay = FCUtilsWorld.IsValidSourceForFluidBlockToFacing( world, i, j, k, iFacing );
+        		
+				if ( iTargetDecay == 0 )
+				{
+					iSmallestFlowDecay = 0;
+					
+					break;
+				}
+				
+				if ( iTargetDecay > 0 )
+				{
+					if ( iSmallestFlowDecay < 0 || iTargetDecay < iSmallestFlowDecay )
+					{
+						iSmallestFlowDecay = iTargetDecay;
+					}
+				}
+        	}
+        }
+        
+		return iSmallestFlowDecay;
+	}
+	
+    public boolean blockBlocksFlow( World world, int i, int j, int k )
+    {
+        Block block = blocksList[world.getBlockId( i, j, k )];
+        
+        return block != null && block.GetPreventsFluidFlow( world, i, j, k, this );
+    }
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockFluid.java b/minecraft_server/net/minecraft/src/BlockFluid.java
index c8d70bd..3d1b6f0 100644
--- a/minecraft_server/net/minecraft/src/BlockFluid.java
+++ b/minecraft_server/net/minecraft/src/BlockFluid.java
@@ -9,7 +9,10 @@ public abstract class BlockFluid extends Block
         super(par1, par2Material);
         float var3 = 0.0F;
         float var4 = 0.0F;
-        this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
+        InitBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
+        // END FCMOD
         this.setTickRandomly(true);
     }
 
@@ -134,6 +137,8 @@ public abstract class BlockFluid extends Block
     /**
      * Returns a vector indicating the direction and intensity of fluid flow.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     private Vec3 getFlowVector(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         Vec3 var5 = par1IBlockAccess.getWorldVec3Pool().getVecFromPool(0.0D, 0.0D, 0.0D);
@@ -240,6 +245,8 @@ public abstract class BlockFluid extends Block
         var5 = var5.normalize();
         return var5;
     }
+    */
+    // END FCMOD
 
     /**
      * Can add to the passed in vector for a movement vector to be applied to the entity. Args: x, y, z, entity, vec3d
@@ -323,7 +330,11 @@ public abstract class BlockFluid extends Block
                     }
                     else if (var6 <= 4)
                     {
-                        par1World.setBlock(par2, par3, par4, Block.cobblestone.blockID);
+                    	// FCMOD: Changed
+                        //par1World.setBlock(par2, par3, par4, Block.cobblestone.blockID);
+                        par1World.setBlock( par2, par3, par4, 
+                        	FCBetterThanWolves.fcBlockLavaPillow.blockID );
+                        // END FCMOD
                     }
 
                     this.triggerLavaMixEffects(par1World, par2, par3, par4);
@@ -344,4 +355,81 @@ public abstract class BlockFluid extends Block
             par1World.spawnParticle("largesmoke", (double)par2 + Math.random(), (double)par3 + 1.2D, (double)par4 + Math.random(), 0.0D, 0.0D, 0.0D);
         }
     }
+    
+    // FCMOD: Added New
+    @Override
+    public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
+    {
+    	return false;
+    }
+    
+    @Override
+    public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
+    {	 
+    	return null; // can't be picked up
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+    private Vec3 AddFlowVectorAtTarget( IBlockAccess iBlockAccess, int i, int j, int k, int iFlowDecay, int iTempI, int iTempK, Vec3 flowVec )
+    {
+        int iTempDecay = getEffectiveFlowDecay( iBlockAccess, iTempI, j, iTempK );
+
+        if ( iTempDecay < 0 )
+        {
+            if (!iBlockAccess.getBlockMaterial(iTempI, j, iTempK).blocksMovement())
+            {
+                iTempDecay = this.getEffectiveFlowDecay(iBlockAccess, iTempI, j - 1, iTempK);
+
+                if (iTempDecay >= 0)
+                {
+                    int iDeltaDecay = iTempDecay - (iFlowDecay - 8);
+                    return flowVec.addVector((double)((iTempI - i) * iDeltaDecay), 0D, (double)((iTempK - k) * iDeltaDecay));
+                }
+            }
+        }
+        else if (iTempDecay >= 0)
+        {
+            int iDeltaDecay = iTempDecay - iFlowDecay;
+            return flowVec.addVector((double)((iTempI - i) * iDeltaDecay), 0D, (double)((iTempK - k) * iDeltaDecay));
+        }
+        
+        return flowVec;
+    }
+    
+    private Vec3 getFlowVector( IBlockAccess iBlockAccess, int i, int j, int k )
+    {
+    	// optomized vanilla function
+    	
+        Vec3 flowVec = iBlockAccess.getWorldVec3Pool().getVecFromPool(0.0D, 0.0D, 0.0D);
+        
+        int iFlowDecay = getEffectiveFlowDecay( iBlockAccess, i, j, k );
+
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i - 1, k, flowVec );
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i, k - 1, flowVec );
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i + 1, k, flowVec );
+        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i, k + 1, flowVec );
+                
+        if (iBlockAccess.getBlockMetadata(i, j, k) >= 8)
+        {
+            if ( this.isBlockSolid(iBlockAccess, i, j, k - 1, 2)
+            || this.isBlockSolid(iBlockAccess, i, j, k + 1, 3)
+            || this.isBlockSolid(iBlockAccess, i - 1, j, k, 4)
+            || this.isBlockSolid(iBlockAccess, i + 1, j, k, 5)
+            || this.isBlockSolid(iBlockAccess, i, j + 1, k - 1, 2)
+            || this.isBlockSolid(iBlockAccess, i, j + 1, k + 1, 3)
+            || this.isBlockSolid(iBlockAccess, i - 1, j + 1, k, 4)
+            || this.isBlockSolid(iBlockAccess, i + 1, j + 1, k, 5) )
+            {
+                flowVec = flowVec.normalize().addVector(0.0D, -6.0D, 0.0D);
+            }
+        }
+
+        flowVec = flowVec.normalize();
+        
+        return flowVec;
+    }
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/BlockFurnace.java b/minecraft_server/net/minecraft/src/BlockFurnace.java
index 9c0f183..6b2d8dd 100644
--- a/minecraft_server/net/minecraft/src/BlockFurnace.java
+++ b/minecraft_server/net/minecraft/src/BlockFurnace.java
@@ -10,13 +10,21 @@ public class BlockFurnace extends BlockContainer
     private final Random furnaceRand = new Random();
 
     /** True if this is an active furnace, false if idle */
+    // FCMOD: Changed to protected
+    /*
     private final boolean isActive;
+    */
+    protected final boolean isActive;
+    // END FCMOD
 
     /**
      * This flag is used to prevent the furnace inventory to be dropped upon block removal, is used internally when the
      * furnace block changes from idle to active and vice-versa.
      */
-    private static boolean keepFurnaceInventory = false;
+    // FCMOD: Changed
+    //private static boolean keepFurnaceInventory = false;
+    protected static boolean keepFurnaceInventory = false;
+    // END FCMOD
 
     protected BlockFurnace(int par1, boolean par2)
     {
@@ -103,7 +111,12 @@ public class BlockFurnace extends BlockContainer
     /**
      * Update which block ID the furnace is using depending on whether or not it is burning
      */
+    // FCMOD: Changed
+    /*
     public static void updateFurnaceBlockState(boolean par0, World par1World, int par2, int par3, int par4)
+    */
+    public void updateFurnaceBlockState(boolean par0, World par1World, int par2, int par3, int par4, boolean bHasContents)
+    // END FCMOD
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         TileEntity var6 = par1World.getBlockTileEntity(par2, par3, par4);
@@ -119,6 +132,16 @@ public class BlockFurnace extends BlockContainer
         }
 
         keepFurnaceInventory = false;
+        // FCMOD: Code added
+        if ( !bHasContents )
+        {
+        	var5 = var5 & 7;
+        }
+        else
+        {
+        	var5 = var5 | 8;
+        }
+        // END FCMOD        
         par1World.setBlockMetadata(par2, par3, par4, var5, 2);
 
         if (var6 != null)
diff --git a/minecraft_server/net/minecraft/src/BlockHalfSlab.java b/minecraft_server/net/minecraft/src/BlockHalfSlab.java
index df4879e..a14c26c 100644
--- a/minecraft_server/net/minecraft/src/BlockHalfSlab.java
+++ b/minecraft_server/net/minecraft/src/BlockHalfSlab.java
@@ -15,18 +15,26 @@ public abstract class BlockHalfSlab extends Block
         if (par2)
         {
             opaqueCubeLookup[par1] = true;
+            
+            // FCMOD: Added
+            InitBlockBounds( 0D, 0D, 0D, 1D, 1D, 1D );
+            // END FCMOD
         }
         else
         {
-            this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+        	// FCMOD: Changed
+            //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+            InitBlockBounds( 0D, 0D, 0D, 1D, 0.5D, 1D );
+            
+            useNeighborBrightness[par1] = true;
+            // END FCMOD
         }
 
         this.setLightOpacity(255);
     }
 
-    /**
-     * Updates the blocks bounds based on its current state. Args: world, x, y, z
-     */
+    // FCMOD: Removed
+    /*
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         if (this.isDoubleSlab)
@@ -48,9 +56,6 @@ public abstract class BlockHalfSlab extends Block
         }
     }
 
-    /**
-     * Sets the block's bounds for rendering it as an item
-     */
     public void setBlockBoundsForItemRender()
     {
         if (this.isDoubleSlab)
@@ -63,15 +68,13 @@ public abstract class BlockHalfSlab extends Block
         }
     }
 
-    /**
-     * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
-     * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
-     */
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
         super.addCollisionBoxesToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);
     }
+    */
+    // END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -126,4 +129,108 @@ public abstract class BlockHalfSlab extends Block
     {
         return super.getDamageValue(par1World, par2, par3, par4) & 7;
     }
+    
+	// FCMOD: Added New
+    @Override
+    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+    	IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	AxisAlignedBB bounds;
+    	
+        if ( isDoubleSlab )
+        {
+            bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0F, 0F, 1F, 1F, 1F );
+        }
+        else
+        {
+            if ( GetIsUpsideDown( blockAccess, i, j, k ) )
+            {
+                bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0.5F, 0F, 1F, 1F, 1F );
+            }
+            else
+            {
+            	bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0F, 0F, 1F, 0.5F, 1F );
+            }
+        }
+        
+        return bounds;
+    }
+    
+    @Override
+	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
+	{
+    	if ( !isDoubleSlab )
+    	{
+            boolean bIsUpsideDown = GetIsUpsideDown( blockAccess, i, j, k );
+            
+            if ( iFacing == 0  ) 
+            {
+            	if ( !bIsUpsideDown )
+            	{
+            		return true;
+            	}
+            }
+            else if ( iFacing == 1 )
+            {
+            	if ( bIsUpsideDown )
+            	{
+            		return true;
+            	}
+            }
+    	}
+    	
+		return super.HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
+	}
+
+    @Override
+    public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
+    {
+        if ( !isDoubleSlab )
+        {
+            if ( ( blockAccess.getBlockMetadata( i, j, k ) & 8 ) == 0 )
+            {
+            	return -0.5F;
+            }
+        }
+        
+    	return 0F;
+    }
+    
+    @Override
+    public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
+    {
+    	return true;
+    }
+    
+    @Override
+    public boolean CanMobsSpawnOn( World world, int i, int j, int k )
+    {
+        return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId );
+    }
+
+    @Override
+    public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
+    {
+        if ( !isDoubleSlab && !GetIsUpsideDown( world, i, j, k ) )
+        {
+        	return -0.5F;
+        }
+        
+    	return 0F;
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+    public boolean GetIsUpsideDown( IBlockAccess blockAccess, int i, int j, int k )
+    {
+    	return GetIsUpsideDown( blockAccess.getBlockMetadata( i, j, k ) );
+    }
+    
+    public boolean GetIsUpsideDown( int iMetadata )
+    {
+    	return ( iMetadata & 8 ) > 0;
+    }
+    
+	//----------- Client Side Functionality -----------//
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockLog.java b/minecraft_server/net/minecraft/src/BlockLog.java
index c5d17b1..e9fb66d 100644
--- a/minecraft_server/net/minecraft/src/BlockLog.java
+++ b/minecraft_server/net/minecraft/src/BlockLog.java
@@ -123,4 +123,12 @@ public class BlockLog extends Block
     {
         return new ItemStack(this.blockID, 1, limitToValidMetadata(par1));
     }
+    // FCMOD: Code added
+    protected BlockLog( int iBlockID, Material material )
+    {
+        super(iBlockID, material );
+        
+        setCreativeTab( CreativeTabs.tabBlock );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockPistonBase.java b/minecraft_server/net/minecraft/src/BlockPistonBase.java
index 884ffd0..ffad395 100644
--- a/minecraft_server/net/minecraft/src/BlockPistonBase.java
+++ b/minecraft_server/net/minecraft/src/BlockPistonBase.java
@@ -5,7 +5,10 @@ import java.util.List;
 public class BlockPistonBase extends Block
 {
     /** This pistons is the sticky one? */
-    private final boolean isSticky;
+	// FCMOD: Changed
+    //private final boolean isSticky;
+    protected final boolean isSticky;
+    // END FCMOD
 
     public BlockPistonBase(int par1, boolean par2)
     {
@@ -81,7 +84,10 @@ public class BlockPistonBase extends Block
     /**
      * handles attempts to extend or retract the piston.
      */
-    private void updatePistonState(World par1World, int par2, int par3, int par4)
+    // FCMOD: Changed
+    //private void updatePistonState(World par1World, int par2, int par3, int par4)
+    protected void updatePistonState(World par1World, int par2, int par3, int par4)
+    // END FCMOD
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         int var6 = getOrientation(var5);
@@ -184,8 +190,18 @@ public class BlockPistonBase extends Block
                     }
                 }
 
-                if (!var13 && var11 > 0 && canPushBlock(var11, par1World, var8, var9, var10, false) && (Block.blocksList[var11].getMobilityFlag() == 0 || var11 == Block.pistonBase.blockID || var11 == Block.pistonStickyBase.blockID))
+                // FCMOD: Changed
+                //if (!var13 && var11 > 0 && canPushBlock(var11, par1World, var8, var9, var10, false) && (Block.blocksList[var11].getMobilityFlag() == 0 || var11 == Block.pistonBase.blockID || var11 == Block.pistonStickyBase.blockID))
+                Block targetBlock = Block.blocksList[var11];
+                
+                if ( !var13 && targetBlock != null && 
+                	targetBlock.CanBlockBePulledByPiston( par1World, var8, var9, var10, Block.GetOppositeFacing( par6 ) ) )
+                // END FCMOD                	
                 {
+                    // FCMOD: Added
+            		var12 =  targetBlock.AdjustMetadataForPistonMove( var12 );
+                    // END FCMOD
+                    
                     par2 += Facing.offsetsXForSide[par6];
                     par3 += Facing.offsetsYForSide[par6];
                     par4 += Facing.offsetsZForSide[par6];
@@ -329,6 +345,8 @@ public class BlockPistonBase extends Block
     /**
      * returns true if the piston can push the specified block
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     private static boolean canPushBlock(int par0, World par1World, int par2, int par3, int par4, boolean par5)
     {
         if (par0 == Block.obsidian.blockID)
@@ -367,10 +385,14 @@ public class BlockPistonBase extends Block
             return !(Block.blocksList[par0] instanceof ITileEntityProvider);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * checks to see if this piston could push the blocks in front of it.
      */
+    // FCMOD: Removed and replaced in child class
+    /* 
     private static boolean canExtend(World par0World, int par1, int par2, int par3, int par4)
     {
         int var5 = par1 + Facing.offsetsXForSide[par4];
@@ -415,10 +437,14 @@ public class BlockPistonBase extends Block
             return true;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * attempts to extend the piston. returns false if impossible.
      */
+    // FCMOD: Removed and replaced in child class
+    /* 
     private boolean tryExtend(World par1World, int par2, int par3, int par4, int par5)
     {
         int var6 = par2 + Facing.offsetsXForSide[par5];
@@ -515,4 +541,22 @@ public class BlockPistonBase extends Block
             return true;
         }
     }
+    */
+    // END FCMOD
+    
+    // FCMOD: Added New    
+    protected boolean canExtend( World world, int i, int j, int k, int iFacing )
+    {
+    	// intended to be overriden by child class
+    	
+    	return false;
+    }
+    
+    protected boolean tryExtend( World world, int i, int j, int k, int iFacing )
+    {
+    	// intended to be overriden by child class
+    	
+    	return false;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/BlockRailBase.java b/minecraft_server/net/minecraft/src/BlockRailBase.java
index 2630b4c..fba81d0 100644
--- a/minecraft_server/net/minecraft/src/BlockRailBase.java
+++ b/minecraft_server/net/minecraft/src/BlockRailBase.java
@@ -21,14 +21,22 @@ public abstract class BlockRailBase extends Block
      */
     public static final boolean isRailBlock(int par0)
     {
+        // FCMOD: Changed to recognize all rail blocks
+		/*
         return par0 == Block.rail.blockID || par0 == Block.railPowered.blockID || par0 == Block.railDetector.blockID || par0 == Block.railActivator.blockID;
+        */
+    	return Block.blocksList[par0] instanceof BlockRailBase;
+    	// END FCMOD
     }
 
     protected BlockRailBase(int par1, boolean par2)
     {
         super(par1, Material.circuits);
         this.isPowered = par2;
-        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        InitBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        // END FCMOD
         this.setCreativeTab(CreativeTabs.tabTransport);
     }
 
@@ -62,15 +70,21 @@ public abstract class BlockRailBase extends Block
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
+    // FCMOD: Removed
+    /*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
         return super.collisionRayTrace(par1World, par2, par3, par4, par5Vec3, par6Vec3);
     }
+    */
+    // END FCMOD
 
     /**
      * Updates the blocks bounds based on its current state. Args: world, x, y, z
      */
+    // FCMOD: Removed
+    /*
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
@@ -84,6 +98,8 @@ public abstract class BlockRailBase extends Block
             this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * If this block doesn't render as an ordinary block it will return False (examples: signs, buttons, stairs, etc)
@@ -178,6 +194,12 @@ public abstract class BlockRailBase extends Block
 
             if (var8)
             {
+            	// FCMOD: Code added to prevent item duplication since multiple notifications can occur at once
+            	if ( par1World.getBlockId( par2, par3, par4 ) != blockID )
+            	{
+            		return;
+            	}
+            	// END FCMOD
                 this.dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
                 par1World.setBlockToAir(par2, par3, par4);
             }
@@ -235,4 +257,121 @@ public abstract class BlockRailBase extends Block
             par1World.notifyBlocksOfNeighborChange(par2, par3 - 1, par4, par5);
         }
     }
+    
+	// FCMOD: Added New
+	@Override
+	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
+	{
+		return true;
+	}
+	
+	@Override
+	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
+	{
+		int iDirection = iMetadata;
+		
+		if ( isPowered() ) // this should never be true
+		{
+			iDirection &= 7;
+		}
+		
+		if ( iDirection == 0 )
+		{
+			iDirection = 1;
+		}
+		else if ( iDirection == 1 )
+		{
+			iDirection = 0;
+		}
+		// sloped rails
+		else if ( iDirection == 2 )
+		{
+		}
+		else if ( iDirection == 3 )
+		{
+		}
+		else if ( iDirection == 4 )
+		{
+		}
+		else if ( iDirection == 5 )
+		{
+		}
+		// curved rails
+		else if ( iDirection == 6 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 7;
+			}
+			else
+			{
+				iDirection = 9;
+			}
+		}
+		else if ( iDirection == 7 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 8;
+			}
+			else
+			{
+				iDirection = 6;
+			}
+		}
+		else if ( iDirection == 8 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 9;
+			}
+			else
+			{
+				iDirection = 7;
+			}
+		}
+		else if ( iDirection == 9 )
+		{
+			if ( bReverse )
+			{
+				iDirection = 6;
+			}
+			else
+			{
+				iDirection = 8;
+			}
+		}
+		
+		if ( isPowered() ) // this should never be true
+		{
+			iMetadata = (iMetadata & 8) | iDirection;
+		}
+		else
+		{
+			iMetadata = iDirection;
+		}
+		
+		return iMetadata;
+	}
+	
+    @Override
+    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
+    	IBlockAccess blockAccess, int i, int j, int k )
+    {
+        int iDirection = blockAccess.getBlockMetadata( i, j, k );
+
+        if ( iDirection >= 2 && iDirection <= 5 )
+        {
+        	return AxisAlignedBB.getAABBPool().getAABB(         	
+        		0D, 0D, 0D, 1D, 0.625D, 1D );
+        }
+        else
+        {
+        	return AxisAlignedBB.getAABBPool().getAABB(         	
+        		0D, 0D, 0D, 1D, 0.125F, 1D );
+        }
+    }
+    
+	//----------- Client Side Functionality -----------//
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockRedstoneLogic.java b/minecraft_server/net/minecraft/src/BlockRedstoneLogic.java
index 03d437d..0f00c40 100644
--- a/minecraft_server/net/minecraft/src/BlockRedstoneLogic.java
+++ b/minecraft_server/net/minecraft/src/BlockRedstoneLogic.java
@@ -11,7 +11,10 @@ public abstract class BlockRedstoneLogic extends BlockDirectional
     {
         super(par1, Material.circuits);
         this.isRepeaterPowered = par2;
-        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        // FCMOD: Changed
+        //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+        InitBlockBounds( 0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F );
+        // END FCMOD
     }
 
     /**
@@ -346,4 +349,8 @@ public abstract class BlockRedstoneLogic extends BlockDirectional
     {
         return this.func_94487_f(par1);
     }
+    
+    // FCMOD: Added New
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockRedstoneTorch.java b/minecraft_server/net/minecraft/src/BlockRedstoneTorch.java
index cbf2eae..cbd42f9 100644
--- a/minecraft_server/net/minecraft/src/BlockRedstoneTorch.java
+++ b/minecraft_server/net/minecraft/src/BlockRedstoneTorch.java
@@ -6,7 +6,12 @@ import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
+// FCMOD: Change
+/*
 public class BlockRedstoneTorch extends BlockTorch
+*/
+public class BlockRedstoneTorch extends FCBlockTorchBase
+// END FCMOD
 {
     /** Whether the redstone torch is currently active or not. */
     private boolean torchActive = false;
@@ -122,7 +127,13 @@ public class BlockRedstoneTorch extends BlockTorch
     /**
      * Returns true or false based on whether the block the torch is attached to is providing indirect power.
      */
+    // FCMOD: Renamed function to prevent problems for add-on mods
+	/*
     private boolean isIndirectlyPowered(World par1World, int par2, int par3, int par4)
+	*/
+    private boolean isIndirectlyPoweredLocal(World par1World, int par2, int par3, int par4)
+    // END FCMOD
+
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         return var5 == 5 && par1World.getIndirectPowerOutput(par2, par3 - 1, par4, 0) ? true : (var5 == 3 && par1World.getIndirectPowerOutput(par2, par3, par4 - 1, 2) ? true : (var5 == 4 && par1World.getIndirectPowerOutput(par2, par3, par4 + 1, 3) ? true : (var5 == 1 && par1World.getIndirectPowerOutput(par2 - 1, par3, par4, 4) ? true : var5 == 2 && par1World.getIndirectPowerOutput(par2 + 1, par3, par4, 5))));
@@ -133,7 +144,12 @@ public class BlockRedstoneTorch extends BlockTorch
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
+		// FCMOD: Renamed function as per above
+		/*
         boolean var6 = this.isIndirectlyPowered(par1World, par2, par3, par4);
+		*/
+        boolean var6 = this.isIndirectlyPoweredLocal(par1World, par2, par3, par4);
+		// END FCMOD
         List var7 = (List)redstoneUpdateInfoCache.get(par1World);
 
         while (var7 != null && !var7.isEmpty() && par1World.getTotalWorldTime() - ((RedstoneUpdateInfo)var7.get(0)).updateTime > 60L)
@@ -171,6 +187,8 @@ public class BlockRedstoneTorch extends BlockTorch
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
      */
+    // FCMOD: Removed and replaced
+    /*
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)
     {
         if (!this.func_94397_d(par1World, par2, par3, par4, par5))
@@ -183,6 +201,8 @@ public class BlockRedstoneTorch extends BlockTorch
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns true if the block is emitting direct/strong redstone power on the specified side. Args: World, X, Y, Z,
@@ -217,4 +237,27 @@ public class BlockRedstoneTorch extends BlockTorch
     {
         return par1 == Block.torchRedstoneIdle.blockID || par1 == Block.torchRedstoneActive.blockID;
     }
+    
+    // FCMOD: Added new
+	@Override
+    public void onNeighborBlockChange( World world, int i, int j, int k, int iNeighborBlockID )
+    {
+    	if ( !ValidateState( world, i, j, k, iNeighborBlockID ) )    	
+        {
+            boolean bPowered = isIndirectlyPoweredLocal( world, i, j, k );
+
+            if ( torchActive == bPowered &&
+            	!world.IsUpdatePendingThisTickForBlock( i, j, k, blockID ) )            	
+            {
+                world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
+            }
+        }
+    }
+    
+	@Override
+	public boolean TriggersBuddy()
+	{
+		return false;
+	}
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/BlockStationary.java b/minecraft_server/net/minecraft/src/BlockStationary.java
index 68f6f5e..154f33e 100644
--- a/minecraft_server/net/minecraft/src/BlockStationary.java
+++ b/minecraft_server/net/minecraft/src/BlockStationary.java
@@ -66,7 +66,10 @@ public class BlockStationary extends BlockFluid
                 {
                     if (this.isFlammable(par1World, par2 - 1, par3, par4) || this.isFlammable(par1World, par2 + 1, par3, par4) || this.isFlammable(par1World, par2, par3, par4 - 1) || this.isFlammable(par1World, par2, par3, par4 + 1) || this.isFlammable(par1World, par2, par3 - 1, par4) || this.isFlammable(par1World, par2, par3 + 1, par4))
                     {
-                        par1World.setBlock(par2, par3, par4, Block.fire.blockID);
+                    	if (par1World.getGameRules().getGameRuleBooleanValue("doFireTick")) {
+                    		par1World.setBlock(par2, par3, par4, Block.fire.blockID);
+                    	}
+                    	
                         return;
                     }
                 }
diff --git a/minecraft_server/net/minecraft/src/BlockStem.java b/minecraft_server/net/minecraft/src/BlockStem.java
index c794ee3..a1e7fad 100644
--- a/minecraft_server/net/minecraft/src/BlockStem.java
+++ b/minecraft_server/net/minecraft/src/BlockStem.java
@@ -5,7 +5,12 @@ import java.util.Random;
 public class BlockStem extends BlockFlower
 {
     /** Defines if it is a Melon or a Pumpkin that the stem is producing. */
+	// FCMOD: Changed
+	/*
     private final Block fruitType;
+    */
+    protected Block fruitType;
+	// END FCMOD
 
     protected BlockStem(int par1, Block par2Block)
     {
diff --git a/minecraft_server/net/minecraft/src/Chunk.java b/minecraft_server/net/minecraft/src/Chunk.java
index f87d0fd..3f48937 100644
--- a/minecraft_server/net/minecraft/src/Chunk.java
+++ b/minecraft_server/net/minecraft/src/Chunk.java
@@ -204,7 +204,12 @@ public class Chunk
             while (var3 < 16)
             {
                 this.precipitationHeightMap[var2 + (var3 << 4)] = -999;
+                // FCMOD: Changed to match 1.8
+                /*
                 int var4 = var1 + 16 - 1;
+                */
+                int var4 = var1 + 16;
+                // END FCMOD
 
                 while (true)
                 {
@@ -562,10 +567,23 @@ public class Chunk
                 {
                     Block.blocksList[var8].breakBlock(this.worldObj, var12, par2, var13, var8, var9);
                 }
+                // FCMOD: Code change
+                /*
                 else if (Block.blocksList[var8] instanceof ITileEntityProvider && var8 != par4)
                 {
                     this.worldObj.removeBlockTileEntity(var12, par2, var13);
                 }
+                */
+                else if ( var8 != par4 )
+                {
+                    Block.blocksList[var8].ClientBreakBlock(this.worldObj, var12, par2, var13, var8, var9);
+                    
+                    if ( Block.blocksList[var8] instanceof ITileEntityProvider && Block.blocksList[var8].ShouldDeleteTileEntityOnBlockChange( par4 ) )
+                    {
+                    	this.worldObj.removeBlockTileEntity(var12, par2, var13);
+                    }
+                }
+                // END FCMOD
             }
 
             if (var10.getExtBlockID(par1, par2 & 15, par3) != par4)
@@ -605,6 +623,12 @@ public class Chunk
                     {
                         Block.blocksList[par4].onBlockAdded(this.worldObj, var12, par2, var13);
                     }
+                    // FCMOD: Code added
+                    else if ( var8 != par4 )
+                    {
+                        Block.blocksList[par4].ClientBlockAdded(worldObj, var12, par2, var13);
+                    }
+                    // END FCMOD
 
                     if (Block.blocksList[par4] instanceof ITileEntityProvider)
                     {
@@ -1290,4 +1314,56 @@ public class Chunk
             }
         }
     }
+    
+    // FCMOD: Code added
+    public void GetClosestEntityMatchingCriteriaWithinRangeSq( FCClosestEntityInfo closestEntityInfo )
+    {
+    	for ( int iVerticalIndex = closestEntityInfo.m_iChunkEntityListMinVerticalIndex; iVerticalIndex <= closestEntityInfo.m_iChunkEntityListMaxVerticalIndex; iVerticalIndex++ )
+    	{
+            List tempEntityList = entityLists[iVerticalIndex];
+            
+            if ( !tempEntityList.isEmpty() )
+            {            
+            	Iterator entityIterator = tempEntityList.iterator();
+            	
+            	while ( entityIterator.hasNext() )
+            	{
+		        	Entity tempEntity = (Entity)entityIterator.next();
+		        	
+		        	closestEntityInfo.m_criteria.ProcessEntity( closestEntityInfo, tempEntity );
+            	}
+            }
+    	}
+    }
+    
+    public int GetBlockNaturalLightValue( int i, int j, int k, int iSkylightSubtracted )
+    {
+    	// modified version of getBlockLightValue that only considers natural light
+    	
+        ExtendedBlockStorage blockStorage = this.storageArrays[j >> 4];
+
+        if ( blockStorage == null )
+        {
+            return !this.worldObj.provider.hasNoSky && iSkylightSubtracted < EnumSkyBlock.Sky.defaultLightValue ? EnumSkyBlock.Sky.defaultLightValue - iSkylightSubtracted : 0;
+        }
+        else
+        {
+            int iLightValue = this.worldObj.provider.hasNoSky ? 0 : blockStorage.getExtSkylightValue(i, j & 15, k);
+
+            if (iLightValue > 0)
+            {
+                isLit = true;
+            }
+
+            iLightValue -= iSkylightSubtracted;
+            
+            if ( iLightValue < 0 )
+            {
+            	iLightValue = 0;
+            }
+
+            return iLightValue;
+        }
+    }    
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ChunkProviderGenerate.java b/minecraft_server/net/minecraft/src/ChunkProviderGenerate.java
index 9ca95ba..a24fd4b 100644
--- a/minecraft_server/net/minecraft/src/ChunkProviderGenerate.java
+++ b/minecraft_server/net/minecraft/src/ChunkProviderGenerate.java
@@ -80,6 +80,9 @@ public class ChunkProviderGenerate implements IChunkProvider
         this.worldObj = par1World;
         this.mapFeaturesEnabled = par4;
         this.rand = new Random(par2);
+        // FCMOD: Added
+        m_structureRand = new Random(par2);
+        // END FCMOD
         this.noiseGen1 = new NoiseGeneratorOctaves(this.rand, 16);
         this.noiseGen2 = new NoiseGeneratorOctaves(this.rand, 16);
         this.noiseGen3 = new NoiseGeneratorOctaves(this.rand, 8);
@@ -370,48 +373,48 @@ public class ChunkProviderGenerate implements IChunkProvider
                 var17 /= var18;
                 var16 = var16 * 0.9F + 0.1F;
                 var17 = (var17 * 4.0F - 1.0F) / 8.0F;
-                double var46 = this.noise6[var13] / 8000.0D;
+                double var47 = this.noise6[var13] / 8000.0D;
 
-                if (var46 < 0.0D)
+                if (var47 < 0.0D)
                 {
-                    var46 = -var46 * 0.3D;
+                    var47 = -var47 * 0.3D;
                 }
 
-                var46 = var46 * 3.0D - 2.0D;
+                var47 = var47 * 3.0D - 2.0D;
 
-                if (var46 < 0.0D)
+                if (var47 < 0.0D)
                 {
-                    var46 /= 2.0D;
+                    var47 /= 2.0D;
 
-                    if (var46 < -1.0D)
+                    if (var47 < -1.0D)
                     {
-                        var46 = -1.0D;
+                        var47 = -1.0D;
                     }
 
-                    var46 /= 1.4D;
-                    var46 /= 2.0D;
+                    var47 /= 1.4D;
+                    var47 /= 2.0D;
                 }
                 else
                 {
-                    if (var46 > 1.0D)
+                    if (var47 > 1.0D)
                     {
-                        var46 = 1.0D;
+                        var47 = 1.0D;
                     }
 
-                    var46 /= 8.0D;
+                    var47 /= 8.0D;
                 }
 
                 ++var13;
 
-                for (int var47 = 0; var47 < par6; ++var47)
+                for (int var46 = 0; var46 < par6; ++var46)
                 {
                     double var48 = (double)var17;
                     double var26 = (double)var16;
-                    var48 += var46 * 0.2D;
+                    var48 += var47 * 0.2D;
                     var48 = var48 * (double)par6 / 16.0D;
                     double var28 = (double)par6 / 2.0D + var48 * 4.0D;
                     double var30 = 0.0D;
-                    double var32 = ((double)var47 - var28) * 12.0D * 128.0D / 128.0D / var26;
+                    double var32 = ((double)var46 - var28) * 12.0D * 128.0D / 128.0D / var26;
 
                     if (var32 < 0.0D)
                     {
@@ -437,9 +440,9 @@ public class ChunkProviderGenerate implements IChunkProvider
 
                     var30 -= var32;
 
-                    if (var47 > par6 - 4)
+                    if (var46 > par6 - 4)
                     {
-                        double var40 = (double)((float)(var47 - (par6 - 4)) / 3.0F);
+                        double var40 = (double)((float)(var46 - (par6 - 4)) / 3.0F);
                         var30 = var30 * (1.0D - var40) + -10.0D * var40;
                     }
 
@@ -472,15 +475,40 @@ public class ChunkProviderGenerate implements IChunkProvider
         this.rand.setSeed(this.worldObj.getSeed());
         long var7 = this.rand.nextLong() / 2L * 2L + 1L;
         long var9 = this.rand.nextLong() / 2L * 2L + 1L;
+        
+        // FCMOD: Added so that future changes to structure generation will not
+        // impact the other aspects of chunk population
+        long lStructureSeedX = rand.nextLong() / 2L * 2L + 1L;
+        long lStructureSeedZ = rand.nextLong() / 2L * 2L + 1L;        
+        // END FCMOD
+        
         this.rand.setSeed((long)par2 * var7 + (long)par3 * var9 ^ this.worldObj.getSeed());
         boolean var11 = false;
 
         if (this.mapFeaturesEnabled)
         {
+        	// FCNOTE: The structure seed is intentionally not applied to mineshafts given
+        	// how frequent they are, so as not to mess too much with other details throughout the 
+        	// world
             this.mineshaftGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
+        	// FCMOD: Changed  
+            /*
             var11 = this.villageGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
             this.strongholdGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
             this.scatteredFeatureGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
+             */
+            m_structureRand.setSeed((long)par2 * lStructureSeedX + 
+            	(long)par3 * lStructureSeedZ ^ this.worldObj.getSeed());
+            
+            var11 = villageGenerator.generateStructuresInChunk( worldObj, 
+            	m_structureRand, par2, par3 );
+            
+            strongholdGenerator.generateStructuresInChunk( worldObj, 
+            	m_structureRand, par2, par3 );
+            
+            scatteredFeatureGenerator.generateStructuresInChunk( worldObj, 
+            	m_structureRand, par2, par3 );
+            // END FCMOD
         }
 
         int var12;
@@ -543,6 +571,10 @@ public class ChunkProviderGenerate implements IChunkProvider
         }
 
         BlockSand.fallInstantly = false;
+
+        // FCMOD: Added
+        BTWPostProcessChunk( worldObj, var4 - 8, var5 - 8 ); // -8 because of += 8 offset applied above
+        // END FCMOD
     }
 
     /**
@@ -612,4 +644,67 @@ public class ChunkProviderGenerate implements IChunkProvider
             this.scatteredFeatureGenerator.generate(this, this.worldObj, par1, par2, (byte[])null);
         }
     }
+    
+    // FCMOD: Added New    
+    private Random m_structureRand;
+    
+    private void BTWPostProcessChunk( World worldObj, int iChunkX, int iChunkZ )
+    {
+    	if ( worldObj.provider.dimensionId == 0 )
+    	{
+    		GenerateStrata( worldObj, iChunkX, iChunkZ );
+    		GenerateAdditionalBrownMushrooms( worldObj, iChunkX, iChunkZ );
+    	}
+    }    
+    
+    private void GenerateAdditionalBrownMushrooms( World worldObj, int iChunkX, int iChunkZ )
+    {
+        if ( worldObj.rand.nextInt( 4 ) == 0 )
+        {
+        	WorldGenerator mushroomBrownGen = new WorldGenFlowers( Block.mushroomBrown.blockID );    	
+        	
+            int iMushroomX = iChunkX + worldObj.rand.nextInt( 16 ) + 8;
+            int iMushroomY = worldObj.rand.nextInt( 25 );
+            int iMushroomZ = iChunkZ + worldObj.rand.nextInt( 16 ) + 8;
+            
+            mushroomBrownGen.generate( worldObj, worldObj.rand, iMushroomX, iMushroomY, iMushroomZ );
+        }
+    }
+    
+    private void GenerateStrata( World world, int iChunkX, int iChunkZ )
+    {
+        Chunk chunk = world.getChunkFromChunkCoords( iChunkX >> 4, iChunkZ >> 4);
+        
+        for ( int iTempI = 0; iTempI < 16; iTempI++ )
+        {
+        	for ( int iTempK = 0; iTempK < 16; iTempK++ )
+        	{
+        		int iTempJ = 0;
+        		int iStrataHeight = 24 + world.rand.nextInt( 2 );
+        		
+        		for( ; iTempJ <= iStrataHeight; iTempJ++ )
+        		{
+        			int iTempBlockID = chunk.getBlockID( iTempI, iTempJ, iTempK );
+        			
+        			if ( iTempBlockID == Block.stone.blockID )
+        			{
+        				chunk.setBlockMetadata( iTempI, iTempJ, iTempK, 2 );
+        			}
+        		}
+        		
+        		iStrataHeight = 48  + world.rand.nextInt( 2 );
+        		
+        		for( ; iTempJ <= iStrataHeight; iTempJ++ )
+        		{
+        			int iTempBlockID = chunk.getBlockID( iTempI, iTempJ, iTempK );
+        			
+        			if ( iTempBlockID == Block.stone.blockID )
+        			{
+        				chunk.setBlockMetadata( iTempI, iTempJ, iTempK, 1 );
+        			}
+        		}        		
+        	}
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ChunkProviderHell.java b/minecraft_server/net/minecraft/src/ChunkProviderHell.java
index 22103f6..f3e0fb3 100644
--- a/minecraft_server/net/minecraft/src/ChunkProviderHell.java
+++ b/minecraft_server/net/minecraft/src/ChunkProviderHell.java
@@ -25,7 +25,10 @@ public class ChunkProviderHell implements IChunkProvider
     /** Is the world that the nether is getting generated. */
     private World worldObj;
     private double[] noiseField;
-    public MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
+    // FCMOD: Changed
+    //public MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
+    public FCMapGenNetherBridge genNetherBridge = new FCMapGenNetherBridge();
+    // END FCMOD
 
     /**
      * Holds the noise used to determine whether slowsand can be generated at a location
@@ -500,9 +503,14 @@ public class ChunkProviderHell implements IChunkProvider
 
         for (var8 = 0; var8 < 16; ++var8)
         {
-            var9 = var4 + this.hellRNG.nextInt(16);
+        	// FCMOD: changed to fix unnecessary chunk loads and memory leaks
+            //var9 = var4 + this.hellRNG.nextInt(16);
+            //var10 = this.hellRNG.nextInt(108) + 10;
+            //var11 = var5 + this.hellRNG.nextInt(16);
+            var9 = var4 + this.hellRNG.nextInt(16) + 8;
             var10 = this.hellRNG.nextInt(108) + 10;
-            var11 = var5 + this.hellRNG.nextInt(16);
+            var11 = var5 + this.hellRNG.nextInt(16) + 8;
+            // END FCMOD
             (new WorldGenHellLava(Block.lavaMoving.blockID, true)).generate(this.worldObj, this.hellRNG, var9, var10, var11);
         }
 
@@ -549,7 +557,13 @@ public class ChunkProviderHell implements IChunkProvider
      */
     public List getPossibleCreatures(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)
     {
+    	// FCMOD: Code change to loosen spawn restrictions on wither skeletons and blazes
+    	/*
         if (par1EnumCreatureType == EnumCreatureType.monster && this.genNetherBridge.hasStructureAt(par2, par3, par4))
+        */
+        if ( par1EnumCreatureType == EnumCreatureType.monster && 
+        	genNetherBridge.HasStructureAtLoose( par2, par3, par4 ) )
+    	// END FCMOD
         {
             return this.genNetherBridge.getSpawnList();
         }
diff --git a/minecraft_server/net/minecraft/src/ChunkProviderServer.java b/minecraft_server/net/minecraft/src/ChunkProviderServer.java
index 71647df..5a67ce6 100644
--- a/minecraft_server/net/minecraft/src/ChunkProviderServer.java
+++ b/minecraft_server/net/minecraft/src/ChunkProviderServer.java
@@ -47,16 +47,28 @@ public class ChunkProviderServer implements IChunkProvider
         return this.id2ChunkMap.containsItem(ChunkCoordIntPair.chunkXZ2Int(par1, par2));
     }
 
+    // FCMOD: Added (server only) to provide alias to match client naming
+    public void unloadChunksIfNotNearSpawn( int par1, int par2 )
+    {
+        dropChunk( par1, par2 );
+    }
+    // END FCMOD
     public void dropChunk(int par1, int par2)
     {
         if (this.worldObj.provider.canRespawnHere())
         {
+        	// FCCHUNK: Decide on updates around original spawn
+        	// FCMOD: Changed
+        	/*
             ChunkCoordinates var3 = this.worldObj.getSpawnPoint();
             int var4 = par1 * 16 + 8 - var3.posX;
             int var5 = par2 * 16 + 8 - var3.posZ;
             short var6 = 128;
 
             if (var4 < -var6 || var4 > var6 || var5 < -var6 || var5 > var6)
+            */
+        	if ( !IsSpawnChunk( par1, par2 ) )
+        	// END FCMOD
             {
                 this.droppedChunksSet.add(Long.valueOf(ChunkCoordIntPair.chunkXZ2Int(par1, par2)));
             }
@@ -338,4 +350,45 @@ public class ChunkProviderServer implements IChunkProvider
     }
 
     public void recreateStructures(int par1, int par2) {}
+    
+    // FCMOD: Added
+    IChunkProvider GetCurrentProvider()
+    {
+    	// client
+    	//return currentChunkProvider;
+    	// server
+    	return serverChunkGenerator;
+	}
+    
+	protected boolean IsSpawnChunk( int iChunkX, int iChunkZ )
+	{
+		if ( worldObj.provider.canRespawnHere() )
+		{
+		    ChunkCoordinates var3 = this.worldObj.getSpawnPoint();
+		    
+		    // uses the same math as addPlayer in PlayerManager for consistent results
+		    
+		    int iSpawnChunkX = worldObj.worldInfo.getSpawnX() >> 4;
+		    int iSpawnChunkZ = worldObj.worldInfo.getSpawnZ() >> 4;
+		    
+		    int iChunkViewDistance = 
+		    	worldObj.getMinecraftServer().getConfigurationManager().getViewDistance(); 
+	
+		    return iChunkX >= iSpawnChunkX - iChunkViewDistance &&
+		    	iChunkX <= iSpawnChunkX + iChunkViewDistance &&
+			    iChunkZ >= iSpawnChunkZ - iChunkViewDistance &&
+		    	iChunkZ <= iSpawnChunkZ + iChunkViewDistance;
+		}
+		
+		return false;
+	}
+	
+    public void ForceAddToChunksToUnload( int iChunkX, int iChunkZ )
+    {
+    	// client
+        //chunksToUnload.add( Long.valueOf( ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ ) ) );
+    	// server
+    	droppedChunksSet.add( Long.valueOf( ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ ) ) );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/CommandDifficulty.java b/minecraft_server/net/minecraft/src/CommandDifficulty.java
index afcfc55..7be7934 100644
--- a/minecraft_server/net/minecraft/src/CommandDifficulty.java
+++ b/minecraft_server/net/minecraft/src/CommandDifficulty.java
@@ -30,6 +30,12 @@ public class CommandDifficulty extends CommandBase
         if (par2ArrayOfStr.length > 0)
         {
             int var3 = this.getDifficultyForName(par1ICommandSender, par2ArrayOfStr[0]);
+            // FCMOD: Code added to remove peaceful and easy
+            if ( var3 < 2 )
+            {
+            	var3 = 2;
+            }
+            // END FCMOD
             MinecraftServer.getServer().setDifficultyForAllWorlds(var3);
             String var4 = StatCollector.translateToLocal(difficulties[var3]);
             notifyAdmins(par1ICommandSender, "commands.difficulty.success", new Object[] {var4});
diff --git a/minecraft_server/net/minecraft/src/CommandGive.java b/minecraft_server/net/minecraft/src/CommandGive.java
index 402fba0..ab57d97 100644
--- a/minecraft_server/net/minecraft/src/CommandGive.java
+++ b/minecraft_server/net/minecraft/src/CommandGive.java
@@ -49,6 +49,9 @@ public class CommandGive extends CommandBase
                 }
 
                 ItemStack var7 = new ItemStack(var4, var5, var6);
+                // FCMOD: Added
+                var7.getItem().InitializeStackOnGiveCommand( var3.worldObj.rand, var7 );
+                // END FCMOD
                 EntityItem var8 = var3.dropPlayerItem(var7);
                 var8.delayBeforeCanPickup = 0;
                 notifyAdmins(par1ICommandSender, "commands.give.success", new Object[] {Item.itemsList[var4].func_77653_i(var7), Integer.valueOf(var4), Integer.valueOf(var5), var3.getEntityName()});
diff --git a/minecraft_server/net/minecraft/src/CommandTime.java b/minecraft_server/net/minecraft/src/CommandTime.java
index 7afdc23..bb871b9 100644
--- a/minecraft_server/net/minecraft/src/CommandTime.java
+++ b/minecraft_server/net/minecraft/src/CommandTime.java
@@ -57,6 +57,19 @@ public class CommandTime extends CommandBase
                 return;
             }
         }
+        // FCMOD: Code added to display time
+        else
+        {
+	    	par1ICommandSender.sendChatToPlayer( (new StringBuilder()).append( "\247e"). // yellow text
+            	append("Current Overworld Time: " ).
+            	append( Long.valueOf( MinecraftServer.getServer().worldServers[0].getWorldTime() ) ).
+            	append( " Total Overworld Time: " ).
+            	append( Long.valueOf( MinecraftServer.getServer().worldServers[0].getTotalWorldTime() ) ).
+            	toString() );            	
+            
+            return;
+        }
+        // END FCMOD
 
         throw new WrongUsageException("commands.time.usage", new Object[0]);
     }
diff --git a/minecraft_server/net/minecraft/src/ComponentMineshaftCorridor.java b/minecraft_server/net/minecraft/src/ComponentMineshaftCorridor.java
index 9cf80ea..3b5060f 100644
--- a/minecraft_server/net/minecraft/src/ComponentMineshaftCorridor.java
+++ b/minecraft_server/net/minecraft/src/ComponentMineshaftCorridor.java
@@ -199,6 +199,9 @@ public class ComponentMineshaftCorridor extends StructureComponent
             par1World.setBlock(var9, var10, var11, Block.rail.blockID, this.getMetadataWithOffset(Block.rail.blockID, par3Random.nextBoolean() ? 1 : 0), 2);
             EntityMinecartChest var12 = new EntityMinecartChest(par1World, (double)((float)var9 + 0.5F), (double)((float)var10 + 0.5F), (double)((float)var11 + 0.5F));
             WeightedRandomChestContent.generateChestContents(par3Random, par7ArrayOfWeightedRandomChestContent, var12, par8);
+            // FCMOD: Added
+            FilterChestMinecartContents( var12 );
+            // END FCMOD
             par1World.spawnEntityInWorld(var12);
             return true;
         }
@@ -226,7 +229,11 @@ public class ComponentMineshaftCorridor extends StructureComponent
 
             if (this.hasSpiders)
             {
-                this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, Block.web.blockID, 0, false);
+            	// FCMOD: Changed
+                //this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, Block.web.blockID, 0, false);
+                this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, 
+                	FCBetterThanWolves.fcBlockWeb.blockID, 0, false);
+                // END FCMOD            	
             }
 
             int var9;
@@ -236,19 +243,42 @@ public class ComponentMineshaftCorridor extends StructureComponent
             for (var9 = 0; var9 < this.sectionCount; ++var9)
             {
                 var10 = 2 + var9 * 5;
+                // FCMOD: Code change to replace fences by logs
+                /*
                 this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, var10, 0, 1, var10, Block.fence.blockID, 0, false);
                 this.fillWithBlocks(par1World, par3StructureBoundingBox, 2, 0, var10, 2, 1, var10, Block.fence.blockID, 0, false);
-
+                */
+                this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 0, var10, 0, 1, var10, Block.wood.blockID, 0, 0, 0, false);
+                this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 2, 0, var10, 2, 1, var10, Block.wood.blockID, 0, 0, 0, false);
+                // END FCMOD
+
+            	// FCMOD: Code added
+                int iHorizontalLogMetadata = getMetadataWithOffset( Block.wood.blockID, 4 );
+                // END FCMOD
+                
                 if (par2Random.nextInt(4) == 0)
                 {
+                	// FCMOD: Code change
+                	/*
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 0, 2, var10, Block.planks.blockID, 0, false);
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 2, 2, var10, 2, 2, var10, Block.planks.blockID, 0, false);
+                    */
+                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 0, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
+                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 2, 2, var10, 2, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
+                	// END FCMOD
                 }
                 else
                 {
+                	// FCMOD: Code change
+                	/*
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 2, 2, var10, Block.planks.blockID, 0, false);
+                    */
+                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 2, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
+                	// END FCMOD
                 }
 
+                // FCMOD: Changed
+                /*
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 - 1, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 - 1, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 + 1, Block.web.blockID, 0);
@@ -259,6 +289,18 @@ public class ComponentMineshaftCorridor extends StructureComponent
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 + 2, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 - 1, Block.torchWood.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 + 1, Block.torchWood.blockID, 0);
+                */
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 - 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 - 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 + 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 + 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 0, 2, var10 - 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 - 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 0, 2, var10 + 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 + 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 - 1, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8);
+                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 + 1, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8);                
+                // END FCMOD
 
                 if (par2Random.nextInt(100) == 0)
                 {
@@ -320,4 +362,89 @@ public class ComponentMineshaftCorridor extends StructureComponent
             return true;
         }
     }
+    
+    // FCMOD: Added
+    private void FilterChestMinecartContents( EntityMinecartChest minecart )
+    {
+        for ( int iSlot = 0; iSlot < minecart.getSizeInventory(); iSlot++ )
+        {
+            ItemStack tempStack = minecart.getStackInSlot( iSlot );
+            
+            if ( tempStack != null )
+            {
+            	int iItemID = tempStack.itemID;
+
+            	if ( iItemID == Item.ingotIron.itemID )
+            	{
+            		if ( minecart.posY > 36F )
+            		{
+                		minecart.setInventorySlotContents( iSlot, null );
+            		}
+            		else
+            		{
+            			tempStack.stackSize = 1;
+            		}
+            	}
+            	else if ( iItemID == Item.diamond.itemID )
+            	{
+            		if ( minecart.posY > 24F )
+            		{
+                		minecart.setInventorySlotContents( iSlot, null );
+            		}
+            		else
+            		{
+            			tempStack.stackSize = 1;
+            		}
+            	}
+            	else if ( iItemID == Item.pickaxeIron.itemID )
+            	{
+            		minecart.setInventorySlotContents( iSlot, null );
+            	}
+            	else if ( iItemID == Item.redstone.itemID )
+            	{
+            		if ( minecart.posY > 24F )
+            		{
+                		minecart.setInventorySlotContents( iSlot, null );
+            		}
+            	}
+            	else if ( iItemID == Item.pumpkinSeeds.itemID )
+            	{
+            		minecart.setInventorySlotContents( iSlot, null );
+            	}            	
+            }
+        }
+    }
+
+    @Override
+    protected int getMetadataWithOffset( int iBlockID, int iMetadata )
+    {
+    	// override to handle horizontal log placement in supports
+    	
+    	if ( iBlockID == Block.wood.blockID )
+    	{
+            if (this.coordBaseMode == 1 || this.coordBaseMode == 3)
+            {
+            	int iLogType = iMetadata & 3;
+            	int iDirection = iMetadata & 12;
+            	
+            	if ( iDirection == 4 )
+            	{
+            		iDirection = 8;
+            	}
+            	else if ( iDirection == 8 )
+            	{
+            		iDirection = 4;
+            	}
+            	
+            	iMetadata = iLogType | iDirection;
+            }
+            
+    		return iMetadata;
+    	}
+    	else
+    	{
+    		return super.getMetadataWithOffset( iBlockID, iMetadata );
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentNetherBridgeEntrance.java b/minecraft_server/net/minecraft/src/ComponentNetherBridgeEntrance.java
index e721c2f..dea2640 100644
--- a/minecraft_server/net/minecraft/src/ComponentNetherBridgeEntrance.java
+++ b/minecraft_server/net/minecraft/src/ComponentNetherBridgeEntrance.java
@@ -117,6 +117,10 @@ public class ComponentNetherBridgeEntrance extends ComponentNetherBridgePiece
             par1World.scheduledUpdatesAreImmediate = false;
         }
 
+        // FCMOD: Code added
+        placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockSoulforgeDormant.blockID, FCUtilsWorld.RotateFacingForCoordBaseMode( 4, coordBaseMode ), 5, 6, 6, par3StructureBoundingBox );
+        // END FCMOD
+
         return true;
     }
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java b/minecraft_server/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java
index d981adc..de0e729 100644
--- a/minecraft_server/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java
+++ b/minecraft_server/net/minecraft/src/ComponentScatteredFeatureDesertPyramid.java
@@ -4,10 +4,13 @@ import java.util.Random;
 
 public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFeature
 {
+	// FCNOTE: Tracks the loot chests which have already been generated.
     private boolean[] field_74940_h = new boolean[4];
 
     /** List of items to generate in chests of Temples. */
-    private static final WeightedRandomChestContent[] itemsToGenerateInTemple = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // FCMOD: Removed as deprecated
+    //private static final WeightedRandomChestContent[] itemsToGenerateInTemple = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // END FCMOD
 
     public ComponentScatteredFeatureDesertPyramid(Random par1Random, int par2, int par3)
     {
@@ -18,6 +21,8 @@ public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFe
      * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes Mineshafts at
      * the end, it adds Fences...
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, -4, 0, this.scatteredFeatureSizeX - 1, 0, this.scatteredFeatureSizeZ - 1, Block.sandStone.blockID, Block.sandStone.blockID, false);
@@ -222,4 +227,316 @@ public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFe
 
         return true;
     }
+    */
+    // END FCMOD
+    
+    // FCMOD: Added New
+    private static final WeightedRandomChestContent[] m_LootListArray = 
+    	new WeightedRandomChestContent[] {
+    		// item ID, item damage, min stack size, max stack size, weight
+	    	new WeightedRandomChestContent( Item.helmetGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.plateGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.legsGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.bootsGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.swordGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.emerald.itemID, 0, 1, 5, 15 ), 
+	    	new WeightedRandomChestContent( Item.bone.itemID, 0, 4, 6, 20 ), 
+	    	new WeightedRandomChestContent( Item.rottenFlesh.itemID, 0, 3, 7, 11 ),
+	    	new WeightedRandomChestContent( Item.skull.itemID, 0, 1, 1, 5 )
+		};
+    
+    private static final WeightedRandomChestContent[] m_LootedLootListArray = 
+    	new WeightedRandomChestContent[] {
+	    	new WeightedRandomChestContent( Item.bone.itemID, 0, 4, 6, 20 ), 
+	    	new WeightedRandomChestContent( Item.rottenFlesh.itemID, 0, 3, 7, 11 ),
+	    	new WeightedRandomChestContent( Item.skull.itemID, 0, 1, 1, 5 )
+		};
+    
+    public boolean addComponentParts( World world, Random generatorRand, 
+    	StructureBoundingBox boundingBox )
+    {
+    	boolean bIsLooted = FCUtilsHardcoreSpawn.IsInLootedTempleRadius( world, 
+    		boundingBox.getCenterX(), boundingBox.getCenterZ() );
+    	
+    	// All cloth blocks from original have been replaced by obsidian, 
+    	// and allowances made for looted temples
+    	
+        fillWithBlocks(world, boundingBox, 0, -4, 0, this.scatteredFeatureSizeX - 1, 0, this.scatteredFeatureSizeZ - 1, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        int var4;
+
+        for (var4 = 1; var4 <= 9; ++var4)
+        {
+            fillWithBlocks(world, boundingBox, var4, var4, var4, this.scatteredFeatureSizeX - 1 - var4, var4, this.scatteredFeatureSizeZ - 1 - var4, Block.sandStone.blockID, Block.sandStone.blockID, false);
+            fillWithBlocks(world, boundingBox, var4 + 1, var4, var4 + 1, this.scatteredFeatureSizeX - 2 - var4, var4, this.scatteredFeatureSizeZ - 2 - var4, 0, 0, false);
+        }
+
+        int var5;
+
+        for (var4 = 0; var4 < this.scatteredFeatureSizeX; ++var4)
+        {
+            for (var5 = 0; var5 < this.scatteredFeatureSizeZ; ++var5)
+            {
+                fillCurrentPositionBlocksDownwards(world, Block.sandStone.blockID, 0, var4, -5, var5, boundingBox);
+            }
+        }
+
+        var4 = getMetadataWithOffset(Block.stairsSandStone.blockID, 3);
+        var5 = getMetadataWithOffset(Block.stairsSandStone.blockID, 2);
+        
+        int var6 = getMetadataWithOffset(Block.stairsSandStone.blockID, 0);
+        int var7 = getMetadataWithOffset(Block.stairsSandStone.blockID, 1);
+        
+        fillWithBlocks(world, boundingBox, 0, 0, 0, 4, 9, 4, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 1, 10, 1, 3, 10, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 10, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var5, 2, 10, 4, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, 0, 10, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, 4, 10, 2, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 0, 0, this.scatteredFeatureSizeX - 1, 9, 4, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 4, 10, 1, this.scatteredFeatureSizeX - 2, 10, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 10, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var5, this.scatteredFeatureSizeX - 3, 10, 4, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, this.scatteredFeatureSizeX - 5, 10, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, this.scatteredFeatureSizeX - 1, 10, 2, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 8, 0, 0, 12, 4, 4, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 9, 1, 0, 11, 3, 4, 0, 0, false);
+        
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 1, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 2, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 3, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, 3, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 3, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 2, 1, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 1, 1, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 4, 1, 1, 8, 3, 3, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 4, 1, 2, 8, 2, 2, 0, 0, false);
+        fillWithBlocks(world, boundingBox, 12, 1, 1, 16, 3, 3, Block.sandStone.blockID, 0, false);
+        fillWithBlocks(world, boundingBox, 12, 1, 2, 16, 2, 2, 0, 0, false);
+        fillWithBlocks(world, boundingBox, 5, 4, 5, this.scatteredFeatureSizeX - 6, 4, this.scatteredFeatureSizeZ - 6, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 9, 4, 9, 11, 4, 11, 0, 0, false);
+        
+        fillWithMetadataBlocks(world, boundingBox, 8, 1, 8, 8, 3, 8, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 12, 1, 8, 12, 3, 8, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 8, 1, 12, 8, 3, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 12, 1, 12, 12, 3, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        fillWithBlocks(world, boundingBox, 1, 1, 5, 4, 4, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 1, 5, this.scatteredFeatureSizeX - 2, 4, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 6, 7, 9, 6, 7, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 7, 7, 9, this.scatteredFeatureSizeX - 7, 7, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        fillWithMetadataBlocks(world, boundingBox, 5, 5, 9, 5, 7, 11, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, this.scatteredFeatureSizeX - 6, 5, 9, this.scatteredFeatureSizeX - 6, 7, 11, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 5, 5, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 5, 6, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 6, 6, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 6, 5, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 6, 6, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 7, 6, 10, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 2, 4, 4, 2, 6, 4, 0, 0, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 3, 4, 4, this.scatteredFeatureSizeX - 3, 6, 4, 0, 0, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 4, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 3, 4, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 4, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 3, 4, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 1, 1, 3, 2, 2, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 3, 1, 3, this.scatteredFeatureSizeX - 2, 2, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, 0, 1, 1, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, 0, this.scatteredFeatureSizeX - 2, 1, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stoneSingleSlab.blockID, 1, 1, 2, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stoneSingleSlab.blockID, 1, this.scatteredFeatureSizeX - 2, 2, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, 2, 1, 2, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, this.scatteredFeatureSizeX - 3, 1, 2, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 4, 3, 5, 4, 3, 18, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 3, 5, this.scatteredFeatureSizeX - 5, 3, 17, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 3, 1, 5, 4, 2, 16, 0, 0, false);
+        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 6, 1, 5, this.scatteredFeatureSizeX - 5, 2, 16, 0, 0, false);
+        
+        int var10;
+
+        for (var10 = 5; var10 <= 17; var10 += 2)
+        {
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 4, 1, var10, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 4, 2, var10, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, this.scatteredFeatureSizeX - 5, 1, var10, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, this.scatteredFeatureSizeX - 5, 2, var10, boundingBox);
+        }
+
+        // the following is the center tiled portion of the floor, centered on 10, 0, 10
+        
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 7, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 0, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 0, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 8, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 12, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 7, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 13, 0, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 0, 11, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 0, 11, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 12, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 13, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 10, boundingBox);
+
+        for (var10 = 0; var10 <= this.scatteredFeatureSizeX - 1; var10 += this.scatteredFeatureSizeX - 1)
+        {
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 2, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 2, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 2, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 3, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 3, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 3, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 4, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 4, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 4, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 5, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 5, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 5, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 6, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 6, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 6, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 3, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 1, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 2, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 3, boundingBox);
+        }
+
+        for (var10 = 2; var10 <= this.scatteredFeatureSizeX - 3; var10 += this.scatteredFeatureSizeX - 3 - 2)
+        {
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 2, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 2, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 2, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 3, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 3, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 3, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 4, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 4, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 4, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 5, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 5, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 5, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 6, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 6, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 6, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 7, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 7, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 8, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 0, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 8, 0, boundingBox);
+        }
+
+        fillWithMetadataBlocks(world, boundingBox, 8, 4, 0, 12, 6, 0, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 8, 6, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 12, 6, 0, boundingBox);
+        
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 5, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, 5, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 5, 0, boundingBox);
+        
+        fillWithMetadataBlocks(world, boundingBox, 8, -14, 8, 12, -11, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        fillWithMetadataBlocks(world, boundingBox, 8, -10, 8, 12, -10, 12, Block.sandStone.blockID, 1, Block.sandStone.blockID, 1, false);
+        fillWithMetadataBlocks(world, boundingBox, 8, -9, 8, 12, -9, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
+        
+        fillWithBlocks(world, boundingBox, 8, -8, 8, 12, -1, 12, Block.sandStone.blockID, Block.sandStone.blockID, false);
+        fillWithBlocks(world, boundingBox, 9, -11, 9, 11, -1, 11, 0, 0, false);
+        
+        placeBlockAtCurrentPosition(world, Block.pressurePlatePlanks.blockID, 0, 10, -11, 10, boundingBox);
+        
+        fillWithBlocks(world, boundingBox, 9, -13, 9, 11, -13, 11, Block.tnt.blockID, 0, false);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 8, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 8, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 7, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 7, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 12, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 12, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 13, -10, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 13, -11, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -11, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -10, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, -10, 7, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, -11, 7, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -11, 12, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, -10, 12, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, -10, 13, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, -11, 13, boundingBox);
+
+        for ( var10 = 0; var10 < 4; ++var10 )
+        {
+            if ( !field_74940_h[var10] )
+            {
+                int iXOffset = Direction.offsetX[var10] * 2;
+                int iZOffset = Direction.offsetZ[var10] * 2;
+                
+                WeightedRandomChestContent[] lootList = m_LootListArray;
+                int iNumItems = 2 + generatorRand.nextInt( 5 );
+
+            	if ( bIsLooted )
+            	{
+                    lootList = m_LootedLootListArray;
+                    iNumItems /= 2;
+            	}
+            	
+                // creates a modified loot list that includes instantiated items with complex data
+                // such as the following enchanted book with a random enchantment
+                
+            	WeightedRandomChestContent[] moddedLootList =
+                	WeightedRandomChestContent.func_92080_a( lootList, 
+                		new WeightedRandomChestContent[] { 
+            			Item.enchantedBook.func_92114_b( generatorRand ) } );
+            	
+                field_74940_h[var10] = generateStructureChestContents( world, boundingBox, 
+                	generatorRand, 10 + iXOffset, -11, 10 + iZOffset, 
+                	moddedLootList, iNumItems );
+            }
+        }
+
+        if ( bIsLooted )
+        {
+        	// clear the center of the floor for access to the shaft
+        	
+            fillWithBlocks(world, boundingBox, 9, 0, 9, 10, 0, 10, 0, 0, false);
+            
+            // clear out trapped area
+            
+            this.fillWithBlocks(world, boundingBox, 9, -13, 9, 11, -11, 11, 0, 0, false);            
+            
+            // drop a ladder
+            
+            int iLadderFacing = getMetadataWithOffset( Block.ladder.blockID, 5 ); // legacy ladder metadata is straight facing
+            
+            int iLadderMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iLadderFacing ); 
+            
+            for ( int iTempY = -13; iTempY <= 0; iTempY++ )
+            {
+            	placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockLadder.blockID, iLadderMetadata, 
+            		9, iTempY, 9, boundingBox );
+            }            
+        }
+        else
+        {
+        	// place enchanting table at center
+        	
+        	placeBlockAtCurrentPosition(world, Block.enchantmentTable.blockID, 0, 10, 1, 10, boundingBox );
+        }
+        
+        return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java b/minecraft_server/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java
index d1f68fb..ed0a33b 100644
--- a/minecraft_server/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java
+++ b/minecraft_server/net/minecraft/src/ComponentScatteredFeatureJunglePyramid.java
@@ -4,13 +4,19 @@ import java.util.Random;
 
 public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFeature
 {
+	// FCNOTE: These two track the loot chests which have already been generated.
     private boolean field_74947_h;
     private boolean field_74948_i;
-    private boolean field_74945_j;
-    private boolean field_74946_k;
+    
+    // FCMOD: Removed as deprecated
+    //private boolean field_74945_j;
+    //private boolean field_74946_k;
+    // END FCMOD
 
     /** List of Chest contents to be generated in the Jungle Pyramid chests. */
-    private static final WeightedRandomChestContent[] junglePyramidsChestContents = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // FCMOD: Removed as deprecated
+    //private static final WeightedRandomChestContent[] junglePyramidsChestContents = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
+    // END FCMOD
 
     /**
      * List of Dispenser contents to be generated in the Jungle Pyramid dispensers.
@@ -29,6 +35,8 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
      * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes Mineshafts at
      * the end, it adds Fences...
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
         if (!this.func_74935_a(par1World, par3StructureBoundingBox, 0))
@@ -149,6 +157,7 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             this.placeBlockAtCurrentPosition(par1World, Block.tripWireSource.blockID, this.getMetadataWithOffset(Block.tripWireSource.blockID, 1) | 4, 4, -3, 8, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.tripWire.blockID, 4, 2, -3, 8, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.tripWire.blockID, 4, 3, -3, 8, par3StructureBoundingBox);
+            
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 7, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 6, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 5, par3StructureBoundingBox);
@@ -175,7 +184,7 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 9, -3, 5, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.cobblestoneMossy.blockID, 0, 9, -3, 4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 9, -2, 4, par3StructureBoundingBox);
-
+            
             if (!this.field_74946_k)
             {
                 this.field_74946_k = this.generateStructureDispenserContents(par1World, par3StructureBoundingBox, par2Random, 9, -2, 3, 4, junglePyramidsDispenserContents, 2);
@@ -209,13 +218,6 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             this.fillWithRandomizedBlocks(par1World, par3StructureBoundingBox, 8, -3, 8, 8, -3, 10, false, par2Random, junglePyramidsRandomScatteredStones);
             this.fillWithRandomizedBlocks(par1World, par3StructureBoundingBox, 10, -3, 8, 10, -3, 10, false, par2Random, junglePyramidsRandomScatteredStones);
             this.placeBlockAtCurrentPosition(par1World, Block.cobblestoneMossy.blockID, 0, 10, -2, 9, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 8, -2, 9, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 8, -2, 10, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 10, -1, 9, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, 1, 9, -2, 8, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, this.getMetadataWithOffset(Block.pistonStickyBase.blockID, 4), 10, -2, 8, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, this.getMetadataWithOffset(Block.pistonStickyBase.blockID, 4), 10, -1, 8, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.redstoneRepeaterIdle.blockID, this.getMetadataWithOffset(Block.redstoneRepeaterIdle.blockID, 2), 10, -2, 10, par3StructureBoundingBox);
 
             if (!this.field_74948_i)
             {
@@ -225,4 +227,291 @@ public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFe
             return true;
         }
     }
+    */
+    // END FCMOD
+    
+    // FCMOD: Added New
+    private static final WeightedRandomChestContent[] m_LootListArray = 
+    	new WeightedRandomChestContent[] {
+    		// item ID, item damage, min stack size, max stack size, weight
+	    	new WeightedRandomChestContent( Item.pickaxeGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.shovelGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.axeGold.itemID, 0, 1, 1, 2 ), 
+	    	new WeightedRandomChestContent( Item.hoeGold.itemID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( FCBetterThanWolves.fcBlockLightningRod.blockID, 0, 1, 1, 5 ), 
+	    	new WeightedRandomChestContent( Item.emerald.itemID, 0, 1, 5, 15 ), 
+	    	new WeightedRandomChestContent( Item.bowlEmpty.itemID, 0, 1, 1, 10 ), 
+	    	new WeightedRandomChestContent( Item.book.itemID, 0, 2, 4, 25 )
+		};
+    
+    private static final WeightedRandomChestContent[] m_LootedLootListArray = 
+    	new WeightedRandomChestContent[] {
+	    	new WeightedRandomChestContent( Item.bowlEmpty.itemID, 0, 1, 1, 10 ), 
+	    	new WeightedRandomChestContent( Item.book.itemID, 0, 2, 4, 25 )
+		};
+    
+    public boolean addComponentParts( World world, Random generatorRand, 
+    	StructureBoundingBox boundingBox )
+    {
+        if ( !func_74935_a( world, boundingBox, 0 ) )
+        {
+            return false;
+        }
+        
+    	boolean bIsLooted = FCUtilsHardcoreSpawn.IsInLootedTempleRadius( world, 
+    		boundingBox.getCenterX(), boundingBox.getCenterZ() );
+    	
+        int var4 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 3 );
+        int var5 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 2 );
+        int var6 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 0 );
+        int var7 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 1 );
+        
+        fillWithRandomizedBlocks(world, boundingBox, 0, -4, 0, scatteredFeatureSizeX - 1, 0, scatteredFeatureSizeZ - 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 2, 9, 2, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 12, 9, 2, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 3, 2, 2, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 9, 1, 3, 9, 2, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 1, 10, 6, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 13, 10, 6, 13, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 2, 1, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 10, 3, 2, 10, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 3, 2, 9, 3, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 6, 2, 9, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 3, 7, 3, 8, 7, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 8, 4, 7, 8, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        fillWithAir(world, boundingBox, 3, 1, 3, 8, 2, 11);
+        fillWithAir(world, boundingBox, 4, 3, 6, 7, 3, 9);
+        fillWithAir(world, boundingBox, 2, 4, 2, 9, 5, 12);
+        fillWithAir(world, boundingBox, 4, 6, 5, 7, 6, 9);
+        fillWithAir(world, boundingBox, 5, 7, 6, 6, 7, 8);
+        fillWithAir(world, boundingBox, 5, 1, 2, 6, 2, 2);
+        fillWithAir(world, boundingBox, 5, 2, 12, 6, 2, 12);
+        fillWithAir(world, boundingBox, 5, 5, 1, 6, 5, 1);
+        fillWithAir(world, boundingBox, 5, 5, 13, 6, 5, 13);
+        
+        placeBlockAtCurrentPosition(world, 0, 0, 1, 5, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, 5, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 1, 5, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, 0, 0, 10, 5, 9, boundingBox);
+        
+        int var8;
+
+        for ( var8 = 0; var8 <= 14; var8 += 14 )
+        {
+            fillWithRandomizedBlocks(world, boundingBox, 2, 4, var8, 2, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, 4, 4, var8, 4, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, 7, 4, var8, 7, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, 9, 4, var8, 9, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        this.fillWithRandomizedBlocks(world, boundingBox, 5, 6, 0, 6, 6, 0, false, generatorRand, junglePyramidsRandomScatteredStones);
+
+        for (var8 = 0; var8 <= 11; var8 += 11)
+        {
+            for (int var9 = 2; var9 <= 12; var9 += 2)
+            {
+                fillWithRandomizedBlocks(world, boundingBox, var8, 4, var9, var8, 5, var9, false, generatorRand, junglePyramidsRandomScatteredStones);
+            }
+
+            fillWithRandomizedBlocks(world, boundingBox, var8, 6, 5, var8, 6, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
+            fillWithRandomizedBlocks(world, boundingBox, var8, 6, 9, var8, 6, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        fillWithRandomizedBlocks(world, boundingBox, 2, 7, 2, 2, 9, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 9, 7, 2, 9, 9, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 2, 7, 12, 2, 9, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 9, 7, 12, 9, 9, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 9, 4, 4, 9, 4, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, 9, 4, 7, 9, 4, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 9, 10, 4, 9, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, 9, 10, 7, 9, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 5, 9, 7, 6, 9, 7, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 5, 9, 6, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 6, 9, 6, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 5, 9, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 6, 9, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 5, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 6, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 0, 0, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 1, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 2, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 3, 10, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 1, 8, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 2, 9, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 3, 10, boundingBox);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 1, 9, 4, 1, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, 1, 9, 7, 1, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 4, 1, 10, 7, 2, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 5, 4, 5, 6, 4, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var6, 4, 4, 5, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var7, 7, 4, 5, boundingBox);
+
+        for (var8 = 0; var8 < 4; ++var8)
+        {
+            placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 5, 0 - var8, 6 + var8, boundingBox);
+            placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 6, 0 - var8, 6 + var8, boundingBox);
+            fillWithAir(world, boundingBox, 5, 0 - var8, 7 + var8, 6, 0 - var8, 9 + var8);
+        }
+
+        fillWithAir(world, boundingBox, 1, -3, 12, 10, -1, 13);
+        fillWithAir(world, boundingBox, 1, -3, 1, 3, -1, 13);
+        fillWithAir(world, boundingBox, 1, -3, 1, 9, -1, 5);
+
+        for (var8 = 1; var8 <= 13; var8 += 2)
+        {
+            this.fillWithRandomizedBlocks(world, boundingBox, 1, -3, var8, 1, -2, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        for (var8 = 2; var8 <= 12; var8 += 2)
+        {
+            this.fillWithRandomizedBlocks(world, boundingBox, 1, -1, var8, 3, -1, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
+        }
+
+        fillWithRandomizedBlocks(world, boundingBox, 2, -2, 1, 5, -2, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 7, -2, 1, 9, -2, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 6, -3, 1, 6, -3, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        fillWithRandomizedBlocks(world, boundingBox, 6, -1, 1, 6, -1, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 3, -3, 1, boundingBox);
+
+        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 3, -2, 2, boundingBox);
+        
+        placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 9, -3, 4, boundingBox);
+        
+        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 8, -1, 3, boundingBox);
+        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 8, -2, 3, boundingBox);
+
+        if ( !field_74947_h )
+        {
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+            WeightedRandomChestContent[] lootList = m_LootListArray;
+        	int iNumItems = 2 + generatorRand.nextInt( 5 );
+        	
+        	if ( bIsLooted )
+        	{
+                lootList = m_LootedLootListArray;
+                iNumItems /= 2;
+        	}
+        	
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+        	WeightedRandomChestContent[] moddedLootList =
+            	WeightedRandomChestContent.func_92080_a( lootList, 
+            		new WeightedRandomChestContent[] { 
+        			Item.enchantedBook.func_92114_b( generatorRand ) } );
+        	
+            field_74947_h = generateStructureChestContents( world, boundingBox, 
+            	generatorRand, 8, -3, 3, 
+            	moddedLootList, iNumItems );
+        }
+
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 9, -3, 2, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 8, -3, 1, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 4, -3, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 5, -2, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 5, -1, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 6, -3, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 7, -2, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 7, -1, 5, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 8, -3, 5, boundingBox);
+        this.fillWithRandomizedBlocks(world, boundingBox, 9, -1, 1, 9, -1, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
+        this.fillWithAir(world, boundingBox, 8, -3, 8, 10, -1, 10);
+        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 8, -2, 11, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 9, -2, 11, boundingBox);
+        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 10, -2, 11, boundingBox);
+        
+        if ( bIsLooted )
+        {
+        	// knock a hole in the wall where the levers used to be
+        	
+            this.placeBlockAtCurrentPosition(world, 0, 0, 9, -2, 11, boundingBox);
+            this.placeBlockAtCurrentPosition(world, 0, 0, 9, -3, 11, boundingBox);                
+        }
+        
+        this.fillWithRandomizedBlocks(world, boundingBox, 8, -3, 8, 8, -3, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        this.fillWithRandomizedBlocks(world, boundingBox, 10, -3, 8, 10, -3, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
+        
+        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 10, -2, 9, boundingBox);
+        
+        if ( !field_74948_i )
+        {
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+            WeightedRandomChestContent[] lootList = m_LootListArray;
+        	int iNumItems = 2 + generatorRand.nextInt( 5 );
+        	
+        	if ( bIsLooted )
+        	{
+                lootList = m_LootedLootListArray;
+                iNumItems /= 2;
+        	}
+        	
+            // creates a modified loot list that includes instantiated items with complex data
+            // such as the following enchanted book with a random enchantment
+            
+        	WeightedRandomChestContent[] moddedLootList =
+            	WeightedRandomChestContent.func_92080_a( lootList, 
+            		new WeightedRandomChestContent[] { 
+        			Item.enchantedBook.func_92114_b( generatorRand ) } );
+        	
+        	field_74948_i = generateStructureChestContents( world, boundingBox, 
+            	generatorRand, 9, -3, 10, 
+            	moddedLootList, iNumItems );
+        }
+        
+        // Sacrificial altar
+        
+        placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcAestheticOpaque.blockID, FCBlockAestheticOpaque.m_iSubtypeChoppingBlockDirty, 5, 4, 11, boundingBox);
+        placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcAestheticOpaque.blockID, FCBlockAestheticOpaque.m_iSubtypeChoppingBlockDirty, 6, 4, 11, boundingBox);
+        
+        if ( !bIsLooted )
+        {
+        	if ( coordBaseMode != 3 && coordBaseMode != 2 )
+        	{
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockArcaneVessel.blockID, 0, 5, 3, 10, boundingBox);
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcHandCrank.blockID, 0, 6, 3, 10, boundingBox);
+                
+            	FillVesselWithExperience( world, boundingBox, 5, 3, 10 );
+        	}
+        	else
+        	{
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockArcaneVessel.blockID, 0, 6, 3, 10, boundingBox);
+                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcHandCrank.blockID, 0, 5, 3, 10, boundingBox);
+                
+            	FillVesselWithExperience( world, boundingBox, 6, 3, 10 );
+        	}                
+        }
+        else
+        {
+            placeBlockAtCurrentPosition(world, 0, 0, 5, 3, 10, boundingBox);
+            placeBlockAtCurrentPosition(world, 0, 0, 6, 3, 10, boundingBox);
+        }
+
+        return true;
+    }
+    
+    public void FillVesselWithExperience( World world, StructureBoundingBox boundingBox, int iRelativeI, int iRelativeJ, int iRelativeK )
+    {
+        int iAbsoluteI = getXWithOffset( iRelativeI, iRelativeK );
+        int iAbsoluteJ = getYWithOffset( iRelativeJ );
+        int iAbsoluteK = getZWithOffset( iRelativeI, iRelativeK );
+        
+        TileEntity tileEnt = world.getBlockTileEntity( iAbsoluteI, iAbsoluteJ, iAbsoluteK );
+        
+        if ( tileEnt != null && ( tileEnt instanceof FCTileEntityArcaneVessel ) )
+        {
+            FCTileEntityArcaneVessel vesselEnt = (FCTileEntityArcaneVessel)tileEnt;
+            
+            vesselEnt.InitTempleExperience();
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentScatteredFeatureSwampHut.java b/minecraft_server/net/minecraft/src/ComponentScatteredFeatureSwampHut.java
index e4e331e..c330e5b 100644
--- a/minecraft_server/net/minecraft/src/ComponentScatteredFeatureSwampHut.java
+++ b/minecraft_server/net/minecraft/src/ComponentScatteredFeatureSwampHut.java
@@ -41,8 +41,14 @@ public class ComponentScatteredFeatureSwampHut extends ComponentScatteredFeature
             this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 5, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.flowerPot.blockID, 7, 1, 3, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 3, 2, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.cauldron.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+            // FCMOD: Removed
+            //this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 3, 2, 6, par3StructureBoundingBox);
+            //this.placeBlockAtCurrentPosition(par1World, Block.cauldron.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+            // END FCMOD
+            // FCMOD: Code added to add brewing stand to witch huts
+            this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 1, 2, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.brewingStand.blockID, 0, 2, 3, 6, par3StructureBoundingBox);
+            // END FCMOD
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 2, 1, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 5, 2, 1, par3StructureBoundingBox);
             int var4 = this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3);
@@ -64,6 +70,13 @@ public class ComponentScatteredFeatureSwampHut extends ComponentScatteredFeature
                 }
             }
 
+            // FCMOD: Added
+            if ( !m_bHasLootBasket )
+            {
+            	AddLootBasket( par1World, par3StructureBoundingBox, 3, 2, 6 );
+            }
+            // END FCMOD
+            
             if (!this.hasWitch)
             {
                 var8 = this.getXWithOffset(2, 5);
@@ -73,14 +86,114 @@ public class ComponentScatteredFeatureSwampHut extends ComponentScatteredFeature
                 if (par3StructureBoundingBox.isVecInside(var8, var9, var10))
                 {
                     this.hasWitch = true;
-                    EntityWitch var11 = new EntityWitch(par1World);
+                    // FCMOD: Changed
+                    //EntityWitch var11 = new EntityWitch(par1World);
+                    FCEntityWitch var11 = new FCEntityWitch(par1World);
+                    var11.PreInitCreature();
+                    // END FCMOD
                     var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
                     var11.initCreature();
+                    // FCMOD: Added
+                    var11.SetPersistent( true );
+                    // END FCMOD
                     par1World.spawnEntityInWorld(var11);
                 }
+                
+            	// FCMOD: Added
+            	SpawnAdditionalWitches( par1World );
+            	// END FCMOD
             }
 
             return true;
         }
     }
+    
+    // FCMOD: Added
+    private boolean m_bHasLootBasket = false;
+    
+    private static FCUtilsRandomItemStack[] m_LootBasketContents = null;
+    
+    private void InitContentsArray()
+    {
+    	m_LootBasketContents = new FCUtilsRandomItemStack[] {
+    		new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemHempSeeds.itemID, 0, 1, 4, 5 ),  
+        	new FCUtilsRandomItemStack( Item.glassBottle.itemID, 0, 2, 8, 10 ),  
+        	new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemMushroomRed.itemID, 0, 5, 16, 5 )
+        }; 
+    }
+    
+    private void SpawnAdditionalWitches( World world )
+    {
+    	int iNumWitches = 2;
+    	
+    	if ( !hasWitch )
+    	{
+    		iNumWitches++;
+    	}
+
+    	// constrain spawning to the chunk containing the structure component that we know is loaded
+    	// note that we can't rely on neighboring chunks with a component, like we can with a structure
+    	
+        int iMinSpawnX = ( boundingBox.minX >> 4 ) << 4;
+        int iMinSpawnZ = ( boundingBox.minZ >> 4 ) << 4;
+        
+        int iSpawnZoneWidth = 16;
+    	
+    	for ( int iTempCount = 0; iTempCount < iNumWitches; iTempCount++ )
+    	{
+    		for ( int iTempTries = 0; iTempTries < 20; iTempTries++ )
+    		{
+    			int x = iMinSpawnX + world.rand.nextInt( iSpawnZoneWidth );
+    			int z = iMinSpawnZ + world.rand.nextInt( iSpawnZoneWidth );
+    			
+    			int y = world.getTopSolidOrLiquidBlock( x, z );
+    			
+    			if (SpawnerAnimals.canEntitySpawnDuringWorldGen(FCEntityWitch.class, world, x, y, z ))
+				{
+                    hasWitch = true;
+                    
+                    FCEntityWitch witch = new FCEntityWitch( world );
+                    
+                    // FCMOD: Added
+                    witch.PreInitCreature();
+                    // END FCMOD
+                    witch.setLocationAndAngles( (double)x + 0.5D, (double)y, (double)z + 0.5D, 0.0F, 0.0F);                    
+                    witch.initCreature();                    
+                    witch.SetPersistent( true );
+                    
+                    world.spawnEntityInWorld( witch );
+                    
+                    break;
+				}
+    		}
+    	}
+    }
+    
+    private void AddLootBasket( World world, StructureBoundingBox boundingBox, int iRelX, int iRelY, int iRelZ )
+    {
+    	if ( m_LootBasketContents == null )
+    	{
+    		// only initialize array on first use to ensure referenced mod items are intialized
+    		InitContentsArray();
+    	}
+    	
+    	int i = getXWithOffset( iRelX, iRelZ );
+        int j = getYWithOffset( iRelY );
+        int k = getZWithOffset( iRelX, iRelZ );
+    	
+        if ( boundingBox.isVecInside( i, j, k) && world.getBlockId( i, j, k ) != FCBetterThanWolves.fcBlockBasketWicker.blockID )
+        {
+        	m_bHasLootBasket = true;
+        	
+	    	world.setBlock( i, j, k, FCBetterThanWolves.fcBlockBasketWicker.blockID, world.rand.nextInt( 4 ) | 4, 2 );
+	    	
+	    	FCTileEntityBasketWicker tileEntity = (FCTileEntityBasketWicker)world.getBlockTileEntity( i, j, k );
+	    	
+	    	if ( tileEntity != null )
+	    	{
+	    		tileEntity.SetStorageStack( FCUtilsRandomItemStack.GetRandomStack( world.rand, m_LootBasketContents ) );
+	    	}
+        }	    	
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentStrongholdLibrary.java b/minecraft_server/net/minecraft/src/ComponentStrongholdLibrary.java
index b47bdc4..2628695 100644
--- a/minecraft_server/net/minecraft/src/ComponentStrongholdLibrary.java
+++ b/minecraft_server/net/minecraft/src/ComponentStrongholdLibrary.java
@@ -111,6 +111,8 @@ public class ComponentStrongholdLibrary extends ComponentStronghold
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 9, 6, 11, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 8, 6, 11, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 9, 6, 10, par3StructureBoundingBox);
+                // FCMOD: Changed
+                /*
                 var7 = this.getMetadataWithOffset(Block.ladder.blockID, 3);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 1, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 2, 13, par3StructureBoundingBox);
@@ -119,6 +121,18 @@ public class ComponentStrongholdLibrary extends ComponentStronghold
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 5, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 6, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 7, 13, par3StructureBoundingBox);
+                */
+                int iFacing = getMetadataWithOffset( Block.ladder.blockID, 3 ); // legacy ladder metadata is straight facing
+                int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
+                
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 1, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 2, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 3, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 4, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 5, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 6, 13, par3StructureBoundingBox);
+                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 7, 13, par3StructureBoundingBox);
+                // END FCMOD
                 byte var8 = 7;
                 byte var9 = 7;
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, var8 - 1, 9, var9, par3StructureBoundingBox);
diff --git a/minecraft_server/net/minecraft/src/ComponentStrongholdRoomCrossing.java b/minecraft_server/net/minecraft/src/ComponentStrongholdRoomCrossing.java
index 8db732d..49bf67c 100644
--- a/minecraft_server/net/minecraft/src/ComponentStrongholdRoomCrossing.java
+++ b/minecraft_server/net/minecraft/src/ComponentStrongholdRoomCrossing.java
@@ -139,9 +139,19 @@ public class ComponentStrongholdRoomCrossing extends ComponentStronghold
                         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 8, 3, var4, par3StructureBoundingBox);
                     }
 
+                    // FCMOD: Changed
+                    /*
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 1, 3, par3StructureBoundingBox);
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 2, 3, par3StructureBoundingBox);
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 3, 3, par3StructureBoundingBox);
+	                */
+	                int iFacing = getMetadataWithOffset( Block.ladder.blockID, 4 ); // legacy ladder metadata is straight facing
+	                int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
+	                
+                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 1, 3, par3StructureBoundingBox );
+                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 2, 3, par3StructureBoundingBox );
+                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 3, 3, par3StructureBoundingBox );
+	                // END FCMOD
                     this.generateStructureChestContents(par1World, par3StructureBoundingBox, par2Random, 3, 4, 8, WeightedRandomChestContent.func_92080_a(strongholdRoomCrossingChestContents, new WeightedRandomChestContent[] {Item.enchantedBook.func_92114_b(par2Random)}), 1 + par2Random.nextInt(4));
             }
 
diff --git a/minecraft_server/net/minecraft/src/ComponentVillage.java b/minecraft_server/net/minecraft/src/ComponentVillage.java
index 13fa952..c9a8186 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillage.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillage.java
@@ -5,234 +5,282 @@ import java.util.Random;
 
 abstract class ComponentVillage extends StructureComponent
 {
-    /** The number of villagers that have been spawned in this component. */
-    private int villagersSpawned;
-
-    /** The starting piece of the village. */
-    protected ComponentVillageStartPiece startPiece;
-
-    protected ComponentVillage(ComponentVillageStartPiece par1ComponentVillageStartPiece, int par2)
-    {
-        super(par2);
-        this.startPiece = par1ComponentVillageStartPiece;
-    }
-
-    /**
-     * Gets the next village component, with the bounding box shifted -1 in the X and Z direction.
-     */
-    protected StructureComponent getNextComponentNN(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
-    {
-        switch (this.coordBaseMode)
-        {
-            case 0:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
-
-            case 1:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
-
-            case 2:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
-
-            case 3:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
-
-            default:
-                return null;
-        }
-    }
-
-    /**
-     * Gets the next village component, with the bounding box shifted +1 in the X and Z direction.
-     */
-    protected StructureComponent getNextComponentPP(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
-    {
-        switch (this.coordBaseMode)
-        {
-            case 0:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
-
-            case 1:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
-
-            case 2:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
-
-            case 3:
-                return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
-
-            default:
-                return null;
-        }
-    }
-
-    /**
-     * Discover the y coordinate that will serve as the ground level of the supplied BoundingBox. (A median of all the
-     * levels in the BB's horizontal rectangle).
-     */
-    protected int getAverageGroundLevel(World par1World, StructureBoundingBox par2StructureBoundingBox)
-    {
-        int var3 = 0;
-        int var4 = 0;
-
-        for (int var5 = this.boundingBox.minZ; var5 <= this.boundingBox.maxZ; ++var5)
-        {
-            for (int var6 = this.boundingBox.minX; var6 <= this.boundingBox.maxX; ++var6)
-            {
-                if (par2StructureBoundingBox.isVecInside(var6, 64, var5))
-                {
-                    var3 += Math.max(par1World.getTopSolidOrLiquidBlock(var6, var5), par1World.provider.getAverageGroundLevel());
-                    ++var4;
-                }
-            }
-        }
-
-        if (var4 == 0)
-        {
-            return -1;
-        }
-        else
-        {
-            return var3 / var4;
-        }
-    }
-
-    protected static boolean canVillageGoDeeper(StructureBoundingBox par0StructureBoundingBox)
-    {
-        return par0StructureBoundingBox != null && par0StructureBoundingBox.minY > 10;
-    }
-
-    /**
-     * Spawns a number of villagers in this component. Parameters: world, component bounding box, x offset, y offset, z
-     * offset, number of villagers
-     */
-    protected void spawnVillagers(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6)
-    {
-        if (this.villagersSpawned < par6)
-        {
-            for (int var7 = this.villagersSpawned; var7 < par6; ++var7)
-            {
-                int var8 = this.getXWithOffset(par3 + var7, par5);
-                int var9 = this.getYWithOffset(par4);
-                int var10 = this.getZWithOffset(par3 + var7, par5);
-
-                if (!par2StructureBoundingBox.isVecInside(var8, var9, var10))
-                {
-                    break;
-                }
-
-                ++this.villagersSpawned;
+	/** The number of villagers that have been spawned in this component. */
+	private int villagersSpawned;
+
+	/** The starting piece of the village. */
+	protected ComponentVillageStartPiece startPiece;
+
+	protected ComponentVillage(ComponentVillageStartPiece par1ComponentVillageStartPiece, int par2)
+	{
+		super(par2);
+		this.startPiece = par1ComponentVillageStartPiece;
+	}
+
+	/**
+	 * Gets the next village component, with the bounding box shifted -1 in the X and Z direction.
+	 */
+	protected StructureComponent getNextComponentNN(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
+	{
+		switch (this.coordBaseMode)
+		{
+		case 0:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
+
+		case 1:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
+
+		case 2:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX - 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 1, this.getComponentType());
+
+		case 3:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.minZ - 1, 2, this.getComponentType());
+
+		default:
+			return null;
+		}
+	}
+
+	/**
+	 * Gets the next village component, with the bounding box shifted +1 in the X and Z direction.
+	 */
+	protected StructureComponent getNextComponentPP(ComponentVillageStartPiece par1ComponentVillageStartPiece, List par2List, Random par3Random, int par4, int par5)
+	{
+		switch (this.coordBaseMode)
+		{
+		case 0:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
+
+		case 1:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
+
+		case 2:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.maxX + 1, this.boundingBox.minY + par4, this.boundingBox.minZ + par5, 3, this.getComponentType());
+
+		case 3:
+			return StructureVillagePieces.getNextStructureComponent(par1ComponentVillageStartPiece, par2List, par3Random, this.boundingBox.minX + par5, this.boundingBox.minY + par4, this.boundingBox.maxZ + 1, 0, this.getComponentType());
+
+		default:
+			return null;
+		}
+	}
+
+	/**
+	 * Discover the y coordinate that will serve as the ground level of the supplied BoundingBox. (A median of all the
+	 * levels in the BB's horizontal rectangle).
+	 */
+	protected int getAverageGroundLevel(World par1World, StructureBoundingBox par2StructureBoundingBox)
+	{
+		int var3 = 0;
+		int var4 = 0;
+
+		for (int var5 = this.boundingBox.minZ; var5 <= this.boundingBox.maxZ; ++var5)
+		{
+			for (int var6 = this.boundingBox.minX; var6 <= this.boundingBox.maxX; ++var6)
+			{
+				if (par2StructureBoundingBox.isVecInside(var6, 64, var5))
+				{
+					var3 += Math.max(par1World.getTopSolidOrLiquidBlock(var6, var5), par1World.provider.getAverageGroundLevel());
+					++var4;
+				}
+			}
+		}
+
+		if (var4 == 0)
+		{
+			return -1;
+		}
+		else
+		{
+			return var3 / var4;
+		}
+	}
+
+	protected static boolean canVillageGoDeeper(StructureBoundingBox par0StructureBoundingBox)
+	{
+		return par0StructureBoundingBox != null && par0StructureBoundingBox.minY > 10;
+	}
+
+	/**
+	 * Spawns a number of villagers in this component. Parameters: world, component bounding box, x offset, y offset, z
+	 * offset, number of villagers
+	 */
+	protected void spawnVillagers(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6)
+	{
+		// FCMOD: Code added
+		int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+
+		boolean bDirtyPeasants = false;
+
+		if ( iAbandonmentLevel > 1 )
+		{
+			if ( par1World.rand.nextInt( 20 ) != 0 )
+			{
+				// only a small chance villagers will spawn in fully abandoned villages
+
+				return;
+			}    		
+			else if ( par6 > 1 )
+			{
+				// and in small dirty numbers if they do
+
+				par6 = 1;    			
+			}
+
+			bDirtyPeasants = true;
+		}
+		// END FCMOD
+
+		if (this.villagersSpawned < par6)
+		{
+			for (int var7 = this.villagersSpawned; var7 < par6; ++var7)
+			{
+				int var8 = this.getXWithOffset(par3 + var7, par5);
+				int var9 = this.getYWithOffset(par4);
+				int var10 = this.getZWithOffset(par3 + var7, par5);
+
+				if (!par2StructureBoundingBox.isVecInside(var8, var9, var10))
+				{
+					break;
+				}
+
+				++this.villagersSpawned;
+
+				// FCMOD: Change
+				/*
                 EntityVillager var11 = new EntityVillager(par1World, this.getVillagerType(var7));
-                var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
-                par1World.spawnEntityInWorld(var11);
-            }
-        }
-    }
-
-    /**
-     * Returns the villager type to spawn in this component, based on the number of villagers already spawned.
-     */
-    protected int getVillagerType(int par1)
-    {
-        return 0;
-    }
-
-    /**
-     * Gets the replacement block for the current biome
-     */
-    protected int getBiomeSpecificBlock(int par1, int par2)
-    {
-        if (this.startPiece.inDesert)
-        {
-            if (par1 == Block.wood.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-
-            if (par1 == Block.cobblestone.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-
-            if (par1 == Block.planks.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-
-            if (par1 == Block.stairsWoodOak.blockID)
-            {
-                return Block.stairsSandStone.blockID;
-            }
-
-            if (par1 == Block.stairsCobblestone.blockID)
-            {
-                return Block.stairsSandStone.blockID;
-            }
-
-            if (par1 == Block.gravel.blockID)
-            {
-                return Block.sandStone.blockID;
-            }
-        }
-
-        return par1;
-    }
-
-    /**
-     * Gets the replacement block metadata for the current biome
-     */
-    protected int getBiomeSpecificBlockMetadata(int par1, int par2)
-    {
-        if (this.startPiece.inDesert)
-        {
-            if (par1 == Block.wood.blockID)
-            {
-                return 0;
-            }
-
-            if (par1 == Block.cobblestone.blockID)
-            {
-                return 0;
-            }
-
-            if (par1 == Block.planks.blockID)
-            {
-                return 2;
-            }
-        }
-
-        return par2;
-    }
-
-    /**
-     * current Position depends on currently set Coordinates mode, is computed here
-     */
-    protected void placeBlockAtCurrentPosition(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
-    {
-        int var8 = this.getBiomeSpecificBlock(par2, par3);
-        int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
-        super.placeBlockAtCurrentPosition(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
-    }
-
-    /**
-     * arguments: (World worldObj, StructureBoundingBox structBB, int minX, int minY, int minZ, int maxX, int maxY, int
-     * maxZ, int placeBlockId, int replaceBlockId, boolean alwaysreplace)
-     */
-    protected void fillWithBlocks(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6, int par7, int par8, int par9, int par10, boolean par11)
-    {
-        int var12 = this.getBiomeSpecificBlock(par9, 0);
-        int var13 = this.getBiomeSpecificBlockMetadata(par9, 0);
-        int var14 = this.getBiomeSpecificBlock(par10, 0);
-        int var15 = this.getBiomeSpecificBlockMetadata(par10, 0);
-        super.fillWithMetadataBlocks(par1World, par2StructureBoundingBox, par3, par4, par5, par6, par7, par8, var12, var13, var14, var15, par11);
-    }
-
-    /**
-     * Overwrites air and liquids from selected position downwards, stops at hitting anything else.
-     */
-    protected void fillCurrentPositionBlocksDownwards(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
-    {
-        int var8 = this.getBiomeSpecificBlock(par2, par3);
-        int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
-        super.fillCurrentPositionBlocksDownwards(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
-    }
+				 */
+				EntityLiving var11;
+
+				int iVillagerType = this.getVillagerType(var7);
+
+				if ( iVillagerType != 0 && iAbandonmentLevel > 0 )
+				{
+					if ( iAbandonmentLevel > 1 || ( iVillagerType != 3 && iVillagerType != 4 ) ) // fully abandoned or not blacksmith or butcher
+					{
+						continue;
+					}
+				}
+
+				FCEntityZombie zombieVillager = new FCEntityZombie( par1World );
+
+				zombieVillager.m_iVillagerClass = iVillagerType;
+				zombieVillager.SetPersistent( true );                	
+				zombieVillager.setVillager( true );
+
+				var11 = zombieVillager;
+				
+				var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
+				par1World.spawnEntityInWorld(var11);
+			}
+		}
+	}
+
+	/**
+	 * Returns the villager type to spawn in this component, based on the number of villagers already spawned.
+	 */
+	protected int getVillagerType(int par1)
+	{
+		return 0;
+	}
+
+	/**
+	 * Gets the replacement block for the current biome
+	 */
+	protected int getBiomeSpecificBlock(int par1, int par2)
+	{
+		if (this.startPiece.inDesert)
+		{
+			if (par1 == Block.wood.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+
+			if (par1 == Block.cobblestone.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+
+			if (par1 == Block.planks.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+
+			if (par1 == Block.stairsWoodOak.blockID)
+			{
+				return Block.stairsSandStone.blockID;
+			}
+
+			if (par1 == Block.stairsCobblestone.blockID)
+			{
+				return Block.stairsSandStone.blockID;
+			}
+
+			if (par1 == Block.gravel.blockID)
+			{
+				return Block.sandStone.blockID;
+			}
+		}
+
+		return par1;
+	}
+
+	/**
+	 * Gets the replacement block metadata for the current biome
+	 */
+	protected int getBiomeSpecificBlockMetadata(int par1, int par2)
+	{
+		if (this.startPiece.inDesert)
+		{
+			if (par1 == Block.wood.blockID)
+			{
+				return 0;
+			}
+
+			if (par1 == Block.cobblestone.blockID)
+			{
+				return 0;
+			}
+
+			if (par1 == Block.planks.blockID)
+			{
+				return 2;
+			}
+		}
+
+		return par2;
+	}
+
+	/**
+	 * current Position depends on currently set Coordinates mode, is computed here
+	 */
+	protected void placeBlockAtCurrentPosition(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
+	{
+		int var8 = this.getBiomeSpecificBlock(par2, par3);
+		int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
+		super.placeBlockAtCurrentPosition(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
+	}
+
+	/**
+	 * arguments: (World worldObj, StructureBoundingBox structBB, int minX, int minY, int minZ, int maxX, int maxY, int
+	 * maxZ, int placeBlockId, int replaceBlockId, boolean alwaysreplace)
+	 */
+	protected void fillWithBlocks(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6, int par7, int par8, int par9, int par10, boolean par11)
+	{
+		int var12 = this.getBiomeSpecificBlock(par9, 0);
+		int var13 = this.getBiomeSpecificBlockMetadata(par9, 0);
+		int var14 = this.getBiomeSpecificBlock(par10, 0);
+		int var15 = this.getBiomeSpecificBlockMetadata(par10, 0);
+		super.fillWithMetadataBlocks(par1World, par2StructureBoundingBox, par3, par4, par5, par6, par7, par8, var12, var13, var14, var15, par11);
+	}
+
+	/**
+	 * Overwrites air and liquids from selected position downwards, stops at hitting anything else.
+	 */
+	protected void fillCurrentPositionBlocksDownwards(World par1World, int par2, int par3, int par4, int par5, int par6, StructureBoundingBox par7StructureBoundingBox)
+	{
+		int var8 = this.getBiomeSpecificBlock(par2, par3);
+		int var9 = this.getBiomeSpecificBlockMetadata(par2, par3);
+		super.fillCurrentPositionBlocksDownwards(par1World, var8, var9, par4, par5, par6, par7StructureBoundingBox);
+	}
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageChurch.java b/minecraft_server/net/minecraft/src/ComponentVillageChurch.java
index 89277d8..9d68fd5 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageChurch.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageChurch.java
@@ -65,6 +65,8 @@ public class ComponentVillageChurch extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 3), 3, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 1), 1, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 0), 3, 2, 7, par3StructureBoundingBox);
+        // FCMOD: Code change
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
@@ -84,17 +86,76 @@ public class ComponentVillageChurch extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 4, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 3, 4, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 4, 5, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 6, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 7, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 6, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 7, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 3, 8, par3StructureBoundingBox);
+
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 4, 7, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 4, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 3, 4, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 4, 5, par3StructureBoundingBox);
+    	}
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 6, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 7, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 6, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 7, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 6, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 7, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 3, 8, par3StructureBoundingBox);
+        }
+        // END FCMOD
         int var4 = this.getMetadataWithOffset(Block.ladder.blockID, 4);
         int var5;
 
         for (var5 = 1; var5 <= 9; ++var5)
         {
-            this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, var5, 3, par3StructureBoundingBox);
+        	// FCMOD: Changed
+            //this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, var5, 3, par3StructureBoundingBox);
+            int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, var4 );
+            
+            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, var5, 3, par3StructureBoundingBox);
+            // END FCMOD
         }
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        // FCMOD: Changed
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel == 0 )
+        {
+            placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+    	// END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
         {
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageField.java b/minecraft_server/net/minecraft/src/ComponentVillageField.java
index 8804122..2eeb9ae 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageField.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageField.java
@@ -44,7 +44,10 @@ public class ComponentVillageField extends ComponentVillage
                 return Block.potato.blockID;
 
             default:
-                return Block.crops.blockID;
+            	// FCMOD: Changed
+                //return Block.crops.blockID;
+                return FCBetterThanWolves.fcBlockWheatCrop.blockID;
+                // END FCMOD
         }
     }
 
@@ -60,6 +63,13 @@ public class ComponentVillageField extends ComponentVillage
      */
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
+    	// FCMOD: Added
+        cropTypeA = startPiece.GetPrimaryCropBlockID( par1World );
+        cropTypeB = cropTypeA;
+        cropTypeC = cropTypeA;
+        cropTypeD = startPiece.GetSecondaryCropBlockID( par1World );
+        // END FCMOD
+        
         if (this.averageGroundLevel < 0)
         {
             this.averageGroundLevel = this.getAverageGroundLevel(par1World, par3StructureBoundingBox);
@@ -73,21 +83,74 @@ public class ComponentVillageField extends ComponentVillage
         }
 
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 0, 12, 4, 8, 0, 0, false);
+    	// FCMOD: Changed
+    	/*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
+        */
+    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+    	
+    	if ( iAbandonmentLevel <= 1 )
+    	{
+            fillWithBlocks( par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+    	}
+    	else
+    	{
+            fillWithBlocks( par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks( par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+    	}
+    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, 0, 0, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 0, 0, 6, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 12, 0, 0, 12, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 0, 11, 0, 0, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 8, 11, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
+    	// FCMOD: Changed
+        /*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 0, 1, 9, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
+        */
+    	if ( iAbandonmentLevel <= 1 )
+        {
+            this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
+            this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 0, 1, 9, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
+        }
+        // END FCMOD
         int var4;
 
         for (var4 = 1; var4 <= 7; ++var4)
         {
+        	// FCMOD: Changed
+        	/*
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 1, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 2, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 4, 1, var4, par3StructureBoundingBox);
@@ -96,6 +159,74 @@ public class ComponentVillageField extends ComponentVillage
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeC, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 8, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeD, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 10, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeD, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 11, 1, var4, par3StructureBoundingBox);
+            */
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	1, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	2, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	4, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	5, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeC, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	7, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeC, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	8, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeD, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	10, 1, var4, par3StructureBoundingBox);
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeD, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	11, 1, var4, par3StructureBoundingBox);
+        	// END FCMOD
+            
+            // FCMOD: Added
+        	if ( iAbandonmentLevel > 1 )
+            {
+            	// delete all generated crops after placing so as not to disturb random number generator
+            	
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 7, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 10, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 11, 1, var4, par3StructureBoundingBox);
+            }
+        	else if ( iAbandonmentLevel == 1 )
+        	{
+        		// randomly destroy some of the crops to give the impression of the field being only partially tended
+        		
+        		for ( int iTempCount = 1; iTempCount <= 10; iTempCount += 3 )
+        		{
+        			// use the world random so as not to mess with generation
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount, 1, var4, par3StructureBoundingBox);
+        			}
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount + 1, 1, var4, par3StructureBoundingBox);
+        			}
+        		}
+        	}
+            // END FCMOD
         }
 
         for (var4 = 0; var4 < 9; ++var4)
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageField2.java b/minecraft_server/net/minecraft/src/ComponentVillageField2.java
index 5243eeb..f8f2e22 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageField2.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageField2.java
@@ -36,7 +36,10 @@ public class ComponentVillageField2 extends ComponentVillage
                 return Block.potato.blockID;
 
             default:
-                return Block.crops.blockID;
+            	// FCMOD: Changed
+                //return Block.crops.blockID;
+                return FCBetterThanWolves.fcBlockWheatCrop.blockID;
+                // END FCMOD
         }
     }
 
@@ -52,6 +55,11 @@ public class ComponentVillageField2 extends ComponentVillage
      */
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
+    	// FCMOD: Added
+        cropTypeA = startPiece.GetPrimaryCropBlockID( par1World );
+        cropTypeB = startPiece.GetSecondaryCropBlockID( par1World );
+    	// END FCMOD
+        
         if (this.averageGroundLevel < 0)
         {
             this.averageGroundLevel = this.getAverageGroundLevel(par1World, par3StructureBoundingBox);
@@ -65,21 +73,99 @@ public class ComponentVillageField2 extends ComponentVillage
         }
 
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 0, 6, 4, 8, 0, 0, false);
+    	// FCMOD: Changed
+    	/*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
+        */
+    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+    	if ( iAbandonmentLevel <= 1 )
+    	{
+            fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+            
+            fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, 
+            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
+    	}
+    	else
+    	{
+            fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+            
+            fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
+            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
+    	}
+    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, 0, 0, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 0, 0, 6, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 0, 5, 0, 0, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 8, 5, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
+        // FCMOD: Added
+    	if ( iAbandonmentLevel <= 1 )
+    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
         int var4;
 
         for (var4 = 1; var4 <= 7; ++var4)
         {
+        	// FCMOD: Changed
+        	/*
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 1, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 2, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 4, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 5, 1, var4, par3StructureBoundingBox);
+            */
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	1, 1, var4, par3StructureBoundingBox );
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeA, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	2, 1, var4, par3StructureBoundingBox );
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	4, 1, var4, par3StructureBoundingBox );
+            
+            placeBlockAtCurrentPosition( par1World, cropTypeB, 
+            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
+            	5, 1, var4, par3StructureBoundingBox );
+        	// END FCMOD
+            
+            // FCMOD: Added
+        	if ( iAbandonmentLevel > 1 )
+            {
+            	// delete all generated crops after placing so as not to disturb random number generator
+            	
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 1, var4, par3StructureBoundingBox);
+                this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, var4, par3StructureBoundingBox);
+            }
+        	else if ( iAbandonmentLevel == 1 )
+        	{
+        		// randomly destroy some of the crops to give the impression of the field being only partially tended
+        		
+        		for ( int iTempCount = 1; iTempCount <= 4; iTempCount += 3 )
+        		{
+        			// use the world random so as not to mess with generation
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount, 1, var4, par3StructureBoundingBox);
+        			}
+        			
+        			if ( par1World.rand.nextInt( 3 ) != 0 )
+        			{
+                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount + 1, 1, var4, par3StructureBoundingBox);
+        			}
+        		}
+        	}        		
+            // END FCMOD
         }
 
         for (var4 = 0; var4 < 9; ++var4)
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageHall.java b/minecraft_server/net/minecraft/src/ComponentVillageHall.java
index 93aebac..fc94328 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageHall.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageHall.java
@@ -77,6 +77,8 @@ public class ComponentVillageHall extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 4, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
@@ -85,8 +87,42 @@ public class ComponentVillageHall extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+    	}
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
+        }
+        // END FCMOD
+        // FCMOD: Code change to replace pressure plate tables with actual mod tables
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 2, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 2, 2, 3, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	2, 1, 3, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3), 2, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 1), 1, 1, 3, par3StructureBoundingBox);
@@ -95,8 +131,17 @@ public class ComponentVillageHall extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 6, 1, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel <= 1 )
+        {
+        	placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
+            placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
+            	this.getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+        // END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
         {
@@ -105,8 +150,17 @@ public class ComponentVillageHall extends ComponentVillage
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 6, 3, 4, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 6, 3, 4, par3StructureBoundingBox);
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 6, 3, 4, par3StructureBoundingBox);
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, 
+            	this.getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+        // END FCMOD
 
         for (var6 = 0; var6 < 5; ++var6)
         {
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageHouse1.java b/minecraft_server/net/minecraft/src/ComponentVillageHouse1.java
index 4edf6ab..1c86b50 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageHouse1.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageHouse1.java
@@ -69,6 +69,8 @@ public class ComponentVillageHouse1 extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 2, 5, 7, 4, 5, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 8, 2, 1, 8, 4, 4, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 2, 0, 7, 4, 0, Block.planks.blockID, Block.planks.blockID, false);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
@@ -87,6 +89,54 @@ public class ComponentVillageHouse1 extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
+    	}
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 3, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 3, 3, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 5, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
+        }        	
+        // END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 4, 1, 7, 4, 1, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 4, 4, 7, 4, 4, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 3, 4, 7, 3, 4, Block.bookShelf.blockID, Block.bookShelf.blockID, false);
@@ -97,14 +147,33 @@ public class ComponentVillageHouse1 extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 5, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 4, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 3, 1, 4, par3StructureBoundingBox);
+        // FCMOD: Code change to replace pressure plate tables with actual mod tables
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 6, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 4, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 4, 2, 3, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 7, 1, 1, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	6, 1, 3, par3StructureBoundingBox);
+        
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	4, 1, 3, par3StructureBoundingBox);
+        // FCMOD
+        
+        // FCMOD: Removed
+        //this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 7, 1, 1, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 2, 0, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        // FCMOD: Changed
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+    	// END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 1, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 1, -1, -1, par3StructureBoundingBox) != 0)
         {
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageHouse2.java b/minecraft_server/net/minecraft/src/ComponentVillageHouse2.java
index dee4293..c591249 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageHouse2.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageHouse2.java
@@ -58,21 +58,70 @@ public class ComponentVillageHouse2 extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 5, 1, 0, 5, 3, 0, Block.fence.blockID, Block.fence.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 1, 0, 9, 3, 0, Block.fence.blockID, Block.fence.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 1, 4, 9, 4, 6, Block.cobblestone.blockID, Block.cobblestone.blockID, false);
-        this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox);
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox);
+        //this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox);
+        placeBlockAtCurrentPosition( par1World, Block.waterMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox );
+        placeBlockAtCurrentPosition( par1World, Block.waterMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox );
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.fenceIron.blockID, 0, 9, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fenceIron.blockID, 0, 9, 2, 4, par3StructureBoundingBox);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 7, 2, 4, 8, 2, 5, 0, 0, false);
         this.placeBlockAtCurrentPosition(par1World, Block.cobblestone.blockID, 0, 6, 1, 3, par3StructureBoundingBox);
+        // FCMOD: Changed
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.furnaceIdle.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.furnaceIdle.blockID, 0, 6, 3, 3, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 8, 1, 1, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockFurnaceBrickIdle.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
+            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockFurnaceBrickIdle.blockID, 0, 6, 3, 3, par3StructureBoundingBox);
+    	}
+        // END FCMOD
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 8, 1, 1, par3StructureBoundingBox);
+        if ( iAbandonmentLevel == 0 )
+    	{
+        	placeBlockAtCurrentPosition(par1World, Block.anvil.blockID, par1World.rand.nextInt( 4 ), 8, 1, 1, par3StructureBoundingBox);
+    	}
+        // END FCMOD
+        
+        // FCMOD: Changed to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+        */
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
+        }
+        else
+        {
+        	// cut out holes where windows normally are
+        	
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 6, par3StructureBoundingBox);
+        }        	
+        // END FCMOD
+        // FCMOD: Changed to replace pressure plate tables with actual mod tables
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 2, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+        	2, 1, 4, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3), 2, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 1), 1, 1, 4, par3StructureBoundingBox);
@@ -89,6 +138,25 @@ public class ComponentVillageHouse2 extends ComponentVillage
             {
                 this.hasMadeChest = true;
                 this.generateStructureChestContents(par1World, par3StructureBoundingBox, par2Random, 5, 1, 5, villageBlacksmithChestContents, 3 + par2Random.nextInt(6));
+                // FCMOD: Added
+                if ( startPiece.GetAbandonmentLevel( par1World ) > 0 )
+                {
+                	// delete the chest after generation so as not to mess with the terrain generator
+                	
+                    int iChestI = getXWithOffset( 5, 5 );
+                    int iChestJ = getYWithOffset( 1 );
+                    int iChestK = getZWithOffset( 5, 5 );
+                    
+                    TileEntityChest chestEnt = (TileEntityChest)par1World.getBlockTileEntity( iChestI, iChestJ, iChestK );
+                    
+                    if ( chestEnt != null )
+                    {
+                    	FCUtilsInventory.ClearInventoryContents( chestEnt );
+                    }
+                	
+                    placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, 5, par3StructureBoundingBox);                    
+                }
+                // END FCMOD
             }
         }
 
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageHouse3.java b/minecraft_server/net/minecraft/src/ComponentVillageHouse3.java
index b39acc1..a18b476 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageHouse3.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageHouse3.java
@@ -108,34 +108,89 @@ public class ComponentVillageHouse3 extends ComponentVillage
             }
         }
 
+        // FCMOD: Code added to remove glass from abandoned villages
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        int iGlassBlockID = 0;
+        
+        if ( iAbandonmentLevel == 0 )
+        {
+        	iGlassBlockID = Block.thinGlass.blockID;
+        }
+        // END FCMOD
+        
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 0, 2, 2, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 0, 2, 3, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 5, 2, 0, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 1, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 2, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 3, par3StructureBoundingBox);        
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 8, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 6, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 8, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 7, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 8, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 9, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 8, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 2, 2, 7, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 2, 2, 8, par3StructureBoundingBox);
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 2, 2, 9, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 4, 4, 10, par3StructureBoundingBox);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 4, 10, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 5, 4, 10, par3StructureBoundingBox);
+        // END FCMOD        
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 6, 4, 10, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 5, 5, 10, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( iAbandonmentLevel <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+        // END FCMOD
+        	
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, -1, 3, 2, -1, 0, 0, false);
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageHouse4_Garden.java b/minecraft_server/net/minecraft/src/ComponentVillageHouse4_Garden.java
index 88b45cc..b234e86 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageHouse4_Garden.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageHouse4_Garden.java
@@ -58,9 +58,27 @@ public class ComponentVillageHouse4_Garden extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 1, 0, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 1, 1, 4, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 4, 3, 3, 4, Block.planks.blockID, Block.planks.blockID, false);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
+    	}
+        else
+        {
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 4, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 2, par3StructureBoundingBox);
+        }
+        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 3, 0, par3StructureBoundingBox);
@@ -100,14 +118,31 @@ public class ComponentVillageHouse4_Garden extends ComponentVillage
 
         if (this.isRoofAccessible)
         {
+            // FCMOD: Changed
+        	/*
             var4 = this.getMetadataWithOffset(Block.ladder.blockID, 3);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 1, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 2, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 3, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 4, 3, par3StructureBoundingBox);
+            */
+            int iFacing = getMetadataWithOffset( Block.ladder.blockID, 3 ); // legacy ladder metadata is straight facing
+            int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
+            
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 1, 3, par3StructureBoundingBox );
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 2, 3, par3StructureBoundingBox );
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 3, 3, par3StructureBoundingBox );
+            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 4, 3, par3StructureBoundingBox );
+            // END FCMOD
         }
 
-        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        // FCMOD: Changed
+        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
+        }
+        // END FCMOD
 
         for (var4 = 0; var4 < 5; ++var4)
         {
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageStartPiece.java b/minecraft_server/net/minecraft/src/ComponentVillageStartPiece.java
index 1eec37b..922e28e 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageStartPiece.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageStartPiece.java
@@ -37,4 +37,94 @@ public class ComponentVillageStartPiece extends ComponentVillageWell
     {
         return this.worldChunkMngr;
     }
+    
+    // FCMOD: Code added
+    private int m_iAbandonmentLevel;  // 0 = not abandoned, 1 = partially abandoned 2 = fully abandonded
+    private int m_iPrimaryCropBlockID;
+    private int m_iSecondaryCropBlockID;
+    private boolean m_bModSpecificDataInitialized = false;
+
+    public int GetAbandonmentLevel( World world )
+    {
+    	CheckIfModSpecificDataRequiresInit( world );
+    	
+    	return m_iAbandonmentLevel;
+    }
+    
+    public int GetPrimaryCropBlockID( World world )
+    {
+    	CheckIfModSpecificDataRequiresInit( world );
+    	
+    	return m_iPrimaryCropBlockID;
+    }
+    
+    public int GetSecondaryCropBlockID( World world )
+    {
+    	CheckIfModSpecificDataRequiresInit( world );
+    	
+    	return m_iSecondaryCropBlockID;
+    }
+    
+    private void CheckIfModSpecificDataRequiresInit( World world )
+    {
+    	if ( !m_bModSpecificDataInitialized )
+    	{
+    		InitializeModSpecificData( world );    		
+    	}
+    }
+    
+    private void InitializeModSpecificData( World world )
+    {    	
+		m_bModSpecificDataInitialized = true;
+		m_iAbandonmentLevel = 0;
+    	
+    	int iSpawnX = world.getWorldInfo().getSpawnX();
+    	int iSpawnZ = world.getWorldInfo().getSpawnZ();
+    	
+    	int iVillageX = boundingBox.getCenterX();
+    	int iVillageZ = boundingBox.getCenterZ();
+    	
+    	double dDeltaX = (double)( iSpawnX - iVillageX );
+    	double dDeltaZ = (double)( iSpawnZ - iVillageZ );
+    	
+    	double dDistSqFromSpawn = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;    	
+    	double dAbandonedRadius = FCUtilsHardcoreSpawn.GetAbandonedVillageRadius();
+    	
+    	if ( dDistSqFromSpawn < ( dAbandonedRadius * dAbandonedRadius ) )
+    	{
+    		m_iAbandonmentLevel = 2;
+    	}
+    	else
+    	{
+    		double dPartiallyAbandonedRadius = FCUtilsHardcoreSpawn.GetPartiallyAbandonedVillageRadius();
+    		
+    		if ( dDistSqFromSpawn < ( dPartiallyAbandonedRadius * dPartiallyAbandonedRadius ) )
+    		{    		
+        		m_iAbandonmentLevel = 1;
+        		
+    			m_iPrimaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    			m_iSecondaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    		}
+    		else
+    		{	
+    			m_iPrimaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    			
+    			int iRandomFactor = world.rand.nextInt( 6 ); 
+    			
+    			if ( iRandomFactor == 5 )
+    			{
+    				m_iSecondaryCropBlockID = Block.potato.blockID;
+    			}
+    			else if ( iRandomFactor == 4 )
+    			{
+    				m_iSecondaryCropBlockID = Block.carrot.blockID;
+    			}
+    			else
+    			{
+    				m_iSecondaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
+    			}
+    		}
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageTorch.java b/minecraft_server/net/minecraft/src/ComponentVillageTorch.java
index ae477c5..3bae64b 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageTorch.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageTorch.java
@@ -42,11 +42,24 @@ public class ComponentVillageTorch extends ComponentVillage
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 0, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 2, 0, par3StructureBoundingBox);
+        // FCMOD: Code change
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.cloth.blockID, 15, 1, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 0, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 3, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 3, -1, par3StructureBoundingBox);
+        */
+        this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 1, 1, 3, 0, par3StructureBoundingBox);
+        
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 0, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 3, 1, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 0, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 3, -1, par3StructureBoundingBox);
+        }
+        // END FCMOD        
         return true;
     }
 }
diff --git a/minecraft_server/net/minecraft/src/ComponentVillageWoodHut.java b/minecraft_server/net/minecraft/src/ComponentVillageWoodHut.java
index 0384b47..c82a740 100644
--- a/minecraft_server/net/minecraft/src/ComponentVillageWoodHut.java
+++ b/minecraft_server/net/minecraft/src/ComponentVillageWoodHut.java
@@ -73,18 +73,48 @@ public class ComponentVillageWoodHut extends ComponentVillage
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 1, 1, 3, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 0, 2, 3, 0, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 4, 2, 3, 4, Block.planks.blockID, Block.planks.blockID, false);
+        // FCMOD: Code change to remove glass from abandoned villages
+        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 2, par3StructureBoundingBox);
+        */
+        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
+        
+        if ( iAbandonmentLevel == 0 )
+    	{
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 2, par3StructureBoundingBox);
+    	}
+        else
+        {
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 2, par3StructureBoundingBox);
+        }
+        // END FCMOD
 
         if (this.tablePosition > 0)
         {
+            // FCMOD: Code change to replace pressure plate tables with actual mod tables
+            /*
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, this.tablePosition, 1, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, this.tablePosition, 2, 3, par3StructureBoundingBox);
+            */
+            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
+            	this.tablePosition, 1, 3, par3StructureBoundingBox);
+        	// END FCMOD
         }
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 2, 0, par3StructureBoundingBox);
-        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        
+        // FCMOD: Changed
+        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
+        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
+        {
+            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, 
+            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
+        }
+    	// END FCMOD
 
         if (this.getBlockIdAtCurrentPosition(par1World, 1, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 1, -1, -1, par3StructureBoundingBox) != 0)
         {
diff --git a/minecraft_server/net/minecraft/src/Container.java b/minecraft_server/net/minecraft/src/Container.java
index ad690f1..09c5ba3 100644
--- a/minecraft_server/net/minecraft/src/Container.java
+++ b/minecraft_server/net/minecraft/src/Container.java
@@ -225,8 +225,8 @@ public abstract class Container
         else
         {
             Slot var16;
-            int var19;
-            ItemStack var22;
+            int var21;
+            ItemStack var23;
 
             if ((par3 == 0 || par3 == 1) && (par2 == 0 || par2 == 1))
             {
@@ -288,7 +288,7 @@ public abstract class Container
                     if (var16 != null)
                     {
                         var17 = var16.getStack();
-                        ItemStack var20 = var6.getItemStack();
+                        ItemStack var19 = var6.getItemStack();
 
                         if (var17 != null)
                         {
@@ -297,18 +297,18 @@ public abstract class Container
 
                         if (var17 == null)
                         {
-                            if (var20 != null && var16.isItemValid(var20))
+                            if (var19 != null && var16.isItemValid(var19))
                             {
-                                var19 = par2 == 0 ? var20.stackSize : 1;
+                                var21 = par2 == 0 ? var19.stackSize : 1;
 
-                                if (var19 > var16.getSlotStackLimit())
+                                if (var21 > var16.getSlotStackLimit())
                                 {
-                                    var19 = var16.getSlotStackLimit();
+                                    var21 = var16.getSlotStackLimit();
                                 }
 
-                                var16.putStack(var20.splitStack(var19));
+                                var16.putStack(var19.splitStack(var21));
 
-                                if (var20.stackSize == 0)
+                                if (var19.stackSize == 0)
                                 {
                                     var6.setItemStack((ItemStack)null);
                                 }
@@ -316,11 +316,11 @@ public abstract class Container
                         }
                         else if (var16.canTakeStack(par4EntityPlayer))
                         {
-                            if (var20 == null)
+                            if (var19 == null)
                             {
-                                var19 = par2 == 0 ? var17.stackSize : (var17.stackSize + 1) / 2;
-                                var22 = var16.decrStackSize(var19);
-                                var6.setItemStack(var22);
+                                var21 = par2 == 0 ? var17.stackSize : (var17.stackSize + 1) / 2;
+                                var23 = var16.decrStackSize(var21);
+                                var6.setItemStack(var23);
 
                                 if (var17.stackSize == 0)
                                 {
@@ -329,45 +329,45 @@ public abstract class Container
 
                                 var16.onPickupFromSlot(par4EntityPlayer, var6.getItemStack());
                             }
-                            else if (var16.isItemValid(var20))
+                            else if (var16.isItemValid(var19))
                             {
-                                if (var17.itemID == var20.itemID && var17.getItemDamage() == var20.getItemDamage() && ItemStack.areItemStackTagsEqual(var17, var20))
+                                if (var17.itemID == var19.itemID && var17.getItemDamage() == var19.getItemDamage() && ItemStack.areItemStackTagsEqual(var17, var19))
                                 {
-                                    var19 = par2 == 0 ? var20.stackSize : 1;
+                                    var21 = par2 == 0 ? var19.stackSize : 1;
 
-                                    if (var19 > var16.getSlotStackLimit() - var17.stackSize)
+                                    if (var21 > var16.getSlotStackLimit() - var17.stackSize)
                                     {
-                                        var19 = var16.getSlotStackLimit() - var17.stackSize;
+                                        var21 = var16.getSlotStackLimit() - var17.stackSize;
                                     }
 
-                                    if (var19 > var20.getMaxStackSize() - var17.stackSize)
+                                    if (var21 > var19.getMaxStackSize() - var17.stackSize)
                                     {
-                                        var19 = var20.getMaxStackSize() - var17.stackSize;
+                                        var21 = var19.getMaxStackSize() - var17.stackSize;
                                     }
 
-                                    var20.splitStack(var19);
+                                    var19.splitStack(var21);
 
-                                    if (var20.stackSize == 0)
+                                    if (var19.stackSize == 0)
                                     {
                                         var6.setItemStack((ItemStack)null);
                                     }
 
-                                    var17.stackSize += var19;
+                                    var17.stackSize += var21;
                                 }
-                                else if (var20.stackSize <= var16.getSlotStackLimit())
+                                else if (var19.stackSize <= var16.getSlotStackLimit())
                                 {
-                                    var16.putStack(var20);
+                                    var16.putStack(var19);
                                     var6.setItemStack(var17);
                                 }
                             }
-                            else if (var17.itemID == var20.itemID && var20.getMaxStackSize() > 1 && (!var17.getHasSubtypes() || var17.getItemDamage() == var20.getItemDamage()) && ItemStack.areItemStackTagsEqual(var17, var20))
+                            else if (var17.itemID == var19.itemID && var19.getMaxStackSize() > 1 && (!var17.getHasSubtypes() || var17.getItemDamage() == var19.getItemDamage()) && ItemStack.areItemStackTagsEqual(var17, var19))
                             {
-                                var19 = var17.stackSize;
+                                var21 = var17.stackSize;
 
-                                if (var19 > 0 && var19 + var20.stackSize <= var20.getMaxStackSize())
+                                if (var21 > 0 && var21 + var19.stackSize <= var19.getMaxStackSize())
                                 {
-                                    var20.stackSize += var19;
-                                    var17 = var16.decrStackSize(var19);
+                                    var19.stackSize += var21;
+                                    var17 = var16.decrStackSize(var21);
 
                                     if (var17.stackSize == 0)
                                     {
@@ -391,34 +391,34 @@ public abstract class Container
                 {
                     var17 = var6.getStackInSlot(par2);
                     boolean var18 = var17 == null || var16.inventory == var6 && var16.isItemValid(var17);
-                    var19 = -1;
+                    var21 = -1;
 
                     if (!var18)
                     {
-                        var19 = var6.getFirstEmptyStack();
-                        var18 |= var19 > -1;
+                        var21 = var6.getFirstEmptyStack();
+                        var18 |= var21 > -1;
                     }
 
                     if (var16.getHasStack() && var18)
                     {
-                        var22 = var16.getStack();
-                        var6.setInventorySlotContents(par2, var22.copy());
+                        var23 = var16.getStack();
+                        var6.setInventorySlotContents(par2, var23.copy());
 
                         if ((var16.inventory != var6 || !var16.isItemValid(var17)) && var17 != null)
                         {
-                            if (var19 > -1)
+                            if (var21 > -1)
                             {
                                 var6.addItemStackToInventory(var17);
-                                var16.decrStackSize(var22.stackSize);
+                                var16.decrStackSize(var23.stackSize);
                                 var16.putStack((ItemStack)null);
-                                var16.onPickupFromSlot(par4EntityPlayer, var22);
+                                var16.onPickupFromSlot(par4EntityPlayer, var23);
                             }
                         }
                         else
                         {
-                            var16.decrStackSize(var22.stackSize);
+                            var16.decrStackSize(var23.stackSize);
                             var16.putStack(var17);
-                            var16.onPickupFromSlot(par4EntityPlayer, var22);
+                            var16.onPickupFromSlot(par4EntityPlayer, var23);
                         }
                     }
                     else if (!var16.getHasStack() && var17 != null && var16.isItemValid(var17))
@@ -458,15 +458,15 @@ public abstract class Container
                 if (var17 != null && (var16 == null || !var16.getHasStack() || !var16.canTakeStack(par4EntityPlayer)))
                 {
                     var9 = par2 == 0 ? 0 : this.inventorySlots.size() - 1;
-                    var19 = par2 == 0 ? 1 : -1;
+                    var21 = par2 == 0 ? 1 : -1;
 
-                    for (int var21 = 0; var21 < 2; ++var21)
+                    for (int var20 = 0; var20 < 2; ++var20)
                     {
-                        for (int var23 = var9; var23 >= 0 && var23 < this.inventorySlots.size() && var17.stackSize < var17.getMaxStackSize(); var23 += var19)
+                        for (int var22 = var9; var22 >= 0 && var22 < this.inventorySlots.size() && var17.stackSize < var17.getMaxStackSize(); var22 += var21)
                         {
-                            Slot var24 = (Slot)this.inventorySlots.get(var23);
+                            Slot var24 = (Slot)this.inventorySlots.get(var22);
 
-                            if (var24.getHasStack() && func_94527_a(var24, var17, true) && var24.canTakeStack(par4EntityPlayer) && this.func_94530_a(var17, var24) && (var21 != 0 || var24.getStack().stackSize != var24.getStack().getMaxStackSize()))
+                            if (var24.getHasStack() && func_94527_a(var24, var17, true) && var24.canTakeStack(par4EntityPlayer) && this.func_94530_a(var17, var24) && (var20 != 0 || var24.getStack().stackSize != var24.getStack().getMaxStackSize()))
                             {
                                 int var14 = Math.min(var17.getMaxStackSize() - var17.stackSize, var24.getStack().stackSize);
                                 ItemStack var15 = var24.decrStackSize(var14);
@@ -558,6 +558,8 @@ public abstract class Container
     /**
      * merges provided ItemStack with the first avaliable one in the container/player inventory
      */
+    // FCMOD: Removed and replaced later
+    /*
     protected boolean mergeItemStack(ItemStack par1ItemStack, int par2, int par3, boolean par4)
     {
         boolean var5 = false;
@@ -647,6 +649,8 @@ public abstract class Container
 
         return var5;
     }
+    */
+    // END FCMOD
 
     public static int func_94529_b(int par0)
     {
@@ -728,4 +732,169 @@ public abstract class Container
             return MathHelper.floor_float(var2 * 14.0F) + (var1 > 0 ? 1 : 0);
         }
     }
+    
+    // FCMOD: Added
+    protected boolean mergeItemStack( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap, boolean bFavorHotbar )
+    {
+    	// test of specific player inv size shouldn't be necessary, but serves as a sanity check
+    	
+    	if ( bFavorHotbar && iSlotDestCap - iSlotDestFirst == 36 )
+    	{
+        	// favor the hotbar from left to right, then the main inventory, whereas vanilla
+    		// just reverses the order from last slot of hotbar to first of inv.
+    		
+        	return MergeItemStackFavoringHotbar( stackSource, iSlotDestFirst, iSlotDestCap );
+    	}
+    	else
+    	{    	
+    		return mergeItemStack( stackSource, iSlotDestFirst, iSlotDestCap );
+    	}
+    }
+    
+	protected boolean mergeItemStack( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap )
+	{
+	    boolean bMerged = false;
+	    
+	    if ( stackSource.isStackable() )
+	    {
+	    	// look for destination stacks already containing the same item type
+	    	
+		    for ( int iTempSlot = iSlotDestFirst; 
+		    	iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {
+		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    if ( stackSource.stackSize > 0 )
+	    {
+	    	// look for empty destination stacks
+	    	
+		    for ( int iTempSlot = iSlotDestFirst; 
+	    		iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {	
+		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    return bMerged;
+	}
+    
+	protected boolean MergeItemStackFavoringHotbar( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap )
+	{
+	    boolean bMerged = false;
+
+	    if ( stackSource.isStackable() )
+	    {
+	    	// look for destination stacks already containing the same item type
+	    	
+		    for ( int iTempSlot = iSlotDestCap - 9; 
+		    	iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {
+		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
+	        }
+		    
+		    for ( int iTempSlot = iSlotDestFirst; 
+	    		iTempSlot < iSlotDestCap - 9 && stackSource.stackSize > 0; iTempSlot++ )
+		    {
+		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    if ( stackSource.stackSize > 0 )
+	    {
+	    	// look for empty destination stacks
+	    	
+		    for ( int iTempSlot = iSlotDestCap - 9; 
+	    		iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
+	        {	
+		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
+	        }
+	    	
+		    for ( int iTempSlot = iSlotDestFirst; 
+    			iTempSlot < iSlotDestCap - 9 && stackSource.stackSize > 0; iTempSlot++ )
+	        {	
+		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
+	        }
+	    }
+	
+	    return bMerged;
+	}
+    
+    protected boolean AttemptToMergeWithSlot( ItemStack stackSource, int iTempSlot )
+    {
+        Slot tempDestSlot = (Slot)inventorySlots.get( iTempSlot );
+        ItemStack tempDestStack = tempDestSlot.getStack();
+
+        if ( tempDestStack != null && tempDestStack.itemID == stackSource.itemID && 
+        	( !stackSource.getHasSubtypes() || 
+    		stackSource.getItemDamage() == tempDestStack.getItemDamage() ) && 
+    		ItemStack.areItemStackTagsEqual( stackSource, tempDestStack ) )
+        {
+            int iDestStackSize = tempDestStack.stackSize + stackSource.stackSize;
+            int iMaxStackSize = stackSource.getMaxStackSize();
+            
+            if ( tempDestSlot.getSlotStackLimit() < iMaxStackSize )
+            {
+            	iMaxStackSize = tempDestSlot.getSlotStackLimit();
+            }
+
+            if ( tempDestStack.stackSize < iMaxStackSize )
+            {
+                if ( iDestStackSize <= iMaxStackSize )
+                {
+                    stackSource.stackSize = 0;
+                    tempDestStack.stackSize = iDestStackSize;
+                }
+                else
+                {
+                    stackSource.stackSize -= iMaxStackSize - tempDestStack.stackSize;
+                    tempDestStack.stackSize = iMaxStackSize;
+                }
+                
+                tempDestSlot.onSlotChanged();
+                
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    protected boolean AttemptToMergeWithSlotIfEmpty( ItemStack stackSource, int iTempSlot )
+    {
+    	boolean bReturnValue = false;
+    	
+        Slot tempDestSlot = (Slot)inventorySlots.get(iTempSlot);
+        ItemStack tempDestStack = tempDestSlot.getStack();
+
+        if ( tempDestStack == null )
+        {
+            int iMaxStackSize = stackSource.getMaxStackSize();
+            
+            if ( tempDestSlot.getSlotStackLimit() < iMaxStackSize )
+            {
+            	iMaxStackSize = tempDestSlot.getSlotStackLimit();
+            }
+
+            if ( stackSource.stackSize <= iMaxStackSize )
+            {
+                tempDestSlot.putStack( stackSource.copy() );
+                stackSource.stackSize = 0;
+            }
+            else
+            {
+                tempDestSlot.putStack( stackSource.copy() );
+                stackSource.stackSize -= iMaxStackSize;
+                tempDestSlot.getStack().stackSize = iMaxStackSize;
+            }
+            
+            tempDestSlot.onSlotChanged();
+            
+            return true;
+        }
+        
+        return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ContainerBrewingStand.java b/minecraft_server/net/minecraft/src/ContainerBrewingStand.java
index ca2ae23..714d061 100644
--- a/minecraft_server/net/minecraft/src/ContainerBrewingStand.java
+++ b/minecraft_server/net/minecraft/src/ContainerBrewingStand.java
@@ -105,7 +105,10 @@ public class ContainerBrewingStand extends Container
                         return null;
                     }
                 }
-                else if (!this.mergeItemStack(var5, 4, 40, false))
+                // FCMOD: Change to give priority to player hotbar
+                //else if (!this.mergeItemStack(var5, 4, 40, false))
+                else if (!this.mergeItemStack(var5, 4, 40, true))
+            	// END FCMOD
                 {
                     return null;
                 }
diff --git a/minecraft_server/net/minecraft/src/ContainerEnchantment.java b/minecraft_server/net/minecraft/src/ContainerEnchantment.java
index 4584c5b..0d3559a 100644
--- a/minecraft_server/net/minecraft/src/ContainerEnchantment.java
+++ b/minecraft_server/net/minecraft/src/ContainerEnchantment.java
@@ -190,6 +190,10 @@ public class ContainerEnchantment extends Container
                     }
 
                     this.onCraftMatrixChanged(this.tableInventory);
+
+                    // FCMOD: Code added
+                    worldPointer.playSoundAtEntity( par1EntityPlayer, "random.levelup", 0.25F, worldPointer.rand.nextFloat() * 0.1F + 0.5F );
+                    // END FCMOD
                 }
             }
 
diff --git a/minecraft_server/net/minecraft/src/ContainerMerchant.java b/minecraft_server/net/minecraft/src/ContainerMerchant.java
index 22579dc..0555081 100644
--- a/minecraft_server/net/minecraft/src/ContainerMerchant.java
+++ b/minecraft_server/net/minecraft/src/ContainerMerchant.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
+
 public class ContainerMerchant extends Container
 {
     /** Instance of Merchant. */
@@ -14,22 +16,42 @@ public class ContainerMerchant extends Container
         this.theMerchant = par2IMerchant;
         this.theWorld = par3World;
         this.merchantInventory = new InventoryMerchant(par1InventoryPlayer.player, par2IMerchant);
+    	// FCMOD: Changed y offset of GUI
+    	/*
         this.addSlotToContainer(new Slot(this.merchantInventory, 0, 36, 53));
         this.addSlotToContainer(new Slot(this.merchantInventory, 1, 62, 53));
         this.addSlotToContainer(new SlotMerchantResult(par1InventoryPlayer.player, par2IMerchant, this.merchantInventory, 2, 120, 53));
+        */
+        this.addSlotToContainer(new Slot(this.merchantInventory, 0, 36, 119));
+        this.addSlotToContainer(new Slot(this.merchantInventory, 1, 62, 119));
+        this.addSlotToContainer(new SlotMerchantResult(par1InventoryPlayer.player, par2IMerchant, this.merchantInventory, 2, 120, 119));
+        // END FCMOD
         int var4;
 
         for (var4 = 0; var4 < 3; ++var4)
         {
             for (int var5 = 0; var5 < 9; ++var5)
             {
+            	// FCMOD: Changing y offset of GUI
+            	/*
                 this.addSlotToContainer(new Slot(par1InventoryPlayer, var5 + var4 * 9 + 9, 8 + var5 * 18, 84 + var4 * 18));
+                */
+                this.addSlotToContainer(new Slot(par1InventoryPlayer, 
+                	var5 + var4 * 9 + 9, 
+                	8 + var5 * 18, 
+                	157 + var4 * 18));
+            	// END FCMOD
             }
         }
 
         for (var4 = 0; var4 < 9; ++var4)
         {
+        	// FCMOD: Changing y offset of GUI
+        	/*
             this.addSlotToContainer(new Slot(par1InventoryPlayer, var4, 8 + var4 * 18, 142));
+            */
+            this.addSlotToContainer(new Slot(par1InventoryPlayer, var4, 8 + var4 * 18, 215));
+        	// END FCMOD
         }
     }
 
@@ -41,6 +63,10 @@ public class ContainerMerchant extends Container
     public void onCraftGuiOpened(ICrafting par1ICrafting)
     {
         super.onCraftGuiOpened(par1ICrafting);
+        
+        // FCMOD: Added (Note that uses different function name on client and server)
+        OnCrafterAdded( par1ICrafting );
+        // END FCMOD
     }
 
     /**
@@ -49,6 +75,10 @@ public class ContainerMerchant extends Container
     public void detectAndSendChanges()
     {
         super.detectAndSendChanges();
+        
+        // FCMOD: Added        
+        DetectAndSendChangesToBTSMTradeVariables();
+        // END FCMOD
     }
 
     /**
@@ -85,6 +115,15 @@ public class ContainerMerchant extends Container
 
             if (par2 == 2)
             {
+            	// FCMOD: Code added to abort trade if it's used up
+            	if ( merchantInventory.getCurrentRecipe().func_82784_g() )
+            	{
+                    var4.putStack((ItemStack)null);
+
+            		return null;
+            	}
+            	// END FCMOD
+            	
                 if (!this.mergeItemStack(var5, 3, 39, true))
                 {
                     return null;
@@ -96,17 +135,32 @@ public class ContainerMerchant extends Container
             {
                 if (par2 >= 3 && par2 < 30)
                 {
+                	// FCMOD: Changed to allow shift-click transfer to merchant slots
+                	/*
                     if (!this.mergeItemStack(var5, 30, 39, false))
+                	*/
+                    if (!this.mergeItemStack(var5, 0, 2, false))
+                	// END FCMOD
                     {
                         return null;
                     }
                 }
+                // FCMOD: Changed to allow shift-click transfer to merchant slots
+                /*
                 else if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(var5, 3, 30, false))
+                */
+                else if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(var5, 0, 2, false))
+            	// END FCMOD
                 {
                     return null;
                 }
             }
+        	// FCMOD: Changed to prioritize player hotbar
+        	/*
             else if (!this.mergeItemStack(var5, 3, 39, false))
+            */
+            else if (!this.mergeItemStack(var5, 3, 39, true))
+        	// END FCMOD
             {
                 return null;
             }
@@ -157,4 +211,58 @@ public class ContainerMerchant extends Container
             }
         }
     }
+    // FCMOD: Added
+    public int m_iAssociatedVillagerTradeLevel = 0;
+    public int m_iAssociatedVillagerTradeXP = 0;
+    public int m_iAssociatedVillagerTradeMaxXP = 0;
+    
+    private void DetectAndSendChangesToBTSMTradeVariables()
+    {
+        int iCurrentTradeLevel = theMerchant.GetCurrentTradeLevel();
+        
+        if ( iCurrentTradeLevel != m_iAssociatedVillagerTradeLevel )
+        {
+        	SendProgressBarUpdateToAllCrafters( 0, iCurrentTradeLevel );
+        	
+        	m_iAssociatedVillagerTradeLevel = iCurrentTradeLevel;        	
+        }
+        
+        int iCurrentTradeXP = theMerchant.GetCurrentTradeXP();
+        
+        if ( iCurrentTradeXP != m_iAssociatedVillagerTradeXP )
+        {
+        	SendProgressBarUpdateToAllCrafters( 1, iCurrentTradeXP );
+        	
+        	m_iAssociatedVillagerTradeXP = iCurrentTradeXP;         	
+        }
+        
+        int iCurrentTradeMaxXP = theMerchant.GetCurrentTradeMaxXP();
+        
+        if ( iCurrentTradeMaxXP != m_iAssociatedVillagerTradeMaxXP )
+        {
+        	SendProgressBarUpdateToAllCrafters( 2, iCurrentTradeMaxXP );
+        	
+        	m_iAssociatedVillagerTradeMaxXP = iCurrentTradeMaxXP;         	
+        }
+    }
+    
+    public void SendProgressBarUpdateToAllCrafters( int iVariableIndex, int iValue )
+    {
+        Iterator iterator = crafters.iterator();
+
+        while( iterator.hasNext() )
+        {
+            ICrafting icrafting = (ICrafting)iterator.next();
+
+            icrafting.sendProgressBarUpdate( this, iVariableIndex, iValue );
+        }
+    }
+    
+    public void OnCrafterAdded( ICrafting crafter )
+    {
+        crafter.sendProgressBarUpdate( this, 0, m_iAssociatedVillagerTradeLevel );
+        crafter.sendProgressBarUpdate( this, 1, m_iAssociatedVillagerTradeXP );
+        crafter.sendProgressBarUpdate( this, 2, m_iAssociatedVillagerTradeMaxXP );
+    }    
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ContainerWorkbench.java b/minecraft_server/net/minecraft/src/ContainerWorkbench.java
index da461af..0d83e78 100644
--- a/minecraft_server/net/minecraft/src/ContainerWorkbench.java
+++ b/minecraft_server/net/minecraft/src/ContainerWorkbench.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 08/09/2018
+
 package net.minecraft.src;
 
 public class ContainerWorkbench extends Container
diff --git a/minecraft_server/net/minecraft/src/CraftingManager.java b/minecraft_server/net/minecraft/src/CraftingManager.java
index f44e6f4..74bf223 100644
--- a/minecraft_server/net/minecraft/src/CraftingManager.java
+++ b/minecraft_server/net/minecraft/src/CraftingManager.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -32,7 +33,9 @@ public class CraftingManager
         (new RecipesDyes()).addRecipes(this);
         this.recipes.add(new RecipesArmorDyes());
         this.recipes.add(new RecipesMapCloning());
-        this.recipes.add(new RecipesMapExtending());
+        // FCMOD: Removed
+        //this.recipes.add(new RecipesMapExtending());
+        // END FCMOD
         this.recipes.add(new RecipeFireworks());
         this.addRecipe(new ItemStack(Item.paper, 3), new Object[] {"###", '#', Item.reed});
         this.addShapelessRecipe(new ItemStack(Item.book, 1), new Object[] {Item.paper, Item.paper, Item.paper, Item.leather});
@@ -179,25 +182,25 @@ public class CraftingManager
         for (var12 = new HashMap(); var4 < par2ArrayOfObj.length; var4 += 2)
         {
             Character var13 = (Character)par2ArrayOfObj[var4];
-            ItemStack var15 = null;
+            ItemStack var14 = null;
 
             if (par2ArrayOfObj[var4 + 1] instanceof Item)
             {
-                var15 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
+                var14 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
             }
             else if (par2ArrayOfObj[var4 + 1] instanceof Block)
             {
-                var15 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
+                var14 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
             }
             else if (par2ArrayOfObj[var4 + 1] instanceof ItemStack)
             {
-                var15 = (ItemStack)par2ArrayOfObj[var4 + 1];
+                var14 = (ItemStack)par2ArrayOfObj[var4 + 1];
             }
 
-            var12.put(var13, var15);
+            var12.put(var13, var14);
         }
 
-        ItemStack[] var14 = new ItemStack[var5 * var6];
+        ItemStack[] var15 = new ItemStack[var5 * var6];
 
         for (int var16 = 0; var16 < var5 * var6; ++var16)
         {
@@ -205,20 +208,27 @@ public class CraftingManager
 
             if (var12.containsKey(Character.valueOf(var10)))
             {
-                var14[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
+                var15[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
             }
             else
             {
-                var14[var16] = null;
+                var15[var16] = null;
             }
         }
 
-        ShapedRecipes var17 = new ShapedRecipes(var5, var6, var14, par1ItemStack);
+        ShapedRecipes var17 = new ShapedRecipes(var5, var6, var15, par1ItemStack);
         this.recipes.add(var17);
         return var17;
     }
 
     void addShapelessRecipe(ItemStack par1ItemStack, Object ... par2ArrayOfObj)
+    // FCMOD: Added
+    {
+    	AddShapelessRecipe( par1ItemStack, par2ArrayOfObj );
+    }
+    
+    ShapelessRecipes AddShapelessRecipe(ItemStack par1ItemStack, Object ... par2ArrayOfObj)
+    // END FCMOD
     {
         ArrayList var3 = new ArrayList();
         Object[] var4 = par2ArrayOfObj;
@@ -246,10 +256,19 @@ public class CraftingManager
                 var3.add(new ItemStack((Block)var7));
             }
         }
-
-        this.recipes.add(new ShapelessRecipes(par1ItemStack, var3));
+        
+        // FCMOD: Changed        
+        //this.recipes.add(new ShapelessRecipes(par1ItemStack, var3));
+        ShapelessRecipes recipe = new ShapelessRecipes( par1ItemStack, var3 );
+        
+        recipes.add( recipe );
+        
+        return recipe;
+        // END FCMOD
     }
 
+    // FCMOD: Removed and replaced
+    /*
     public ItemStack findMatchingRecipe(InventoryCrafting par1InventoryCrafting, World par2World)
     {
         int var3 = 0;
@@ -307,6 +326,8 @@ public class CraftingManager
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * returns the List<> of all recipes
@@ -315,4 +336,278 @@ public class CraftingManager
     {
         return this.recipes;
     }
+    
+    // FCMOD: Added
+    public ItemStack findMatchingRecipe( InventoryCrafting inventory, World world )
+    {
+    	IRecipe recipe = FindMatchingRecipe( inventory, world );
+    	ItemStack outputStack = null;
+    	
+    	if ( recipe != null )
+    	{
+    		outputStack = recipe.getCraftingResult( inventory );
+    	}
+    	
+    	return outputStack;
+    }
+    
+    public IRecipe FindMatchingRecipe( InventoryCrafting inventory, World world )
+    {
+        for ( int iTempIndex = 0; iTempIndex < this.recipes.size(); ++iTempIndex)
+        {
+            IRecipe tempRecipe = (IRecipe)this.recipes.get(iTempIndex);
+
+            if ( tempRecipe.matches( inventory, world ) )
+            {
+                return tempRecipe;
+            }
+        }
+
+        return null;
+    }
+    
+    public boolean RemoveRecipe( ItemStack itemStack, Object recipeArray[] )
+    {
+    	ShapedRecipes recipe = CreateRecipe( itemStack, recipeArray );
+    	
+    	int iMatchingIndex = GetMatchingRecipeIndex( recipe );
+    	
+    	if ( iMatchingIndex >= 0 )
+    	{
+    		recipes.remove( iMatchingIndex );
+    		
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    
+    public boolean RemoveShapelessRecipe( ItemStack itemStack, Object recipeArray[] )
+    {
+    	ShapelessRecipes recipe = CreateShapelessRecipe( itemStack, recipeArray );
+    	
+    	int iMatchingIndex = GetMatchingRecipeIndex( recipe );
+    	
+    	if ( iMatchingIndex >= 0 )
+    	{
+    		recipes.remove( iMatchingIndex );
+    		
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    
+    private int GetMatchingRecipeIndex( IRecipe recipe )
+    {
+    	int iMatchingRecipeIndex = -1;
+    	
+        for ( int iIndex = 0; iIndex < recipes.size(); iIndex++ )
+        {
+            IRecipe tempRecipe = (IRecipe)(recipes.get( iIndex ));
+
+            if ( tempRecipe.matches( recipe ) )
+            {
+                return iIndex;
+            }            
+        }
+
+    	return -1;
+    }
+    
+    private ShapedRecipes CreateRecipe( ItemStack par1ItemStack, Object par2ArrayOfObj[] )
+    {
+        String s = "";
+        int i = 0;
+        int j = 0;
+        int k = 0;
+
+        if (par2ArrayOfObj[i] instanceof String[])
+        {
+            String as[] = (String[])par2ArrayOfObj[i++];
+            String as1[] = as;
+            int l = as1.length;
+
+            for (int j1 = 0; j1 < l; j1++)
+            {
+                String s2 = as1[j1];
+                String s3 = s2;
+                k++;
+                j = s3.length();
+                s = (new StringBuilder()).append(s).append(s3).toString();
+            }
+        }
+        else
+        {
+            while (par2ArrayOfObj[i] instanceof String)
+            {
+                String s1 = (String)par2ArrayOfObj[i++];
+                k++;
+                j = s1.length();
+                s = (new StringBuilder()).append(s).append(s1).toString();
+            }
+        }
+
+        HashMap hashmap = new HashMap();
+
+        for (; i < par2ArrayOfObj.length; i += 2)
+        {
+            Character character = (Character)par2ArrayOfObj[i];
+            ItemStack itemstack = null;
+
+            if (par2ArrayOfObj[i + 1] instanceof Item)
+            {
+                itemstack = new ItemStack((Item)par2ArrayOfObj[i + 1]);
+            }
+            else if (par2ArrayOfObj[i + 1] instanceof Block)
+            {
+                itemstack = new ItemStack((Block)par2ArrayOfObj[i + 1], 1, FCUtilsInventory.m_iIgnoreMetadata);
+            }
+            else if (par2ArrayOfObj[i + 1] instanceof ItemStack)
+            {
+                itemstack = (ItemStack)par2ArrayOfObj[i + 1];
+            }
+
+            hashmap.put(character, itemstack);
+        }
+
+        ItemStack aitemstack[] = new ItemStack[j * k];
+
+        for (int i1 = 0; i1 < j * k; i1++)
+        {
+            char c = s.charAt(i1);
+
+            if (hashmap.containsKey(Character.valueOf(c)))
+            {
+                aitemstack[i1] = ((ItemStack)hashmap.get(Character.valueOf(c))).copy();
+            }
+            else
+            {
+                aitemstack[i1] = null;
+            }
+        }
+
+        return new ShapedRecipes(j, k, aitemstack, par1ItemStack );
+    }
+    
+    private ShapelessRecipes CreateShapelessRecipe(ItemStack par1ItemStack, Object par2ArrayOfObj[])
+    {
+        ArrayList arraylist = new ArrayList();
+        Object aobj[] = par2ArrayOfObj;
+        int i = aobj.length;
+
+        for (int j = 0; j < i; j++)
+        {
+            Object obj = aobj[j];
+
+            if (obj instanceof ItemStack)
+            {
+                arraylist.add(((ItemStack)obj).copy());
+                continue;
+            }
+
+            if (obj instanceof Item)
+            {
+                arraylist.add(new ItemStack((Item)obj));
+                continue;
+            }
+
+            if (obj instanceof Block)
+            {
+                arraylist.add(new ItemStack((Block)obj));
+            }
+            else
+            {
+                throw new RuntimeException("Invalid shapeless recipy!");
+            }
+        }
+
+        return new ShapelessRecipes( par1ItemStack, arraylist );
+    }
+    
+    ShapedRecipes AddShapedRecipeWithCustomClass( Class<? extends ShapedRecipes> recipeClass, ItemStack par1ItemStack, Object ... par2ArrayOfObj )
+    {
+        String var3 = "";
+        int var4 = 0;
+        int var5 = 0;
+        int var6 = 0;
+
+        if (par2ArrayOfObj[var4] instanceof String[])
+        {
+            String[] var7 = (String[])((String[])par2ArrayOfObj[var4++]);
+
+            for (int var8 = 0; var8 < var7.length; ++var8)
+            {
+                String var9 = var7[var8];
+                ++var6;
+                var5 = var9.length();
+                var3 = var3 + var9;
+            }
+        }
+        else
+        {
+            while (par2ArrayOfObj[var4] instanceof String)
+            {
+                String var11 = (String)par2ArrayOfObj[var4++];
+                ++var6;
+                var5 = var11.length();
+                var3 = var3 + var11;
+            }
+        }
+
+        HashMap var12;
+
+        for (var12 = new HashMap(); var4 < par2ArrayOfObj.length; var4 += 2)
+        {
+            Character var13 = (Character)par2ArrayOfObj[var4];
+            ItemStack var14 = null;
+
+            if (par2ArrayOfObj[var4 + 1] instanceof Item)
+            {
+                var14 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
+            }
+            else if (par2ArrayOfObj[var4 + 1] instanceof Block)
+            {
+                var14 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
+            }
+            else if (par2ArrayOfObj[var4 + 1] instanceof ItemStack)
+            {
+                var14 = (ItemStack)par2ArrayOfObj[var4 + 1];
+            }
+
+            var12.put(var13, var14);
+        }
+
+        ItemStack[] var15 = new ItemStack[var5 * var6];
+
+        for (int var16 = 0; var16 < var5 * var6; ++var16)
+        {
+            char var10 = var3.charAt(var16);
+
+            if (var12.containsKey(Character.valueOf(var10)))
+            {
+                var15[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
+            }
+            else
+            {
+                var15[var16] = null;
+            }
+        }
+
+        try
+        {
+	        Constructor recipeConstructor = recipeClass.getDeclaredConstructor( new Class[] { int.class, int.class, ItemStack[].class, ItemStack.class } );
+	        
+	        ShapedRecipes recipe = (ShapedRecipes)( recipeConstructor.newInstance( var5, var6, var15, par1ItemStack) );
+	        
+	        recipes.add( recipe );
+	        
+	        return recipe;
+        }
+        catch( Exception e ) 
+        {
+	        throw new RuntimeException( "Haha...noob" );
+        }            
+    }
+    // END FCMOD   
 }
diff --git a/minecraft_server/net/minecraft/src/DispenserBehaviorBoat.java b/minecraft_server/net/minecraft/src/DispenserBehaviorBoat.java
index 9c076a6..c77f74c 100644
--- a/minecraft_server/net/minecraft/src/DispenserBehaviorBoat.java
+++ b/minecraft_server/net/minecraft/src/DispenserBehaviorBoat.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorBoat extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -39,12 +41,18 @@ final class DispenserBehaviorBoat extends BehaviorDefaultDispenseItem
         par2ItemStack.splitStack(1);
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+    // FCMOD: Code removed
+    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         par1IBlockSource.getWorld().playAuxSFX(1000, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/DispenserBehaviorDye.java b/minecraft_server/net/minecraft/src/DispenserBehaviorDye.java
index 8a31fc2..276cb32 100644
--- a/minecraft_server/net/minecraft/src/DispenserBehaviorDye.java
+++ b/minecraft_server/net/minecraft/src/DispenserBehaviorDye.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorDye extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         if (par2ItemStack.getItemDamage() == 15)
@@ -36,10 +38,14 @@ final class DispenserBehaviorDye extends BehaviorDefaultDispenseItem
             return super.dispenseStack(par1IBlockSource, par2ItemStack);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+	// FCMOD: Code removed
+	/*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         if (this.field_96461_b)
@@ -51,4 +57,6 @@ final class DispenserBehaviorDye extends BehaviorDefaultDispenseItem
             par1IBlockSource.getWorld().playAuxSFX(1001, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/DispenserBehaviorEmptyBucket.java b/minecraft_server/net/minecraft/src/DispenserBehaviorEmptyBucket.java
index ecca50f..42e5843 100644
--- a/minecraft_server/net/minecraft/src/DispenserBehaviorEmptyBucket.java
+++ b/minecraft_server/net/minecraft/src/DispenserBehaviorEmptyBucket.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorEmptyBucket extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+    // FCMOD: Code removed to prevent usage
+    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -46,4 +48,6 @@ final class DispenserBehaviorEmptyBucket extends BehaviorDefaultDispenseItem
 
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/DispenserBehaviorFilledBucket.java b/minecraft_server/net/minecraft/src/DispenserBehaviorFilledBucket.java
index afac306..2741aec 100644
--- a/minecraft_server/net/minecraft/src/DispenserBehaviorFilledBucket.java
+++ b/minecraft_server/net/minecraft/src/DispenserBehaviorFilledBucket.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorFilledBucket extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+    // FCMOD: Code removed to prevent usage
+    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         ItemBucket var3 = (ItemBucket)par2ItemStack.getItem();
@@ -26,4 +28,6 @@ final class DispenserBehaviorFilledBucket extends BehaviorDefaultDispenseItem
             return this.defaultDispenserItemBehavior.dispense(par1IBlockSource, par2ItemStack);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/DispenserBehaviorFire.java b/minecraft_server/net/minecraft/src/DispenserBehaviorFire.java
index dc5c371..5557222 100644
--- a/minecraft_server/net/minecraft/src/DispenserBehaviorFire.java
+++ b/minecraft_server/net/minecraft/src/DispenserBehaviorFire.java
@@ -7,6 +7,8 @@ final class DispenserBehaviorFire extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+    // FCMOD: Code removed to prevent usage
+    /*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -36,10 +38,14 @@ final class DispenserBehaviorFire extends BehaviorDefaultDispenseItem
 
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
+    // FCMOD: Code removed
+    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         if (this.field_96466_b)
@@ -51,4 +57,6 @@ final class DispenserBehaviorFire extends BehaviorDefaultDispenseItem
             par1IBlockSource.getWorld().playAuxSFX(1001, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/DispenserBehaviorTNT.java b/minecraft_server/net/minecraft/src/DispenserBehaviorTNT.java
index e6b0caf..c0f4e6d 100644
--- a/minecraft_server/net/minecraft/src/DispenserBehaviorTNT.java
+++ b/minecraft_server/net/minecraft/src/DispenserBehaviorTNT.java
@@ -5,6 +5,8 @@ final class DispenserBehaviorTNT extends BehaviorDefaultDispenseItem
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
+	// FCMOD: Code removed to prevent usage
+	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -17,4 +19,6 @@ final class DispenserBehaviorTNT extends BehaviorDefaultDispenseItem
         --par2ItemStack.stackSize;
         return par2ItemStack;
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Enchantment.java b/minecraft_server/net/minecraft/src/Enchantment.java
index 56d2c60..3e53ff0 100644
--- a/minecraft_server/net/minecraft/src/Enchantment.java
+++ b/minecraft_server/net/minecraft/src/Enchantment.java
@@ -198,7 +198,10 @@ public abstract class Enchantment
 
     public boolean func_92089_a(ItemStack par1ItemStack)
     {
-        return this.type.canEnchantItem(par1ItemStack.getItem());
+    	// FCMOD: Changed
+        //return this.type.canEnchantItem(par1ItemStack.getItem());
+        return par1ItemStack.getItem().IsEnchantmentApplicable( this );
+    	// END FCMOD
     }
 
     static
@@ -219,4 +222,24 @@ public abstract class Enchantment
 
         field_92090_c = (Enchantment[])var0.toArray(new Enchantment[0]);
     }
+    
+    // FCMOD: Added New
+    private boolean m_bCanBeAppliedByVanillaEnchanter = true;
+    
+    static
+    {
+        // remove the more powerful enchants from the vanilla enchanter
+    	
+        protection.m_bCanBeAppliedByVanillaEnchanter = false;
+        silkTouch.m_bCanBeAppliedByVanillaEnchanter = false;
+        fortune.m_bCanBeAppliedByVanillaEnchanter = false;
+        sharpness.m_bCanBeAppliedByVanillaEnchanter = false;
+        featherFalling.m_bCanBeAppliedByVanillaEnchanter = false;
+    }
+    
+    public boolean CanBeAppliedByVanillaEnchanter()
+    {
+    	return m_bCanBeAppliedByVanillaEnchanter;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EnchantmentHelper.java b/minecraft_server/net/minecraft/src/EnchantmentHelper.java
index 6f3df8e..43f81e4 100644
--- a/minecraft_server/net/minecraft/src/EnchantmentHelper.java
+++ b/minecraft_server/net/minecraft/src/EnchantmentHelper.java
@@ -254,7 +254,24 @@ public class EnchantmentHelper
      */
     public static int getFortuneModifier(EntityLiving par0EntityLiving)
     {
+    	// FCMOD: Code change
+    	/*
         return getEnchantmentLevel(Enchantment.fortune.effectId, par0EntityLiving.getHeldItem());
+        */
+    	int iEnchantmentLevel = getEnchantmentLevel(Enchantment.fortune.effectId, par0EntityLiving.getHeldItem());
+    	
+    	if ( par0EntityLiving.isPotionActive(FCBetterThanWolves.potionFortune ) )
+    	{
+        	int iPotionLevel = par0EntityLiving.getActivePotionEffect( FCBetterThanWolves.potionFortune ).getAmplifier() + 1;
+        	
+        	if ( iPotionLevel > iEnchantmentLevel )
+        	{
+        		iEnchantmentLevel = iPotionLevel;
+        	}        	
+    	}
+    	
+    	return iEnchantmentLevel;
+    	// END FCMOD
     }
 
     /**
@@ -262,7 +279,24 @@ public class EnchantmentHelper
      */
     public static int getLootingModifier(EntityLiving par0EntityLiving)
     {
+    	// FCMOD: Code change
+    	/*
         return getEnchantmentLevel(Enchantment.looting.effectId, par0EntityLiving.getHeldItem());
+        */
+    	int iEnchantmentLevel = getEnchantmentLevel(Enchantment.looting.effectId, par0EntityLiving.getHeldItem());
+    	
+    	if ( par0EntityLiving.isPotionActive(FCBetterThanWolves.potionLooting ) )
+    	{
+        	int iPotionLevel = par0EntityLiving.getActivePotionEffect( FCBetterThanWolves.potionLooting ).getAmplifier() + 1;
+        	
+        	if ( iPotionLevel > iEnchantmentLevel )
+        	{
+        		iEnchantmentLevel = iPotionLevel;
+        	}        	
+    	}
+    	
+    	return iEnchantmentLevel;
+    	// END FCMOD
     }
 
     /**
@@ -300,6 +334,8 @@ public class EnchantmentHelper
      * Returns the enchantability of itemstack, it's uses a singular formula for each index (2nd parameter: 0, 1 and 2),
      * cutting to the max enchantability power of the table (3rd parameter)
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public static int calcItemStackEnchantability(Random par0Random, int par1, int par2, ItemStack par3ItemStack)
     {
         Item var4 = par3ItemStack.getItem();
@@ -320,6 +356,8 @@ public class EnchantmentHelper
             return par1 == 0 ? Math.max(var6 / 3, 1) : (par1 == 1 ? var6 * 2 / 3 + 1 : Math.max(var6, par2 * 2));
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Adds a random enchantment to the specified item. Args: random, itemStack, enchantabilityLevel
@@ -456,8 +494,18 @@ public class EnchantmentHelper
         {
             Enchantment var8 = var5[var7];
 
-            if (var8 != null && (var8.type.canEnchantItem(var2) || var4))
+        	// FCMOD: Changed
+            //if (var8 != null && (var8.type.canEnchantItem(var2) || var4))
+            if ( var8 != null && (var2.IsEnchantmentApplicable( var8 ) || var4))
+        	// END FCMOD
             {
+            	// FCMOD: Added to prevent certain enchants from vanilla enchanter
+            	if ( !var8.CanBeAppliedByVanillaEnchanter() )
+            	{
+            		continue;
+            	}
+            	// END FCMOD
+            	
                 for (int var9 = var8.getMinLevel(); var9 <= var8.getMaxLevel(); ++var9)
                 {
                     if (par0 >= var8.getMinEnchantability(var9) && par0 <= var8.getMaxEnchantability(var9))
@@ -475,4 +523,56 @@ public class EnchantmentHelper
 
         return var3;
     }
+    
+    // FCMOD: Code added
+    public static int calcItemStackEnchantability( Random rand, int iTableSlotNum, int iNumBookShelves, ItemStack stack )
+    {
+    	// Replace vanilla code to double amount of bookshelves required, cap enchant level at 15, and make enchant with no shelves be level 1
+    	
+        Item item = stack.getItem();
+        int iItemEnchantability = item.getItemEnchantability();
+
+        if (iItemEnchantability <= 0)
+        {
+            return 0;
+        }
+        else
+        {
+            int iEnchantmentLevel = 1;
+            
+            if ( iTableSlotNum != 0 )
+            {
+                int iMaxEnchantmentLevel = iNumBookShelves >> 1;
+                    
+                if ( iMaxEnchantmentLevel <= 0 )
+                {
+                	iMaxEnchantmentLevel = 1;
+                }
+                else if ( iMaxEnchantmentLevel > 15 )
+                {
+                	iMaxEnchantmentLevel = 15;
+                }
+                	
+            	if ( iTableSlotNum == 1 )
+            	{
+            		if ( iMaxEnchantmentLevel > 1 )
+            		{
+                		iEnchantmentLevel = 2;
+                		
+                		if ( iMaxEnchantmentLevel > 3 )
+                		{
+                			iEnchantmentLevel += rand.nextInt( iMaxEnchantmentLevel - 2 );
+                		}
+            		}
+            	}
+            	else
+            	{
+            		iEnchantmentLevel = iMaxEnchantmentLevel;
+            	}
+            }
+            
+            return iEnchantmentLevel;
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Entity.java b/minecraft_server/net/minecraft/src/Entity.java
index f7bb8e4..6a808ee 100644
--- a/minecraft_server/net/minecraft/src/Entity.java
+++ b/minecraft_server/net/minecraft/src/Entity.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
@@ -117,6 +118,9 @@ public abstract class Entity
      * The entity's Z coordinate at the previous tick, used to calculate position during rendering routines
      */
     public double lastTickPosZ;
+    /**
+     * FCNOTE: TERRIBLE NAMING.  This is actually the position offset due to player sneaking/crouching
+     */
     public float ySize;
 
     /**
@@ -265,6 +269,9 @@ public abstract class Entity
      */
     protected void setSize(float par1, float par2)
     {
+    	// FCMOD: Code change to duplicate 1.6 fix for animals suffocating and escaping fences bug
+    	// I do not believe this is actually helping anything due to the incremental nature of the 
+    	// move plus I am now ensuring sufficient space on animal grow elsewhere in the code.
         if (par1 != this.width || par2 != this.height)
         {
             this.width = par1;
@@ -275,6 +282,27 @@ public abstract class Entity
         }
 
         float var3 = par1 % 2.0F;
+    	/*
+        float var3;
+
+        if (par1 != this.width || par2 != this.height)
+        {
+            var3 = this.width;
+            this.width = par1;
+            this.height = par2;
+            this.boundingBox.maxX = this.boundingBox.minX + (double)this.width;
+            this.boundingBox.maxZ = this.boundingBox.minZ + (double)this.width;
+            this.boundingBox.maxY = this.boundingBox.minY + (double)this.height;
+
+            if (this.width > var3 && !this.firstUpdate && !this.worldObj.isRemote)
+            {
+                this.moveEntity((double)(var3 - this.width), 0.0D, (double)(var3 - this.width));
+            }
+        }
+
+        var3 = par1 % 2.0F;
+        */    	
+        // END FCMOD
 
         if ((double)var3 < 0.375D)
         {
@@ -529,6 +557,8 @@ public abstract class Entity
     /**
      * Tries to moves the entity by the passed in displacement. Args: x, y, z
      */
+    // FCMOD: Removed and replaced
+    /*
     public void moveEntity(double par1, double par3, double par5)
     {
         if (this.noClip)
@@ -632,11 +662,11 @@ public abstract class Entity
                 }
             }
 
-            List var34 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(par1, par3, par5));
+            List var35 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(par1, par3, par5));
 
-            for (int var22 = 0; var22 < var34.size(); ++var22)
+            for (int var22 = 0; var22 < var35.size(); ++var22)
             {
-                par3 = ((AxisAlignedBB)var34.get(var22)).calculateYOffset(this.boundingBox, par3);
+                par3 = ((AxisAlignedBB)var35.get(var22)).calculateYOffset(this.boundingBox, par3);
             }
 
             this.boundingBox.offset(0.0D, par3, 0.0D);
@@ -648,12 +678,12 @@ public abstract class Entity
                 par1 = 0.0D;
             }
 
-            boolean var35 = this.onGround || var15 != par3 && var15 < 0.0D;
+            boolean var34 = this.onGround || var15 != par3 && var15 < 0.0D;
             int var23;
 
-            for (var23 = 0; var23 < var34.size(); ++var23)
+            for (var23 = 0; var23 < var35.size(); ++var23)
             {
-                par1 = ((AxisAlignedBB)var34.get(var23)).calculateXOffset(this.boundingBox, par1);
+                par1 = ((AxisAlignedBB)var35.get(var23)).calculateXOffset(this.boundingBox, par1);
             }
 
             this.boundingBox.offset(par1, 0.0D, 0.0D);
@@ -665,9 +695,9 @@ public abstract class Entity
                 par1 = 0.0D;
             }
 
-            for (var23 = 0; var23 < var34.size(); ++var23)
+            for (var23 = 0; var23 < var35.size(); ++var23)
             {
-                par5 = ((AxisAlignedBB)var34.get(var23)).calculateZOffset(this.boundingBox, par5);
+                par5 = ((AxisAlignedBB)var35.get(var23)).calculateZOffset(this.boundingBox, par5);
             }
 
             this.boundingBox.offset(0.0D, 0.0D, par5);
@@ -684,7 +714,7 @@ public abstract class Entity
             int var30;
             double var36;
 
-            if (this.stepHeight > 0.0F && var35 && (var20 || this.ySize < 0.05F) && (var13 != par1 || var17 != par5))
+            if (this.stepHeight > 0.0F && var34 && (var20 || this.ySize < 0.05F) && (var13 != par1 || var17 != par5))
             {
                 var36 = par1;
                 var25 = par3;
@@ -694,11 +724,11 @@ public abstract class Entity
                 par5 = var17;
                 AxisAlignedBB var29 = this.boundingBox.copy();
                 this.boundingBox.setBB(var19);
-                var34 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(var13, par3, var17));
+                var35 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.addCoord(var13, par3, var17));
 
-                for (var30 = 0; var30 < var34.size(); ++var30)
+                for (var30 = 0; var30 < var35.size(); ++var30)
                 {
-                    par3 = ((AxisAlignedBB)var34.get(var30)).calculateYOffset(this.boundingBox, par3);
+                    par3 = ((AxisAlignedBB)var35.get(var30)).calculateYOffset(this.boundingBox, par3);
                 }
 
                 this.boundingBox.offset(0.0D, par3, 0.0D);
@@ -710,9 +740,9 @@ public abstract class Entity
                     par1 = 0.0D;
                 }
 
-                for (var30 = 0; var30 < var34.size(); ++var30)
+                for (var30 = 0; var30 < var35.size(); ++var30)
                 {
-                    par1 = ((AxisAlignedBB)var34.get(var30)).calculateXOffset(this.boundingBox, par1);
+                    par1 = ((AxisAlignedBB)var35.get(var30)).calculateXOffset(this.boundingBox, par1);
                 }
 
                 this.boundingBox.offset(par1, 0.0D, 0.0D);
@@ -724,9 +754,9 @@ public abstract class Entity
                     par1 = 0.0D;
                 }
 
-                for (var30 = 0; var30 < var34.size(); ++var30)
+                for (var30 = 0; var30 < var35.size(); ++var30)
                 {
-                    par5 = ((AxisAlignedBB)var34.get(var30)).calculateZOffset(this.boundingBox, par5);
+                    par5 = ((AxisAlignedBB)var35.get(var30)).calculateZOffset(this.boundingBox, par5);
                 }
 
                 this.boundingBox.offset(0.0D, 0.0D, par5);
@@ -748,9 +778,9 @@ public abstract class Entity
                 {
                     par3 = (double)(-this.stepHeight);
 
-                    for (var30 = 0; var30 < var34.size(); ++var30)
+                    for (var30 = 0; var30 < var35.size(); ++var30)
                     {
-                        par3 = ((AxisAlignedBB)var34.get(var30)).calculateYOffset(this.boundingBox, par3);
+                        par3 = ((AxisAlignedBB)var35.get(var30)).calculateYOffset(this.boundingBox, par3);
                     }
 
                     this.boundingBox.offset(0.0D, par3, 0.0D);
@@ -872,6 +902,8 @@ public abstract class Entity
             this.worldObj.theProfiler.endSection();
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Checks for block collisions, and calls the associated onBlockCollided method for the collided block.
@@ -910,13 +942,28 @@ public abstract class Entity
      */
     protected void playStepSound(int par1, int par2, int par3, int par4)
     {
+    	// FCMOD: Changed
+    	/*
         StepSound var5 = Block.blocksList[par4].stepSound;
-
+        
         if (this.worldObj.getBlockId(par1, par2 + 1, par3) == Block.snow.blockID)
         {
             var5 = Block.snow.stepSound;
             this.playSound(var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch());
         }
+        */
+        StepSound var5 = Block.blocksList[par4].GetStepSound( worldObj, par1, par2, par3 );
+        
+        int iBlockAboveID = worldObj.getBlockId( par1, par2 + 1, par3 );
+        Block blockAbove = Block.blocksList[iBlockAboveID];
+        
+        if ( blockAbove != null && blockAbove.IsGroundCover( ) )
+        {
+            var5 = blockAbove.stepSound;
+            
+            playSound( var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch() );
+        }
+    	// END FCMOD
         else if (!Block.blocksList[par4].blockMaterial.isLiquid())
         {
             this.playSound(var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch());
@@ -998,7 +1045,10 @@ public abstract class Entity
      */
     public boolean isWet()
     {
-        return this.inWater || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + (double)this.height), MathHelper.floor_double(this.posZ));
+    	// FCMOD: Changed
+        //return this.inWater || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + (double)this.height), MathHelper.floor_double(this.posZ));
+        return inWater || IsBeingRainedOn();
+        // END FCMOD
     }
 
     /**
@@ -1373,6 +1423,12 @@ public abstract class Entity
         try
         {
             par1NBTTagCompound.setTag("Pos", this.newDoubleNBTList(new double[] {this.posX, this.posY + (double)this.ySize, this.posZ}));
+        	// FCMOD: Added to fix collision errors on load 
+            par1NBTTagCompound.setTag( "fcMin", newDoubleNBTList( 
+            	new double[] { boundingBox.minX, boundingBox.minY, boundingBox.minZ } ) );
+            par1NBTTagCompound.setTag( "fcMax", newDoubleNBTList(
+            	new double[] { boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ } ) );
+            // END FCMOD
             par1NBTTagCompound.setTag("Motion", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
             par1NBTTagCompound.setTag("Rotation", this.newFloatNBTList(new float[] {this.rotationYaw, this.rotationPitch}));
             par1NBTTagCompound.setFloat("FallDistance", this.fallDistance);
@@ -1408,6 +1464,8 @@ public abstract class Entity
     /**
      * Reads the entity from NBT (calls an abstract helper method to read specialized data)
      */
+    // FCMOD: Removed and replaced
+    /*
     public void readFromNBT(NBTTagCompound par1NBTTagCompound)
     {
         try
@@ -1464,6 +1522,8 @@ public abstract class Entity
             throw new ReportedException(var3);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the string that identifies this Entity's class
@@ -1730,6 +1790,7 @@ public abstract class Entity
 
     /**
      * Called when a player unounts an entity.
+     * FCNOTE: Call mountEntity( null ) for regular entities.  This searches area for solid ground, and is intended for the player.
      */
     public void unmountEntity(Entity par1Entity)
     {
@@ -2169,7 +2230,12 @@ public abstract class Entity
 
     public float func_82146_a(Explosion par1Explosion, World par2World, int par3, int par4, int par5, Block par6Block)
     {
+    	// FCMOD: Code change
+    	/*
         return par6Block.getExplosionResistance(this);
+        */
+        return par6Block.getExplosionResistance(this, par2World, par3, par4, par5);
+    	// END FCMOD
     }
 
     public boolean func_96091_a(Explosion par1Explosion, World par2World, int par3, int par4, int par5, int par6, float par7)
@@ -2217,4 +2283,709 @@ public abstract class Entity
     {
         return this.getEntityName();
     }
+
+    // FCMOD: Added New
+    public boolean IsAffectedByMovementModifiers()
+    {
+    	return true;
+    }
+    
+    public void NotifyOfWolfHowl( Entity sourceEntity )
+    {
+    }
+    
+    protected boolean ShouldSetPositionOnLoad()
+    {
+    	return true;
+    }
+    
+    public boolean CanCollideWithEntity( Entity entity )
+    {
+    	return true;
+    }
+    
+    public boolean IsItemEntity()
+    {
+    	return false;
+    }
+    
+    public boolean CanEntityTriggerTripwire()
+    {
+    	return true;
+    }
+    
+    public AxisAlignedBB GetVisualBoundingBox()
+    {
+    	return boundingBox;    	
+    }
+    
+    public boolean IsSecondaryTargetForSquid()
+    {
+    	return false;
+    }
+    
+    public boolean GetCanBeHeadCrabbed( boolean bSquidInWater )
+    {
+    	return isEntityAlive() && riddenByEntity == null && ridingEntity == null && 
+    		IsSecondaryTargetForSquid();
+    }
+    
+    public boolean IsValidOngoingAttackTargetForSquid()
+    {
+    	return IsSecondaryTargetForSquid() && isEntityAlive();
+    }
+    
+    public void OnFlungBySquidTentacle( FCEntitySquid squid )
+    {
+    }
+    
+    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
+    {
+    }    
+    
+    public boolean HasHeadCrabbedSquid()
+    {
+    	return riddenByEntity != null && riddenByEntity instanceof FCEntitySquid;
+    }
+    
+    public Entity GetHeadCrabSharedAttackTarget()
+    {
+    	return null;
+    }
+    
+	public boolean IsImmuneToHeadCrabDamage()
+	{
+		return false;
+	}
+	
+    public void OnKickedByCow( FCEntityCow cow )
+	{
+    	FlingAwayFromEntity( cow, GetCowKickMovementMultiplier() );    	
+    }
+    
+    protected double GetCowKickMovementMultiplier()
+    {
+    	return 1D;
+    }
+    
+    public void FlingAwayFromEntity( Entity repulsingEntity, double dForceMultiplier )
+	{
+        if ( ridingEntity != null )
+        {
+        	mountEntity( null );
+        }
+        
+        double dVelocityX = motionX;
+        double dVelocityZ = motionZ;
+        
+		double dDeltaX = posX - repulsingEntity.posX; 
+		double dDeltaZ = posZ - repulsingEntity.posZ;
+		
+		double dFlatDistToTargetSq = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+
+		if ( dFlatDistToTargetSq > 0.1D )
+		{
+			double dFlatDistToTarget = MathHelper.sqrt_double( dFlatDistToTargetSq );
+			
+			dVelocityX += ( dDeltaX / dFlatDistToTarget ) * 0.5D * dForceMultiplier;
+			dVelocityZ += ( dDeltaZ / dFlatDistToTarget ) * 0.5F * dForceMultiplier;
+		}
+		
+		isAirBorne = true;
+
+        double dVelocityY = motionY + ( 0.25D * dForceMultiplier );
+        
+        dVelocityX *= ( rand.nextDouble() * 0.2D ) + 0.9;
+        dVelocityZ *= ( rand.nextDouble() * 0.2D ) + 0.9;
+        
+		motionX = FCUtilsMath.ClampDouble( dVelocityX, -1D, 1D );
+		motionY = FCUtilsMath.ClampDoubleTop( dVelocityY, 0.75D );
+		motionZ = FCUtilsMath.ClampDouble( dVelocityZ, -1D, 1D );
+    }
+    
+    public boolean DoesEntityApplyToSpawnCap()
+    {
+    	// by default entities do not apply to the spawn cap as this avoids a lot of unnecessary instanceof checks in World.CountEntitiesThatApplyToSpawnCap()
+    	// Note that this behavior is overriden in EntityLiving, which is where it really matters.
+    	
+    	return false;
+    }
+    
+	public void OutOfUpdateRangeUpdate()
+	{
+	}
+	
+	public boolean AppliesConstantForceWhenRidingBoat()
+	{
+		return false;
+	}
+	
+	public double MovementModifierWhenRidingBoat()
+	{
+		return 1.0D;
+	}
+	
+	/**
+	 * Returns true if this function has handled the possession transfer from the dead entity.  Called on server only.
+	 */
+	public boolean OnPossesedRidingEntityDeath()
+	{
+		return false;
+	}
+	
+    public boolean IsBeingRainedOn()
+    {
+        int i = MathHelper.floor_double( posX );
+        int j = MathHelper.floor_double( boundingBox.maxY );
+        int k = MathHelper.floor_double( posZ );
+    	
+    	return worldObj.IsRainingAtPos( i, j, k );
+    }    
+    
+    public boolean DoesEntityApplyToSquidPossessionCap()
+    {
+    	return false;
+    }
+    
+    public boolean IsValidZombieSecondaryTarget( EntityZombie zombie )
+    {
+    	return false;
+    }
+
+    public boolean AttractsLightning()
+    {
+    	return false;
+    }
+    
+    public void OnStruckByLightning( FCEntityLightningBolt boltEntity )
+    {
+        dealFireDamage( 7 );
+        
+        fire++;
+
+        if ( fire == 0 )
+        {
+            setFire( 8 );
+        }
+        
+        if ( !isEntityInvulnerable() )
+        {
+        	FlingAwayFromEntity( boltEntity, 2D );
+        }
+    }
+    
+    public void moveEntity( double dMoveX, double dMoveY, double dMoveZ )
+    {
+    	// replacement for vanilla function that cleans up the code for readability while retaining
+    	// same functionality.  Modifications to vanilla functionality listed as FCMOD
+    	
+    	// Note: I've elminated all references to field_70135_K as this seems to be a lingering
+    	// debug value that serves no actual purpose
+    	
+        if ( noClip )
+        {
+            boundingBox.offset( dMoveX, dMoveY, dMoveZ );
+            
+            posX = ( boundingBox.minX + boundingBox.maxX ) / 2D;
+            posY = boundingBox.minY + (double)yOffset - (double)ySize;
+            posZ = ( boundingBox.minZ + boundingBox.maxZ ) / 2D;
+            
+            return;
+        }
+        
+        worldObj.theProfiler.startSection("move");
+        ySize *= 0.4F; // This is actually the position offset due to player sneaking/crouching 
+        
+        double dOldPosX = posX;
+        double dOldPosY = posY;
+        double dOldPosZ = posZ;
+
+        AxisAlignedBB oldBoundingBox = boundingBox.copy();
+        
+        if ( isInWeb )
+        {
+            isInWeb = false;
+            
+            dMoveX *= 0.25D;
+            dMoveY *= 0.05000000074505806D;
+            dMoveZ *= 0.25D;
+            
+            motionX = 0.0D;
+            motionY = 0.0D;
+            motionZ = 0.0D;
+        }
+
+        boolean bIsSneakingPlayer = onGround && isSneaking() && this instanceof EntityPlayer;
+
+        if ( bIsSneakingPlayer )
+        {
+            double dStepSize = 0.05D;
+
+            while ( dMoveX != 0D && worldObj.getCollidingBoundingBoxes( this, 
+        		boundingBox.getOffsetBoundingBox( dMoveX, -1D, 0D ) ).isEmpty() )
+            {
+                if (dMoveX < dStepSize && dMoveX >= -dStepSize)
+                {
+                    dMoveX = 0D;
+                }
+                else if ( dMoveX > 0D )
+                {
+                    dMoveX -= dStepSize;
+                }
+                else
+                {
+                    dMoveX += dStepSize;
+                }
+            }
+
+            while ( dMoveZ != 0D && worldObj.getCollidingBoundingBoxes( this, 
+            	boundingBox.getOffsetBoundingBox( 0D, -1D, dMoveZ ) ).isEmpty() )
+            {
+                if ( dMoveZ < dStepSize && dMoveZ >= -dStepSize )
+                {
+                    dMoveZ = 0D;
+                }
+                else if ( dMoveZ > 0D )
+                {
+                    dMoveZ -= dStepSize;
+                }
+                else
+                {
+                    dMoveZ += dStepSize;
+                }
+            }
+
+            // FCNOTE: the dMoveX != 0D && dMoveZ != 0D below looks a bit weird,
+            // but it's valid as single axis collisions have already been checked above
+            while ( dMoveX != 0D && dMoveZ != 0D && worldObj.getCollidingBoundingBoxes( this, 
+            	boundingBox.getOffsetBoundingBox( dMoveX, -1D, dMoveZ ) ).isEmpty() )
+            {
+                if ( dMoveX < dStepSize && dMoveX >= -dStepSize )
+                {
+                    dMoveX = 0D;
+                }
+                else if ( dMoveX > 0D )
+                {
+                    dMoveX -= dStepSize;
+                }
+                else
+                {
+                    dMoveX += dStepSize;
+                }
+
+                if ( dMoveZ < dStepSize && dMoveZ >= -dStepSize )
+                {
+                    dMoveZ = 0D;
+                }
+                else if ( dMoveZ > 0D )
+                {
+                    dMoveZ -= dStepSize;
+                }
+                else
+                {
+                    dMoveZ += dStepSize;
+                }
+            }
+        }
+
+        double dUnboundedMoveX = dMoveX;
+        double dUnboundedMoveY = dMoveY;
+        double dUnboundedMoveZ = dMoveZ;
+        
+        // addCoord() below returns a new box expanded in the direction of the point
+        
+        // FCMOD: Changed the following bit to calculate one collision list that takes steps
+        // into account right from the start, instead of doing this whole thing a second time 
+        // when steps are checked for later
+        //List<AxisAlignedBB> moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
+        	//boundingBox.addCoord( dMoveX, dMoveY, dMoveZ ) );
+        AxisAlignedBB moveRangeBoundingBox = boundingBox.addCoord( dMoveX, dMoveY, dMoveZ );
+        
+        if ( stepHeight > dMoveY )
+        {
+        	moveRangeBoundingBox.maxY = boundingBox.maxY + stepHeight;
+        }
+        
+        List<AxisAlignedBB> moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
+        	moveRangeBoundingBox );
+        // END FCMOD
+
+        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+        {
+        	// Keep reducing the magnitude of the y movement until it is within the vertical gap
+        	// between the original position and any potentially colliding blocks
+        	
+            dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset( 
+            	boundingBox, dMoveY );
+        }
+
+        boundingBox.offset( 0D, dMoveY, 0D );
+
+        boolean bVerticallySupported = onGround || 
+        	( dUnboundedMoveY != dMoveY && dUnboundedMoveY < 0D );
+        
+        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+        {        	
+            dMoveX = moveRangeCollisionList.get( iTempIndex ).calculateXOffset( 
+            	boundingBox, dMoveX );
+        }
+
+        boundingBox.offset( dMoveX, 0D, 0D );
+
+        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+        {
+            dMoveZ = moveRangeCollisionList.get( iTempIndex ).calculateZOffset(
+            	boundingBox, dMoveZ );
+        }
+
+        boundingBox.offset( 0D, 0D, dMoveZ );
+        
+        if ( stepHeight > 0F && bVerticallySupported && 
+        	( bIsSneakingPlayer || ySize < 0.05F ) && 
+        	( dUnboundedMoveX != dMoveX || dUnboundedMoveZ != dMoveZ ) )
+        {
+            double dBoundedMoveX = dMoveX;
+            double dBoundedMoveY = dMoveY;
+            double dBoundedMoveZ = dMoveZ;
+            
+            dMoveX = dUnboundedMoveX;
+            dMoveY = stepHeight;
+            dMoveZ = dUnboundedMoveZ;
+            
+            AxisAlignedBB dBoundedMoveBox = boundingBox.copy();
+            
+            boundingBox.setBB( oldBoundingBox );
+            
+            // FCMOD: Removed to use precomputed collision list
+            //moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
+            	//boundingBox.addCoord( dUnboundedMoveX, dMoveY, dUnboundedMoveZ ) );
+            // END FCMOD
+
+            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+            {
+                dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset(
+                	boundingBox, dMoveY );
+            }
+
+            boundingBox.offset( 0D, dMoveY, 0D );
+
+            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+            {
+                dMoveX = moveRangeCollisionList.get( iTempIndex ).calculateXOffset(
+                	boundingBox, dMoveX );
+            }
+
+            boundingBox.offset( dMoveX, 0D, 0D );
+
+            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+            {
+                dMoveZ = moveRangeCollisionList.get( iTempIndex ).calculateZOffset(
+                	boundingBox, dMoveZ );
+            }
+
+            boundingBox.offset( 0D, 0D, dMoveZ );
+
+            // the following portion drops the entity downward after stepping up, to find
+            // the surface it should be resting on
+
+            if ( dMoveY > 0D )
+            {
+	            // FCMOD: Changed so that the entity doesn't end up descending further than it 
+            	// climbed fixing a bug with mobs falling through slabs [MC-72868]
+	            //dMoveY = -stepHeight;
+	            dMoveY = -dMoveY;
+	
+	            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
+	            {
+	                dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset(
+	                	boundingBox, dMoveY );
+	            }
+
+	            boundingBox.offset( 0D, dMoveY, 0D );
+            }
+
+            if ( dBoundedMoveX * dBoundedMoveX + dBoundedMoveZ * dBoundedMoveZ >= 
+            	dMoveX * dMoveX + dMoveZ * dMoveZ )
+            {
+                dMoveX = dBoundedMoveX;
+                dMoveY = dBoundedMoveY;
+                dMoveZ = dBoundedMoveZ;
+                
+                boundingBox.setBB(dBoundedMoveBox);
+            }
+        }
+
+        worldObj.theProfiler.endSection();
+        
+        worldObj.theProfiler.startSection("rest");
+        
+        posX = ( boundingBox.minX + boundingBox.maxX ) / 2D;
+        posY = boundingBox.minY + yOffset - ySize;
+        posZ = ( boundingBox.minZ + boundingBox.maxZ ) / 2D;
+        
+        isCollidedHorizontally = dUnboundedMoveX != dMoveX || dUnboundedMoveZ != dMoveZ;
+        isCollidedVertically = dUnboundedMoveY != dMoveY;        
+        onGround = dUnboundedMoveY != dMoveY && dUnboundedMoveY < 0.0D;
+        
+        isCollided = isCollidedHorizontally || isCollidedVertically;
+        
+        updateFallState( dMoveY, onGround );
+
+        if ( dUnboundedMoveX != dMoveX )
+        {
+            motionX = 0D;
+        }
+
+        if ( dUnboundedMoveY != dMoveY )
+        {
+            motionY = 0D;
+        }
+
+        if ( dUnboundedMoveZ != dMoveZ )
+        {
+            motionZ = 0D;
+        }
+
+        double dDeltaX = posX - dOldPosX;
+        double dDeltaY = posY - dOldPosY;
+        double dDeltaZ = posZ - dOldPosZ;
+
+        if ( canTriggerWalking() && !bIsSneakingPlayer && ridingEntity == null )
+        {
+            int iGroundI = MathHelper.floor_double( posX );
+            // FCMOD: Changed to refine step sounds
+            //int iGroundJ = MathHelper.floor_double( posY - 0.20000000298023224D - yOffset );
+            int iGroundJ = MathHelper.floor_double( posY - 0.03D - yOffset );
+            // END FCMOD
+            int iGroundK = MathHelper.floor_double( posZ );
+            
+            int iGroundBlockID = worldObj.getBlockId(iGroundI, iGroundJ, iGroundK);
+            
+            // FCMOD: Added
+            int iTempY = iGroundJ;
+            // END FCMOD
+
+            if ( iGroundBlockID == 0 )
+            {
+                int iGroundRenderType = worldObj.blockGetRenderType( iGroundI, iGroundJ - 1, 
+                	iGroundK );
+
+                if ( iGroundRenderType == 11 || iGroundRenderType == 32 || 
+                	iGroundRenderType == 21 )
+                {
+                    iGroundBlockID = worldObj.getBlockId( iGroundI, iGroundJ - 1, iGroundK );
+                    // FCMOD: Added
+                    iTempY = iGroundJ - 1;
+                    // END FCMOD
+                }
+            }
+
+            // FCMOD: Changed
+            /*
+            if (var32 != Block.ladder.blockID)
+            {
+                var25 = 0.0D;
+            }
+            */
+            Block inBlock = Block.blocksList[iGroundBlockID];
+            
+            if ( inBlock == null || !inBlock.IsBlockClimbable( worldObj, iGroundI, iTempY, iGroundK ) )
+            {
+                dDeltaY = 0D;
+            }                
+            // END FCMOD
+
+            distanceWalkedModified = distanceWalkedModified + MathHelper.sqrt_double(
+            	dDeltaX * dDeltaX + dDeltaZ * dDeltaZ ) * 0.6F;
+            
+            distanceWalkedOnStepModified = distanceWalkedOnStepModified + MathHelper.sqrt_double( 
+            	dDeltaX * dDeltaX + dDeltaY * dDeltaY + dDeltaZ * dDeltaZ ) * 0.6F;
+
+            if ( distanceWalkedOnStepModified > nextStepDistance && iGroundBlockID > 0 )
+            {
+                nextStepDistance = (int)distanceWalkedOnStepModified + 1;
+
+                if ( isInWater() )
+                {
+                    float fSwimSoundVolume = MathHelper.sqrt_double(
+                    	motionX * motionX * 0.20000000298023224D + motionY * motionY + 
+                    	motionZ * motionZ * 0.20000000298023224D ) * 0.35F;
+
+                    if ( fSwimSoundVolume > 1F )
+                    {
+                        fSwimSoundVolume = 1F;
+                    }
+
+                    playSound( "liquid.swim", fSwimSoundVolume, 
+                    	1F + ( rand.nextFloat() - rand.nextFloat() ) * 0.4F );
+                }
+
+                playStepSound( iGroundI, iGroundJ, iGroundK, iGroundBlockID );
+                
+                Block.blocksList[iGroundBlockID].onEntityWalking( worldObj, 
+                	iGroundI, iGroundJ, iGroundK, this );
+            }
+        }
+
+        doBlockCollisions(); // notifies blocks of intersections, doesn't move entity
+        
+        boolean bWet = isWet();
+
+        // FCMOD: Changed
+        //if ( worldObj.isBoundingBoxBurning( boundingBox.contract( 0.001D, 0.001D, 0.001D ) ) )
+        if ( worldObj.isBoundingBoxBurning( this ) )
+    	// END FCMOD
+        {
+            dealFireDamage( 1 );
+
+            if ( !bWet )
+            {
+                fire++;
+
+                if ( fire == 0 )
+                {
+                    setFire( 8 );
+                }
+            }
+        }
+        else if ( fire <= 0 )
+        {
+            fire = -fireResistance;
+        }
+
+        if ( bWet && fire > 0 )
+        {
+            playSound( "random.fizz", 0.7F, 1.6F + ( rand.nextFloat() - 
+            	rand.nextFloat() ) * 0.4F );
+            
+            fire = -fireResistance;
+        }
+
+        worldObj.theProfiler.endSection();
+    }
+    
+    public void readFromNBT( NBTTagCompound tag )
+    {
+        try
+        {
+        	boolean bHasBoundingData = false;
+        	
+    		NBTTagList posTag = tag.getTagList( "Pos" );
+    		
+    		prevPosX = lastTickPosX = posX = ( (NBTTagDouble)posTag.tagAt( 0 ) ).data;
+    		prevPosY = lastTickPosY = posY = ( (NBTTagDouble)posTag.tagAt( 1 ) ).data;
+    		prevPosZ = lastTickPosZ = posZ = ( (NBTTagDouble)posTag.tagAt( 2 ) ).data;
+        	
+        	if ( tag.hasKey( "fcMin" ) )
+        	{
+        		bHasBoundingData = true; 
+        			
+        		// fix for entities getting stuck in blocks on load
+        		
+        		NBTTagList minTag = tag.getTagList( "fcMin" );
+        		
+                double dMinX = ( (NBTTagDouble )minTag.tagAt( 0 ) ).data;
+                double dMinY = ( (NBTTagDouble )minTag.tagAt( 1 ) ).data;
+                double dMinZ = ( (NBTTagDouble )minTag.tagAt( 2 ) ).data;                
+	            
+        		NBTTagList maxTag = tag.getTagList( "fcMax" );
+        		
+                double dMaxX = ( (NBTTagDouble )maxTag.tagAt( 0 ) ).data;
+                double dMaxY = ( (NBTTagDouble )maxTag.tagAt( 1 ) ).data;
+                double dMaxZ = ( (NBTTagDouble )maxTag.tagAt( 2 ) ).data;
+                
+                boundingBox.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );
+        	}
+        	else
+        	{   
+                setPosition( posX, posY, posZ );        		
+        	}
+        	
+            NBTTagList motionTag = tag.getTagList("Motion");
+            
+            motionX = ((NBTTagDouble)motionTag.tagAt(0)).data;
+            motionY = ((NBTTagDouble)motionTag.tagAt(1)).data;
+            motionZ = ((NBTTagDouble)motionTag.tagAt(2)).data;
+
+            if (Math.abs(this.motionX) > 10.0D)
+            {
+                this.motionX = 0.0D;
+            }
+
+            if (Math.abs(this.motionY) > 10.0D)
+            {
+                this.motionY = 0.0D;
+            }
+
+            if (Math.abs(this.motionZ) > 10.0D)
+            {
+                this.motionZ = 0.0D;
+            }
+
+            NBTTagList rotationTag = tag.getTagList("Rotation");
+            
+            this.prevRotationYaw = this.rotationYaw = ((NBTTagFloat)rotationTag.tagAt(0)).data;
+            this.prevRotationPitch = this.rotationPitch = ((NBTTagFloat)rotationTag.tagAt(1)).data;
+            
+            this.fallDistance = tag.getFloat("FallDistance");
+            this.fire = tag.getShort("Fire");
+            this.setAir(tag.getShort("Air"));
+            this.onGround = tag.getBoolean("OnGround");
+            this.dimension = tag.getInteger("Dimension");
+            this.invulnerable = tag.getBoolean("Invulnerable");
+            this.timeUntilPortal = tag.getInteger("PortalCooldown");
+
+            if (tag.hasKey("UUIDMost") && tag.hasKey("UUIDLeast"))
+            {
+                this.entityUniqueID = new UUID(tag.getLong("UUIDMost"), tag.getLong("UUIDLeast"));
+            }
+
+            this.setRotation(this.rotationYaw, this.rotationPitch);
+            
+            readEntityFromNBT(tag);
+            
+            if ( !bHasBoundingData && ShouldSetPositionOnLoad() )
+            {
+            	// added to duplicate 1.6 fix for animals suffocating and escaping.
+            	// I believe this was due to stuff like child animals modifying their dimensions
+            	// during init, but is not required with the changes made to save full bounding
+            	// boxes
+            	
+                setPosition( posX, posY, posZ);
+            }
+        }
+        catch (Throwable var5)
+        {
+            CrashReport var3 = CrashReport.makeCrashReport(var5, "Loading entity NBT");
+            CrashReportCategory var4 = var3.makeCategory("Entity being loaded");
+            this.func_85029_a(var4);
+            throw new ReportedException(var3);
+        }
+    }
+    
+    /**
+     * Called when clients receive a packed from the server indicating that they should
+     * mount an entity as part of fix for MC-1291.
+     */
+    public void MountEntityRemote( Entity entityToMount )
+    {
+    	mountEntity( entityToMount );
+    }
+    
+    public void FlagAllWatchedObjectsDirty()
+    {
+    	List watchList = dataWatcher.getAllWatched();
+    	
+    	if ( watchList != null )
+    	{
+	        Iterator watchIterator = watchList.iterator();
+	
+	        while ( watchIterator.hasNext() )
+	        {
+	            WatchableObject tempWatchable = (WatchableObject)watchIterator.next();
+	            dataWatcher.setObjectWatched( tempWatchable.getDataValueId() );
+	        }
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIAttackOnCollide.java b/minecraft_server/net/minecraft/src/EntityAIAttackOnCollide.java
index e9dbb69..268da4d 100644
--- a/minecraft_server/net/minecraft/src/EntityAIAttackOnCollide.java
+++ b/minecraft_server/net/minecraft/src/EntityAIAttackOnCollide.java
@@ -80,6 +80,12 @@ public class EntityAIAttackOnCollide extends EntityAIBase
      */
     public void resetTask()
     {
+    	// FCMOD: Added
+    	if ( attacker.getAttackTarget() == entityTarget )
+    	{
+    		attacker.setAttackTarget( null );
+    	}
+    	// END FCMOD
         this.entityTarget = null;
         this.attacker.getNavigator().clearPathEntity();
     }
@@ -98,7 +104,20 @@ public class EntityAIAttackOnCollide extends EntityAIBase
         }
 
         this.attackTick = Math.max(this.attackTick - 1, 0);
+        // FCMOD: Code change to take width of target into account as the original code assumes it's the same as the attacker
+        /*
         double var1 = (double)(this.attacker.width * 2.0F * this.attacker.width * 2.0F);
+        */
+        double dCombinedWidth = attacker.width + entityTarget.width;
+        double var1 = dCombinedWidth * dCombinedWidth;
+        
+        if ( entityTarget == attacker.riddenByEntity )
+        {
+        	// stop stuff like wolves biting squid on their backs
+        	
+        	return;
+        }
+        // END FCMOD
 
         if (this.attacker.getDistanceSq(this.entityTarget.posX, this.entityTarget.boundingBox.minY, this.entityTarget.posZ) <= var1)
         {
diff --git a/minecraft_server/net/minecraft/src/EntityAICreeperSwell.java b/minecraft_server/net/minecraft/src/EntityAICreeperSwell.java
index 89b8be6..f53c193 100644
--- a/minecraft_server/net/minecraft/src/EntityAICreeperSwell.java
+++ b/minecraft_server/net/minecraft/src/EntityAICreeperSwell.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityAICreeperSwell extends EntityAIBase
diff --git a/minecraft_server/net/minecraft/src/EntityAIDoorInteract.java b/minecraft_server/net/minecraft/src/EntityAIDoorInteract.java
index 61704ab..e049e9e 100644
--- a/minecraft_server/net/minecraft/src/EntityAIDoorInteract.java
+++ b/minecraft_server/net/minecraft/src/EntityAIDoorInteract.java
@@ -106,6 +106,10 @@ public abstract class EntityAIDoorInteract extends EntityAIBase
     private BlockDoor findUsableDoor(int par1, int par2, int par3)
     {
         int var4 = this.theEntity.worldObj.getBlockId(par1, par2, par3);
-        return var4 != Block.doorWood.blockID ? null : (BlockDoor)Block.blocksList[var4];
+        // FCMOD: Changed
+        //return var4 != Block.doorWood.blockID ? null : (BlockDoor)Block.blocksList[var4];
+        return ( var4 != Block.doorWood.blockID && var4 != FCBetterThanWolves.fcBlockDoorWood.blockID ) ? 
+        	null : (BlockDoor)Block.blocksList[var4];
+    	// END FCMOD
     }
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIEatGrass.java b/minecraft_server/net/minecraft/src/EntityAIEatGrass.java
index 15500a1..eadde58 100644
--- a/minecraft_server/net/minecraft/src/EntityAIEatGrass.java
+++ b/minecraft_server/net/minecraft/src/EntityAIEatGrass.java
@@ -85,7 +85,12 @@ public class EntityAIEatGrass extends EntityAIBase
             else if (this.theWorld.getBlockId(var1, var2 - 1, var3) == Block.grass.blockID)
             {
                 this.theWorld.playAuxSFX(2001, var1, var2 - 1, var3, Block.grass.blockID);
+                // FCMOD: Changed to send notification
+                /*
                 this.theWorld.setBlock(var1, var2 - 1, var3, Block.dirt.blockID, 0, 2);
+                */
+                this.theWorld.setBlock(var1, var2 - 1, var3, Block.dirt.blockID, 0, 3);
+                // END FCMOD
                 this.theEntity.eatGrassBonus();
             }
         }
diff --git a/minecraft_server/net/minecraft/src/EntityAIFollowOwner.java b/minecraft_server/net/minecraft/src/EntityAIFollowOwner.java
index 6698b3c..4ab2c7e 100644
--- a/minecraft_server/net/minecraft/src/EntityAIFollowOwner.java
+++ b/minecraft_server/net/minecraft/src/EntityAIFollowOwner.java
@@ -84,6 +84,13 @@ public class EntityAIFollowOwner extends EntityAIBase
     {
         this.thePet.getLookHelper().setLookPositionWithEntity(this.theOwner, 10.0F, (float)this.thePet.getVerticalFaceSpeed());
 
+        // FCMOD: Code added to prevent pets sitting in Minecarts from teleporting
+        if ( thePet.ridingEntity != null )
+        {
+        	return;
+        }
+        // END FCMOD
+        
         if (!this.thePet.isSitting())
         {
             if (--this.field_75343_h <= 0)
@@ -94,10 +101,11 @@ public class EntityAIFollowOwner extends EntityAIBase
                 {
                     if (this.thePet.getDistanceSqToEntity(this.theOwner) >= 144.0D)
                     {
+                        // FCMOD: Code changed
+                    	/*
                         int var1 = MathHelper.floor_double(this.theOwner.posX) - 2;
                         int var2 = MathHelper.floor_double(this.theOwner.posZ) - 2;
                         int var3 = MathHelper.floor_double(this.theOwner.boundingBox.minY);
-
                         for (int var4 = 0; var4 <= 4; ++var4)
                         {
                             for (int var5 = 0; var5 <= 4; ++var5)
@@ -110,9 +118,57 @@ public class EntityAIFollowOwner extends EntityAIBase
                                 }
                             }
                         }
+                        */
+				        HandleTeleportation();
+				    	// END FCMOD
                     }
                 }
             }
         }
     }
+    
+    // FCMOD: Added
+    private void HandleTeleportation()
+    {
+    	if ( !thePet.IsAITryingToSit() )
+    	{
+	        // Code changed so that pets will teleport *behind* the player instead of just randomly around him
+	        Float xVector = ( MathHelper.sin((theOwner.rotationYaw / 180F) * (float)Math.PI) * 4.0F );
+	        Float zVector = -( MathHelper.cos((theOwner.rotationYaw / 180F) * (float)Math.PI) * 4.0F );
+	
+	        int var1 = MathHelper.floor_double(theOwner.posX + xVector);
+	        int var2 = MathHelper.floor_double(theOwner.posZ + zVector);
+	        int var3 = MathHelper.floor_double(theOwner.boundingBox.minY);
+	        
+	        // Changed this so that the searching starts at the center of the location
+	        
+	        for (int xCount = 0; xCount <= 4; xCount++)
+	        {
+	            for (int zCount = 0; zCount <= 4; zCount++)
+	            {
+	            	int xOffset = ( xCount + 1 ) >> 1;
+	            	int zOffset = ( zCount + 1 ) >> 1;
+	        
+	        		if ( ( xCount & 1 ) == 0 )
+	        		{
+	        			xOffset = -xOffset;
+	        		}
+	        		
+	        		if ( ( zOffset & 1 ) == 0 )
+	        		{
+	        			zOffset = -zOffset;
+	        		}
+	        		
+	                if ( theWorld.doesBlockHaveSolidTopSurface( var1 + xOffset, var3 - 1, var2 + zOffset) && 
+	            		!theWorld.isBlockNormalCube(var1 + xOffset, var3, var2 + zOffset) && !theWorld.isBlockNormalCube(var1 + xOffset, var3 + 1, var2 + zOffset))
+	                {
+	                    thePet.setLocationAndAngles((float)(var1 + xOffset) + 0.5F, var3, (float)(var2 + zOffset) + 0.5F, thePet.rotationYaw, thePet.rotationPitch);
+	                    petPathfinder.clearPathEntity();
+	                    return;
+	                }
+	            }
+	        }
+    	}
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIFollowParent.java b/minecraft_server/net/minecraft/src/EntityAIFollowParent.java
index a47aecd..0a08711 100644
--- a/minecraft_server/net/minecraft/src/EntityAIFollowParent.java
+++ b/minecraft_server/net/minecraft/src/EntityAIFollowParent.java
@@ -15,6 +15,10 @@ public class EntityAIFollowParent extends EntityAIBase
     {
         this.childAnimal = par1EntityAnimal;
         this.field_75347_c = par2;
+        
+        // FCMOD: Added
+        setMutexBits( 1 );
+        // END FCMOD
     }
 
     /**
@@ -70,6 +74,12 @@ public class EntityAIFollowParent extends EntityAIBase
      */
     public boolean continueExecuting()
     {
+    	// FCMOD: Added to prevent adult children from following their parents
+    	if ( !childAnimal.isChild() )
+    	{
+    		return false;
+    	}
+    	// FCMOD
         if (!this.parentAnimal.isEntityAlive())
         {
             return false;
diff --git a/minecraft_server/net/minecraft/src/EntityAIHurtByTarget.java b/minecraft_server/net/minecraft/src/EntityAIHurtByTarget.java
index 32ca596..5b2f2ab 100644
--- a/minecraft_server/net/minecraft/src/EntityAIHurtByTarget.java
+++ b/minecraft_server/net/minecraft/src/EntityAIHurtByTarget.java
@@ -5,15 +5,21 @@ import java.util.List;
 
 public class EntityAIHurtByTarget extends EntityAITarget
 {
+	// FCMOD: Changed the name of the following for clarity
+	/*
     boolean field_75312_a;
+	*/ 
+    private boolean m_bNearbyEntitiesOfSameTypeAttack;
+    // END FCMOD
 
     /** The PathNavigate of our entity. */
+    // FCNOTE: This is actually the target entity
     EntityLiving entityPathNavigate;
 
     public EntityAIHurtByTarget(EntityLiving par1EntityLiving, boolean par2)
     {
         super(par1EntityLiving, 16.0F, false);
-        this.field_75312_a = par2;
+        this.m_bNearbyEntitiesOfSameTypeAttack = par2;
         this.setMutexBits(1);
     }
 
@@ -22,7 +28,12 @@ public class EntityAIHurtByTarget extends EntityAITarget
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Changed this to ignore players in creative mode to reduce overall code complexity
+    	/*
         return this.isSuitableTarget(this.taskOwner.getAITarget(), true);
+        */
+        return this.isSuitableTarget(this.taskOwner.getAITarget(), false);
+        // END FCMOD    	
     }
 
     /**
@@ -30,7 +41,16 @@ public class EntityAIHurtByTarget extends EntityAITarget
      */
     public boolean continueExecuting()
     {
+    	// FCMOD: Change to stop executing when the target is dead, and to fix vanilla bug where this would immediately stop executing
+    	/*
         return this.taskOwner.getAITarget() != null && this.taskOwner.getAITarget() != this.entityPathNavigate;
+        */    	
+        return taskOwner.getAITarget() != null && 
+			taskOwner.getAITarget().isEntityAlive() && 
+	    	taskOwner.getAITarget() == entityPathNavigate && 
+	    	taskOwner.getAttackTarget() != null &&
+	    	taskOwner.getAttackTarget() == entityPathNavigate;
+    	// END FCMOD
     }
 
     /**
@@ -41,7 +61,7 @@ public class EntityAIHurtByTarget extends EntityAITarget
         this.taskOwner.setAttackTarget(this.taskOwner.getAITarget());
         this.entityPathNavigate = this.taskOwner.getAITarget();
 
-        if (this.field_75312_a)
+        if (this.m_bNearbyEntitiesOfSameTypeAttack)
         {
             List var1 = this.taskOwner.worldObj.getEntitiesWithinAABB(this.taskOwner.getClass(), AxisAlignedBB.getAABBPool().getAABB(this.taskOwner.posX, this.taskOwner.posY, this.taskOwner.posZ, this.taskOwner.posX + 1.0D, this.taskOwner.posY + 1.0D, this.taskOwner.posZ + 1.0D).expand((double)this.targetDistance, 10.0D, (double)this.targetDistance));
             Iterator var2 = var1.iterator();
@@ -50,10 +70,19 @@ public class EntityAIHurtByTarget extends EntityAITarget
             {
                 EntityLiving var3 = (EntityLiving)var2.next();
 
+            	// FCMOD: Changed this so any other creatures that glom on will trigger this same AI instead of having an attack target without a corresponding
+            	// AI state
+            	/*
                 if (this.taskOwner != var3 && var3.getAttackTarget() == null)
                 {
                     var3.setAttackTarget(this.taskOwner.getAITarget());
                 }
+                */
+                if (this.taskOwner != var3 && var3.getAttackTarget() == null && var3.getAITarget() == null )
+                {
+                	var3.setRevengeTarget( taskOwner.getAITarget() );
+                }
+            	// END FCMOD
             }
         }
 
@@ -65,9 +94,26 @@ public class EntityAIHurtByTarget extends EntityAITarget
      */
     public void resetTask()
     {
+    	// FCMOD: Code change to prevent problems with AI not resetting its target when it dies
+    	/*
         if (this.taskOwner.getAttackTarget() != null && this.taskOwner.getAttackTarget() instanceof EntityPlayer && ((EntityPlayer)this.taskOwner.getAttackTarget()).capabilities.disableDamage)
         {
             super.resetTask();
+            
+            // FCMOD: Code added to fix flickering between angry and not in creative            
+            taskOwner.entityLivingToAttack = null;
+            // END FCMOD
         }
+        */
+    	if ( taskOwner.getAttackTarget() != null && entityPathNavigate == taskOwner.getAttackTarget() )
+    	{
+            taskOwner.setAttackTarget((EntityLiving)null);
+    	}
+    	
+    	if ( taskOwner.getAITarget() != null && entityPathNavigate == taskOwner.getAITarget() )
+    	{
+    		taskOwner.setRevengeTarget( null );
+    	}
+    	// END FCMOD
     }
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIMate.java b/minecraft_server/net/minecraft/src/EntityAIMate.java
index 52f2049..6de33d6 100644
--- a/minecraft_server/net/minecraft/src/EntityAIMate.java
+++ b/minecraft_server/net/minecraft/src/EntityAIMate.java
@@ -6,9 +6,9 @@ import java.util.Random;
 
 public class EntityAIMate extends EntityAIBase
 {
-    private EntityAnimal theAnimal;
+    protected EntityAnimal theAnimal;
     World theWorld;
-    private EntityAnimal targetMate;
+    protected EntityAnimal targetMate;
 
     /**
      * Delay preventing a baby from spawning immediately when two mate-able animals find each other.
@@ -47,6 +47,12 @@ public class EntityAIMate extends EntityAIBase
      */
     public boolean continueExecuting()
     {
+    	// FCMOD: Added
+        if ( !theAnimal.isInLove() )
+        {
+            return false;
+        }
+    	// END FCMOD
         return this.targetMate.isEntityAlive() && this.targetMate.isInLove() && this.spawnBabyDelay < 60;
     }
 
@@ -70,7 +76,11 @@ public class EntityAIMate extends EntityAIBase
 
         if (this.spawnBabyDelay >= 60 && this.theAnimal.getDistanceSqToEntity(this.targetMate) < 9.0D)
         {
+        	/* FCMOD: Changed to use entity function to make birthing behavior easier to override and to consolodate it in one place
             this.spawnBaby();
+            */
+        	theAnimal.procreate( targetMate );
+        	// END FCMOD
         }
     }
 
@@ -103,6 +113,8 @@ public class EntityAIMate extends EntityAIBase
     /**
      * Spawns a baby animal of the same type.
      */
+    // FCMOD: Removed dead code
+    /*
     private void spawnBaby()
     {
         EntityAgeable var1 = this.theAnimal.createChild(this.targetMate);
@@ -126,7 +138,9 @@ public class EntityAIMate extends EntityAIBase
                 this.theWorld.spawnParticle("heart", this.theAnimal.posX + (double)(var2.nextFloat() * this.theAnimal.width * 2.0F) - (double)this.theAnimal.width, this.theAnimal.posY + 0.5D + (double)(var2.nextFloat() * this.theAnimal.height), this.theAnimal.posZ + (double)(var2.nextFloat() * this.theAnimal.width * 2.0F) - (double)this.theAnimal.width, var4, var6, var8);
             }
 
-            this.theWorld.spawnEntityInWorld(new EntityXPOrb(this.theWorld, this.theAnimal.posX, this.theAnimal.posY, this.theAnimal.posZ, var2.nextInt(7) + 1));
-        }
+            this.theWorld.spawnEntityInWorld(new EntityXPOrb(this.theWorld, this.theAnimal.posX, this.theAnimal.posY, this.theAnimal.posZ, var2.nextInt(7) + 1));            
+        }        
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIOpenDoor.java b/minecraft_server/net/minecraft/src/EntityAIOpenDoor.java
index 6b1f702..b4ce78a 100644
--- a/minecraft_server/net/minecraft/src/EntityAIOpenDoor.java
+++ b/minecraft_server/net/minecraft/src/EntityAIOpenDoor.java
@@ -26,7 +26,12 @@ public class EntityAIOpenDoor extends EntityAIDoorInteract
     public void startExecuting()
     {
         this.field_75360_j = 20;
+        // FCMOD: Code change
+        /*
         this.targetDoor.onPoweredBlockChange(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, true);
+        */        
+        this.targetDoor.OnAIOpenDoor(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, true);
+        // END FCMOD
     }
 
     /**
@@ -36,7 +41,12 @@ public class EntityAIOpenDoor extends EntityAIDoorInteract
     {
         if (this.field_75361_i)
         {
+            // FCMOD: Code change
+            /*
             this.targetDoor.onPoweredBlockChange(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, false);
+            */
+            this.targetDoor.OnAIOpenDoor(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, false);
+        	// END FCMOD
         }
     }
 
diff --git a/minecraft_server/net/minecraft/src/EntityAIOwnerHurtByTarget.java b/minecraft_server/net/minecraft/src/EntityAIOwnerHurtByTarget.java
index 540c235..977440b 100644
--- a/minecraft_server/net/minecraft/src/EntityAIOwnerHurtByTarget.java
+++ b/minecraft_server/net/minecraft/src/EntityAIOwnerHurtByTarget.java
@@ -17,6 +17,12 @@ public class EntityAIOwnerHurtByTarget extends EntityAITarget
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Code added to check if sitting before attacking    	
+    	if ( theDefendingTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	// END FCMOD
         if (!this.theDefendingTameable.isTamed())
         {
             return false;
@@ -45,4 +51,17 @@ public class EntityAIOwnerHurtByTarget extends EntityAITarget
         this.taskOwner.setAttackTarget(this.theOwnerAttacker);
         super.startExecuting();
     }
+
+    // FCMOD: Inherited function added
+    @Override
+    public boolean continueExecuting()
+    {
+    	if ( theDefendingTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	
+    	return super.continueExecuting();
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIOwnerHurtTarget.java b/minecraft_server/net/minecraft/src/EntityAIOwnerHurtTarget.java
index 7fcd2d9..d4eafad 100644
--- a/minecraft_server/net/minecraft/src/EntityAIOwnerHurtTarget.java
+++ b/minecraft_server/net/minecraft/src/EntityAIOwnerHurtTarget.java
@@ -17,6 +17,12 @@ public class EntityAIOwnerHurtTarget extends EntityAITarget
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Code added to check if sitting before attacking    	
+    	if ( theEntityTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	// END FCMOD
         if (!this.theEntityTameable.isTamed())
         {
             return false;
@@ -45,4 +51,17 @@ public class EntityAIOwnerHurtTarget extends EntityAITarget
         this.taskOwner.setAttackTarget(this.theTarget);
         super.startExecuting();
     }
+
+    // FCMOD: Inherited function added
+    @Override
+    public boolean continueExecuting()
+    {
+    	if ( theEntityTameable.isSitting() )
+    	{
+    		return false;
+    	}
+    	
+    	return super.continueExecuting();
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAISit.java b/minecraft_server/net/minecraft/src/EntityAISit.java
index f709bff..633f9a4 100644
--- a/minecraft_server/net/minecraft/src/EntityAISit.java
+++ b/minecraft_server/net/minecraft/src/EntityAISit.java
@@ -33,7 +33,12 @@ public class EntityAISit extends EntityAIBase
         else
         {
             EntityLiving var1 = this.theEntity.getOwner();
+            // FCMOD: Line change to prevent wolves from standing when player is attacked
+            /*
             return var1 == null ? true : (this.theEntity.getDistanceSqToEntity(var1) < 144.0D && var1.getAITarget() != null ? false : this.isSitting);
+            */
+            return var1 == null ? true : this.isSitting;
+            // END FCMOD
         }
     }
 
@@ -61,4 +66,11 @@ public class EntityAISit extends EntityAIBase
     {
         this.isSitting = par1;
     }
-}
+    
+    // FCMOD: Added
+    public boolean IsTryingToSit()
+    {
+    	return this.isSitting;
+    }
+    // END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/EntityAITasks.java b/minecraft_server/net/minecraft/src/EntityAITasks.java
index 035b107..7acb980 100644
--- a/minecraft_server/net/minecraft/src/EntityAITasks.java
+++ b/minecraft_server/net/minecraft/src/EntityAITasks.java
@@ -178,4 +178,48 @@ public class EntityAITasks
     {
         return (par1EntityAITaskEntry.action.getMutexBits() & par2EntityAITaskEntry.action.getMutexBits()) == 0;
     }
+    
+    // FCMOD: Added New
+    public void RemoveAllTasksOfClass( Class classToRemove )
+    {
+        Iterator<EntityAITaskEntry> entries = taskEntries.iterator();
+
+        while ( entries.hasNext())
+        {
+            EntityAITaskEntry tempEntry = entries.next();
+            EntityAIBase tempAction = tempEntry.action;
+
+            if ( classToRemove.isAssignableFrom( tempAction.getClass() ) )
+            {
+                if ( executingTaskEntries.contains( tempEntry ) )
+                {
+                    tempAction.resetTask();
+                    
+                    executingTaskEntries.remove( tempEntry );
+                }
+
+                entries.remove();
+            }
+        }
+    }
+    
+    public void RemoveAllTasks()
+    {
+        Iterator<EntityAITaskEntry> entries = taskEntries.iterator();
+
+        while ( entries.hasNext())
+        {
+            EntityAITaskEntry tempEntry = entries.next();
+
+            if ( executingTaskEntries.contains( tempEntry ) )
+            {
+                tempEntry.action.resetTask();
+                
+                executingTaskEntries.remove( tempEntry );
+            }
+
+            entries.remove();
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAITempt.java b/minecraft_server/net/minecraft/src/EntityAITempt.java
index 870e031..cb54816 100644
--- a/minecraft_server/net/minecraft/src/EntityAITempt.java
+++ b/minecraft_server/net/minecraft/src/EntityAITempt.java
@@ -97,7 +97,12 @@ public class EntityAITempt extends EntityAIBase
             this.field_75279_g = (double)this.temptingPlayer.rotationYaw;
         }
 
+        // FCMOD: Changed this line
+        /*
         return this.shouldExecute();
+        */
+        return ShouldContinueFollowing();
+        // END FCMOD
     }
 
     /**
@@ -120,7 +125,12 @@ public class EntityAITempt extends EntityAIBase
     {
         this.temptingPlayer = null;
         this.temptedEntity.getNavigator().clearPathEntity();
+        // FCMOD: Code change to make animals more responsive to tempting.  Note that AI is only checked every three ticks
+        /*
         this.delayTemptCounter = 100;
+        */
+        this.delayTemptCounter = 33;
+        // END FCMOD
         this.field_75287_j = false;
         this.temptedEntity.getNavigator().setAvoidsWater(this.field_75286_m);
     }
@@ -146,4 +156,34 @@ public class EntityAITempt extends EntityAIBase
     {
         return this.field_75287_j;
     }
+    
+    // FCMOD: Function added
+    private boolean ShouldContinueFollowing()
+    {
+        if (delayTemptCounter > 0)
+        {
+            delayTemptCounter--;
+            return false;
+        }
+
+        if (temptingPlayer == null || temptingPlayer.isLivingDead )
+        {
+            return false;
+        }
+
+        if (temptedEntity.getDistanceSqToEntity(temptingPlayer) > 256D)
+        {
+        	return false;
+        }
+
+        ItemStack itemstack = temptingPlayer.getCurrentEquippedItem();
+
+        if (itemstack == null)
+        {
+            return false;
+        }
+
+        return itemstack.itemID == breedingFood;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAIWander.java b/minecraft_server/net/minecraft/src/EntityAIWander.java
index cd0aaf4..ff2e5a1 100644
--- a/minecraft_server/net/minecraft/src/EntityAIWander.java
+++ b/minecraft_server/net/minecraft/src/EntityAIWander.java
@@ -20,11 +20,21 @@ public class EntityAIWander extends EntityAIBase
      */
     public boolean shouldExecute()
     {
+    	// FCMOD: Code removed to disable AI activation distance
+    	/*
         if (this.entity.getAge() >= 100)
         {
             return false;
         }
+        */
+    	// END FCMOD
+    	
+    	// FCMOD: Line change to get rid of else
+    	/*
         else if (this.entity.getRNG().nextInt(120) != 0)
+        */
+        if (this.entity.getRNG().nextInt(120) != 0)
+    	// END FCMOD
         {
             return false;
         }
diff --git a/minecraft_server/net/minecraft/src/EntityAgeable.java b/minecraft_server/net/minecraft/src/EntityAgeable.java
index 7bdbf48..0f1321d 100644
--- a/minecraft_server/net/minecraft/src/EntityAgeable.java
+++ b/minecraft_server/net/minecraft/src/EntityAgeable.java
@@ -1,9 +1,16 @@
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
+
 public abstract class EntityAgeable extends EntityCreature
 {
-    private float field_98056_d = -1.0F;
-    private float field_98057_e;
+	// FCMOD: Changed for clarity
+    //private float field_98056_d = -1.0F;
+    //private float field_98057_e;
+    private float m_fAdultWidth = -1.0F; // -1 flags super entity size has not been initialized
+    private float m_fAdultHeight;
+    // END FCMOD
 
     public EntityAgeable(World par1World)
     {
@@ -16,6 +23,13 @@ public abstract class EntityAgeable extends EntityCreature
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
     public boolean interact(EntityPlayer par1EntityPlayer)
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	return EntityAgeableInteract( par1EntityPlayer );
+    }
+    
+    public boolean EntityAgeableInteract( EntityPlayer par1EntityPlayer )
+    // END FCMOD
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
 
@@ -29,7 +43,10 @@ public abstract class EntityAgeable extends EntityCreature
 
                 if (var4 != null)
                 {
-                    var4.setGrowingAge(-24000);
+                	// FCMOD: Changed
+                    //var4.setGrowingAge(-24000);
+                    var4.setGrowingAge( -GetTicksForChildToGrow() );
+                	// END FCMOD
                     var4.setLocationAndAngles(this.posX, this.posY, this.posZ, 0.0F, 0.0F);
                     this.worldObj.spawnEntityInWorld(var4);
 
@@ -77,7 +94,12 @@ public abstract class EntityAgeable extends EntityCreature
     public void setGrowingAge(int par1)
     {
         this.dataWatcher.updateObject(12, Integer.valueOf(par1));
-        this.func_98054_a(this.isChild());
+        // FCNOTE: This seems grossly ineffecient as I believe this data will get sent to the 
+        // clients every tick for child animals, and those waiting to recharge their love juice
+        // FCMOD: Changed
+        //this.func_98054_a(this.isChild());
+    	AdjustSizeForAge( isChild() );
+        // END FCMOD
     }
 
     /**
@@ -108,7 +130,10 @@ public abstract class EntityAgeable extends EntityCreature
 
         if (this.worldObj.isRemote)
         {
-            this.func_98054_a(this.isChild());
+        	// FCMOD: Changed
+            //this.func_98054_a(this.isChild());
+        	AdjustSizeForAge( isChild() );
+            // END FCMOD
         }
         else
         {
@@ -116,11 +141,43 @@ public abstract class EntityAgeable extends EntityCreature
 
             if (var1 < 0)
             {
+	        	// FCMOD: Added
+	        	if ( !CanChildGrow() )
+	        	{
+	        		return;
+	        	}
+	        	// END FCMOD
+	        	
                 ++var1;
-                this.setGrowingAge(var1);
+                
+                // FCMOD: Added
+        		if ( var1 == 0 )
+        		{
+        			// child is about to grow to adulthood.  Make sure it has enough space
+        			AxisAlignedBB adultBounds = AxisAlignedBB.getAABBPool().getAABB(
+        				boundingBox.minX, boundingBox.minY, boundingBox.minZ,
+        				boundingBox.minX + m_fAdultWidth, 
+        				boundingBox.minY + m_fAdultHeight, 
+        				boundingBox.minZ + m_fAdultWidth ); 
+        			
+        			if ( !worldObj.getCollidingBoundingBoxes( this, adultBounds ).isEmpty() )
+        			{
+        				var1 = -20;
+        			}        			
+        		}
+        		// END FCMOD
+        		
+                this.setGrowingAge(var1);                
             }
             else if (var1 > 0)
             {
+	        	// FCMOD: Added
+	        	if ( !CanLoveJuiceRegenerate() )
+	        	{
+	        		return;
+	        	}
+	        	// END FCMOD
+	        	
                 --var1;
                 this.setGrowingAge(var1);
             }
@@ -135,14 +192,13 @@ public abstract class EntityAgeable extends EntityCreature
         return this.getGrowingAge() < 0;
     }
 
+	// FCMOD: Removed and replaced
+	/*
     public void func_98054_a(boolean par1)
     {
         this.func_98055_j(par1 ? 0.5F : 1.0F);
     }
 
-    /**
-     * Sets the width and height of the entity. Args: width, height
-     */
     protected final void setSize(float par1, float par2)
     {
         boolean var3 = this.field_98056_d > 0.0F;
@@ -159,4 +215,48 @@ public abstract class EntityAgeable extends EntityCreature
     {
         super.setSize(this.field_98056_d * par1, this.field_98057_e * par1);
     }
+    */
+	// END FCMOD
+    
+    // FCMOD: Added New
+	protected final void setSize( float fWidth, float fHeight )
+	{
+        boolean bSizeAlreadyInitialized = m_fAdultWidth > 0F;
+        
+        m_fAdultWidth = fWidth;
+        m_fAdultHeight = fHeight;
+
+        if ( !bSizeAlreadyInitialized )
+        {
+        	AdjustedSizeToScale( 1F );
+        }
+	}
+
+    private void AdjustedSizeToScale( float fScale )
+    {
+        super.setSize( m_fAdultWidth * fScale, m_fAdultHeight * fScale );
+    }
+    
+    public void AdjustSizeForAge( boolean bIsChild )
+    {
+    	AdjustedSizeToScale( bIsChild ? 0.5F : 1F );
+    }
+    
+    public boolean CanChildGrow()
+    {
+    	// prevent animals growing up in the end
+    	
+    	return worldObj.provider.dimensionId != 1;
+    }
+    
+    public boolean CanLoveJuiceRegenerate()
+    {
+    	return true;
+    }
+    
+    protected int GetTicksForChildToGrow()
+    {
+    	return FCUtilsMisc.m_iTicksPerGameDay;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityAnimal.java b/minecraft_server/net/minecraft/src/EntityAnimal.java
index 09672b3..7a29314 100644
--- a/minecraft_server/net/minecraft/src/EntityAnimal.java
+++ b/minecraft_server/net/minecraft/src/EntityAnimal.java
@@ -2,15 +2,24 @@ package net.minecraft.src;
 
 import java.util.List;
 
+// FCMOD: Added
+import java.util.Iterator;
+// END FCMOD
+
 public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 {
-    private int inLove;
+	// FCMOD: Removed and replaced with a watchable value
+    //private int inLove;
+	// END FCMOD
 
     /**
      * This is representation of a counter for reproduction progress. (Note that this is different from the inLove which
      * represent being in Love-Mode)
      */
-    private int breeding = 0;
+	// FCMOD: Changed
+    //private int breeding = 0;
+    protected int breeding = 0;
+    // END FCMOD
 
     public EntityAnimal(World par1World)
     {
@@ -24,7 +33,12 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
     {
         if (this.getGrowingAge() != 0)
         {
+        	// FCMOD: Change
+        	/*
             this.inLove = 0;
+            */
+        	resetInLove();
+        	// END FCMOD
         }
 
         super.updateAITick();
@@ -40,15 +54,35 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 
         if (this.getGrowingAge() != 0)
         {
+        	// FCMOD: Change
+        	/*
             this.inLove = 0;
+            */
+        	resetInLove();
+        	// END FCMOD
         }
 
+        // FCMOD: Change
+        /*
         if (this.inLove > 0)
+        */
+        if ( isInLove() )
+    	// END FCMOD
         {
+            // FCMOD: Change
+            /*
             --this.inLove;
+            */
+            setInLove( getInLove() - 1 );
+        	// END FCMOD
             String var1 = "heart";
 
+            // FCMOD: Change
+            /*
             if (this.inLove % 10 == 0)
+            */
+            if ( getInLove() % 10 == 0 )
+        	// END FCMOD
             {
                 double var2 = this.rand.nextGaussian() * 0.02D;
                 double var4 = this.rand.nextGaussian() * 0.02D;
@@ -95,7 +129,12 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
                     this.hasAttacked = true;
                 }
             }
+            // FCMOD: Change
+            /*
             else if (this.inLove > 0 && var8.inLove > 0)
+            */
+            else if ( isInLove() && var8.isInLove() )
+        	// END FCMOD
             {
                 if (var8.entityToAttack == null)
                 {
@@ -104,8 +143,14 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 
                 if (var8.entityToAttack == this && (double)par2 < 3.5D)
                 {
+                	// FCMOD: Code change: 
+                	/*
                     ++var8.inLove;
                     ++this.inLove;
+                    */
+                    setInLove( getInLove() + 1 );
+                    var8.setInLove( var8.getInLove() + 1 );
+                    // END FCMOD
                     ++this.breeding;
 
                     if (this.breeding % 4 == 0)
@@ -135,6 +180,8 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
      * Creates a baby animal according to the animal type of the target at the actual position and spawns 'love'
      * particles.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     private void procreate(EntityAnimal par1EntityAnimal)
     {
         EntityAgeable var2 = this.createChild(par1EntityAnimal);
@@ -163,6 +210,8 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
             this.worldObj.spawnEntityInWorld(var2);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Called when the entity is attacked.
@@ -177,7 +226,13 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
         {
             this.fleeingTick = 60;
             this.entityToAttack = null;
+            // FCMOD: Code change
+            /*
             this.inLove = 0;
+            */
+        	resetInLove();
+        	PanickNearbyAnimals( par1DamageSource );
+        	// END FCMOD
             return super.attackEntityFrom(par1DamageSource, par2);
         }
     }
@@ -186,28 +241,40 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
      * Takes a coordinate in and returns a weight to determine how likely this creature will try to path to the block.
      * Args: x, y, z
      */
+    // FCMOD: Removed and replaced
+    /*
     public float getBlockPathWeight(int par1, int par2, int par3)
     {
         return this.worldObj.getBlockId(par1, par2 - 1, par3) == Block.grass.blockID ? 10.0F : this.worldObj.getLightBrightness(par1, par2, par3) - 0.5F;
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to write subclass entity data to NBT.
      */
+    // FCMOD: Removed and replaced
+    /*
     public void writeEntityToNBT(NBTTagCompound par1NBTTagCompound)
     {
         super.writeEntityToNBT(par1NBTTagCompound);
         par1NBTTagCompound.setInteger("InLove", this.inLove);
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to read subclass entity data from NBT.
      */
+    // FCMOD: Removed and replaced
+    /*
     public void readEntityFromNBT(NBTTagCompound par1NBTTagCompound)
     {
         super.readEntityFromNBT(par1NBTTagCompound);
         this.inLove = par1NBTTagCompound.getInteger("InLove");
     }
+    */
+    // END FCMOD
 
     /**
      * Finds the closest player within 16 blocks to attack, or null if this Entity isn't interested in attacking
@@ -226,8 +293,15 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
             int var3;
             EntityAnimal var4;
 
+            // FCMOD: Change
+            /*
             if (this.inLove > 0)
+            */
+            if ( isInLove() )
+        	// END FCMOD
             {
+	        	// FCMOD: Changed the following to find the closest animal instead of just a random one
+	        	/*	        	
                 var2 = this.worldObj.getEntitiesWithinAABB(this.getClass(), this.boundingBox.expand((double)var1, (double)var1, (double)var1));
 
                 for (var3 = 0; var3 < var2.size(); ++var3)
@@ -239,6 +313,30 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
                         return var4;
                     }
                 }
+                */
+	        	double dClosestAnimalDistanceSq = 0.0F;
+	        	EntityAnimal closestValidAnimal = null;
+	        	
+	            List list = worldObj.getEntitiesWithinAABB(getClass(), boundingBox.expand( var1, var1, var1 ));
+
+	            for (int i = 0; i < list.size(); i++)
+	            {
+	                EntityAnimal entityanimal = (EntityAnimal)list.get(i);
+	                
+	                if (entityanimal != this && entityanimal.isInLove() )
+	                {
+	                	double dDistanceSqToAnimal = getDistanceSqToEntity( entityanimal );
+	                	
+	                	if ( closestValidAnimal == null || dDistanceSqToAnimal < dClosestAnimalDistanceSq )
+	                	{
+	                		dClosestAnimalDistanceSq = dDistanceSqToAnimal;
+	                		closestValidAnimal = entityanimal;
+	                	}
+	        		}
+	            }
+            
+            	return closestValidAnimal;
+	            // END FCMOD
             }
             else if (this.getGrowingAge() == 0)
             {
@@ -320,6 +418,8 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
     /**
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean interact(EntityPlayer par1EntityPlayer)
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
@@ -354,18 +454,26 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
             return super.interact(par1EntityPlayer);
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns if the entity is currently in 'love mode'.
      */
     public boolean isInLove()
     {
-        return this.inLove > 0;
+    	// FCMOD: Changed
+        //return this.inLove > 0;
+    	return getInLove() > 0;
+    	// END FCMOD    	
     }
 
     public void resetInLove()
     {
-        this.inLove = 0;
+    	// FCMOD: Changed
+        //this.inLove = 0;
+    	setInLove( 0 );
+    	// END FCMOD
     }
 
     /**
@@ -375,4 +483,994 @@ public abstract class EntityAnimal extends EntityAgeable implements IAnimals
     {
         return par1EntityAnimal == this ? false : (par1EntityAnimal.getClass() != this.getClass() ? false : this.isInLove() && par1EntityAnimal.isInLove());
     }
+    
+    // FCMOD: Added New
+    protected static final int m_iHungerLevelDataWatcherID = 21;
+	protected static final int m_iInLoveDataWatcherID = 22;
+	protected static final int m_iWearingBreedingHarnessDataWatcherID = 23;
+	
+    @Override
+    protected void entityInit()
+    {
+        super.entityInit();
+        
+        dataWatcher.addObject( m_iHungerLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iInLoveDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iWearingBreedingHarnessDataWatcherID, Byte.valueOf( (byte)0 ) );
+    }
+    
+    @Override
+    public void writeEntityToNBT( NBTTagCompound tag )
+    {
+        super.writeEntityToNBT( tag );
+        
+        tag.setInteger( "InLove", getInLove() );
+        tag.setByte( "fcHungerLvl", (byte)GetHungerLevel() );
+        tag.setBoolean( "BreedingHarness", getWearingBreedingHarness() );
+        tag.setInteger( "fcHungerCnt", m_iHungerCountdown );
+        tag.setInteger( "fcHealCnt", m_iHealingCountdown );
+    }
+
+    @Override
+    public void readEntityFromNBT( NBTTagCompound tag )
+    {
+        super.readEntityFromNBT( tag );
+        
+        setInLove( tag.getInteger( "InLove" ) );
+        
+        if ( tag.hasKey( "BreedingHarness" ) )
+        {
+        	setWearingBreedingHarness( tag.getBoolean( "BreedingHarness" ) );
+        }
+        
+        if ( tag.hasKey( "fcHungerLvl" ) )
+        {
+            SetHungerLevel( tag.getByte( "fcHungerLvl" ) );
+        }
+        
+        if ( tag.hasKey( "fcHungerCnt" ) )
+        {
+        	m_iHungerCountdown = tag.getInteger( "fcHungerCnt" );
+        }
+        else
+        {
+        	ResetHungerCountdown();
+        }
+        
+        if ( tag.hasKey( "fcHealCnt" ) )
+        {
+        	m_iHealingCountdown = tag.getInteger( "fcHealCnt" );
+        }
+        else
+        {
+        	ResetHealingCountdown();
+        }
+    }
+    
+    @Override
+    protected void ModSpecificOnLivingUpdate()
+    {
+    	super.ModSpecificOnLivingUpdate();
+    	
+	    if ( !worldObj.isRemote )
+	    {
+	    	if ( isEntityAlive() )
+	    	{
+		        CheckForLooseFood();
+		        CheckForIntersectingBreedingHarnesses();
+	
+		        UpdateHealing();
+		        UpdateHungerState();
+	    	}
+	    }
+	    else
+	    {
+	        if ( m_iGrazeProgressCounter > 0 )
+	        {
+	        	// update the graze counter on the client as we only get an initial 
+	        	// notification when it starts in a healthUpdate
+	        	
+	            m_iGrazeProgressCounter--;
+	        }
+	    }
+	    
+	    if ( isInLove() )
+	    {
+	    	if ( entityToAttack != null && entityToAttack instanceof EntityAnimal )
+	    	{
+	            EntityAnimal entityanimal = (EntityAnimal)entityToAttack;
+	            
+	            if ( !entityanimal.isInLove() )
+	            {
+	            	// the targeted animal is no longer in love mode.  Reset the target so another will be selected on the following update
+	            	
+	            	entityToAttack = null;
+	            }
+	    	}
+	    }
+    }
+    
+	@Override
+    protected void jump()
+    {
+    	if ( isChild() )
+    	{
+    		// jump half height if child or starving
+    		
+            motionY = 0.21D;
+            isAirBorne = true;    		
+    	}
+    	else
+    	{
+    		super.jump();
+    	}
+    }
+    
+	@Override
+    public void onDeath( DamageSource damageSource )
+    {
+    	super.onDeath( damageSource );
+    	
+    	if ( !worldObj.isRemote && getWearingBreedingHarness() )
+    	{
+            dropItem( FCBetterThanWolves.fcItemBreedingHarness.itemID, 1 );
+    	}        
+    }
+    
+	@Override
+    protected void updateEntityActionState()
+    {
+		super.updateEntityActionState();
+		
+    	if ( getWearingBreedingHarness() )
+    	{
+            moveStrafing = 0F;
+            moveForward = 0F;
+    	}
+    }
+	
+	@Override
+    public void CheckForScrollDrop()
+    {
+		// this is overridden to prevent potentially expensive (and useless) checks every 
+		// time an animal dies, since none of them drop scrolls
+    }
+
+    @Override
+    protected float getSoundPitch()
+    {
+    	float fPitch = super.getSoundPitch();
+
+    	if ( IsPossessed() )
+    	{
+    		fPitch *= 0.60F;
+    	}
+    	
+        return fPitch;
+    }
+    
+	@Override
+    public void setRevengeTarget( EntityLiving targetEntity )
+    {
+		// override to lengthen panic time on animals
+    	
+        entityLivingToAttack = targetEntity;
+        
+        if ( entityLivingToAttack != null )
+        {
+        	revengeTimer = 300; // 15 seconds
+        }
+        else
+        {
+        	revengeTimer = 0;
+        }
+    }
+    
+    @Override
+    public float getBlockPathWeight( int i, int j, int k )
+    {
+    	if ( CanGrazeOnBlock( i, j - 1, k ) || CanGrazeOnBlock( i, j, k ) )
+    	{
+    		return 10F;
+    	}
+    	
+    	return worldObj.GetNaturalLightBrightness( i, j, k ) - 0.5F;
+    }
+    
+    @Override
+    public boolean IsSecondaryTargetForSquid()
+    {
+    	return true;
+    }
+    
+    @Override
+    public void OnFlungBySquidTentacle( FCEntitySquid squid )
+    {
+		DamageSource squidSource = DamageSource.causeMobDamage( squid );
+		
+		attackEntityFrom( squidSource, 0 );
+    }
+    
+    @Override
+    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
+    {
+		DamageSource squidSource = DamageSource.causeMobDamage( squid );
+		
+		attackEntityFrom( squidSource, 0 );
+    }
+    
+    @Override
+    protected void AttemptToPossessNearbyCreatureOnDeath()
+    {
+		AttemptToPossessNearbyCreature( 16D, true );
+    }
+    
+    @Override
+    public float getSpeedModifier()
+    {
+    	return super.getSpeedModifier() * GetHungerSpeedModifier();    	
+    }
+    
+    @Override
+    public boolean CanChildGrow()
+    {
+    	return super.CanChildGrow() && !IsTooHungryToGrow();
+    }
+    
+    @Override
+    public boolean CanLoveJuiceRegenerate()
+    {
+    	return IsFullyFed();
+    }
+    
+    @Override
+    protected int GetTicksForChildToGrow()
+    {
+    	return FCUtilsMisc.m_iTicksPerGameDay * 2;
+    }
+    
+    @Override
+    public boolean interact( EntityPlayer player )
+    {
+    	return EntityAnimalInteract( player );
+    }
+    
+    @Override
+    public void initCreature() 
+    {
+    	InitHungerWithVariance();
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+    public int getInLove()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iInLoveDataWatcherID );
+    }
+    
+    public void setInLove( int iInLove )
+    {
+        dataWatcher.updateObject( m_iInLoveDataWatcherID, Integer.valueOf( iInLove ) );
+    }
+   
+    public boolean getWearingBreedingHarness()
+    {
+        return ( dataWatcher.getWatchableObjectByte( m_iWearingBreedingHarnessDataWatcherID ) > 0 );
+    }
+    
+    public void setWearingBreedingHarness( boolean bWearingHarness )
+    {
+    	Byte wearing = 0;
+    	
+    	if ( bWearingHarness )
+    	{
+    		wearing = 1;
+    	}
+    	
+        dataWatcher.updateObject( m_iWearingBreedingHarnessDataWatcherID, Byte.valueOf( wearing ) );
+    }
+   
+    public void CheckForIntersectingBreedingHarnesses()
+    {    
+    	if ( getWearingBreedingHarness()  )
+    	{
+            AxisAlignedBB tempBoundingBox = boundingBox.copy();
+            
+            tempBoundingBox.contract(0.1D, 0.1D, 0.1D );
+            
+		    List collisionList = worldObj.getEntitiesWithinAABB( EntityAnimal.class, 
+	    		tempBoundingBox );
+		    
+		    if ( !collisionList.isEmpty() )
+		    {
+	            for ( int listIndex = 0; listIndex < collisionList.size(); listIndex++ )
+	            {
+		    		EntityAnimal entityAnimal = (EntityAnimal)collisionList.get( listIndex );;
+		    		
+		    		if ( entityAnimal != this )
+		    		{		    		
+				        if ( entityAnimal.getWearingBreedingHarness() && !(entityAnimal.isLivingDead) )
+				        {
+				        	attackEntityFrom( DamageSource.inWall, 1 );
+				        	
+			    			break;				            
+			    		}
+		    		}
+	            }
+		    }
+    	}
+    }
+    
+	public void PanickNearbyAnimals( DamageSource damageSource )
+	{
+		Entity attackingEntity = damageSource.getEntity();
+
+		if ( attackingEntity != null && ( attackingEntity instanceof EntityLiving ) )
+		{
+			EntityLiving attackingEntityLiving = (EntityLiving)attackingEntity;
+			
+	        List animalList = worldObj.getEntitiesWithinAABB( EntityAnimal.class, boundingBox.expand( 16D, 8D, 16D ) );
+	        
+	        Iterator itemIterator = animalList.iterator();
+	
+	        while ( itemIterator.hasNext())
+	        {
+	    		EntityAnimal tempAnimal = (EntityAnimal)itemIterator.next();
+	    		
+		        if ( !(tempAnimal.isLivingDead) && tempAnimal != this && tempAnimal != attackingEntityLiving )
+		        {
+		        	tempAnimal.OnNearbyAnimalAttacked( this, attackingEntityLiving ); 
+		        }
+		        
+	        }
+		}
+	}
+	
+	public void OnNearbyAnimalAttacked( EntityAnimal attackedAnimal, EntityLiving attackSource )
+	{
+		// only freak the animal out if it isn't already freaked by something else
+		
+		if ( entityLivingToAttack == null )
+		{
+	        entityLivingToAttack = attackSource;	        
+        	revengeTimer = 150; // 7.5 seconds
+		}
+		else if ( revengeTimer < 150 )
+		{
+			revengeTimer = 150;
+		}
+	}
+
+	public void OnNearbyFireStartAttempt( EntityPlayer player )
+	{
+		OnNearbyPlayerStartles( player );
+	}
+	
+	public void OnNearbyPlayerBlockAddOrRemove( EntityPlayer player )
+	{
+		OnNearbyPlayerStartles( player );
+	}
+	
+	protected void OnNearbyPlayerStartles( EntityPlayer player )
+	{
+		// only freak the animal out if it isn't already freaked by something else
+		
+		if ( entityLivingToAttack == null )
+		{
+	        entityLivingToAttack = player;	        
+        	revengeTimer = 150; // 7.5 seconds
+		}
+		else if ( revengeTimer < 150 )
+		{
+			revengeTimer = 150;
+		}
+	}
+	
+    protected void procreate( EntityAnimal targetMate )
+    {
+    	// Replacement for vanilla function above
+    	
+		double dChildX = posX;
+		double dChildY = posY;
+		double dChildZ = posZ;
+		
+        if ( getWearingBreedingHarness() )
+        {
+        	dChildX = ( posX + targetMate.posX ) / 2.0F;
+        	dChildY = ( posY + targetMate.posY ) / 2.0F;
+        	dChildZ = ( posZ + targetMate.posZ ) / 2.0F;                	
+        }
+        
+        GiveBirthAtTargetLocation( targetMate, dChildX, dChildY, dChildZ );
+        
+    	ResetMatingStateOfBothParents( targetMate );
+    	
+        SpawnBirthHeartParticles();
+
+        worldObj.playSoundAtEntity( this, getDeathSound(), getSoundVolume(), (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F );
+        
+        worldObj.playAuxSFX( FCBetterThanWolves.m_iAnimalBirthingAuxFXID,  
+    		MathHelper.floor_double( dChildX ), MathHelper.floor_double( dChildY ), MathHelper.floor_double( dChildZ ), 
+    		0 );            
+    }
+    
+    protected void GiveBirthAtTargetLocation( EntityAnimal targetMate, double dChildX, double dChildY, double dChildZ )
+    {
+        EntityAgeable childEntity = createChild( targetMate );
+
+        if ( childEntity != null )
+        {
+            childEntity.setGrowingAge( -GetTicksForChildToGrow() );
+            
+        	childEntity.setLocationAndAngles( dChildX, dChildY, dChildZ, rotationYaw, rotationPitch );
+            
+            worldObj.spawnEntityInWorld( childEntity );            
+        }
+    }
+    
+    protected void ResetMatingStateOfBothParents( EntityAnimal targetMate )
+    {
+        setGrowingAge( GetTicksToRegenerateLoveJuice() );
+        targetMate.setGrowingAge( targetMate.GetTicksToRegenerateLoveJuice() );
+        
+        resetInLove();            
+        breeding = 0;
+        entityToAttack = null;
+        
+        targetMate.resetInLove();            
+        targetMate.entityToAttack = null;
+        targetMate.breeding = 0;        
+    }
+    
+    protected void SpawnBirthHeartParticles()
+    {
+        for ( int iTempCount = 0; iTempCount < 7; ++iTempCount )
+        {
+            double dParticleVelX = this.rand.nextGaussian() * 0.02D;
+            double dParticleVelY = this.rand.nextGaussian() * 0.02D;
+            double dParticleVelZ = this.rand.nextGaussian() * 0.02D;
+            
+            worldObj.spawnParticle( "heart", 
+            	this.posX + (double)(this.rand.nextFloat() * this.width * 2.0F) - (double)this.width, 
+            	this.posY + 0.5D + (double)(this.rand.nextFloat() * this.height), 
+            	this.posZ + (double)(this.rand.nextFloat() * this.width * 2.0F) - (double)this.width, 
+            	dParticleVelX, dParticleVelY, dParticleVelZ);
+        }
+    }
+    
+    //-------------- Hunger related functionality ------------//
+    
+    protected static final int m_iFullHungerCount = ( FCUtilsMisc.m_iTicksPerGameDay );
+    protected static final int m_iLevelUpHungerCount = ( m_iFullHungerCount + 
+    	( m_iFullHungerCount / 16 ) );
+    
+    protected static final int m_iMaxHealingCount = ( FCUtilsMisc.m_iTicksPerGameDay );
+    
+    protected int m_iHungerCountdown = m_iFullHungerCount;
+    protected int m_iHealingCountdown = m_iFullHungerCount;
+    
+    public static final int m_iBaseGrazeFoodValue = 200;
+    
+    protected static final int m_iDelayBetweenEatLoose = ( FCUtilsMisc.m_iTicksPerSecond / 2 );
+    
+    protected static final int m_iDelayBetweenEatLooseVariance = 
+    	( FCUtilsMisc.m_iTicksPerSecond / 2 );
+    
+    protected int m_iEatLooseCooldownCounter = ( m_iDelayBetweenEatLoose + 
+    	m_iDelayBetweenEatLooseVariance );
+    
+    protected int m_iGrazeProgressCounter = 0;
+    
+    public void InitHungerWithVariance()
+    {
+    	// prevent initially spawned animals from all eating at the same time.
+    	
+    	if ( IsSubjectToHunger() )
+    	{
+    		m_iHungerCountdown = m_iFullHungerCount - rand.nextInt( GetGrazeHungerGain() );
+    	}
+    }
+    
+    protected int GetHungerLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHungerLevelDataWatcherID );
+    }
+    
+    protected void SetHungerLevel( int iHungerLevel )
+    {
+        dataWatcher.updateObject( m_iHungerLevelDataWatcherID, Byte.valueOf( (byte)iHungerLevel ) );
+    }
+    
+    protected boolean IsFullyFed()
+    {
+        return GetHungerLevel() == 0;
+    }
+    
+    protected boolean IsFamished()
+    {
+        return GetHungerLevel() == 1;
+    }
+    
+    protected boolean IsStarving()
+    {
+        return GetHungerLevel() >= 2;
+    }    
+    
+    protected void OnBecomeFamished()
+    {
+		SetHungerLevel( 1 );
+    }
+    
+    public void OnBecomeStarving()
+    {
+		SetHungerLevel( 2 );
+    }
+    
+    protected void OnStarvingCountExpired()
+    {
+		// max health 20 wolves, 15 cows, 10 pigs, 8 sheep, 4 chicken
+		
+		attackEntityFrom( DamageSource.starve, 5 );
+    }
+    
+    public boolean IsSubjectToHunger()
+    {
+    	return false;
+    }
+    
+    protected void UpdateHungerState()
+    {
+    	if ( IsSubjectToHunger() )
+    	{
+    		if ( !isChild() )
+    		{
+    			m_iHungerCountdown--;
+    		}
+    		else    			
+    		{
+    			// children burn more energy
+    			
+    			m_iHungerCountdown -= 2;
+    		}
+	    	
+	    	if ( m_iHungerCountdown <= 0 )
+	    	{
+	    		if ( !isChild() )
+	        	{
+		    		if ( IsFullyFed() )
+		    		{
+	    				OnBecomeFamished();
+		    		}
+		    		else if ( IsFamished() )
+		    		{
+		    			OnBecomeStarving();
+		    		}
+		    		else // starving
+		    		{
+		    			OnStarvingCountExpired();
+		    		}
+		    		
+		    		ResetHungerCountdown();
+	        	}
+	    		else 
+	    		{ 
+	    			// children can not survive being famished.  They'll
+	    			// just keep taking damage once their countdown expires
+	    			
+	    			attackEntityFrom( DamageSource.starve, 1 );
+	    		}		
+	    	}
+    	}
+    }
+    
+    protected void ResetHungerCountdown()
+    {
+    	m_iHungerCountdown = m_iFullHungerCount; 
+    }    
+    
+    protected void AddToHungerCount( int iAddedHunger )
+    {
+    	m_iHungerCountdown += iAddedHunger;
+    	
+    	// don't level up immediately when full to prevent flickering state
+    	
+    	if ( m_iHungerCountdown > m_iLevelUpHungerCount )
+    	{
+    		int iHungerLevel = GetHungerLevel();
+    		
+    		if ( iHungerLevel > 0 )
+    		{
+        		m_iHungerCountdown -= m_iFullHungerCount;
+        		
+    			SetHungerLevel( iHungerLevel - 1 );
+    		}
+    	}    	
+    }
+    
+    protected int GetGrazeHungerGain()
+    {
+    	return m_iBaseGrazeFoodValue * GetFoodValueMultiplier();
+    }
+    
+    protected int GetFoodValueMultiplier()
+    {
+    	return 2;
+    }
+    
+    public void OnGrazeBlock( int i, int j, int k )
+    {
+    	AddToHungerCount( GetGrazeHungerGain() );
+    }
+    
+    public boolean ShouldNotifyBlockOnGraze()
+    {
+    	return true;
+    }
+    
+    public void PlayGrazeFX( int i, int j, int k, int iBlockID )
+    {
+		worldObj.playAuxSFX( 2001, i, j, k, iBlockID ); 
+    }
+    
+    public int GetGrazeDuration()
+    {
+    	return 40;
+    }
+    
+    public boolean IsHungryEnoughToGraze()
+    {
+		return !IsFullyFed() || m_iHungerCountdown + GetGrazeHungerGain() <= 
+			m_iFullHungerCount;
+    }
+    
+    public boolean IsHungryEnoughToForceMoveToGraze()
+    {
+		return isChild() || !IsFullyFed() || m_iHungerCountdown < m_iFullHungerCount / 2;
+    }
+    
+    protected boolean IsTooHungryToGrow()
+    {
+    	return !IsFullyFed() || m_iHungerCountdown < ( m_iFullHungerCount * 3 ) / 4;    	
+    }
+    
+    protected boolean IsTooHungryToHeal()
+    {
+    	return !IsFullyFed() || m_iHungerCountdown < ( m_iFullHungerCount * 3 ) / 4;    	
+    }
+    
+    public boolean CanGrazeMycelium()
+    {
+    	return false;
+    }
+    
+    public boolean GetDisruptsEarthOnGraze()
+    {
+    	return false;
+    }
+    
+    public boolean CanGrazeOnRoughVegetation()
+    {
+    	return false;
+    }
+    
+    /**
+     * Returns null if no valid graze block exists at location
+     */    
+    public FCUtilsBlockPos GetGrazeBlockForPos()
+    {
+    	FCUtilsBlockPos targetPos = new FCUtilsBlockPos( MathHelper.floor_double( posX ), 
+    		(int)boundingBox.minY, MathHelper.floor_double( posZ ) );
+    	
+    	if ( CanGrazeOnBlock( targetPos.i, targetPos.j, targetPos.k ) )
+    	{
+    		return targetPos;
+    	}
+    	else
+    	{
+    		targetPos.j--;
+    		
+        	if ( CanGrazeOnBlock( targetPos.i, targetPos.j, targetPos.k ) )
+        	{
+        		return targetPos;
+        	}
+    	}
+        
+        return null;
+    }
+    
+    public boolean ShouldStayInPlaceToGraze()
+    {
+    	return GetGrazeBlockForPos() != null;
+    }
+    
+    public boolean CanGrazeOnBlock( int i, int j, int k )
+    {
+    	Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
+    	
+    	if ( block != null )
+    	{
+    		return block.CanBeGrazedOn( worldObj, i, j, k, this );
+    	}
+    	
+    	return false;
+    }
+    
+    protected float GetHungerSpeedModifier()
+    {
+    	if ( IsStarving() )
+    	{
+    		return 0.5F;
+    	}
+    	else if ( IsFamished() )
+    	{
+    		return 0.75F;
+    	}
+    	
+    	return 1F;
+    }
+
+    public boolean IsTemptingItem( ItemStack stack )
+    {
+    	return GetItemFoodValue( stack ) > 0 || 
+    		( isBreedingItem( stack ) && IsReadyToEatBreedingItem() );
+    }
+    
+    public boolean IsEdibleItem( ItemStack stack )
+    {
+    	return isBreedingItem( stack ) || GetItemFoodValue( stack ) > 0;
+    }
+
+    protected boolean IsHungryEnoughToEatLooseFood()
+    {
+		return !IsFullyFed() || m_iHungerCountdown <= m_iFullHungerCount;
+    }
+    
+    protected boolean IsReadyToEatBreedingItem()
+    {
+    	return IsFullyFed() && getGrowingAge() == 0 && !isInLove();
+    }
+    
+    protected int GetItemFoodValue( ItemStack stack )
+    {
+    	return stack.getItem().GetHerbivoreFoodValue( stack.getItemDamage() ) * 
+    		GetFoodValueMultiplier();
+    }
+    
+    protected boolean AttemptToEatItemForBreeding( ItemStack stack )
+    {
+        if ( isBreedingItem( stack ) && IsReadyToEatBreedingItem() )
+        {
+        	OnEatBreedingItem();
+			
+			return true;
+        }
+        
+        return false;
+    }
+    
+    protected void OnEatBreedingItem()
+    {
+        setInLove( 600 );
+        entityToAttack = null;
+        
+        for( int iTempCount = 0; iTempCount < 7; iTempCount++ )
+        {
+            worldObj.spawnParticle( "heart", 
+            	posX + (double)( ( rand.nextFloat() * width * 2F ) - width ), 
+            	posY + 0.5D + (double)( rand.nextFloat() * height ), 
+            	posZ + (double)( ( rand.nextFloat() * width * 2.0F ) - width ), 
+        		rand.nextGaussian() * 0.02D, rand.nextGaussian() * 0.02D, 
+        		rand.nextGaussian() * 0.02D ); // last 3 are velocity
+        }
+    }
+    
+    protected boolean AttemptToEatItem( ItemStack stack )
+    {
+    	int iFoodValue = GetItemFoodValue( stack );
+    	
+		if ( AttemptToEatItemForBreeding( stack ) || ( iFoodValue > 0 && 
+			IsHungryEnoughToEatLooseFood() ) )
+		{
+        	AddToHungerCount( iFoodValue );
+            
+            worldObj.setEntityState( this, (byte)10 ); // trigger eating anim on client
+            
+	        worldObj.playAuxSFX( FCBetterThanWolves.m_iAnimalEatAuxFXID,	                
+                MathHelper.floor_double( posX ), (int)( posY + height ),
+                MathHelper.floor_double( posZ ), 0 );
+	        
+        	return true;
+		}
+		
+        return false;
+    }
+    
+    public boolean AttemptToBeHandFedItem( ItemStack stack )
+    {
+    	return AttemptToEatItem( stack );
+    }
+
+    protected boolean AttemptToEatLooseItem( ItemStack stack )
+    {
+    	return AttemptToEatItem( stack );
+    }
+    
+    public boolean IsReadyToEatLooseFood()
+    {
+    	return IsHungryEnoughToEatLooseFood() || IsReadyToEatBreedingItem();
+    }
+    
+    public boolean IsReadyToEatLooseItem( ItemStack stack )
+    {
+    	return ( GetItemFoodValue( stack ) > 0 && IsHungryEnoughToEatLooseFood() ) || 
+			( isBreedingItem( stack ) && IsReadyToEatBreedingItem() );
+    }
+    
+    protected void CheckForLooseFood()
+    {    
+    	if ( m_iEatLooseCooldownCounter > 0 )
+    	{
+    		m_iEatLooseCooldownCounter--;
+    	}
+    	else if ( IsReadyToEatLooseFood() )
+    	{
+		    List<EntityItem> entityList = worldObj.getEntitiesWithinAABB( 
+		    	EntityItem.class, AxisAlignedBB.getAABBPool().getAABB( 
+				boundingBox.minX - 1.5F, boundingBox.minY - 1F, boundingBox.minZ - 1.5F, 
+				boundingBox.maxX + 1.5F, boundingBox.maxY + 1F, boundingBox.maxZ + 1.5F ) );
+		    
+		    if ( !entityList.isEmpty() )
+		    {
+		    	Iterator<EntityItem> entityIterator = entityList.iterator();
+
+		    	while ( entityIterator.hasNext() )
+	            {
+		    		EntityItem tempEntity = entityIterator.next();
+		    		
+			        if ( tempEntity.delayBeforeCanPickup == 0 && tempEntity.isEntityAlive() )
+			        {
+			        	ItemStack tempStack = tempEntity.getEntityItem();
+			        	
+			        	if ( AttemptToEatLooseItem( tempEntity.getEntityItem() ) )
+		        		{
+			                tempStack.stackSize--;
+			                
+			                if ( tempStack.stackSize <= 0 )
+			                {
+			    	            tempEntity.setDead();					            
+			                }
+			                else
+			                {
+			                	// slight delay on pickup so animals don't all eat from a stack
+			                	// at once
+			                	
+			                	tempEntity.delayBeforeCanPickup = 2; 			                	
+			                }
+			                
+		    	            m_iEatLooseCooldownCounter = m_iDelayBetweenEatLoose +
+		    	            	rand.nextInt( m_iDelayBetweenEatLooseVariance + 1 );
+					        
+			    			break;				            
+		        		}			        		
+		    		}
+	            }
+		    }
+    	}
+    }
+    
+    public boolean EntityAnimalInteract( EntityPlayer player )
+    {
+        ItemStack heldItem = player.inventory.getCurrentItem();
+
+        if ( heldItem != null )
+        {
+        	if ( IsEdibleItem( heldItem ) )
+        	{
+	        	if ( !worldObj.isRemote && AttemptToBeHandFedItem( heldItem ) )
+	        	{
+	                heldItem.stackSize--;
+	
+	                if ( heldItem.stackSize <= 0 )
+	                {
+	                    player.inventory.setInventorySlotContents( player.inventory.currentItem, 
+	                    	null );
+	                }
+	        	}
+	        	
+	            return true;
+        	}
+        }
+        
+        return super.interact( player );
+    }
+    
+    protected int GetTicksToRegenerateLoveJuice()
+    {
+    	return FCUtilsMisc.m_iTicksPerGameDay;
+    }
+    
+    public float GetGrazeHeadVerticalOffset( float fPartialTick )
+    {
+    	int iGrazeDuration = GetGrazeDuration(); 
+		
+    	if ( getWearingBreedingHarness() || m_iGrazeProgressCounter <= 0 )
+    	{
+            return 0F;
+    	}
+    	else if ( m_iGrazeProgressCounter >= 4 && m_iGrazeProgressCounter <= iGrazeDuration - 4 )
+    	{
+    		return 1F;
+    	}
+    	else if ( m_iGrazeProgressCounter < 4 )
+    	{
+    		return ( (float)m_iGrazeProgressCounter - fPartialTick ) / 4F;
+    	}
+    	else
+    	{
+            return -( (float)( m_iGrazeProgressCounter - iGrazeDuration ) - fPartialTick ) / 4F;
+    	}    	
+    }
+    
+    public float GetGrazeHeadRotation( float fPartialTick )
+    {
+    	int iGrazeDuration = GetGrazeDuration(); 
+		
+    	if ( getWearingBreedingHarness() || m_iGrazeProgressCounter <= 0 )
+    	{
+            return rotationPitch / ( 180F / (float)Math.PI );
+    	}
+    	else if ( m_iGrazeProgressCounter > 4 && m_iGrazeProgressCounter <= iGrazeDuration - 4 )
+        {
+            float fProgress = ((float)( m_iGrazeProgressCounter - 4 ) - fPartialTick ) / 
+            	(float)( iGrazeDuration - 8 );
+            
+            return ( (float)Math.PI / GetGrazeHeadRotationMagnitudeDivisor() ) + 
+            	( (float)Math.PI * 7F / 100F ) * 
+            	MathHelper.sin( fProgress * GetGrazeHeadRotationRateMultiplier() );
+        }
+        else
+        {
+            return (float)Math.PI / GetGrazeHeadRotationMagnitudeDivisor(); 
+        }
+    }
+    
+    protected float GetGrazeHeadRotationMagnitudeDivisor()
+    {
+    	return 5F;
+    }
+    
+    protected float GetGrazeHeadRotationRateMultiplier()
+    {
+    	return 28.7F;
+    }
+    
+    protected void UpdateHealing()
+    {
+    	if ( IsSubjectToHunger() && !isChild() )
+    	{
+    		if ( IsTooHungryToHeal() )
+    		{
+    			ResetHealingCountdown();
+    		}
+    		else
+    		{
+    			m_iHealingCountdown--;
+    			
+    			if ( m_iHealingCountdown <= 0 )
+    			{
+    				heal( 1 );
+    				
+        			ResetHealingCountdown();
+    			}
+    		}
+    	}
+    }
+    
+    protected void ResetHealingCountdown()
+    {
+    	m_iHealingCountdown = m_iMaxHealingCount; 
+    }    
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityArrow.java b/minecraft_server/net/minecraft/src/EntityArrow.java
index ff94f90..0440134 100644
--- a/minecraft_server/net/minecraft/src/EntityArrow.java
+++ b/minecraft_server/net/minecraft/src/EntityArrow.java
@@ -4,12 +4,22 @@ import java.util.List;
 
 public class EntityArrow extends Entity implements IProjectile
 {
+	// FCMOD: Changed to protected
+	/*
     private int xTile = -1;
     private int yTile = -1;
     private int zTile = -1;
     private int inTile = 0;
     private int inData = 0;
     private boolean inGround = false;
+    */
+    protected int xTile = -1;
+    protected int yTile = -1;
+    protected int zTile = -1;
+    protected int inTile = 0;
+    protected int inData = 0;
+    protected boolean inGround = false;
+	// END FCMOD
 
     /** 1 if the player can pick up the arrow */
     public int canBePickedUp = 0;
@@ -143,7 +153,9 @@ public class EntityArrow extends Entity implements IProjectile
 
         if (var16 > 0)
         {
-            Block.blocksList[var16].setBlockBoundsBasedOnState(this.worldObj, this.xTile, this.yTile, this.zTile);
+        	// FCMOD: Removed due to deprecation
+            //Block.blocksList[var16].setBlockBoundsBasedOnState(this.worldObj, this.xTile, this.yTile, this.zTile);
+        	// END FCMOD
             AxisAlignedBB var2 = Block.blocksList[var16].getCollisionBoundingBoxFromPool(this.worldObj, this.xTile, this.yTile, this.zTile);
 
             if (var2 != null && var2.isVecInside(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ)))
@@ -162,11 +174,21 @@ public class EntityArrow extends Entity implements IProjectile
             int var18 = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
             int var19 = this.worldObj.getBlockMetadata(this.xTile, this.yTile, this.zTile);
 
+            // FCMOD: Changed this line
+			/*
             if (var18 == this.inTile && var19 == this.inData)
+			*/
+            if (var18 == this.inTile && ( var19 == this.inData || var18 == FCBetterThanWolves.fcBlockDetector.blockID ) )
+    		// END FCMOD
             {
                 ++this.ticksInGround;
 
+                // FCMOD: Changed this to increase arrow despawn time to be same as items
+                /*
                 if (this.ticksInGround == 1200)
+                */
+                if ( ticksInGround >= 6000 )
+            	// END FCMOD
                 {
                     this.setDead();
                 }
@@ -231,38 +253,38 @@ public class EntityArrow extends Entity implements IProjectile
 
             if (var4 != null && var4.entityHit != null && var4.entityHit instanceof EntityPlayer)
             {
-                EntityPlayer var20 = (EntityPlayer)var4.entityHit;
+                EntityPlayer var21 = (EntityPlayer)var4.entityHit;
 
-                if (var20.capabilities.disableDamage || this.shootingEntity instanceof EntityPlayer && !((EntityPlayer)this.shootingEntity).func_96122_a(var20))
+                if (var21.capabilities.disableDamage || this.shootingEntity instanceof EntityPlayer && !((EntityPlayer)this.shootingEntity).func_96122_a(var21))
                 {
                     var4 = null;
                 }
             }
 
-            float var21;
+            float var20;
             float var27;
 
             if (var4 != null)
             {
                 if (var4.entityHit != null)
                 {
-                    var21 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
-                    int var22 = MathHelper.ceiling_double_int((double)var21 * this.damage);
+                    var20 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
+                    int var24 = MathHelper.ceiling_double_int((double)var20 * this.damage);
 
                     if (this.getIsCritical())
                     {
-                        var22 += this.rand.nextInt(var22 / 2 + 2);
+                        var24 += this.rand.nextInt(var24 / 2 + 2);
                     }
 
-                    DamageSource var23 = null;
+                    DamageSource var22 = null;
 
                     if (this.shootingEntity == null)
                     {
-                        var23 = DamageSource.causeArrowDamage(this, this);
+                        var22 = DamageSource.causeArrowDamage(this, this);
                     }
                     else
                     {
-                        var23 = DamageSource.causeArrowDamage(this, this.shootingEntity);
+                        var22 = DamageSource.causeArrowDamage(this, this.shootingEntity);
                     }
 
                     if (this.isBurning() && !(var4.entityHit instanceof EntityEnderman))
@@ -270,7 +292,12 @@ public class EntityArrow extends Entity implements IProjectile
                         var4.entityHit.setFire(5);
                     }
 
-                    if (var4.entityHit.attackEntityFrom(var23, var22))
+                    // FCMOD: Line changed
+                    /*
+                    if (var4.entityHit.attackEntityFrom(var22, var24))
+                    */
+	                if ( var4.entityHit.attackEntityFrom( var22, (int)((float)var24 * GetDamageMultiplier() ) ))
+	            	// END FCMOD
                     {
                         if (var4.entityHit instanceof EntityLiving)
                         {
@@ -326,13 +353,16 @@ public class EntityArrow extends Entity implements IProjectile
                     this.zTile = var4.blockZ;
                     this.inTile = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
                     this.inData = this.worldObj.getBlockMetadata(this.xTile, this.yTile, this.zTile);
+                    // FCMOD: Added
+                    NotifyColldingBlockOfImpact();
+                    // END FCMOD
                     this.motionX = (double)((float)(var4.hitVec.xCoord - this.posX));
                     this.motionY = (double)((float)(var4.hitVec.yCoord - this.posY));
                     this.motionZ = (double)((float)(var4.hitVec.zCoord - this.posZ));
-                    var21 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
-                    this.posX -= this.motionX / (double)var21 * 0.05000000074505806D;
-                    this.posY -= this.motionY / (double)var21 * 0.05000000074505806D;
-                    this.posZ -= this.motionZ / (double)var21 * 0.05000000074505806D;
+                    var20 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
+                    this.posX -= this.motionX / (double)var20 * 0.05000000074505806D;
+                    this.posY -= this.motionY / (double)var20 * 0.05000000074505806D;
+                    this.posZ -= this.motionZ / (double)var20 * 0.05000000074505806D;
                     this.playSound("random.bowhit", 1.0F, 1.2F / (this.rand.nextFloat() * 0.2F + 0.9F));
                     this.inGround = true;
                     this.arrowShake = 7;
@@ -356,10 +386,10 @@ public class EntityArrow extends Entity implements IProjectile
             this.posX += this.motionX;
             this.posY += this.motionY;
             this.posZ += this.motionZ;
-            var21 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
+            var20 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
             this.rotationYaw = (float)(Math.atan2(this.motionX, this.motionZ) * 180.0D / Math.PI);
 
-            for (this.rotationPitch = (float)(Math.atan2(this.motionY, (double)var21) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
+            for (this.rotationPitch = (float)(Math.atan2(this.motionY, (double)var20) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
             {
                 ;
             }
@@ -381,7 +411,7 @@ public class EntityArrow extends Entity implements IProjectile
 
             this.rotationPitch = this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
             this.rotationYaw = this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
-            float var24 = 0.99F;
+            float var23 = 0.99F;
             var11 = 0.05F;
 
             if (this.isInWater())
@@ -392,16 +422,19 @@ public class EntityArrow extends Entity implements IProjectile
                     this.worldObj.spawnParticle("bubble", this.posX - this.motionX * (double)var27, this.posY - this.motionY * (double)var27, this.posZ - this.motionZ * (double)var27, this.motionX, this.motionY, this.motionZ);
                 }
 
-                var24 = 0.8F;
+                var23 = 0.8F;
             }
 
-            this.motionX *= (double)var24;
-            this.motionY *= (double)var24;
-            this.motionZ *= (double)var24;
+            this.motionX *= (double)var23;
+            this.motionY *= (double)var23;
+            this.motionZ *= (double)var23;
             this.motionY -= (double)var11;
             this.setPosition(this.posX, this.posY, this.posZ);
             this.doBlockCollisions();
         }
+        // FCMOD: Added        
+        NotifyAnyCollidingBlocks();
+        // END FCMOD
     }
 
     /**
@@ -418,6 +451,10 @@ public class EntityArrow extends Entity implements IProjectile
         par1NBTTagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
         par1NBTTagCompound.setByte("pickup", (byte)this.canBePickedUp);
         par1NBTTagCompound.setDouble("damage", this.damage);
+        
+        // FCMOD: Added
+        par1NBTTagCompound.setShort( "fcInTileEx", (short)this.inTile );
+	    // END FCMOD    
     }
 
     /**
@@ -446,6 +483,13 @@ public class EntityArrow extends Entity implements IProjectile
         {
             this.canBePickedUp = par1NBTTagCompound.getBoolean("player") ? 1 : 0;
         }
+        
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcInTileEx" ) )
+        {
+        	inTile = par1NBTTagCompound.getShort( "fcInTileEx" );
+        }
+	    // END FCMOD
     }
 
     /**
@@ -457,7 +501,12 @@ public class EntityArrow extends Entity implements IProjectile
         {
             boolean var2 = this.canBePickedUp == 1 || this.canBePickedUp == 2 && par1EntityPlayer.capabilities.isCreativeMode;
 
+            // FCMOD: Changed line
+            /*
             if (this.canBePickedUp == 1 && !par1EntityPlayer.inventory.addItemStackToInventory(new ItemStack(Item.arrow, 1)))
+	        */
+	        if ( canBePickedUp == 1 && !AddArrowToPlayerInv( par1EntityPlayer ) )
+	    	// END FCMOD
             {
                 var2 = false;
             }
@@ -531,4 +580,49 @@ public class EntityArrow extends Entity implements IProjectile
         byte var1 = this.dataWatcher.getWatchableObjectByte(16);
         return (var1 & 1) != 0;
     }
+    
+    // FCMOD: Code added
+    protected float GetDamageMultiplier()
+    {
+    	return 1F;
+    }
+    
+	protected boolean AddArrowToPlayerInv( EntityPlayer player )
+	{
+		return player.inventory.addItemStackToInventory( new ItemStack( GetCorrespondingItem(), 1 ) );
+	}
+	
+	public Item GetCorrespondingItem()
+	{
+		return Item.arrow;
+	}
+	
+	public boolean CanHopperCollect()
+	{
+		return true;
+	}
+	
+	private void NotifyAnyCollidingBlocks()
+	{
+        if ( inGround )
+        {
+            Block blockHit = Block.blocksList[inTile];
+            
+            if ( blockHit != null )
+            {
+            	blockHit.OnArrowCollide( worldObj, xTile, yTile, zTile, this );
+            }
+        }
+	}
+	
+    private void NotifyColldingBlockOfImpact()
+    {
+	    Block blockHit = Block.blocksList[inTile];
+	    
+	    if ( blockHit != null )
+	    {
+	    	blockHit.OnArrowImpact( worldObj, xTile, yTile, zTile, this );
+	    }
+    }
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityBat.java b/minecraft_server/net/minecraft/src/EntityBat.java
index 292b0d2..0f02c51 100644
--- a/minecraft_server/net/minecraft/src/EntityBat.java
+++ b/minecraft_server/net/minecraft/src/EntityBat.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/23/2018
+
 package net.minecraft.src;
 
 import java.util.Calendar;
diff --git a/minecraft_server/net/minecraft/src/EntityBlaze.java b/minecraft_server/net/minecraft/src/EntityBlaze.java
index 0ca9ef8..bcb4874 100644
--- a/minecraft_server/net/minecraft/src/EntityBlaze.java
+++ b/minecraft_server/net/minecraft/src/EntityBlaze.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/27/2018
+
 package net.minecraft.src;
 
 public class EntityBlaze extends EntityMob
diff --git a/minecraft_server/net/minecraft/src/EntityBoat.java b/minecraft_server/net/minecraft/src/EntityBoat.java
index 0105ee2..8c92457 100644
--- a/minecraft_server/net/minecraft/src/EntityBoat.java
+++ b/minecraft_server/net/minecraft/src/EntityBoat.java
@@ -4,6 +4,7 @@ import java.util.List;
 
 public class EntityBoat extends Entity
 {
+	// FCNOTE: The following seems to be false if the boat is ridden by a player
     private boolean field_70279_a;
     private double speedMultiplier;
     private int boatPosRotationIncrements;
@@ -167,6 +168,15 @@ public class EntityBoat extends Entity
             }
         }
 
+        // FCMOD: Added
+        if ( var2 > 0.1F )
+        {
+        	// var 2 tracks how deep the boat is resting in the water
+            fallDistance = 0.0F;
+            extinguish();
+        }
+        // END FCMOD
+
         double var23 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
         double var6;
         double var8;
@@ -251,6 +261,8 @@ public class EntityBoat extends Entity
                 this.motionY += 0.007000000216066837D;
             }
 
+            // FCMOD: modify boat speed by whether player is holding a sail
+            /*
             if (this.riddenByEntity != null)
             {
                 this.motionX += this.riddenByEntity.motionX * this.speedMultiplier;
@@ -266,6 +278,40 @@ public class EntityBoat extends Entity
                 this.motionZ *= var8;
                 var6 = 0.35D;
             }
+            */
+            double dMaxSpeed = 0.35D;
+            
+            if ( riddenByEntity != null )
+            {
+            	dMaxSpeed *= riddenByEntity.MovementModifierWhenRidingBoat();
+            	
+                this.motionX += this.riddenByEntity.motionX * this.speedMultiplier;
+                this.motionZ += this.riddenByEntity.motionZ * this.speedMultiplier;
+                
+            	if ( riddenByEntity.AppliesConstantForceWhenRidingBoat() )
+            	{
+            		motionX -= Math.cos( (double)rotationYaw * Math.PI / 180.0D ) * dMaxSpeed * 0.02;
+            		motionZ -= Math.sin( (double)rotationYaw * Math.PI / 180.0D ) * dMaxSpeed * 0.02;
+            	}
+            }
+
+            var6 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+
+            if ( var6 > dMaxSpeed )
+            {
+                double dSpeedModifier = dMaxSpeed / var6;
+                
+                if ( dSpeedModifier < 0.9D )
+                {
+                	dSpeedModifier = 0.9D;
+                }
+                
+                motionX *= dSpeedModifier;
+                motionZ *= dSpeedModifier;
+                
+                var6 *= dSpeedModifier;
+            }
+            // END FCMOD
 
             if (var6 > var23 && this.speedMultiplier < 0.35D)
             {
@@ -297,6 +343,8 @@ public class EntityBoat extends Entity
 
             if (this.isCollidedHorizontally && var23 > 0.2D)
             {
+            	// FCMOD: Changed
+            	/*
                 if (!this.worldObj.isRemote && !this.isDead)
                 {
                     this.setDead();
@@ -312,6 +360,9 @@ public class EntityBoat extends Entity
                         this.dropItemWithOffset(Item.stick.itemID, 1, 0.0F);
                     }
                 }
+                */
+            	BreakBoat();
+            	// END FCMOD
             }
             else
             {
@@ -373,7 +424,14 @@ public class EntityBoat extends Entity
                         int var21 = MathHelper.floor_double(this.posY) + var20;
                         int var22 = this.worldObj.getBlockId(var27, var21, var19);
 
+                        // FCMOD: Changed
+                        /*
                         if (var22 == Block.snow.blockID)
+                        */
+                        Block tempBlock = Block.blocksList[var22];
+                        
+                        if ( tempBlock != null && tempBlock.IsGroundCover( ) )
+                        // END FCMOD
                         {
                             this.worldObj.setBlockToAir(var27, var21, var19);
                         }
@@ -479,4 +537,40 @@ public class EntityBoat extends Entity
     {
         return this.dataWatcher.getWatchableObjectInt(18);
     }
+    
+    // FCMOD: Code added
+    @Override
+    public boolean CanCollideWithEntity( Entity entity )
+    {
+    	return !entity.IsItemEntity();
+    }
+    
+    @Override
+    protected void fall( float fFallDistance )
+    {
+    	super.fall( fFallDistance );
+    	
+    	if ( fFallDistance > 5F )
+    	{
+    		BreakBoat();
+    	}
+    }
+    
+    public void BreakBoat()
+    {
+        if ( !worldObj.isRemote && !isDead )
+        {
+            setDead();
+
+            for ( int iCount = 0; iCount < 4; iCount++ )
+            {
+                dropItemWithOffset( Item.stick.itemID, 1, 0.0F );
+                
+                dropItemWithOffset( FCBetterThanWolves.fcItemSawDust.itemID, 1, 0.0F );
+            }
+            
+            playSound( "mob.zombie.woodbreak", 0.5F, 0.50F + ( rand.nextFloat() * 0.25F ) );
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityCaveSpider.java b/minecraft_server/net/minecraft/src/EntityCaveSpider.java
index f6cd1d3..6fc7031 100644
--- a/minecraft_server/net/minecraft/src/EntityCaveSpider.java
+++ b/minecraft_server/net/minecraft/src/EntityCaveSpider.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityCaveSpider extends EntitySpider
diff --git a/minecraft_server/net/minecraft/src/EntityChicken.java b/minecraft_server/net/minecraft/src/EntityChicken.java
index 3a5e534..93cee7a 100644
--- a/minecraft_server/net/minecraft/src/EntityChicken.java
+++ b/minecraft_server/net/minecraft/src/EntityChicken.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 08/10/2018
+
 package net.minecraft.src;
 
 public class EntityChicken extends EntityAnimal
@@ -141,7 +143,7 @@ public class EntityChicken extends EntityAnimal
         {
             this.dropItem(Item.feather.itemID, 1);
         }
-
+        
         if (this.isBurning())
         {
             this.dropItem(Item.chickenCooked.itemID, 1);
diff --git a/minecraft_server/net/minecraft/src/EntityCow.java b/minecraft_server/net/minecraft/src/EntityCow.java
index 542a0c4..d109331 100644
--- a/minecraft_server/net/minecraft/src/EntityCow.java
+++ b/minecraft_server/net/minecraft/src/EntityCow.java
@@ -1,5 +1,12 @@
+// FCMOD: Class changes deprecated 07/23/2018
+
 package net.minecraft.src;
 
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.util.Iterator;
+import java.util.List;
+
 public class EntityCow extends EntityAnimal
 {
     public EntityCow(World par1World)
diff --git a/minecraft_server/net/minecraft/src/EntityCreature.java b/minecraft_server/net/minecraft/src/EntityCreature.java
index 3c905cc..a0ec59f 100644
--- a/minecraft_server/net/minecraft/src/EntityCreature.java
+++ b/minecraft_server/net/minecraft/src/EntityCreature.java
@@ -1,5 +1,10 @@
 package net.minecraft.src;
 
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.util.Iterator;
+import java.util.List;
+
 public abstract class EntityCreature extends EntityLiving
 {
     private PathEntity pathToEntity;
@@ -53,10 +58,25 @@ public abstract class EntityCreature extends EntityLiving
         {
             float var2 = this.entityToAttack.getDistanceToEntity(this);
 
+            // FCMOD: Changed
+            /*
             if (this.canEntityBeSeen(this.entityToAttack))
             {
                 this.attackEntity(this.entityToAttack, var2);
             }
+            */
+            if ( ShouldContinueAttacking( var2 ) )
+        	{
+                if (this.canEntityBeSeen(this.entityToAttack))
+                {
+                    this.attackEntity(this.entityToAttack, var2);
+                }
+        	}
+            else
+            {
+                entityToAttack = null;
+            }
+            // END FCMOD
         }
         else
         {
@@ -69,7 +89,12 @@ public abstract class EntityCreature extends EntityLiving
         {
             this.pathToEntity = this.worldObj.getPathEntityToEntity(this, this.entityToAttack, var1, true, false, false, true);
         }
+        // FCMOD: Code changed to stop AI deactivating with distance
+        /*
         else if (!this.hasAttacked && (this.pathToEntity == null && this.rand.nextInt(180) == 0 || this.rand.nextInt(120) == 0 || this.fleeingTick > 0) && this.entityAge < 100)
+        */
+        else if (!this.hasAttacked && (this.pathToEntity == null && this.rand.nextInt(180) == 0 || this.rand.nextInt(120) == 0 || this.fleeingTick > 0))
+        // END FCMOD
         {
             this.updateWanderPath();
         }
@@ -156,6 +181,13 @@ public abstract class EntityCreature extends EntityLiving
             }
 
             this.worldObj.theProfiler.endSection();
+            
+            // FCMOD: Added as the lack of super call in this condition was causing spiders 
+            // with targets to hang out for an exceedingly long time without despawning
+            entityAge++;
+            
+            despawnEntity();            
+            // END FCMOD
         }
         else
         {
@@ -282,4 +314,299 @@ public abstract class EntityCreature extends EntityLiving
 
         return var1;
     }
+    
+    // FCMOD: Added New
+    private static final int m_iIsPossessedDataWatcherID = 24;
+    
+    protected int m_iPossessionTimer = -1; // - 1 is not possessed
+    
+    @Override
+    protected void entityInit()
+    {
+    	EntityCreatureEntityInit();
+    }
+    
+    protected void EntityCreatureEntityInit()
+    {
+    	// Added to alow calling entityInit() directly regardless of class hierarchy
+    	
+        super.entityInit();
+        
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+        	dataWatcher.addObject( m_iIsPossessedDataWatcherID, new Byte( (byte)0 ) );
+        }
+    }
+    
+    @Override
+    public void writeEntityToNBT( NBTTagCompound tag )
+    {
+        super.writeEntityToNBT( tag );
+        
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+	        tag.setInteger( "fcPossessionTimer", m_iPossessionTimer );
+	        
+	        tag.setByte( "fcPossessionLevel", (byte)GetPossessionLevel() );
+        }
+    }
+
+    @Override
+    public void readEntityFromNBT( NBTTagCompound tag )
+    {
+        super.readEntityFromNBT( tag );
+        
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+	        if ( tag.hasKey( "fcPossessionTimer" ) )
+	    	{
+	        	m_iPossessionTimer = tag.getInteger( "fcPossessionTimer" );
+	        
+	        	if ( m_iPossessionTimer >= 0 )
+	        	{
+	        		SetPossessionLevel( 1 );
+	        	}
+	        	else
+	        	{
+	        		SetPossessionLevel( 0 );
+	        	}
+	    	}
+	        else
+	        {
+	        	m_iPossessionTimer = -1;
+	        	
+	    		SetPossessionLevel( 0 );
+	        }
+	        
+	        if ( tag.hasKey( "fcPossessionLevel" ) )
+	        {
+	        	SetPossessionLevel( tag.getByte( "fcPossessionLevel" ) );
+	        }
+        }
+    }
+
+    @Override
+    protected void ModSpecificOnLivingUpdate()
+    {
+    	super.ModSpecificOnLivingUpdate();
+    	
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+        	HandlePossession();
+        }
+    }
+    
+    protected boolean GetCanCreatureTypeBePossessed()
+    {
+    	return false;
+    }
+    
+    protected boolean GetCanCreatureBePossessedFromDistance( boolean bPersistentSpirit )
+    {
+        return GetCanCreatureTypeBePossessed() && isEntityAlive() && !IsPossessed();
+    }
+    
+    protected boolean IsPossessed()
+    {
+    	return GetCanCreatureTypeBePossessed() && dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) != 0;    	
+    }
+    
+    protected boolean IsFullyPossessed()
+    {
+    	return GetCanCreatureTypeBePossessed() && dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) > 1;
+    }
+    
+    protected void SetPossessionLevel( int iLevel )
+    {    	
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+	    	byte byteValue = (byte)iLevel;
+	    	
+	        dataWatcher.updateObject( m_iIsPossessedDataWatcherID, Byte.valueOf( byteValue ) );
+        }
+    }
+
+    protected int GetPossessionLevel()
+    {    	
+        if ( GetCanCreatureTypeBePossessed() )
+        {
+        	return (int)( dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) );
+        }
+        
+        return 0;
+    }
+    
+    protected int GetInitialPossessionChance()
+    {
+    	return 1000;    	
+    }
+    
+    protected int GetTimeToFullPossession()
+    {
+    	return 2400 + worldObj.rand.nextInt( 2400 ); // 2 to 4 minutes    	
+    }
+    
+    protected void OnInitialPossession()
+    {
+        worldObj.playSoundAtEntity( this, getDeathSound(), getSoundVolume(), (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F );
+        
+        worldObj.playAuxSFX( FCBetterThanWolves.m_iGhastMoanSoundAuxFXID, 
+        	MathHelper.floor_double( posX ), MathHelper.floor_double( posY ), MathHelper.floor_double( posZ ), 0 );            
+    }
+    
+    protected void OnFullPossession()
+    {
+    }
+    
+    public void InitiatePossession()
+    {
+		SetPossessionLevel( 1 );
+		
+		m_iPossessionTimer = GetTimeToFullPossession();
+		
+		OnInitialPossession();	    				
+    }
+    
+    protected void HandlePossession()
+    {
+    	if ( worldObj.getWorldInfo().getGameType() == EnumGameType.CREATIVE )
+    	{
+    		return;
+    	}
+    	
+        if ( !worldObj.isRemote )
+        {
+	    	if ( !IsPossessed() )
+	    	{
+	    		if ( worldObj.provider.dimensionId == -1 ) // is nether
+	    		{
+	    			if ( worldObj.rand.nextInt( GetInitialPossessionChance() ) == 0 )
+	    			{
+	    				InitiatePossession();	    				
+	    			}
+	    		}
+	    	}
+	    	else if ( !isChild() ) // children can be possessed but it won't take full effect until they grow up
+	    	{
+	    		if ( GetPossessionLevel() == 1 )
+	    		{
+		    		m_iPossessionTimer--;
+		    		
+		    		if ( m_iPossessionTimer < 0 )
+		    		{
+		    			m_iPossessionTimer = 0;
+		    		}
+		    		
+		    		if ( m_iPossessionTimer == 0 )
+		    		{
+		    			SetPossessionLevel( 2 );
+		    			
+		    			OnFullPossession();	    			
+		    		}
+	    		}
+	    	}
+        }
+    }
+    
+    protected boolean AttemptToPossessNearbyCreature( double dRange, boolean bPersistentSpirit )
+    {    	
+        List nearbyCreatures = worldObj.getEntitiesWithinAABB( EntityCreature.class, boundingBox.expand( dRange, dRange, dRange ) );
+        
+        Iterator itemIterator = nearbyCreatures.iterator();
+    	
+        while ( itemIterator.hasNext() )
+        {
+    		EntityCreature tempCreature = (EntityCreature)itemIterator.next();
+    		
+	        if ( tempCreature.GetCanCreatureBePossessedFromDistance( bPersistentSpirit ) && tempCreature != this )
+	        {
+	        	tempCreature.InitiatePossession();
+        		
+        		return true;
+	        }	        
+        }
+        
+    	return false;
+    }
+    
+    static public int AttemptToPossessCreaturesAroundBlock( World world, int i, int j, int k, int iPossessionCount, int iCubicRange )
+    {
+		AxisAlignedBB possessionBox = AxisAlignedBB.getAABBPool().getAABB( 
+			(double)( i - iCubicRange ), (double)( j - iCubicRange ), (double)( k - iCubicRange ),
+			(double)( i + 1 + iCubicRange ), (double)( j + 1 + iCubicRange ), (double)( k + 1 + iCubicRange ) );
+		
+        List nearbyCreatures = world.getEntitiesWithinAABB( EntityCreature.class, possessionBox );
+        
+        Iterator creatureIterator = nearbyCreatures.iterator();
+    	
+        while ( creatureIterator.hasNext() && iPossessionCount > 0 )
+        {
+        	EntityCreature tempCreature = (EntityCreature)creatureIterator.next();
+    		
+	        if ( tempCreature.GetCanCreatureBePossessedFromDistance( false ) )
+	        {
+	        	tempCreature.InitiatePossession();
+	        	
+	        	iPossessionCount--;        		
+	        }        	        
+        }    
+        
+        return iPossessionCount;
+    }    
+    
+    protected void AttemptToPossessNearbyCreatureOnDeath()
+    {
+		AttemptToPossessNearbyCreature( 16D, false );
+    }
+    
+    @Override
+    public void onDeath( DamageSource source )
+    {
+    	super.onDeath( source );
+    	
+    	// if a possessed creature dies, the spirits attempt to possess another nearby
+    	
+    	if ( !worldObj.isRemote && IsPossessed() )
+    	{
+    		if ( riddenByEntity == null || !riddenByEntity.OnPossesedRidingEntityDeath() )
+    		{
+    			AttemptToPossessNearbyCreatureOnDeath();
+    		}
+    	}
+    }
+
+    protected boolean ShouldContinueAttacking( float fDistanceToTarget )
+    {
+    	return true;
+    }
+
+    protected void TransmitAttackTargetToClients()
+    {
+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
+        DataOutputStream dataStream = new DataOutputStream( byteStream );
+        
+        try
+        {
+	        dataStream.writeInt( entityId );
+	        dataStream.writeByte( (byte)FCBetterThanWolves.fcCustomEntityEventPacketTypeSetAttackTarget );
+
+	        if ( entityToAttack != null )
+	        {
+	        	dataStream.writeInt( entityToAttack.entityId );
+	        }
+	        else
+	        {
+	        	dataStream.writeInt( -1 );
+	        }
+        }
+        catch (Exception exception)
+        {
+            exception.printStackTrace();
+        }        
+	        
+        Packet250CustomPayload packet = new Packet250CustomPayload( FCBetterThanWolves.fcCustomPacketChannelCustomEntityEvent, byteStream.toByteArray() );
+        
+        FCUtilsWorld.SendPacketToAllPlayersTrackingEntity( (WorldServer)worldObj, this, packet );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityCreeper.java b/minecraft_server/net/minecraft/src/EntityCreeper.java
index f01a1f4..a072cf2 100644
--- a/minecraft_server/net/minecraft/src/EntityCreeper.java
+++ b/minecraft_server/net/minecraft/src/EntityCreeper.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityCreeper extends EntityMob
diff --git a/minecraft_server/net/minecraft/src/EntityDragon.java b/minecraft_server/net/minecraft/src/EntityDragon.java
index 53d8a12..c4b306f 100644
--- a/minecraft_server/net/minecraft/src/EntityDragon.java
+++ b/minecraft_server/net/minecraft/src/EntityDragon.java
@@ -174,7 +174,7 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
             double var6;
             double var8;
             double var26;
-            float var31;
+            float var33;
 
             if (this.worldObj.isRemote)
             {
@@ -226,16 +226,16 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
                 }
 
                 var4 /= (double)MathHelper.sqrt_double(var26 * var26 + var6 * var6);
-                var31 = 0.6F;
+                var33 = 0.6F;
 
-                if (var4 < (double)(-var31))
+                if (var4 < (double)(-var33))
                 {
-                    var4 = (double)(-var31);
+                    var4 = (double)(-var33);
                 }
 
-                if (var4 > (double)var31)
+                if (var4 > (double)var33)
                 {
-                    var4 = (double)var31;
+                    var4 = (double)var33;
                 }
 
                 this.motionY += var4 * 0.10000000149011612D;
@@ -254,8 +254,8 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
                 }
 
                 Vec3 var15 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.targetX - this.posX, this.targetY - this.posY, this.targetZ - this.posZ).normalize();
-                Vec3 var39 = this.worldObj.getWorldVec3Pool().getVecFromPool((double)MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F), this.motionY, (double)(-MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F))).normalize();
-                float var17 = (float)(var39.dotProduct(var15) + 0.5D) / 1.5F;
+                Vec3 var40 = this.worldObj.getWorldVec3Pool().getVecFromPool((double)MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F), this.motionY, (double)(-MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F))).normalize();
+                float var17 = (float)(var40.dotProduct(var15) + 0.5D) / 1.5F;
 
                 if (var17 < 0.0F)
                 {
@@ -287,7 +287,7 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
                 }
 
                 Vec3 var23 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.motionX, this.motionY, this.motionZ).normalize();
-                float var24 = (float)(var23.dotProduct(var39) + 1.0D) / 2.0F;
+                float var24 = (float)(var23.dotProduct(var40) + 1.0D) / 2.0F;
                 var24 = 0.8F + 0.15F * var24;
                 this.motionX *= (double)var24;
                 this.motionZ *= (double)var24;
@@ -307,16 +307,16 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
             this.dragonPartWing2.width = 4.0F;
             var2 = (float)(this.getMovementOffsets(5, 1.0F)[1] - this.getMovementOffsets(10, 1.0F)[1]) * 10.0F / 180.0F * (float)Math.PI;
             var3 = MathHelper.cos(var2);
-            float var27 = -MathHelper.sin(var2);
+            float var28 = -MathHelper.sin(var2);
             float var5 = this.rotationYaw * (float)Math.PI / 180.0F;
-            float var28 = MathHelper.sin(var5);
+            float var27 = MathHelper.sin(var5);
             float var7 = MathHelper.cos(var5);
             this.dragonPartBody.onUpdate();
-            this.dragonPartBody.setLocationAndAngles(this.posX + (double)(var28 * 0.5F), this.posY, this.posZ - (double)(var7 * 0.5F), 0.0F, 0.0F);
+            this.dragonPartBody.setLocationAndAngles(this.posX + (double)(var27 * 0.5F), this.posY, this.posZ - (double)(var7 * 0.5F), 0.0F, 0.0F);
             this.dragonPartWing1.onUpdate();
-            this.dragonPartWing1.setLocationAndAngles(this.posX + (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ + (double)(var28 * 4.5F), 0.0F, 0.0F);
+            this.dragonPartWing1.setLocationAndAngles(this.posX + (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ + (double)(var27 * 4.5F), 0.0F, 0.0F);
             this.dragonPartWing2.onUpdate();
-            this.dragonPartWing2.setLocationAndAngles(this.posX - (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ - (double)(var28 * 4.5F), 0.0F, 0.0F);
+            this.dragonPartWing2.setLocationAndAngles(this.posX - (double)(var7 * 4.5F), this.posY + 2.0D, this.posZ - (double)(var27 * 4.5F), 0.0F, 0.0F);
 
             if (!this.worldObj.isRemote && this.hurtTime == 0)
             {
@@ -327,38 +327,38 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
 
             double[] var29 = this.getMovementOffsets(5, 1.0F);
             double[] var9 = this.getMovementOffsets(0, 1.0F);
-            var31 = MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
-            float var33 = MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
+            var33 = MathHelper.sin(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
+            float var32 = MathHelper.cos(this.rotationYaw * (float)Math.PI / 180.0F - this.randomYawVelocity * 0.01F);
             this.dragonPartHead.onUpdate();
-            this.dragonPartHead.setLocationAndAngles(this.posX + (double)(var31 * 5.5F * var3), this.posY + (var9[1] - var29[1]) * 1.0D + (double)(var27 * 5.5F), this.posZ - (double)(var33 * 5.5F * var3), 0.0F, 0.0F);
+            this.dragonPartHead.setLocationAndAngles(this.posX + (double)(var33 * 5.5F * var3), this.posY + (var9[1] - var29[1]) * 1.0D + (double)(var28 * 5.5F), this.posZ - (double)(var32 * 5.5F * var3), 0.0F, 0.0F);
 
             for (int var30 = 0; var30 < 3; ++var30)
             {
-                EntityDragonPart var32 = null;
+                EntityDragonPart var31 = null;
 
                 if (var30 == 0)
                 {
-                    var32 = this.dragonPartTail1;
+                    var31 = this.dragonPartTail1;
                 }
 
                 if (var30 == 1)
                 {
-                    var32 = this.dragonPartTail2;
+                    var31 = this.dragonPartTail2;
                 }
 
                 if (var30 == 2)
                 {
-                    var32 = this.dragonPartTail3;
+                    var31 = this.dragonPartTail3;
                 }
 
-                double[] var34 = this.getMovementOffsets(12 + var30 * 2, 1.0F);
-                float var35 = this.rotationYaw * (float)Math.PI / 180.0F + this.simplifyAngle(var34[0] - var29[0]) * (float)Math.PI / 180.0F * 1.0F;
-                float var37 = MathHelper.sin(var35);
-                float var36 = MathHelper.cos(var35);
-                float var38 = 1.5F;
-                float var40 = (float)(var30 + 1) * 2.0F;
-                var32.onUpdate();
-                var32.setLocationAndAngles(this.posX - (double)((var28 * var38 + var37 * var40) * var3), this.posY + (var34[1] - var29[1]) * 1.0D - (double)((var40 + var38) * var27) + 1.5D, this.posZ + (double)((var7 * var38 + var36 * var40) * var3), 0.0F, 0.0F);
+                double[] var35 = this.getMovementOffsets(12 + var30 * 2, 1.0F);
+                float var34 = this.rotationYaw * (float)Math.PI / 180.0F + this.simplifyAngle(var35[0] - var29[0]) * (float)Math.PI / 180.0F * 1.0F;
+                float var38 = MathHelper.sin(var34);
+                float var37 = MathHelper.cos(var34);
+                float var36 = 1.5F;
+                float var39 = (float)(var30 + 1) * 2.0F;
+                var31.onUpdate();
+                var31.setLocationAndAngles(this.posX - (double)((var27 * var36 + var38 * var39) * var3), this.posY + (var35[1] - var29[1]) * 1.0D - (double)((var39 + var36) * var28) + 1.5D, this.posZ + (double)((var7 * var36 + var37 * var39) * var3), 0.0F, 0.0F);
             }
 
             if (!this.worldObj.isRemote)
@@ -460,11 +460,31 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
     {
         this.forceNewTarget = false;
 
+        // FCMOD: Code added
+        boolean bTargetSelected = false;
+        // END FCMOD
+
         if (this.rand.nextInt(2) == 0 && !this.worldObj.playerEntities.isEmpty())
         {
             this.target = (Entity)this.worldObj.playerEntities.get(this.rand.nextInt(this.worldObj.playerEntities.size()));
+            
+            // FCMOD: Code added
+            long lTargetChangedDimensionTime = ((EntityPlayer)target).m_lTimeOfLastDimensionSwitch;
+            long lWorldTime = worldObj.getWorldTime();
+            
+            if ( lWorldTime < lTargetChangedDimensionTime || lWorldTime - lTargetChangedDimensionTime > m_iPlayerSwitchDimensionsGracePeriod )
+            {
+            	bTargetSelected = true;
+            }
+            // END FCMOD
         }
+        
+        // FCMOD: Code change
+        /*
         else
+        */
+        if ( !bTargetSelected )
+    	// END FCMOD
         {
             boolean var1 = false;
 
@@ -741,4 +761,8 @@ public class EntityDragon extends EntityLiving implements IEntityMultiPart
     {
         return 5.0F;
     }
+    
+    // FCMOD: Code added
+    private static final long m_iPlayerSwitchDimensionsGracePeriod = 600; // 30 seconds 
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityEgg.java b/minecraft_server/net/minecraft/src/EntityEgg.java
index 63ca719..d2abdec 100644
--- a/minecraft_server/net/minecraft/src/EntityEgg.java
+++ b/minecraft_server/net/minecraft/src/EntityEgg.java
@@ -38,12 +38,23 @@ public class EntityEgg extends EntityThrowable
 
             for (int var3 = 0; var3 < var2; ++var3)
             {
-                EntityChicken var4 = new EntityChicken(this.worldObj);
-                var4.setGrowingAge(-24000);
+            	// FCMOD: Changed
+                //EntityChicken var4 = new EntityChicken(this.worldObj);
+                //var4.setGrowingAge(-24000);
+                FCEntityChicken var4 = new FCEntityChicken( worldObj );
+                var4.setGrowingAge( -var4.GetTicksForChildToGrow() );
+                // END FCMOD
                 var4.setLocationAndAngles(this.posX, this.posY, this.posZ, this.rotationYaw, 0.0F);
                 this.worldObj.spawnEntityInWorld(var4);
             }
         }
+        // FCMOD: Added
+        else if ( !worldObj.isRemote )
+        {
+        	FCUtilsItem.EjectSingleItemWithRandomVelocity( worldObj, (float)posX, (float)posY, (float)posZ, FCBetterThanWolves.fcItemRawEgg.itemID, 0 );
+        	
+        }
+        // END FCMOD
 
         for (int var5 = 0; var5 < 8; ++var5)
         {
diff --git a/minecraft_server/net/minecraft/src/EntityEnderman.java b/minecraft_server/net/minecraft/src/EntityEnderman.java
index 271f3d5..c0b2d18 100644
--- a/minecraft_server/net/minecraft/src/EntityEnderman.java
+++ b/minecraft_server/net/minecraft/src/EntityEnderman.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/24/2018
+
 package net.minecraft.src;
 
 public class EntityEnderman extends EntityMob
@@ -299,7 +301,14 @@ public class EntityEnderman extends EntityMob
 
                 if (this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox).isEmpty() && !this.worldObj.isAnyLiquid(this.boundingBox))
                 {
-                    var13 = true;
+                    // FCMOD: Added
+                    Block blockBelow = Block.blocksList[worldObj.getBlockId( 
+                    	var14, var15 - 1, var16 )];
+
+                    if ( blockBelow != null && blockBelow.CanMobsSpawnOn( 
+                    	worldObj, var14, var15 - 1, var16 ) )
+                    // END FCMOD
+                    var13 = true;                    
                 }
             }
         }
diff --git a/minecraft_server/net/minecraft/src/EntityFireball.java b/minecraft_server/net/minecraft/src/EntityFireball.java
index 39fbe4a..a955427 100644
--- a/minecraft_server/net/minecraft/src/EntityFireball.java
+++ b/minecraft_server/net/minecraft/src/EntityFireball.java
@@ -94,6 +94,15 @@ public abstract class EntityFireball extends Entity
             else
             {
                 ++this.ticksInAir;
+                
+                // FCMOD: Added as fix for undying fireballs MC-4465
+                if ( ticksInAir >= 600 )
+                {
+                    setDead();
+                    
+                    return;
+                }
+                // END FCMOD
             }
 
             Vec3 var15 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
@@ -176,10 +185,10 @@ public abstract class EntityFireball extends Entity
 
             if (this.isInWater())
             {
-                for (int var18 = 0; var18 < 4; ++var18)
+                for (int var19 = 0; var19 < 4; ++var19)
                 {
-                    float var19 = 0.25F;
-                    this.worldObj.spawnParticle("bubble", this.posX - this.motionX * (double)var19, this.posY - this.motionY * (double)var19, this.posZ - this.motionZ * (double)var19, this.motionX, this.motionY, this.motionZ);
+                    float var18 = 0.25F;
+                    this.worldObj.spawnParticle("bubble", this.posX - this.motionX * (double)var18, this.posY - this.motionY * (double)var18, this.posZ - this.motionZ * (double)var18, this.motionX, this.motionY, this.motionZ);
                 }
 
                 var17 = 0.8F;
@@ -220,6 +229,10 @@ public abstract class EntityFireball extends Entity
         par1NBTTagCompound.setByte("inTile", (byte)this.inTile);
         par1NBTTagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
         par1NBTTagCompound.setTag("direction", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
+        
+        // FCMOD: Added as fix for undying fireballs MC-4465
+        par1NBTTagCompound.setShort( "ticksInAir", (short)ticksInAir );
+        // END FCMOD        
     }
 
     /**
@@ -244,6 +257,13 @@ public abstract class EntityFireball extends Entity
         {
             this.setDead();
         }
+        
+        // FCMOD: Added as fix for undying fireballs MC-4465
+        if (par1NBTTagCompound.hasKey( "ticksInAir" ) )
+        {
+        	ticksInAir = par1NBTTagCompound.getShort( "ticksInAir" );
+        }
+        // END FCMOD        
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/EntityFishHook.java b/minecraft_server/net/minecraft/src/EntityFishHook.java
index ce6846b..ec37e5a 100644
--- a/minecraft_server/net/minecraft/src/EntityFishHook.java
+++ b/minecraft_server/net/minecraft/src/EntityFishHook.java
@@ -36,6 +36,9 @@ public class EntityFishHook extends Entity
         super(par1World);
         this.setSize(0.25F, 0.25F);
         this.ignoreFrustumCheck = true;
+        // FCMOD: Added
+        m_bIsBaited = false;
+        // END FCMOD
     }
 
     public EntityFishHook(World par1World, EntityPlayer par2EntityPlayer)
@@ -56,6 +59,9 @@ public class EntityFishHook extends Entity
         this.motionZ = (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI) * var3);
         this.motionY = (double)(-MathHelper.sin(this.rotationPitch / 180.0F * (float)Math.PI) * var3);
         this.calculateVelocity(this.motionX, this.motionY, this.motionZ, 1.5F, 1.0F);
+        // FCMOD: Added
+        m_bIsBaited = false;
+        // END FCMOD
     }
 
     protected void entityInit() {}
@@ -106,7 +112,15 @@ public class EntityFishHook extends Entity
             {
                 ItemStack var1 = this.angler.getCurrentEquippedItem();
 
+                // FCMOD: Changed
+                /*
                 if (this.angler.isDead || !this.angler.isEntityAlive() || var1 == null || var1.getItem() != Item.fishingRod || this.getDistanceSqToEntity(this.angler) > 1024.0D)
+                */
+                if ( angler.isDead || !angler.isEntityAlive() || var1 == null || 
+                	!( ( var1.getItem() == Item.fishingRod && !m_bIsBaited ) || 
+            		( var1.getItem() == FCBetterThanWolves.fcItemFishingRodBaited && m_bIsBaited ) ) ||
+                	getDistanceSqToEntity( angler ) > 1024D )
+                // END FCMOD
                 {
                     this.setDead();
                     this.angler.fishEntity = null;
@@ -254,22 +268,22 @@ public class EntityFishHook extends Entity
                     var25 = 0.5F;
                 }
 
-                byte var26 = 5;
-                double var27 = 0.0D;
+                byte var27 = 5;
+                double var26 = 0.0D;
 
-                for (int var28 = 0; var28 < var26; ++var28)
+                for (int var29 = 0; var29 < var27; ++var29)
                 {
-                    double var14 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var28 + 0) / (double)var26 - 0.125D + 0.125D;
-                    double var16 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var28 + 1) / (double)var26 - 0.125D + 0.125D;
+                    double var14 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var29 + 0) / (double)var27 - 0.125D + 0.125D;
+                    double var16 = this.boundingBox.minY + (this.boundingBox.maxY - this.boundingBox.minY) * (double)(var29 + 1) / (double)var27 - 0.125D + 0.125D;
                     AxisAlignedBB var18 = AxisAlignedBB.getAABBPool().getAABB(this.boundingBox.minX, var14, this.boundingBox.minZ, this.boundingBox.maxX, var16, this.boundingBox.maxZ);
 
                     if (this.worldObj.isAABBInMaterial(var18, Material.water))
                     {
-                        var27 += 1.0D / (double)var26;
+                        var26 += 1.0D / (double)var27;
                     }
                 }
 
-                if (var27 > 0.0D)
+                if (var26 > 0.0D)
                 {
                     if (this.ticksCatchable > 0)
                     {
@@ -277,14 +291,19 @@ public class EntityFishHook extends Entity
                     }
                     else
                     {
-                        short var29 = 500;
+                        // FCMOD: Changed
+                        /*
+                        short var28 = 500;
 
                         if (this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY) + 1, MathHelper.floor_double(this.posZ)))
                         {
-                            var29 = 300;
+                            var28 = 300;
                         }
 
-                        if (this.rand.nextInt(var29) == 0)
+                        if (this.rand.nextInt(var28) == 0)
+                        */
+                        if ( CheckForBite() )
+                    	// END FCMOD
                         {
                             this.ticksCatchable = this.rand.nextInt(30) + 10;
                             this.motionY -= 0.20000000298023224D;
@@ -307,6 +326,13 @@ public class EntityFishHook extends Entity
                                 var17 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
                                 this.worldObj.spawnParticle("splash", this.posX + (double)var31, (double)(var30 + 1.0F), this.posZ + (double)var17, this.motionX, this.motionY, this.motionZ);
                             }
+                            
+                            // FCMOD: Added
+                            if ( rand.nextInt( 5 ) == 0 )
+                            {
+                            	LoseBait();
+                            }
+                            // END FCMOD
                         }
                     }
                 }
@@ -316,10 +342,10 @@ public class EntityFishHook extends Entity
                     this.motionY -= (double)(this.rand.nextFloat() * this.rand.nextFloat() * this.rand.nextFloat()) * 0.2D;
                 }
 
-                var13 = var27 * 2.0D - 1.0D;
+                var13 = var26 * 2.0D - 1.0D;
                 this.motionY += 0.03999999910593033D * var13;
 
-                if (var27 > 0.0D)
+                if (var26 > 0.0D)
                 {
                     var25 = (float)((double)var25 * 0.9D);
                     this.motionY *= 0.8D;
@@ -384,6 +410,16 @@ public class EntityFishHook extends Entity
             else if (this.ticksCatchable > 0)
             {
                 EntityItem var13 = new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.fishRaw));
+            	// FCMOD: Added
+            	LoseBait();
+            	
+            	if ( this.rand.nextInt( 100 ) == 0 )
+            	{
+            		var13 = new EntityItem( worldObj, posX, posY, posZ, new ItemStack( Item.bootsLeather ) );
+            		
+            		var13.getEntityItem().setItemDamage( var13.getEntityItem().getMaxDamage() - ( 1 + this.rand.nextInt( 10 ) ) );
+            	}
+            	// END FCMOD
                 double var3 = this.angler.posX - this.posX;
                 double var5 = this.angler.posY - this.posY;
                 double var7 = this.angler.posZ - this.posZ;
@@ -394,7 +430,11 @@ public class EntityFishHook extends Entity
                 var13.motionZ = var7 * var11;
                 this.worldObj.spawnEntityInWorld(var13);
                 this.angler.addStat(StatList.fishCaughtStat, 1);
+                // FCMOD: Removed
+                /*
                 this.angler.worldObj.spawnEntityInWorld(new EntityXPOrb(this.angler.worldObj, this.angler.posX, this.angler.posY + 0.5D, this.angler.posZ + 0.5D, this.rand.nextInt(6) + 1));
+                */
+                // END FCMOD
                 var1 = 1;
             }
 
@@ -421,4 +461,123 @@ public class EntityFishHook extends Entity
             this.angler.fishEntity = null;
         }
     }
+    
+    // FCMOD: Added New
+    private boolean m_bIsBaited;
+    
+    public EntityFishHook( World world, EntityPlayer player, boolean bIsBaited )
+    {
+    	this( world, player );
+    	
+    	m_bIsBaited = bIsBaited;
+    }
+    
+	private void LoseBait()
+	{
+		if ( m_bIsBaited )
+		{
+			m_bIsBaited = false;
+			
+            ItemStack rodStack = angler.getCurrentEquippedItem();
+            
+            if ( rodStack != null && rodStack.getItem() == FCBetterThanWolves.fcItemFishingRodBaited )
+            {
+            	ItemStack unbaitedStack = rodStack.copy();
+            	unbaitedStack.stackSize = 1;
+            	unbaitedStack.itemID = Item.fishingRod.itemID;
+            	
+            	angler.inventory.setInventorySlotContents( angler.inventory.currentItem, unbaitedStack );
+            }
+		}
+	}
+	
+	private boolean IsBodyOfWaterLargeEnoughForFishing()
+	{
+        int i = MathHelper.floor_double( posX );
+        int j = MathHelper.floor_double( posY ) - 1;
+        int k = MathHelper.floor_double( posZ );
+
+        for ( int iTempI = i - 2; iTempI <= i + 2; iTempI++ )
+        {
+            for ( int iTempJ = j - 2; iTempJ <= j; iTempJ++ )
+            {
+                for ( int iTempK = k - 2; iTempK <= k + 2; iTempK++ )
+                {
+                	if ( !FCUtilsWorld.IsWaterSourceBlock( worldObj, iTempI, iTempJ, iTempK ) )
+            		{
+                		return false;
+            		}                		
+                }
+            }
+        }
+        
+		return true;
+	}
+
+    private boolean CheckForBite()
+    {
+    	if ( m_bIsBaited )
+    	{
+	        int iBiteOdds = 1500; // previously 1000
+	        
+	        int iTimeOfDay = (int)( worldObj.worldInfo.getWorldTime() % 24000L );
+	        
+	        if ( iTimeOfDay > 14000 && iTimeOfDay < 22000 )
+	        {
+	        	// at night
+	        	
+	        	int iMoonPhase = worldObj.getMoonPhase();
+	        	
+	        	if ( iMoonPhase == 0 )
+	        	{
+	        		iBiteOdds /= 10;
+	        	}
+	        	else
+	        	{
+	        		iBiteOdds *= 4;
+	        		
+	                if ( worldObj.IsPrecipitatingAtPos( MathHelper.floor_double( posX ), 
+	                	MathHelper.floor_double( posZ ) ) )
+	                {
+		            	// in the rain
+		            	
+	                	iBiteOdds /= 2;
+	                }
+	        	}
+	        }
+	        else
+	        {
+	        	if ( iTimeOfDay < 2000 || iTimeOfDay > 22000 || 
+	        		( iTimeOfDay > 10000 && iTimeOfDay < 14000 ) ) 
+	            {
+	        		// dawn or dusk
+	        		
+	        		iBiteOdds /= 2;
+	            }
+	
+                if ( worldObj.IsPrecipitatingAtPos( MathHelper.floor_double( posX ), 
+                	MathHelper.floor_double( posZ ) ) )
+	            {
+	            	// in the rain
+	            	
+	            	iBiteOdds /= 2;
+	            }
+	        }
+	
+	        if ( rand.nextInt( iBiteOdds ) == 0 )
+	        {
+	        	if ( worldObj.canBlockSeeTheSky( MathHelper.floor_double( posX ), 
+	        		MathHelper.floor_double( posY) + 1, MathHelper.floor_double( posZ) ) )
+	        	{	        		
+		        	if ( IsBodyOfWaterLargeEnoughForFishing() )
+		        	{
+		        		return true;
+		        	}
+	        	}
+	        }
+    	}
+    	
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityGhast.java b/minecraft_server/net/minecraft/src/EntityGhast.java
index 0449920..114638d 100644
--- a/minecraft_server/net/minecraft/src/EntityGhast.java
+++ b/minecraft_server/net/minecraft/src/EntityGhast.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntityGhast extends EntityFlying implements IMob
@@ -115,7 +117,7 @@ public class EntityGhast extends EntityFlying implements IMob
         if (this.targetedEntity == null || this.aggroCooldown-- <= 0)
         {
             this.targetedEntity = this.worldObj.getClosestVulnerablePlayerToEntity(this, 100.0D);
-
+            
             if (this.targetedEntity != null)
             {
                 this.aggroCooldown = 20;
@@ -200,7 +202,7 @@ public class EntityGhast extends EntityFlying implements IMob
                 return false;
             }
         }
-
+        
         return true;
     }
 
diff --git a/minecraft_server/net/minecraft/src/EntityHanging.java b/minecraft_server/net/minecraft/src/EntityHanging.java
index f544157..48bcb36 100644
--- a/minecraft_server/net/minecraft/src/EntityHanging.java
+++ b/minecraft_server/net/minecraft/src/EntityHanging.java
@@ -198,7 +198,12 @@ public abstract class EntityHanging extends Entity
 
                 var11 = (Entity)var10.next();
             }
+        	// FCMOD: Code change so that paintings and canvas can't overlap
+            /*
             while (!(var11 instanceof EntityHanging));
+            */
+            while (!(var11 instanceof EntityHanging) && !(var11 instanceof FCEntityCanvas));
+            // END FCMOD
 
             return false;
         }
@@ -348,4 +353,12 @@ public abstract class EntityHanging extends Entity
      * Drop the item currently on this item frame.
      */
     public abstract void dropItemStack();
+    
+    // FCMOD: Code added
+    @Override
+    protected boolean ShouldSetPositionOnLoad()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityItem.java b/minecraft_server/net/minecraft/src/EntityItem.java
index 442a2f7..eb70468 100644
--- a/minecraft_server/net/minecraft/src/EntityItem.java
+++ b/minecraft_server/net/minecraft/src/EntityItem.java
@@ -2,6 +2,8 @@ package net.minecraft.src;
 
 import java.util.Iterator;
 
+import net.minecraft.server.MinecraftServer;
+
 public class EntityItem extends Entity
 {
     /**
@@ -77,7 +79,19 @@ public class EntityItem extends Entity
         this.prevPosY = this.posY;
         this.prevPosZ = this.posZ;
         this.motionY -= 0.03999999910593033D;
+        // FCMOD: Added
+        UpdateHardcoreBuoy();
+        // END FCMOD
+        // FCMOD: Changed this to reverse Mojang's "fix" to items getting stuck in blocks
+        // and to reduce discrepancies between client and server by pushing only on server
+        /*
         this.noClip = this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+        */
+        if ( !worldObj.isRemote )
+        {
+        	pushOutOfBlocks( posX, ( boundingBox.minY + boundingBox.maxY) / 2D, posZ );
+        }
+        // END FCMOD
         this.moveEntity(this.motionX, this.motionY, this.motionZ);
         boolean var1 = (int)this.prevPosX != (int)this.posX || (int)this.prevPosY != (int)this.posY || (int)this.prevPosZ != (int)this.posZ;
 
@@ -121,10 +135,15 @@ public class EntityItem extends Entity
 
         ++this.age;
 
+        // FCMOD: Code change
+        /*
         if (!this.worldObj.isRemote && this.age >= 6000)
         {
             this.setDead();
         }
+        */
+        CheckForItemDespawn();
+        // END FCMOD
     }
 
     /**
@@ -238,6 +257,14 @@ public class EntityItem extends Entity
         else
         {
             this.setBeenAttacked();
+	        // FCMOD: Code added
+	        if ( !worldObj.isRemote && !isDead && getEntityItem().getItem().itemID == FCBetterThanWolves.fcItemBlastingOil.itemID )
+	        {
+	    		DetonateBlastingOil();
+	    		
+	    		return false;
+		    }
+	        // END FCMOD
             this.health -= par2;
 
             if (this.health <= 0)
@@ -261,6 +288,10 @@ public class EntityItem extends Entity
         {
             par1NBTTagCompound.setCompoundTag("Item", this.getEntityItem().writeToNBT(new NBTTagCompound()));
         }
+        
+        // FCMOD: Code added
+        par1NBTTagCompound.setLong( "fcDespawnTime", m_lAbsoluteItemDespawnTime );
+	    // END FCMOD    
     }
 
     /**
@@ -273,6 +304,13 @@ public class EntityItem extends Entity
         NBTTagCompound var2 = par1NBTTagCompound.getCompoundTag("Item");
         this.setEntityItemStack(ItemStack.loadItemStackFromNBT(var2));
 
+        // FCMOD: Code added
+	    if ( par1NBTTagCompound.hasKey( "fcDespawnTime" ) )
+	    {
+	    	m_lAbsoluteItemDespawnTime = par1NBTTagCompound.getLong( "fcDespawnTime" );
+	    }
+	    // END FCMOD
+	    
         if (this.getEntityItem() == null)
         {
             this.setDead();
@@ -379,4 +417,343 @@ public class EntityItem extends Entity
         this.getDataWatcher().updateObject(10, par1ItemStack);
         this.getDataWatcher().setObjectWatched(10);
     }
+
+    // FCMOD: Code added
+    private long m_lAbsoluteItemDespawnTime = 0;
+    
+    private void UpdateHardcoreBuoy()
+    {
+        if ( FCBetterThanWolves.IsHardcoreBuoyEnabled( worldObj ) )
+        {
+	        int numDepthChecks = 10;
+	        double d = 0.0D;
+	        double dBoundingYOffset = 0.10D;
+	
+	        for ( int j = 0; j < numDepthChecks; j++ )
+	        {
+	            double d2 = ( boundingBox.minY + ( ( boundingBox.maxY - boundingBox.minY) * (double)(j + 0) ) * ( 0.375D ) ) + dBoundingYOffset;
+	            double d8 = ( boundingBox.minY + ( ( boundingBox.maxY - boundingBox.minY) * (double)(j + 1) ) * ( 0.375D ) ) + dBoundingYOffset;
+	            
+	            AxisAlignedBB axisalignedbb = AxisAlignedBB.getAABBPool().getAABB(boundingBox.minX, d2, boundingBox.minZ, boundingBox.maxX, d8, boundingBox.maxZ);
+	
+	            if ( worldObj.isAABBInMaterial( axisalignedbb, Material.water ) )
+	            {
+	                d += 1.0D / (double)numDepthChecks;
+	            }
+	            else 
+	            {
+	            	break;
+	            }
+	        }
+	        
+	        if ( d > 0.001D )
+	        {
+	    		if ( !IsInUndertow() )
+	    		{
+		        	float fBuoyancyShifted = getEntityItem().getItem().GetBuoyancy( getEntityItem().getItemDamage() ) + 1.0F;
+		        	
+		        	// positive velocity due to boyancy
+		        	
+		        	motionY += 0.04D * fBuoyancyShifted * d;
+	    		}
+		  
+		        // drag due to being in water
+		        
+	        	motionX *= 0.90F;
+	        	motionY *= 0.90F;
+	        	motionZ *= 0.90F;	        	
+	        }	        
+        }
+    }
+
+    @Override
+    protected void doBlockCollisions()
+    {
+		//Inherited function added so that blocks like Hoppers get collision events with items on top.  
+    	// Copy of code from Entity.java, changes marked with FCMOD.
+
+        int i = MathHelper.floor_double(boundingBox.minX + 0.001D);
+        // FCMOD: code change
+        /*
+        int j = MathHelper.floor_double(boundingBox.minY + 0.001D);
+        */
+        int j = MathHelper.floor_double(boundingBox.minY - 0.01D);
+        // END FCMOD
+        int k = MathHelper.floor_double(boundingBox.minZ + 0.001D);
+        int l = MathHelper.floor_double(boundingBox.maxX - 0.001D);
+        int i1 = MathHelper.floor_double(boundingBox.maxY - 0.001D);
+        int j1 = MathHelper.floor_double(boundingBox.maxZ - 0.001D);
+
+        if (worldObj.checkChunksExist(i, j, k, l, i1, j1))
+        {
+            for (int k1 = i; k1 <= l; k1++)
+            {
+                for (int l1 = j; l1 <= i1; l1++)
+                {
+                    for (int i2 = k; i2 <= j1; i2++)
+                    {
+                        int j2 = worldObj.getBlockId(k1, l1, i2);
+
+                        if (j2 > 0)
+                        {
+                            Block.blocksList[j2].onEntityCollidedWithBlock(worldObj, k1, l1, i2, this);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean IsInUndertow()
+    {
+        int minI = MathHelper.floor_double( boundingBox.minX);
+        int maxI = MathHelper.floor_double( boundingBox.maxX + 1.0D);
+        
+        int minJ = MathHelper.floor_double( boundingBox.minY);
+        int maxJ = MathHelper.floor_double( boundingBox.maxY + 1.0D);
+        
+        int minK = MathHelper.floor_double( boundingBox.minZ);
+        int maxK = MathHelper.floor_double( boundingBox.maxZ + 1.0D );
+
+        for ( int i = minI; i < maxI; i++ )
+        {
+            for ( int j = minJ; j < maxJ; j++ )
+            {
+                for ( int k = minK; k < maxK; k++ )
+                {
+                	if ( DoesBlockHaveUndertow( i, j, k ) )
+            		{
+                		return true;
+            		}                	
+                }
+            }
+        }
+
+        return false;
+    }
+    
+    private boolean DoesBlockHaveUndertow( int i, int j, int k )
+    {
+		int iBlockID = worldObj.getBlockId( i, j, k );
+		
+		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
+		{
+			int iFluidHeight = worldObj.getBlockMetadata( i, j, k );
+			
+			if ( iFluidHeight >= 8 )
+			{
+				return true;
+			}
+	    		
+			iBlockID = worldObj.getBlockId( i, j - 1, k );
+	    		
+    		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
+    		{
+    			iFluidHeight = worldObj.getBlockMetadata( i, j - 1, k );
+    			
+    			if ( iFluidHeight >= 8 )
+    			{
+    				return true;
+    			}
+    		}	    	 
+	    		
+    		iBlockID = worldObj.getBlockId( i, j + 1, k );
+    		
+    		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
+    		{
+    			iFluidHeight = worldObj.getBlockMetadata( i, j + 1, k );
+    			
+    			if ( iFluidHeight >= 8 )
+    			{
+    				return true;
+    			}
+    		}	    	 
+		}
+		
+		return false;
+    }    
+    
+    @Override
+    protected void fall( float fFallDistance )
+    {
+        super.fall( fFallDistance );
+
+        if ( !worldObj.isRemote )
+        {
+	        if ( getEntityItem().getItem().itemID == FCBetterThanWolves.fcItemBlastingOil.itemID )
+	        {
+	        	if ( fFallDistance > 3F )
+	        	{
+	        		DetonateBlastingOil();
+	        	}
+		    }
+        }
+    }
+    
+    private void DetonateBlastingOil()
+    {
+		int iStackSize = getEntityItem().stackSize;
+		
+    	health = 0;
+		setDead();
+		
+		if ( iStackSize > 0 )
+		{
+			// cap the explosion size at that of TNT to avoid overly weaponzing Blasting Oil
+			
+	        float fExplosionSize = 1.5F + ( ( iStackSize - 1 ) * 2.5F / 63.0F );
+
+	        worldObj.createExplosion( null, posX, posY, posZ, fExplosionSize, true );
+		}
+    }
+
+    @Override
+    protected boolean pushOutOfBlocks(double par1, double par3, double par5)
+    {
+    	// Inherited function added to revert Mojang's changes 
+
+        int var7 = MathHelper.floor_double(par1);
+        int var8 = MathHelper.floor_double(par3);
+        int var9 = MathHelper.floor_double(par5);
+        double var10 = par1 - (double)var7;
+        double var12 = par3 - (double)var8;
+        double var14 = par5 - (double)var9;
+
+        if (this.worldObj.isBlockNormalCube(var7, var8, var9))
+        {
+            boolean var16 = !this.worldObj.isBlockNormalCube(var7 - 1, var8, var9);
+            boolean var17 = !this.worldObj.isBlockNormalCube(var7 + 1, var8, var9);
+            boolean var18 = !this.worldObj.isBlockNormalCube(var7, var8 - 1, var9);
+            boolean var19 = !this.worldObj.isBlockNormalCube(var7, var8 + 1, var9);
+            boolean var20 = !this.worldObj.isBlockNormalCube(var7, var8, var9 - 1);
+            boolean var21 = !this.worldObj.isBlockNormalCube(var7, var8, var9 + 1);
+            byte var22 = -1;
+            double var23 = 9999.0D;
+
+            if (var16 && var10 < var23)
+            {
+                var23 = var10;
+                var22 = 0;
+            }
+
+            if (var17 && 1.0D - var10 < var23)
+            {
+                var23 = 1.0D - var10;
+                var22 = 1;
+            }
+
+            if (var18 && var12 < var23)
+            {
+                var23 = var12;
+                var22 = 2;
+            }
+
+            if (var19 && 1.0D - var12 < var23)
+            {
+                var23 = 1.0D - var12;
+                var22 = 3;
+            }
+
+            if (var20 && var14 < var23)
+            {
+                var23 = var14;
+                var22 = 4;
+            }
+
+            if (var21 && 1.0D - var14 < var23)
+            {
+                var23 = 1.0D - var14;
+                var22 = 5;
+            }
+
+            float var25 = this.rand.nextFloat() * 0.2F + 0.1F;
+
+            if (var22 == 0)
+            {
+                this.motionX = (double)(-var25);
+            }
+
+            if (var22 == 1)
+            {
+                this.motionX = (double)var25;
+            }
+
+            if (var22 == 2)
+            {
+                this.motionY = (double)(-var25);
+            }
+
+            if (var22 == 3)
+            {
+                this.motionY = (double)var25;
+            }
+
+            if (var22 == 4)
+            {
+                this.motionZ = (double)(-var25);
+            }
+
+            if (var22 == 5)
+            {
+                this.motionZ = (double)var25;
+            }
+
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+    
+    @Override
+    public boolean IsItemEntity()
+    {
+    	return true;
+    }
+    
+    @Override
+    public boolean CanEntityTriggerTripwire()
+    {
+    	return false;
+    }
+    
+    private void CheckForItemDespawn()
+    {
+        if ( !worldObj.isRemote )
+        {
+	        if ( m_lAbsoluteItemDespawnTime > 0 )
+	        {
+	        	// using getTotalWorldTime() here so that /time commands and time advancement due to HC Spawn don't affect it
+	        	
+				long lOverworldTime = MinecraftServer.getServer().worldServers[0].getTotalWorldTime();
+				
+				if ( lOverworldTime >= m_lAbsoluteItemDespawnTime  )
+				{
+					setDead();
+				}				
+	        }
+	        else
+	        {
+		        if ( age >= 6000 )
+		        {
+		            setDead();
+		        }
+	        }
+        }
+    }
+    
+    public void SetEntityItemAsDroppedOnPlayerDeath( EntityPlayer player )
+    {
+    	// set items dropped on player death to despawn 1 Minecraft day (20 minutes) later
+    	// using getTotalWorldTime() here so that /time commands and time advancement due to HC Spawn don't affect it
+    	
+    	m_lAbsoluteItemDespawnTime = MinecraftServer.getServer().worldServers[0].getTotalWorldTime() + 24000L;
+    }    
+    
+    static public boolean InstallationIntegrityTestEntityItem()
+    {
+    	return true;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/EntityLightningBolt.java b/minecraft_server/net/minecraft/src/EntityLightningBolt.java
index c31da5c..ba820ad 100644
--- a/minecraft_server/net/minecraft/src/EntityLightningBolt.java
+++ b/minecraft_server/net/minecraft/src/EntityLightningBolt.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 11/20/2018
+
 package net.minecraft.src;
 
 import java.util.List;
diff --git a/minecraft_server/net/minecraft/src/EntityList.java b/minecraft_server/net/minecraft/src/EntityList.java
index f7aaa38..3a7eace 100644
--- a/minecraft_server/net/minecraft/src/EntityList.java
+++ b/minecraft_server/net/minecraft/src/EntityList.java
@@ -1,7 +1,10 @@
 package net.minecraft.src;
 
+import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 
 public class EntityList
@@ -27,7 +30,12 @@ public class EntityList
     /**
      * adds a mapping between Entity classes and both a string representation and an ID
      */
+    // FCMOD: Code change
+    /*
     private static void addMapping(Class par0Class, String par1Str, int par2)
+    */
+    public static void addMapping(Class par0Class, String par1Str, int par2)
+    // END FCMOD
     {
         stringToClassMapping.put(par1Str, par0Class);
         classToStringMapping.put(par0Class, par1Str);
@@ -39,7 +47,7 @@ public class EntityList
     /**
      * Adds a entity mapping with egg info.
      */
-    private static void addMapping(Class par0Class, String par1Str, int par2, int par3, int par4)
+    public static void addMapping(Class par0Class, String par1Str, int par2, int par3, int par4)
     {
         addMapping(par0Class, par1Str, par2);
         entityEggs.put(Integer.valueOf(par2), new EntityEggInfo(par2, par3, par4));
@@ -58,7 +66,12 @@ public class EntityList
 
             if (var3 != null)
             {
-                var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	if (FCEntityVillager.class.equals(var3)) {
+            		var2 = FCEntityVillager.createVillager(par1World);
+            	}
+            	else {
+            		var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	}
             }
         }
         catch (Exception var4)
@@ -101,7 +114,14 @@ public class EntityList
 
             if (var3 != null)
             {
-                var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	if (FCEntityVillager.class.equals(var3)) {
+            		int profession = par0NBTTagCompound.getInteger("Profession");
+
+            		var2 = FCEntityVillager.createVillagerFromProfession(par1World, profession);
+            	}
+            	else {
+            		var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	}
             }
         }
         catch (Exception var4)
@@ -115,6 +135,9 @@ public class EntityList
         }
         else
         {
+        	//Client
+            //par1World.getWorldLogAgent().logWarning("Skipping Entity with id " + par0NBTTagCompound.getString("id"));
+            //Server
             par1World.getWorldLogAgent().func_98236_b("Skipping Entity with id " + par0NBTTagCompound.getString("id"));
         }
 
@@ -134,7 +157,12 @@ public class EntityList
 
             if (var3 != null)
             {
-                var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	if (FCEntityVillager.class.equals(var3)) {
+            		var2 = FCEntityVillager.createVillager(par1World);
+            	}
+            	else {
+            		var2 = (Entity)var3.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par1World});
+            	}
             }
         }
         catch (Exception var4)
@@ -144,6 +172,9 @@ public class EntityList
 
         if (var2 == null)
         {
+        	//Client
+            //par1World.getWorldLogAgent().logWarning("Skipping Entity with id " + par0);
+            //Server
             par1World.getWorldLogAgent().func_98236_b("Skipping Entity with id " + par0);
         }
 
@@ -241,4 +272,205 @@ public class EntityList
         addMapping(EntityVillager.class, "Villager", 120, 5651507, 12422002);
         addMapping(EntityEnderCrystal.class, "EnderCrystal", 200);
     }
-}
+
+    public static void AddMapping( Class entityClass, String sName, int iID )
+    {
+    	addMapping( entityClass, sName, iID );
+    }
+
+    public static boolean RemoveMapping( String sName, boolean bRemoveEgg )
+    {
+    	Integer iID = (Integer)stringToIDMapping.get( sName );
+
+    	if ( iID != null )
+    	{
+	    	Class mappedClass = (Class)IDtoClassMapping.get( Integer.valueOf( iID ) );
+
+	    	if ( mappedClass != null )
+	    	{
+	    		stringToClassMapping.remove( sName );
+	    		classToStringMapping.remove( mappedClass );
+	    		IDtoClassMapping.remove( iID );
+	    		classToIDMapping.remove( mappedClass );
+	    		stringToIDMapping.remove( sName );
+
+	    		if ( bRemoveEgg )
+	    		{
+		    		// may or may not have an egg, but this is a safe operation
+
+	    			entityEggs.remove( iID );
+	    		}
+
+	    		return true;
+	    	}
+    	}
+
+    	return false;
+    }
+
+    public static boolean ReplaceExistingMapping( Class newClass, String sName )
+    {    	
+    	Integer iID = (Integer)stringToIDMapping.get( sName );
+
+    	if ( iID != null )
+    	{
+    		if ( RemoveMapping( sName, false ) ) // egg mapping intentionally left in place
+    		{    		
+    			addMapping( newClass, sName, iID );
+    		}
+    	}
+
+    	return false;
+    }
+
+    /**
+     * Replaces entity mapping but leaves the mapping from class to id so the game won't crash if it tries to spawn something of a class which has been replaced
+     * Does not handle spawnable mobs
+     * @param newClass The new class to be added to the mapping
+     * @param entityName The internal name of the entity
+     * @return
+     */
+    public static boolean replaceExistingMappingSafe(Class newClass, String entityName) {
+        int id = (Integer) stringToIDMapping.get(entityName);
+
+        if (removeMappingSafe(entityName, false)) {
+            addMapping(newClass, entityName, id);
+        }
+
+        return false;
+    }
+    
+    /**
+     * Same behavior as replaceExistingMappingSafe except with a wrapper to handle replacing mob spawn lists
+     * @param newEntity
+     * @param entityName
+     * @return
+     */
+    public static boolean replaceSpawnableMappingSafe(Class newEntity, String entityName) {
+    	Class oldEntity = (Class) stringToClassMapping.get(entityName);
+    	
+    	//Super janky implementation
+    	//Code ripped from old version of deco
+    	//Reflection should not be necessary here, but for now I am using code that works, it can be cleaned up later
+    	
+    	//TODO: Clean up
+    	try {
+			for (BiomeGenBase b : BiomeGenBase.biomeList) {
+				if (b == null)
+					continue;
+
+				Field creatureList;
+				Field monsterList;
+				Field waterCreatureList;
+				Field caveCreatureList;
+
+				if (FCUtilsReflection.isObfuscated()) {
+					if (b.getClass().getSuperclass().equals(BiomeGenBase.class)) {
+						creatureList = b.getClass().getSuperclass().getDeclaredField("K");
+						monsterList = b.getClass().getSuperclass().getDeclaredField("J");
+						waterCreatureList = b.getClass().getSuperclass().getDeclaredField("L");
+						caveCreatureList = b.getClass().getSuperclass().getDeclaredField("M");
+					}
+					else {
+						creatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("K");
+						monsterList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("J");
+						waterCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("L");
+						caveCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("M");
+					}
+				}
+				else {
+					if (b.getClass().getSuperclass().equals(BiomeGenBase.class)) {
+						creatureList = b.getClass().getSuperclass().getDeclaredField("spawnableCreatureList");
+						monsterList = b.getClass().getSuperclass().getDeclaredField("spawnableMonsterList");
+						waterCreatureList = b.getClass().getSuperclass().getDeclaredField("spawnableWaterCreatureList");
+						caveCreatureList = b.getClass().getSuperclass().getDeclaredField("spawnableCaveCreatureList");
+					}
+					else {
+						creatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableCreatureList");
+						monsterList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableMonsterList");
+						waterCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableWaterCreatureList");
+						caveCreatureList = b.getClass().getSuperclass().getSuperclass().getDeclaredField("spawnableCaveCreatureList");
+					}
+				}
+
+				creatureList.setAccessible(true);
+				monsterList.setAccessible(true);
+				waterCreatureList.setAccessible(true);
+				caveCreatureList.setAccessible(true);
+
+				ArrayList<SpawnListEntry> creature = (ArrayList<SpawnListEntry>)creatureList.get(b);
+				ArrayList<SpawnListEntry> monster = (ArrayList<SpawnListEntry>)monsterList.get(b);
+				ArrayList<SpawnListEntry> water = (ArrayList<SpawnListEntry>)waterCreatureList.get(b);
+				ArrayList<SpawnListEntry> cave = (ArrayList<SpawnListEntry>)caveCreatureList.get(b);
+
+				for (SpawnListEntry s : creature) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : monster) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : water) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				for (SpawnListEntry s : cave) {
+					if (s.entityClass == oldEntity) {
+						s.entityClass = newEntity;
+					}
+				}
+
+				return replaceExistingMappingSafe(newEntity, entityName);
+			}
+		} catch (NoSuchFieldException e) {
+			if (FCUtilsReflection.isObfuscated()) {
+				e.printStackTrace();
+			}
+			else {
+				FCUtilsReflection.setObfuscated(true);
+				replaceSpawnableMappingSafe(newEntity, entityName);
+			}
+			e.printStackTrace();
+		} catch (SecurityException e) {
+			e.printStackTrace();
+		} catch (IllegalArgumentException e) {
+			e.printStackTrace();
+		} catch (IllegalAccessException e) {
+			e.printStackTrace();
+		}
+    	
+    	return false;
+    }
+
+    public static boolean removeMappingSafe(String var0, boolean var1)
+    {
+        Integer var2 = (Integer)stringToIDMapping.get(var0);
+
+        if (var2 != null)
+        {
+            Class var3 = (Class)IDtoClassMapping.get(Integer.valueOf(var2.intValue()));
+
+            if (var3 != null)
+            {
+                stringToClassMapping.remove(var0);
+                IDtoClassMapping.remove(var2);
+
+                if (var1)
+                {
+                    entityEggs.remove(var2);
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/EntityLiving.java b/minecraft_server/net/minecraft/src/EntityLiving.java
index a8c31d0..eaa2122 100644
--- a/minecraft_server/net/minecraft/src/EntityLiving.java
+++ b/minecraft_server/net/minecraft/src/EntityLiving.java
@@ -12,16 +12,36 @@ public abstract class EntityLiving extends Entity
      * An array of probabilities that determines whether a random enchantment should be added to the held item. Indexed
      * by difficulty.
      */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+	/*
     private static final float[] enchantmentProbability = new float[] {0.0F, 0.0F, 0.1F, 0.2F};
+    */
+    private static final float[] enchantmentProbability = new float[] {0.05F, 0.05F, 0.05F, 0.05F};
+    // END FCMOD
 
     /** Probability to get enchanted armor */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+	/*
     private static final float[] armorEnchantmentProbability = new float[] {0.0F, 0.0F, 0.25F, 0.5F};
+    */
+    private static final float[] armorEnchantmentProbability = new float[] {0.05F, 0.05F, 0.05F, 0.05F};
+    // END FCMOD
 
     /** Probability to get armor */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+    /*
     private static final float[] armorProbability = new float[] {0.0F, 0.0F, 0.05F, 0.07F};
+    */
+    private static final float[] armorProbability = new float[] {0.0025F, 0.0025F, 0.0025F, 0.0025F};
+    // END FCMOD
 
     /** Probability to pick up loot */
+	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
+    /*
     public static final float[] pickUpLootProability = new float[] {0.0F, 0.1F, 0.15F, 0.45F};
+    */
+    public static final float[] pickUpLootProability = new float[] {0.15F, 0.15F, 0.15F, 0.15F};
+    // END FCMOD
     public int maxHurtResistantTime = 20;
     public float field_70769_ao;
     public float field_70770_ap;
@@ -97,10 +117,15 @@ public abstract class EntityLiving extends Entity
     public float prevCameraPitch;
     public float cameraPitch;
 
+    // FCMOD: Changed for clarity with Entity.isDead.
+    /*
+    protected boolean dead = false;
+    */
     /**
-     * This gets set on entity death, but never used. Looks like a duplicate of isDead
+     * Tells if a creature has shed its mortal coil.  Entity.isDead is whether an entity is flagged to be removed from the game
      */
-    protected boolean dead = false;
+    protected boolean isLivingDead = false;
+    // END FCMOD
 
     /** The experience points the Entity gives. */
     protected int experienceValue;
@@ -125,8 +150,14 @@ public abstract class EntityLiving extends Entity
     protected int recentlyHit = 0;
 
     /** is only being set, has no uses as of MC 1.1 */
+    // FCMOD: Changed to public
+    /*
     private EntityLiving entityLivingToAttack = null;
     private int revengeTimer = 0;
+    */
+    public EntityLiving entityLivingToAttack = null;
+    public int revengeTimer = 0;
+    // END FCMOD
     private EntityLiving lastAttackingEntity = null;
     public int arrowHitTimer = 0;
     protected HashMap activePotionsMap = new HashMap();
@@ -241,6 +272,10 @@ public abstract class EntityLiving extends Entity
         }
 
         this.stepHeight = 0.5F;
+        
+        // FCMOD: Code added to prevent all living sounds playing very rapidly as entities are loaded (was particularly noticeable with ghasts)
+        livingSoundTime = -getTalkInterval();
+        // END FCMOD
     }
 
     protected int func_96121_ay()
@@ -328,8 +363,11 @@ public abstract class EntityLiving extends Entity
 
     public boolean attackEntityAsMob(Entity par1Entity)
     {
-        this.setLastAttackingEntity(par1Entity);
-        return false;
+        // FCMOD: Changed
+        //this.setLastAttackingEntity(par1Entity);
+        //return false;
+        return MeleeAttack( par1Entity );
+        // END FCMOD
     }
 
     /**
@@ -344,6 +382,13 @@ public abstract class EntityLiving extends Entity
      * Sets the active target the Task system uses for tracking
      */
     public void setAttackTarget(EntityLiving par1EntityLiving)
+    // FCMOD: Added to allow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingSetAttackTarget(par1EntityLiving);
+    }
+    
+    protected void EntityLivingSetAttackTarget(EntityLiving par1EntityLiving)
+    // END FCMOD
     {
         this.attackTarget = par1EntityLiving;
     }
@@ -353,7 +398,12 @@ public abstract class EntityLiving extends Entity
      */
     public boolean canAttackClass(Class par1Class)
     {
+    	// FCMOD: Changed
+    	/*
         return EntityCreeper.class != par1Class && EntityGhast.class != par1Class;
+        */
+        return FCEntityCreeper.class != par1Class && FCEntityGhast.class != par1Class;
+        // END FCMOD
     }
 
     /**
@@ -456,10 +506,14 @@ public abstract class EntityLiving extends Entity
     /**
      * returns true if the entity provided in the argument can be seen. (Raytrace)
      */
+	// FCMOD: Code removed and replaced later so that entities can be seen through blocks that don't stop movement
+	/*
     public boolean canEntityBeSeen(Entity par1Entity)
     {
         return this.worldObj.rayTraceBlocks(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ), this.worldObj.getWorldVec3Pool().getVecFromPool(par1Entity.posX, par1Entity.posY + (double)par1Entity.getEyeHeight(), par1Entity.posZ)) == null;
     }
+    */
+    // END FCMOD
 
     /**
      * Returns true if other Entities should be prevented from moving through this Entity.
@@ -553,7 +607,12 @@ public abstract class EntityLiving extends Entity
         }
         else
         {
+        	// FCMOD: Code change for players to recover air gradually
+        	/*
             this.setAir(300);
+            */
+        	RecoverAirSupply();
+        	// END FCMOD
         }
 
         this.prevCameraPitch = this.cameraPitch;
@@ -608,6 +667,13 @@ public abstract class EntityLiving extends Entity
             }
         }
 
+        // FCMOD: Added to prevent problems with the AI sometimes going into limbo due to dead targets 
+        if ( attackTarget != null && !attackTarget.isEntityAlive() )
+        {
+    		setAttackTarget( null );
+        }
+        // END FCMOD
+
         this.updatePotionEffects();
         this.field_70763_ax = this.field_70764_aw;
         this.prevRenderYawOffset = this.renderYawOffset;
@@ -639,6 +705,17 @@ public abstract class EntityLiving extends Entity
                     this.worldObj.spawnEntityInWorld(new EntityXPOrb(this.worldObj, this.posX, this.posY, this.posZ, var2));
                 }
             }
+            // FCMOD: Code added to spawn Dragon Orbs when the creature is not killed by a player
+            else if (!worldObj.isRemote && !isChild())
+	        {
+            	int iExperienceDropped = getExperiencePoints(attackingPlayer);
+
+            	if ( iExperienceDropped > 0 )
+            	{
+            		worldObj.spawnEntityInWorld(new EntityXPOrb(worldObj, posX, posY, posZ, getExperiencePoints(attackingPlayer), true ) );
+            	}
+	        }
+	        // END FCMOD
 
             this.setDead();
 
@@ -933,6 +1010,12 @@ public abstract class EntityLiving extends Entity
             }
             else
             {
+            	// FCMOD: Code added
+            	if ( par1DamageSource == FCDamageSourceCustom.m_DamageSourceChoppingBlock )
+        		{
+            		m_iRecentlyOnChoppingBlockCountdown = m_iOnChoppingBlockMaxCountdown;
+            	}
+            	// END FCMOD
                 if ((par1DamageSource == DamageSource.anvil || par1DamageSource == DamageSource.fallingBlock) && this.getEquipmentInSlot(4) != null)
                 {
                     this.getEquipmentInSlot(4).damageItem(par2 * 4 + this.rand.nextInt(par2 * 2), this);
@@ -1009,6 +1092,9 @@ public abstract class EntityLiving extends Entity
                         }
 
                         this.attackedAtYaw = (float)(Math.atan2(var7, var9) * 180.0D / Math.PI) - this.rotationYaw;
+                        // FCMOD: Added to limit knockback with crappy weapons
+                        if ( par2 > 1 || var4.isSprinting() )
+                    	// END FCMOD
                         this.knockBack(var4, par2, var9, var7);
                     }
                     else
@@ -1184,7 +1270,10 @@ public abstract class EntityLiving extends Entity
     {
         this.isAirBorne = true;
         float var7 = MathHelper.sqrt_double(par3 * par3 + par5 * par5);
-        float var8 = 0.4F;
+        // FCMOD: Changed
+        //float var8 = 0.4F;
+        float var8 = KnockbackMagnitude();
+        // END FCMOD
         this.motionX /= 2.0D;
         this.motionY /= 2.0D;
         this.motionZ /= 2.0D;
@@ -1201,6 +1290,8 @@ public abstract class EntityLiving extends Entity
     /**
      * Called when the mob's health reaches 0.
      */
+    // FCMOD: Function removed and replaced by custom one below
+    /*
     public void onDeath(DamageSource par1DamageSource)
     {
         Entity var2 = par1DamageSource.getEntity();
@@ -1246,6 +1337,8 @@ public abstract class EntityLiving extends Entity
 
         this.worldObj.setEntityState(this, (byte)3);
     }
+    */
+    // END FCMOD
 
     protected void dropRareDrop(int par1) {}
 
@@ -1253,6 +1346,13 @@ public abstract class EntityLiving extends Entity
      * Drop 0-2 items of this living's type
      */
     protected void dropFewItems(boolean par1, int par2)
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingDropFewItems( par1, par2 );
+    }
+    
+    protected void EntityLivingDropFewItems(boolean par1, int par2)
+    // END FCMOD
     {
         int var3 = this.getDropItemId();
 
@@ -1284,6 +1384,13 @@ public abstract class EntityLiving extends Entity
      * Called when the mob is falling. Calculates and applies fall damage.
      */
     protected void fall(float par1)
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingFall(par1);
+    }
+    
+    protected void EntityLivingFall(float par1)
+    // END FCMOD
     {
         super.fall(par1);
         int var2 = MathHelper.ceiling_float_int(par1 - 3.0F);
@@ -1327,6 +1434,12 @@ public abstract class EntityLiving extends Entity
             this.motionZ *= 0.800000011920929D;
             this.motionY -= 0.02D;
 
+            // FCMOD: Code added to apply move penalties in water
+            float fModifier = GetSwimmingHorizontalModifier();
+            motionX *= fModifier;
+            motionZ *= fModifier;
+            // END FCMOD
+
             if (this.isCollidedHorizontally && this.isOffsetPositionInLiquid(this.motionX, this.motionY + 0.6000000238418579D - this.posY + var9, this.motionZ))
             {
                 this.motionY = 0.30000001192092896D;
@@ -1353,12 +1466,25 @@ public abstract class EntityLiving extends Entity
 
             if (this.onGround)
             {
+            	// FCMOD: Changed
+            	/*
                 var3 = 0.54600006F;
                 int var4 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
+                */
+            	var3 = GetDefaultSlipperinessOnGround();
+                int var4 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), 
+                	MathHelper.floor_double(this.boundingBox.minY - 0.25F), // reduced from full block offset above to not slip on partial blocks like slabs 
+                	MathHelper.floor_double(this.posZ));
+            	// END FCMOD
 
                 if (var4 > 0)
                 {
+                	// FCMOD: Changed
+                	/*
                     var3 = Block.blocksList[var4].slipperiness * 0.91F;
+                    */
+                	var3 = GetSlipperinessRelativeToBlock( var4 ) * 0.91F;
+                	// END FCMOD
                 }
             }
 
@@ -1388,12 +1514,25 @@ public abstract class EntityLiving extends Entity
 
             if (this.onGround)
             {
+            	// FCMOD: Changed
+            	/*
                 var3 = 0.54600006F;
                 int var6 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
+                */
+            	var3 = GetDefaultSlipperinessOnGround();
+                int var6 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), 
+                	MathHelper.floor_double(this.boundingBox.minY - 0.25F), // reduced from full block offset above to not slip on partial blocks like slabs 
+                	MathHelper.floor_double(this.posZ));
+            	// END FCMOD
 
                 if (var6 > 0)
                 {
+                	// FCMOD: Changed
+                	/*
                     var3 = Block.blocksList[var6].slipperiness * 0.91F;
+                    */
+                	var3 = GetSlipperinessRelativeToBlock( var6 );
+                	// END FCMOD
                 }
             }
 
@@ -1434,6 +1573,10 @@ public abstract class EntityLiving extends Entity
                 {
                     this.motionY = 0.0D;
                 }
+                // FCMOD: Code added to apply move penalties on ladders                
+                float fModifier = GetLadderVerticalMovementModifier();
+                motionY *= fModifier;
+                // END FCMOD
             }
 
             this.moveEntity(this.motionX, this.motionY, this.motionZ);
@@ -1466,21 +1609,23 @@ public abstract class EntityLiving extends Entity
 
         this.prevLimbYaw = this.limbYaw;
         var9 = this.posX - this.prevPosX;
-        double var11 = this.posZ - this.prevPosZ;
-        float var12 = MathHelper.sqrt_double(var9 * var9 + var11 * var11) * 4.0F;
+        double var12 = this.posZ - this.prevPosZ;
+        float var11 = MathHelper.sqrt_double(var9 * var9 + var12 * var12) * 4.0F;
 
-        if (var12 > 1.0F)
+        if (var11 > 1.0F)
         {
-            var12 = 1.0F;
+            var11 = 1.0F;
         }
 
-        this.limbYaw += (var12 - this.limbYaw) * 0.4F;
+        this.limbYaw += (var11 - this.limbYaw) * 0.4F;
         this.limbSwing += this.limbYaw;
     }
 
     /**
      * returns true if this entity is by a ladder, false otherwise
      */
+    // FCMOD: Removed and replaced later
+    /*
     public boolean isOnLadder()
     {
         int var1 = MathHelper.floor_double(this.posX);
@@ -1489,6 +1634,8 @@ public abstract class EntityLiving extends Entity
         int var4 = this.worldObj.getBlockId(var1, var2, var3);
         return var4 == Block.ladder.blockID || var4 == Block.vine.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to write subclass entity data to NBT.
@@ -1637,6 +1784,13 @@ public abstract class EntityLiving extends Entity
      * use this to react to sunlight and start to burn.
      */
     public void onLivingUpdate()
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingOnLivingUpdate();
+    }
+    
+    protected void EntityLivingOnLivingUpdate()
+    // END FCMOD
     {
         if (this.jumpTicks > 0)
         {
@@ -1708,9 +1862,19 @@ public abstract class EntityLiving extends Entity
 
         if (this.isJumping)
         {
+        	// FCMOD: Line change
+        	/*
             if (!this.isInWater() && !this.handleLavaMovement())
+            */
+            if ( ( !this.isInWater() && !this.handleLavaMovement() ) || !CanSwim() )
+        	// END FCMOD
             {
+            	// FCMOD: Changed
+            	/*
                 if (this.onGround && this.jumpTicks == 0)
+                */
+                if ( CanJump() && ( onGround || CanJumpMidWater() ) && this.jumpTicks == 0)
+        		// END FCMOD            		
                 {
                     this.jump();
                     this.jumpTicks = 10;
@@ -1746,7 +1910,12 @@ public abstract class EntityLiving extends Entity
         this.worldObj.theProfiler.endSection();
         this.worldObj.theProfiler.startSection("looting");
 
+        // FCMOD: Changed for "isLivingDead"
+        /*
         if (!this.worldObj.isRemote && this.canPickUpLoot() && !this.dead && this.worldObj.getGameRules().getGameRuleBooleanValue("mobGriefing"))
+        */
+        if (!this.worldObj.isRemote && this.canPickUpLoot() && !isLivingDead && this.worldObj.getGameRules().getGameRuleBooleanValue("mobGriefing"))
+        // END FCMOD
         {
             List var2 = this.worldObj.getEntitiesWithinAABB(EntityItem.class, this.boundingBox.expand(1.0D, 0.0D, 1.0D));
             Iterator var12 = var2.iterator();
@@ -1835,6 +2004,9 @@ public abstract class EntityLiving extends Entity
         }
 
         this.worldObj.theProfiler.endSection();
+        // FCMOD: Added
+        ModSpecificOnLivingUpdate();
+        // END FCMOD
     }
 
     protected void func_85033_bc()
@@ -1870,6 +2042,7 @@ public abstract class EntityLiving extends Entity
 
     /**
      * Returns whether the entity is in a local (client) world
+     * FCNOTE: This is horribly named.  For everything other than EntityPlayerSP, this returns true if !world.isRemote
      */
     protected boolean isClientWorld()
     {
@@ -1901,7 +2074,12 @@ public abstract class EntityLiving extends Entity
             this.motionY += (double)((float)(this.getActivePotionEffect(Potion.jump).getAmplifier() + 1) * 0.1F);
         }
 
+        // FCMOD: Changed to avoid jump exploit in shallow water while weighted
+		/*
         if (this.isSprinting())
+		*/
+        if (isSprinting() && !isInWater())
+    	// END FCMOD
         {
             float var1 = this.rotationYaw * 0.017453292F;
             this.motionX -= (double)(MathHelper.sin(var1) * 0.2F);
@@ -1922,6 +2100,8 @@ public abstract class EntityLiving extends Entity
     /**
      * Makes the entity despawn if requirements are reached
      */
+    // FCMOD: Removed and replaced
+    /*
     protected void despawnEntity()
     {
         if (!this.persistenceRequired)
@@ -1951,8 +2131,17 @@ public abstract class EntityLiving extends Entity
             }
         }
     }
+    */
+    // END FCMOD
 
     protected void updateAITasks()
+    // FCMOD: Added to allow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingUpdateAITasks();
+    }
+    
+    protected void EntityLivingUpdateAITasks()
+    // END FCMOD
     {
         ++this.entityAge;
         this.worldObj.theProfiler.startSection("checkDespawn");
@@ -2258,6 +2447,12 @@ public abstract class EntityLiving extends Entity
 
         if (var12 > 0)
         {
+            // FCMOD: Code added to not display potion particles if all effects come from beacons        
+            if ( HasOnlyAmbientPotionEffects( activePotionsMap.values() ) )
+            {
+            	return;
+            }
+            // END FCMOD
             boolean var4 = false;
 
             if (!this.isInvisible())
@@ -2346,6 +2541,8 @@ public abstract class EntityLiving extends Entity
 
     public boolean isPotionApplicable(PotionEffect par1PotionEffect)
     {
+    	// FCMOD: Code removed to get rid of undead special casing on potion use
+    	/*
         if (this.getCreatureAttribute() == EnumCreatureAttribute.UNDEAD)
         {
             int var2 = par1PotionEffect.getPotionID();
@@ -2355,6 +2552,8 @@ public abstract class EntityLiving extends Entity
                 return false;
             }
         }
+        */
+    	// END FCMOD
 
         return true;
     }
@@ -2399,6 +2598,8 @@ public abstract class EntityLiving extends Entity
      * This method returns a value to be applied directly to entity speed, this factor is less than 1 when a slowdown
      * potion effect is applied, more than 1 when a haste potion effect is applied and 2 for fleeing entities.
      */
+    // FCMOD: Function removed and replaced later
+    /*
     public float getSpeedModifier()
     {
         float var1 = 1.0F;
@@ -2420,6 +2621,8 @@ public abstract class EntityLiving extends Entity
 
         return var1;
     }
+    */
+    // END FCMOD
 
     /**
      * Sets the position of the entity and updates the 'last' variables
@@ -2473,6 +2676,8 @@ public abstract class EntityLiving extends Entity
         }
         else
         {
+        	// FCTODO: As far as I can tell, the following code can never be anything other than zero unless health is greater than max health (which shouldn't happen), 
+        	// and thus has no effect.  Figure out what's going on here and if difficulty actually impacts anything.
             int var1 = (int)((float)this.health - (float)this.getMaxHealth() * 0.33F);
             var1 -= (3 - this.worldObj.difficultySetting) * 4;
 
@@ -2537,6 +2742,9 @@ public abstract class EntityLiving extends Entity
                 if (!var5 && var4.isItemStackDamageable())
                 {
                     int var6 = Math.max(var4.getMaxDamage() - 25, 1);
+                    // FCMOD: Code added to provide a better range on damage
+                    var6 = Math.max( (int)((float)var4.getMaxDamage() * 0.95F), 1);
+                    // END FCMOD
                     int var7 = var4.getMaxDamage() - this.rand.nextInt(this.rand.nextInt(var6) + 1);
 
                     if (var7 > var6)
@@ -2561,12 +2769,23 @@ public abstract class EntityLiving extends Entity
      * Makes entity wear random armor based on difficulty
      */
     protected void addRandomArmor()
+    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
+    {
+    	EntityLivingAddRandomArmor();
+    }
+    
+    protected void EntityLivingAddRandomArmor()
+    // END FCMOD
     {
         if (this.rand.nextFloat() < armorProbability[this.worldObj.difficultySetting])
         {
             int var1 = this.rand.nextInt(2);
             float var2 = this.worldObj.difficultySetting == 3 ? 0.1F : 0.25F;
 
+            // FCMOD: Code added to make armor drop rate equal on all difficulty levels
+            var2 = 0.1F;
+            // END FCMOD
+
             if (this.rand.nextFloat() < 0.095F)
             {
                 ++var1;
@@ -2598,6 +2817,10 @@ public abstract class EntityLiving extends Entity
                     if (var5 != null)
                     {
                         this.setCurrentItemOrArmor(var3 + 1, new ItemStack(var5));
+                        
+                        // FCMOD: Code added to increase armor drop on mobs
+                        equipmentDropChances[var3 + 1] = 0.75F;
+                        // END FCMOD
                     }
                 }
             }
@@ -2663,6 +2886,8 @@ public abstract class EntityLiving extends Entity
     /**
      * Params: Armor slot, Item tier
      */
+    // FCMOD: Function removed and replaced by custom one below
+    /*
     public static Item getArmorItemForSlot(int par0, int par1)
     {
         switch (par0)
@@ -2759,12 +2984,19 @@ public abstract class EntityLiving extends Entity
                 return null;
         }
     }
+    */
+    // END FCMOD
 
     protected void func_82162_bC()
     {
         if (this.getHeldItem() != null && this.rand.nextFloat() < enchantmentProbability[this.worldObj.difficultySetting])
         {
+        	// FCMOD: Code change to make enchant strength on mob drops uniform accross difficulty levels
+        	/*
             EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItem(), 5 + this.worldObj.difficultySetting * this.rand.nextInt(6));
+            */
+            EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItem(), 7 * this.rand.nextInt(6));
+        	// END FCMOD
         }
 
         for (int var1 = 0; var1 < 4; ++var1)
@@ -2773,7 +3005,12 @@ public abstract class EntityLiving extends Entity
 
             if (var2 != null && this.rand.nextFloat() < armorEnchantmentProbability[this.worldObj.difficultySetting])
             {
+            	// FCMOD: Code change to make enchant strength on mob drops uniform accross difficulty levels
+            	/*
                 EnchantmentHelper.addRandomEnchantment(this.rand, var2, 5 + this.worldObj.difficultySetting * this.rand.nextInt(6));
+                */
+                EnchantmentHelper.addRandomEnchantment(this.rand, var2, 7 * this.rand.nextInt(6));
+            	// END FCMOD
             }
         }
     }
@@ -2781,6 +3018,10 @@ public abstract class EntityLiving extends Entity
     /**
      * Initialize this creature.
      */
+    /**
+     * FCNOTE: this function is only called when creatures spawn into the world, NOT
+     * when they are birthed or loaded.
+     */
     public void initCreature() {}
 
     /**
@@ -2887,8 +3128,604 @@ public abstract class EntityLiving extends Entity
         this.canPickUpLoot = par1;
     }
 
-    public boolean func_104002_bU()
+    // FCMOD: Changed for clarity
+    //public boolean func_104002_bU()
+    public boolean GetIsPersistent()
+    // END FCMOD
     {
         return this.persistenceRequired;
     }
+
+    // FCMOD: Added New
+    private int m_iRecentlyOnChoppingBlockCountdown = 0;
+    
+    public static final int m_iOnChoppingBlockMaxCountdown = 40;
+    
+    public boolean isOnLadder()
+    {
+        int i = MathHelper.floor_double( posX );
+        int j = MathHelper.floor_double( boundingBox.minY );
+        int k = MathHelper.floor_double( posZ );
+        
+        Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
+        
+    	return block != null && block.IsBlockClimbable( worldObj, i, j, k );  
+    }
+    
+    protected void ModSpecificOnLivingUpdate()
+    {
+    	if ( m_iRecentlyOnChoppingBlockCountdown > 0 )
+    	{
+    		m_iRecentlyOnChoppingBlockCountdown--;
+    	}
+    }    
+    
+    public float getSpeedModifier()
+    {
+        float fMoveSpeed = 1.0F;
+
+        if (this.isPotionActive(Potion.moveSlowdown))
+        {
+            fMoveSpeed *= 1.0F - 0.15F * (float)(this.getActivePotionEffect(Potion.moveSlowdown).getAmplifier() + 1);
+        }
+
+        if ( onGround && IsAffectedByMovementModifiers() )
+        {
+        	int iGroundI = MathHelper.floor_double( posX );
+        	int iGroundJ = MathHelper.floor_double( posY - 0.03D - (double)yOffset ); // same calc used for step sound
+        	int iGroundK = MathHelper.floor_double( posZ );
+        	
+        	if ( FCUtilsWorld.IsGroundCoverOnBlock( worldObj, iGroundI, iGroundJ, iGroundK ) )
+        	{
+        		fMoveSpeed *= 0.8F;
+        	}
+            else if (this.isPotionActive(Potion.moveSpeed))
+            {
+                fMoveSpeed *= 1.0F + 0.15F * (float)(this.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1);
+            }
+        	
+        	Block blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+        	
+        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+        	{
+        		float fHalfWidth = width / 2F;
+        		
+        		// block we are standing on directly is air or has no collision box.  Check the horizontal extents of our box for a movement modifier
+
+        		int iCenterGroundI = iGroundI;
+        		
+        		iGroundI = MathHelper.floor_double( posX + fHalfWidth );	        		
+	        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+	        	
+	        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+	        	{
+	        		iGroundI = MathHelper.floor_double( posX - fHalfWidth );
+		        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+		        	
+		        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+		        	{
+		        		iGroundI = iCenterGroundI;
+		        		
+		        		iGroundK = MathHelper.floor_double( posZ + fHalfWidth );
+			        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+			        	
+			        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+			        	{
+			        		iGroundK = MathHelper.floor_double( posZ - fHalfWidth );
+				        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];					        	
+			        	}
+		        	}
+	        	}	        	
+        	}
+        	
+        	if ( blockOn != null )
+        	{
+        		fMoveSpeed *= blockOn.GetMovementModifier( worldObj, iGroundI, iGroundJ, iGroundK );        		
+        	}
+        	
+        	fMoveSpeed *= GetLandMovementModifier();
+        }
+        
+        if ( fMoveSpeed < 0.0F)
+        {
+            fMoveSpeed = 0.0F;
+        }
+
+        return fMoveSpeed;
+    }
+    
+    protected float GetHealthAndExhaustionModifier()
+    {
+    	return 1.0F;
+    }
+    
+    protected float GetSwimmingHorizontalModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+    protected float GetLandMovementModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+    protected float GetLadderVerticalMovementModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+    public static Item getArmorItemForSlot(int par0, int par1)
+    {
+        switch (par0)
+        {
+            case 4:
+            	
+                if ( par1 == 4 )
+                {
+                    return Item.helmetChain;
+                }
+                else
+                {
+                    return Item.helmetIron;
+                }
+
+            case 3:
+
+                if (par1 == 4)
+                {
+                    return Item.plateChain;
+                }
+                else
+                {
+                    return Item.plateIron;
+                }
+
+            case 2:
+
+                if (par1 == 4)
+                {
+                    return Item.legsChain;
+                }
+                else
+                {
+                    return Item.legsIron;
+                }
+
+            case 1:
+
+                if (par1 == 4)
+                {
+                    return Item.bootsChain;
+                }
+                else
+                {
+                    return Item.bootsIron;
+                }
+
+            default:
+            	
+                return null;
+        }
+    }
+    
+    public void onDeath( DamageSource source )
+    {
+    	EntityLivingOnDeath( source );
+    }
+    
+    public void EntityLivingOnDeath( DamageSource source )
+    {
+        EntityLiving killCreditedEntity = this.func_94060_bK();
+
+        if (this.scoreValue >= 0 && killCreditedEntity != null)
+        {
+            killCreditedEntity.addToPlayerScore(this, this.scoreValue);
+        }
+
+        Entity sourceEntity = source.getEntity();
+
+        if ( sourceEntity != null )
+        {
+            sourceEntity.onKillEntity( this );
+        }
+
+        isLivingDead = true;
+
+        if ( !worldObj.isRemote )
+        {
+            if ( !isChild() && worldObj.getGameRules().getGameRuleBooleanValue( "doMobLoot" ) )
+            {
+                int iLootingModifier = GetAmbientLootingModifier();
+
+                if ( sourceEntity instanceof EntityPlayer )
+                {
+                    int iPlayerLootingModifier = EnchantmentHelper.getLootingModifier((EntityLiving)sourceEntity);
+                    
+                    if ( iPlayerLootingModifier > iLootingModifier )
+                    {
+                    	iLootingModifier = iPlayerLootingModifier;
+                    }
+                }
+
+                dropFewItems( true, iLootingModifier);
+                dropEquipment( true, iLootingModifier);
+                
+                CheckForRareDrop( source, iLootingModifier );
+
+                CheckForHeadDrop( source, iLootingModifier );
+                
+            	CheckForScrollDrop();
+            }
+        }
+
+        this.worldObj.setEntityState(this, (byte)3);
+    }
+
+    protected void CheckForRareDrop( DamageSource source, int iLootingModifier )
+    {
+        int iChance = rand.nextInt(800) - ( iLootingModifier * 4 );
+
+        if ( iChance < 5 )
+        {
+            dropRareDrop( iChance <= 0 ? 1 : 0 );
+        }        
+    }
+    
+    public void CheckForScrollDrop()
+    {
+    }
+    
+    protected void CheckForHeadDrop( DamageSource source, int iLootingModifier )
+    {
+        Entity sourceEntity = source.getEntity();
+
+        int iHeadChance = rand.nextInt(200);
+        
+        if ( sourceEntity instanceof EntityPlayer )
+        {
+            iHeadChance -= iLootingModifier;
+            
+        	if ( ((EntityPlayer)sourceEntity).getHeldItem() != null && 
+        		((EntityPlayer)sourceEntity).getHeldItem().getItem().itemID == FCBetterThanWolves.fcItemBattleAxe.itemID )
+        	{
+        		iHeadChance = iHeadChance >> 2;
+    		}
+		}
+        else if ( source == FCDamageSourceCustom.m_DamageSourceChoppingBlock || m_iRecentlyOnChoppingBlockCountdown > 0 )
+        {
+    		iHeadChance = iHeadChance >> 2;
+        }
+        
+        if ( iHeadChance < 5 )
+        {
+            dropHead();
+        }   
+    }
+    
+    protected int GetAmbientLootingModifier()
+    {
+    	int iLocI = MathHelper.floor_double( posX );
+    	int iLocJ = MathHelper.floor_double( posY );
+    	int iLocK = MathHelper.floor_double( posZ );
+    	
+    	return worldObj.GetAmbientLootingEffectAtLocation( iLocI, iLocJ, iLocK );
+    }
+    
+    protected void dropHead()
+    {
+    }
+    
+    public boolean CanJump()
+    {
+    	return true;
+    }
+    
+    public boolean CanSwim()
+    {
+    	return !isWeighted();
+    }
+    
+    public boolean isWeighted()
+    {
+		int iWeight = GetWornArmorWeight();
+		
+		if ( iWeight >= 10 )
+		{
+			return true;
+		}
+		
+    	return IsWeightedByHeadCrab();
+    }
+    
+    protected boolean IsWeightedByHeadCrab()
+    {
+    	return HasHeadCrabbedSquid();
+    }
+    
+    @Override
+    public void OnFlungBySquidTentacle( FCEntitySquid squid )
+    {
+    	// doesn't call attackEntityFrom() by default so that monsters remain chill about it and don't attack back
+    	
+        playSound( getHurtSound(), getSoundVolume(), getSoundPitch() );        
+    }
+    
+    @Override
+    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
+    {
+    	// doesn't call attackEntityFrom() by default so that monsters remain chill about it and don't attack back
+    	
+        playSound( getHurtSound(), getSoundVolume(), getSoundPitch() );        
+    }
+    
+	protected int GetWornArmorWeight()
+	{
+		int iWeight = 0;
+		
+		for ( int iTempSlot = 0; iTempSlot < 4; iTempSlot++ )
+		{
+			ItemStack tempStack = this.getCurrentArmor( iTempSlot );
+			
+			if ( tempStack != null )
+			{
+				iWeight += tempStack.getItem().GetWeightWhenWorn();
+			}
+		}
+        
+		return iWeight;
+	}
+	
+    private boolean HasOnlyAmbientPotionEffects( Collection effectCollection )
+    {    	
+        if ( effectCollection != null && !effectCollection.isEmpty() )
+        {
+            Iterator effectIterator = effectCollection.iterator();
+
+            while (effectIterator.hasNext())
+            {
+                PotionEffect tempEffect = (PotionEffect)effectIterator.next();
+                
+                if ( !tempEffect.getIsAmbient() )
+                {
+                	return false;
+                }
+            }
+            
+        	return true;
+        }
+        
+    	return false;
+    }
+    
+    public void SpawnerInitCreature()
+    {
+    	initCreature();
+    }
+    
+    /** Initialize state variables which may affect ability to spawn, such as bounding box size */
+    public void PreInitCreature() {}
+    
+    public boolean canEntityBeSeen( Entity entity )
+    {
+    	// Vanilla code replaced so that entities can be seen through blocks that don't stop movement
+    	
+        return worldObj.rayTraceBlocks_do_do( 
+        	worldObj.getWorldVec3Pool().getVecFromPool( posX, posY + (double)getEyeHeight(), posZ ), 
+        	worldObj.getWorldVec3Pool().getVecFromPool( entity.posX, entity.posY + 
+    		(double)entity.getEyeHeight(), entity.posZ ), false, true ) == null;
+    }
+    
+    public boolean CanEntityCenterOfMassBeSeen( Entity entity )
+    {
+    	// Same as above, but to other entities' center rather than eye to eye
+    	
+        return worldObj.rayTraceBlocks_do_do( 
+        	worldObj.getWorldVec3Pool().getVecFromPool( posX, posY + (double)getEyeHeight(), posZ ), 
+        	worldObj.getWorldVec3Pool().getVecFromPool( entity.posX, entity.posY + 
+    		( entity.height / 2F ), entity.posZ ), false, true ) == null;
+    }
+    
+    protected void RecoverAirSupply()
+    {
+		setAir(300);		
+    }
+    
+    public void SetPersistent( boolean bPersistant )
+    {
+    	persistenceRequired = bPersistant;
+    }
+    
+    @Override
+    public boolean DoesEntityApplyToSpawnCap()
+    {
+    	// entities with persistance set do not apply to the spawn cap
+    	
+    	return !GetIsPersistent();
+    }
+    
+    @Override
+	public void OutOfUpdateRangeUpdate()
+	{
+    	despawnEntity();
+	}
+	
+	public float GetDefaultSlipperinessOnGround()
+    {
+        return 0.54600006F;
+    }
+    
+	public float GetSlipperinessRelativeToBlock( int iBlockID )
+	{
+    	return Block.blocksList[iBlockID].slipperiness  * 0.91F;
+	}
+	
+	public boolean CanJumpMidWater()
+	{
+		return false;
+	}
+	
+	public void OnClimbWhileSwimming()
+	{
+	}
+	
+    protected void despawnEntity()
+    {
+    	// FCCHUNK: Decide on updates around original spawn
+        if ( !persistenceRequired && canDespawn() )
+        {
+        	int iChunkX = MathHelper.floor_double( posX / 16D ); 
+    		int iChunkZ = MathHelper.floor_double( posZ / 16D );
+    		
+    		if ( !worldObj.IsChunkActive( iChunkX, iChunkZ ) )
+    		{
+        		setDead();    			
+    		}
+    		else
+    		{
+	            EntityPlayer closestPlayer = worldObj.getClosestPlayerToEntity( this, 
+	            	MinDistFromPlayerForDespawn() );
+	        	
+	            if ( closestPlayer != null )
+	            {
+                	// don't despawn creatures close to a player
+                	
+                    entityAge = 0;
+	            }	
+	            else if ( entityAge > 600 && rand.nextInt( 800 ) == 0 ) 
+	            {
+	                setDead();
+	            }
+    		}
+        }
+        else
+        {
+            entityAge = 0;
+        }
+    }
+    
+    protected double MinDistFromPlayerForDespawn()
+    {
+    	return 32D;
+    }
+    
+    protected boolean IsInsideSpawnAreaAroundPlayer( EntityPlayer player )
+    {
+    	return IsInsideSpawnAreaAroundChunk( 
+    		MathHelper.floor_double( player.posX / 16D ), 
+    		MathHelper.floor_double( player.posZ / 16D ) ); 
+    }
+    
+    protected boolean IsInsideSpawnAreaAroundOriginalSpawn()
+    {
+    	return worldObj.provider.dimensionId == 0 && 
+    		IsInsideSpawnAreaAroundChunk( worldObj.worldInfo.getSpawnX() >> 4,
+    			worldObj.worldInfo.getSpawnZ() >> 4 );
+    }
+    
+    protected boolean IsInsideSpawnAreaAroundChunk( int iChunkX, int iChunkZ )
+    {
+        int iValidRange = worldObj.GetMobSpawnRangeInChunks();
+        
+        int iEntityChunkX = MathHelper.floor_double( posX / 16D );
+        int iDeltaX = iChunkX - iEntityChunkX;
+        
+        if ( iDeltaX >= -iValidRange && iDeltaX <= iValidRange )
+        {
+	        int iEntityChunkZ = MathHelper.floor_double( posZ / 16D );
+	        int iDeltaZ = iChunkZ - iEntityChunkZ;
+	        
+	        if ( iDeltaZ >= -iValidRange && iDeltaZ <= iValidRange )
+	        {
+	        	return true;
+	        }
+        }   
+                    
+        return false;
+    }
+    
+    @Override
+    public boolean AttractsLightning()
+    {
+    	return true;
+    }
+    
+    public int GetMeleeAttackStrength( Entity target )
+    {
+    	return 2;
+    }
+    
+    public boolean MeleeAttack( Entity target )
+    {
+        setLastAttackingEntity( target );
+        
+        int iStrength = GetMeleeAttackStrength( target );
+
+        if ( isPotionActive( Potion.damageBoost ) )
+        {
+            iStrength += 3 << getActivePotionEffect( Potion.damageBoost ).getAmplifier();
+        }
+
+        if ( isPotionActive( Potion.weakness ) )
+        {
+            iStrength -= 2 << getActivePotionEffect( Potion.weakness ).getAmplifier();
+        }
+
+        int iKnockback = 0;
+
+        if ( target instanceof EntityLiving )
+        {
+            iStrength += EnchantmentHelper.getEnchantmentModifierLiving( this, 
+            	(EntityLiving)target );
+            
+            iKnockback += EnchantmentHelper.getKnockbackModifier( this, (EntityLiving)target );
+        }
+
+        boolean bAttackSuccess = target.attackEntityFrom( DamageSource.causeMobDamage( this ), 
+        	iStrength );
+
+        if ( bAttackSuccess )
+        {
+            if ( iKnockback > 0 )
+            {
+                target.addVelocity( 
+                	-MathHelper.sin( rotationYaw * (float)Math.PI / 180F ) * iKnockback * 0.5F, 
+                	0.1D, 
+                	MathHelper.cos( rotationYaw * (float)Math.PI / 180F ) * iKnockback * 0.5F );
+                
+                motionX *= 0.6D;
+                motionZ *= 0.6D;
+            }
+
+            int iFireModifier = EnchantmentHelper.getFireAspectModifier( this );
+
+            if ( iFireModifier > 0 )
+            {
+                target.setFire( iFireModifier * 4 );
+            }
+            else if ( isBurning() && rand.nextFloat() < 0.6F )
+            {
+                target.setFire( 4 );
+            }
+
+            if ( target instanceof EntityLiving )
+            {
+                EnchantmentThorns.func_92096_a(this, (EntityLiving)target, rand);
+            }
+        }
+
+        return bAttackSuccess;
+    }
+    
+    public float KnockbackMagnitude()
+    {
+    	return 0.4F;
+    }
+    
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityMagmaCube.java b/minecraft_server/net/minecraft/src/EntityMagmaCube.java
index 2f37f60..45b81ec 100644
--- a/minecraft_server/net/minecraft/src/EntityMagmaCube.java
+++ b/minecraft_server/net/minecraft/src/EntityMagmaCube.java
@@ -1,6 +1,9 @@
 package net.minecraft.src;
 
-public class EntityMagmaCube extends EntitySlime
+// FCMOD: Changed
+//public class EntityMagmaCube extends EntitySlime
+public class EntityMagmaCube extends FCEntitySlime
+// END FCMOD
 {
     public EntityMagmaCube(World par1World)
     {
diff --git a/minecraft_server/net/minecraft/src/EntityMinecart.java b/minecraft_server/net/minecraft/src/EntityMinecart.java
index b478524..0927884 100644
--- a/minecraft_server/net/minecraft/src/EntityMinecart.java
+++ b/minecraft_server/net/minecraft/src/EntityMinecart.java
@@ -672,9 +672,25 @@ public abstract class EntityMinecart extends Entity
         }
         else
         {
+            // FCMOD: Changed the following for less drag on non-ridden carts
+            /*
             this.motionX *= 0.9599999785423279D;
             this.motionY *= 0.0D;
             this.motionZ *= 0.9599999785423279D;
+            */
+            if ( FCBetterThanWolves.fcDisableMinecartChanges )
+            {
+                motionX *= 0.96D;
+                motionY *= 0.0D;
+                motionZ *= 0.96D;
+        	}
+            else
+            {
+                motionX *= 0.985D;
+                motionY *= 0.0D;
+                motionZ *= 0.985D;
+            }
+            // END FCMOD
         }
     }
 
@@ -1033,4 +1049,12 @@ public abstract class EntityMinecart extends Entity
     {
         return this.entityName;
     }
+    
+    // FCMOD: Code added
+    @Override
+    public boolean CanCollideWithEntity( Entity entity )
+    {
+    	return !entity.IsItemEntity();
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityMinecartChest.java b/minecraft_server/net/minecraft/src/EntityMinecartChest.java
index eb7e4ca..93421ff 100644
--- a/minecraft_server/net/minecraft/src/EntityMinecartChest.java
+++ b/minecraft_server/net/minecraft/src/EntityMinecartChest.java
@@ -15,7 +15,17 @@ public class EntityMinecartChest extends EntityMinecartContainer
     public void killMinecart(DamageSource par1DamageSource)
     {
         super.killMinecart(par1DamageSource);
-        this.dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
+        
+        // FCMOD: Changed
+        //this.dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
+    	dropItemWithOffset( FCBetterThanWolves.fcItemSawDust.itemID, 6, 0.0F );
+    	dropItemWithOffset( Item.stick.itemID, 2, 0.0F );
+    	
+        if ( !worldObj.isRemote )
+        {        
+			playSound( "mob.zombie.woodbreak", 0.25F, 0.75F + ( worldObj.rand.nextFloat() * 0.25F ) );
+        }
+        // END FCMOD        
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/EntityMob.java b/minecraft_server/net/minecraft/src/EntityMob.java
index 8252d4c..ea78c89 100644
--- a/minecraft_server/net/minecraft/src/EntityMob.java
+++ b/minecraft_server/net/minecraft/src/EntityMob.java
@@ -13,6 +13,13 @@ public abstract class EntityMob extends EntityCreature implements IMob
      * use this to react to sunlight and start to burn.
      */
     public void onLivingUpdate()
+    // FCMOD: Addded so that method can be called directly regardless of hierarchy
+    {
+    	EntityMobOnLivingUpdate();
+    }
+    
+    public void EntityMobOnLivingUpdate()
+    // END FCMOD
     {
         this.updateArmSwingProgress();
         float var1 = this.getBrightness(1.0F);
@@ -52,6 +59,13 @@ public abstract class EntityMob extends EntityCreature implements IMob
      * Called when the entity is attacked.
      */
     public boolean attackEntityFrom(DamageSource par1DamageSource, int par2)
+    // FCMOD: Addded so that method can be called directly regardless of hierarchy
+    {
+    	return EntityMobAttackEntityFrom(par1DamageSource, par2);
+    }
+    
+    public boolean EntityMobAttackEntityFrom(DamageSource par1DamageSource, int par2)
+    // END FCMOD
     {
         if (this.isEntityInvulnerable())
         {
@@ -65,6 +79,9 @@ public abstract class EntityMob extends EntityCreature implements IMob
             {
                 if (var3 != this)
                 {
+                	// FCMOD: Code added so that mobs won't lose their target if they take damage from an environmental source
+                	if ( var3 != null )
+            		// END FCMOD
                     this.entityToAttack = var3;
                 }
 
@@ -81,6 +98,8 @@ public abstract class EntityMob extends EntityCreature implements IMob
         }
     }
 
+    // FCMOD: Removed and moved up in hiearchy
+	/*
     public boolean attackEntityAsMob(Entity par1Entity)
     {
         int var2 = this.getAttackStrength(par1Entity);
@@ -120,6 +139,12 @@ public abstract class EntityMob extends EntityCreature implements IMob
             {
                 par1Entity.setFire(var5 * 4);
             }
+            // FCMOD: Added so all mobs set fire to others when burning, not just zombies
+            else if ( isBurning() && rand.nextFloat() < 0.6F )
+            {
+                par1Entity.setFire( 4 );
+            }
+            // END FCMOD
 
             if (par1Entity instanceof EntityLiving)
             {
@@ -129,11 +154,20 @@ public abstract class EntityMob extends EntityCreature implements IMob
 
         return var4;
     }
+    */
+    // END FCMOD
 
     /**
      * Basic mob attack. Default to touch of death in EntityCreature. Overridden by each mob to define their attack.
      */
     protected void attackEntity(Entity par1Entity, float par2)
+    // FCMOD: Addded so that method can be called directly regardless of hierarchy
+    {
+    	EntityMobAttackEntity( par1Entity, par2 );
+    }
+    
+    protected void EntityMobAttackEntity(Entity par1Entity, float par2)
+    // END FCMOD
     {
         if (this.attackTime <= 0 && par2 < 2.0F && par1Entity.boundingBox.maxY > this.boundingBox.minY && par1Entity.boundingBox.minY < this.boundingBox.maxY)
         {
@@ -185,7 +219,10 @@ public abstract class EntityMob extends EntityCreature implements IMob
      */
     public boolean getCanSpawnHere()
     {
-        return this.isValidLightLevel() && super.getCanSpawnHere();
+    	// FCMOD: Changed
+        //return this.isValidLightLevel() && super.getCanSpawnHere();
+    	return isValidLightLevel() && super.getCanSpawnHere() && CanSpawnOnBlockBelow();
+        // END FCMOD
     }
 
     /**
@@ -195,4 +232,60 @@ public abstract class EntityMob extends EntityCreature implements IMob
     {
         return 2;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public int GetMeleeAttackStrength( Entity target )
+    {
+    	return getAttackStrength( target );
+    }
+    
+    protected boolean CanSpawnOnBlockBelow()
+    {
+        int i = MathHelper.floor_double( posX );
+        int j = (int)boundingBox.minY - 1;
+        int k = MathHelper.floor_double( posZ );
+        
+        return CanSpawnOnBlock( worldObj.getBlockId( i, j, k ) );        
+    }
+    
+    protected boolean CanSpawnOnBlock( int iBlockID )
+    {
+    	return iBlockID != Block.leaves.blockID;
+    }
+
+    protected void CheckForCatchFireInSun()
+    {
+        if ( !worldObj.isRemote && worldObj.isDaytime() && !isChild() && !inWater )
+        {
+            float fBrightness = getBrightness( 1F );
+
+            if ( fBrightness > 0.5F && rand.nextFloat() * 30F < ( fBrightness - 0.4F ) * 2F && 
+            	worldObj.canBlockSeeTheSky( MathHelper.floor_double( posX ), 
+            		MathHelper.floor_double( posY + (double)getEyeHeight() ), 
+            		MathHelper.floor_double( posZ ) ) )
+            {
+            	// check to make sure water isn't directly below to prevent catching fire while bobbing
+            	
+            	int iBlockBelowID = worldObj.getBlockId( MathHelper.floor_double( posX ), 
+            		MathHelper.floor_double( posY - 0.1F ), MathHelper.floor_double( posZ ) );
+            	
+            	Block blockBelow = Block.blocksList[iBlockBelowID];
+            	
+            	if ( blockBelow == null || blockBelow.blockMaterial != Material.water ) 
+            	{            	                                    
+	            	// client
+	                //ItemStack headStack = getCurrentItemOrArmor( 4 );
+	            	// server
+	                ItemStack headStack = getEquipmentInSlot( 4 );
+	
+	                if ( headStack == null && !HasHeadCrabbedSquid() )
+	                {
+	                    setFire( 8 );
+	                }
+            	}
+            }
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityMooshroom.java b/minecraft_server/net/minecraft/src/EntityMooshroom.java
index 3708327..cd803e3 100644
--- a/minecraft_server/net/minecraft/src/EntityMooshroom.java
+++ b/minecraft_server/net/minecraft/src/EntityMooshroom.java
@@ -1,6 +1,9 @@
 package net.minecraft.src;
 
-public class EntityMooshroom extends EntityCow
+// FCMOD: Changed
+//public class EntityMooshroom extends EntityCow
+public class EntityMooshroom extends FCEntityCow
+// END FCMOD
 {
     public EntityMooshroom(World par1World)
     {
@@ -12,6 +15,8 @@ public class EntityMooshroom extends EntityCow
     /**
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean interact(EntityPlayer par1EntityPlayer)
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
@@ -49,7 +54,7 @@ public class EntityMooshroom extends EntityCow
                     this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY + (double)this.height, this.posZ, new ItemStack(Block.mushroomRed)));
                 }
             }
-
+            
             return true;
         }
         else
@@ -57,6 +62,8 @@ public class EntityMooshroom extends EntityCow
             return super.interact(par1EntityPlayer);
         }
     }
+    */
+    // END FCMOD    
 
     public EntityMooshroom func_94900_c(EntityAgeable par1EntityAgeable)
     {
@@ -66,7 +73,10 @@ public class EntityMooshroom extends EntityCow
     /**
      * This function is used when two same-species animals in 'love mode' breed to generate the new baby animal.
      */
-    public EntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
+    // FCMOD: Changed
+    //public EntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
+    public FCEntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
+    // END FCMOD
     {
         return this.func_94900_c(par1EntityAgeable);
     }
@@ -75,4 +85,78 @@ public class EntityMooshroom extends EntityCow
     {
         return this.func_94900_c(par1EntityAgeable);
     }
+
+    // FCMOD: Added New
+    @Override
+    public void CheckForGrazeSideEffects( int i, int j, int k )
+    {
+    	// override to get rid of mooshroom conversion on eat mycellium
+    }
+    
+    @Override
+    public void ConvertToMooshroom()
+    {
+    }
+    
+    @Override
+    public void onLivingUpdate()
+    {
+        if ( !worldObj.isRemote )
+        {
+            CheckForMyceliumSpread();
+        }
+
+        super.onLivingUpdate();
+    }
+    
+    @Override
+    public boolean interact( EntityPlayer player )
+    {
+        ItemStack heldStack = player.inventory.getCurrentItem();
+
+        if ( heldStack != null && heldStack.itemID == Item.bowlEmpty.itemID && GotMilk() )
+        {
+            attackEntityFrom( DamageSource.generic, 0 );
+            
+            if ( !worldObj.isRemote )
+        	{
+            	SetGotMilk( false );
+            	
+		        worldObj.playAuxSFX( FCBetterThanWolves.m_iCowMilkedAuxFXID,
+	                MathHelper.floor_double( posX ), (int)posY,
+	                MathHelper.floor_double( posZ ), 0 );
+            }
+            
+            if ( heldStack.stackSize == 1 )
+            {
+                player.inventory.setInventorySlotContents( player.inventory.currentItem, 
+                	new ItemStack( Item.bowlSoup ) );
+            }
+            else if ( player.inventory.addItemStackToInventory( new ItemStack( Item.bowlSoup ) ) ) 
+            {
+                player.inventory.decrStackSize(player.inventory.currentItem, 1);
+            }
+            
+            return true;
+        }
+        
+        // skip over parent to avoid vanilla milking
+        
+        return EntityAnimalInteract( player ); 
+    }
+    
+	//------------- Class Specific Methods ------------//
+    
+    private void CheckForMyceliumSpread()
+    {
+    	if ( worldObj.provider.dimensionId != 1 && rand.nextInt( 1000 ) == 0 )
+    	{
+    		FCBlockMycelium.CheckForMyceliumSpreadToRandomBlockAround( worldObj,
+    			MathHelper.floor_double( posX ), (int)posY - 1, 
+    			MathHelper.floor_double( posZ ) );
+    	}
+    }
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/EntityOcelot.java b/minecraft_server/net/minecraft/src/EntityOcelot.java
index b52e778..fff7809 100644
--- a/minecraft_server/net/minecraft/src/EntityOcelot.java
+++ b/minecraft_server/net/minecraft/src/EntityOcelot.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/30/2018
+
 package net.minecraft.src;
 
 public class EntityOcelot extends EntityTameable
diff --git a/minecraft_server/net/minecraft/src/EntityPig.java b/minecraft_server/net/minecraft/src/EntityPig.java
index 585261f..e063bd1 100644
--- a/minecraft_server/net/minecraft/src/EntityPig.java
+++ b/minecraft_server/net/minecraft/src/EntityPig.java
@@ -1,5 +1,10 @@
+// FCMOD: Class changes deprecated 07/23/2018
+
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class EntityPig extends EntityAnimal
 {
     /** AI task for player control. */
diff --git a/minecraft_server/net/minecraft/src/EntityPigZombie.java b/minecraft_server/net/minecraft/src/EntityPigZombie.java
index 1c46e4a..3846c4b 100644
--- a/minecraft_server/net/minecraft/src/EntityPigZombie.java
+++ b/minecraft_server/net/minecraft/src/EntityPigZombie.java
@@ -2,7 +2,10 @@ package net.minecraft.src;
 
 import java.util.List;
 
-public class EntityPigZombie extends EntityZombie
+// FCMOD: Changed
+//public class EntityPigZombie extends EntityZombie
+public class EntityPigZombie extends FCEntityZombie
+// END FCMOD
 {
     /** Above zero if this PigZombie is Angry. */
     private int angerLevel = 0;
@@ -114,7 +117,10 @@ public class EntityPigZombie extends EntityZombie
     /**
      * Causes this PigZombie to become angry at the supplied Entity (which will be a player).
      */
-    private void becomeAngryAt(Entity par1Entity)
+    // FCMOD: Changed
+    //private void becomeAngryAt(Entity par1Entity)
+    protected void becomeAngryAt(Entity par1Entity)
+    // END FCMOD
     {
         this.entityToAttack = par1Entity;
         this.angerLevel = 400 + this.rand.nextInt(400);
diff --git a/minecraft_server/net/minecraft/src/EntityPlayer.java b/minecraft_server/net/minecraft/src/EntityPlayer.java
index bc74162..638737d 100644
--- a/minecraft_server/net/minecraft/src/EntityPlayer.java
+++ b/minecraft_server/net/minecraft/src/EntityPlayer.java
@@ -100,7 +100,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     public EntityPlayer(World par1World)
     {
         super(par1World);
-        this.inventoryContainer = new ContainerPlayer(this.inventory, !par1World.isRemote, this);
+        // FCMOD: Changed
+        //this.inventoryContainer = new ContainerPlayer(this.inventory, !par1World.isRemote, this);
+        inventoryContainer = new FCContainerPlayer( inventory, !par1World.isRemote, this );
+        // END FCMOD
         this.openContainer = this.inventoryContainer;
         this.yOffset = 1.62F;
         ChunkCoordinates var2 = par1World.getSpawnPoint();
@@ -122,8 +125,29 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         this.dataWatcher.addObject(16, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(17, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(18, Integer.valueOf(0));
+        
+        // FCMOD: Added
+        dataWatcher.addObject( m_iHasValidMagneticPointForLocationDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iStongestMagneticPointForLocationIDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iStongestMagneticPointForLocationKDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iGloomLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iFatPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iHungerPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
+        dataWatcher.addObject( m_iHealthPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
+        
+        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationIDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationJDataWatcherID, new Integer( 0 ) );
+        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationKDataWatcherID, new Integer( 0 ) );
+        // END FCMOD
     }
 
+    // FCMOD: Added (server only to match client)
+    public int getItemInUseCount()
+    {
+        return this.itemInUseCount;
+    }
+    // END FCMOD
+
     /**
      * Checks if the entity is currently using an item (e.g., bow, food, sword) by holding down the useItemButton
      */
@@ -163,17 +187,35 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
      */
     public void onUpdate()
     {
+    	// FCMOD: Added
+    	m_iTimesCraftedThisTick = 0;
+        m_iTicksSinceEmoteSound++;
+    	// END FCMOD
+    	
         if (this.itemInUse != null)
         {
             ItemStack var1 = this.inventory.getCurrentItem();
 
-            if (var1 == this.itemInUse)
+            // FCMOD: Changed
+            //if (var1 == this.itemInUse)
+            if ( var1 == this.itemInUse || 
+            	( var1 != null && itemInUse.getItem().IgnoreDamageWhenComparingDuringUse() && 
+        		var1.itemID == itemInUse.itemID && ItemStack.areItemStackTagsEqual( itemInUse, var1 ) ) )
+        	// END FCMOD
             {
+            	// FCMOD: Added
+            	itemInUse = var1;
+            	// END FCMOD
+            	
                 if (this.itemInUseCount <= 25 && this.itemInUseCount % 4 == 0)
                 {
                     this.updateItemUse(var1, 5);
                 }
 
+                // FCMOD: Added
+        		var1.getItem().UpdateUsingItem( var1, this.worldObj, this );
+                // END FCMOD 
+
                 if (--this.itemInUseCount == 0 && !this.worldObj.isRemote)
                 {
                     this.onItemUseFinish();
@@ -286,6 +328,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             this.foodStats.onUpdate(this);
         }
+        
+        // FCMOD: Added
+        UpdateModStatusVariables();
+        // END FCMOD
     }
 
     /**
@@ -304,6 +350,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         return 10;
     }
 
+    // FCMOD: Comment added
+    /**
+	/* the playSound function both plays the sound locally on the client, and plays it remotely on the server without it being sent again to the same player
+	 */ // END FCMOD
     public void playSound(String par1Str, float par2, float par3)
     {
         this.worldObj.playSoundToNearExcept(this, par1Str, par2, par3);
@@ -449,6 +499,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         super.onLivingUpdate();
         this.landMovementFactor = this.capabilities.getWalkSpeed();
         this.jumpMovementFactor = this.speedInAir;
+        // FCMOD: Code added to apply move penalties to jumping
+        jumpMovementFactor *= GetJumpingHorizontalMovementModifier();        
+        // END FCMOD
 
         if (this.isSprinting())
         {
@@ -626,6 +679,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 var3.motionX = (double)(-MathHelper.sin(var6) * var5);
                 var3.motionZ = (double)(MathHelper.cos(var6) * var5);
                 var3.motionY = 0.20000000298023224D;
+                // FCMOD: Code added: par2 flag indicates that the item has been dropped on death
+                var3.SetEntityItemAsDroppedOnPlayerDeath( this );
+                // END FCMOD
             }
             else
             {
@@ -658,9 +714,19 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     /**
      * Returns how strong the player is against the specified block at this moment
      */
+    // FCMOD: Code change
+    /*
     public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2)
+    */
+    public float getCurrentPlayerStrVsBlock(Block par1Block, int i, int j, int k)
+    // END FCMOD
     {
+        // FCMOD: Code change
+        /*
         float var3 = this.inventory.getStrVsBlock(par1Block);
+        */
+        float var3 = this.inventory.getStrVsBlock(worldObj, par1Block, i, j, k);
+    	// END FCMOD
 
         if (var3 > 1.0F)
         {
@@ -671,7 +737,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             {
                 float var6 = (float)(var4 * var4 + 1);
 
+                // FCMOD: Code change
+                /*
                 if (!var5.canHarvestBlock(par1Block) && var3 <= 1.0F)
+                */
+                if (!var5.canHarvestBlock( worldObj, par1Block, i, j, k) && var3 <= 1.0F)
+                // END FCMOD
                 {
                     var3 += var6 * 0.08F;
                 }
@@ -701,6 +772,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             var3 /= 5.0F;
         }
+        
+        // FCMOD: Added
+        var3 *= GetMiningSpeedModifier();
+        // END FCMOD        
 
         return var3;
     }
@@ -708,10 +783,14 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     /**
      * Checks if the player has the ability to harvest a block (checks current inventory item for a tool if necessary)
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return this.inventory.canHarvestBlock(par1Block);
     }
+    */
+    // END FCMOD
 
     /**
      * (abstract) Protected helper method to read subclass entity data from NBT.
@@ -749,6 +828,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             NBTTagList var3 = par1NBTTagCompound.getTagList("EnderItems");
             this.theInventoryEnderChest.loadInventoryFromNBT(var3);
         }
+        // FCMOD: Code added
+        ReadModDataFromNBT( par1NBTTagCompound );
+        // END FCMOD
     }
 
     /**
@@ -777,6 +859,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         this.foodStats.writeNBT(par1NBTTagCompound);
         this.capabilities.writeCapabilitiesToNBT(par1NBTTagCompound);
         par1NBTTagCompound.setTag("EnderItems", this.theInventoryEnderChest.saveInventoryToNBT());
+        // FCMOD: Code added
+        WriteModDataToNBT( par1NBTTagCompound );
+        // END FCMOD
     }
 
     /**
@@ -878,6 +963,14 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     }
 
                     this.addStat(StatList.damageTakenStat, par2);
+                    // FCMOD: Code added
+                    if ( !isDead && IsCarryingBlastingOil() )
+                    {
+                    	DetonateCarriedBlastingOil();
+                    	
+                    	return false;
+                    }
+                    // END FCMOD
                     return super.attackEntityFrom(par1DamageSource, par2);
                 }
             }
@@ -897,7 +990,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
      */
     protected void alertWolves(EntityLiving par1EntityLiving, boolean par2)
     {
-        if (!(par1EntityLiving instanceof EntityCreeper) && !(par1EntityLiving instanceof EntityGhast))
+    	// FCMOD: Added to make sure that wolves don't attack if sitting
+    	par2 = true;
+    	// END FCMOD
+    	// FCMOD: Changed
+        //if (!(par1EntityLiving instanceof EntityCreeper) && !(par1EntityLiving instanceof EntityGhast))
+        if (!(par1EntityLiving instanceof FCEntityCreeper) && !(par1EntityLiving instanceof FCEntityGhast))
+    	// END FCMOD
         {
             if (par1EntityLiving instanceof EntityWolf)
             {
@@ -970,6 +1069,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             if (!par1DamageSource.isUnblockable() && this.isBlocking())
             {
+        		// FCMOD: Code added
+        		OnBlockedDamage( par1DamageSource, par2 );
+        		// END FCMOD
+        		
                 par2 = 1 + par2 >> 1;
             }
 
@@ -1106,6 +1209,15 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     ++var3;
                 }
 
+                // FCMOD: Code added to modify player attack damage by health and exhaustion
+                float fModifier = GetMeleeDamageModifier();
+                
+                if ( fModifier < 0.99F )
+                {
+                	var2 = (int)((float)var2 * fModifier);                	
+                }
+                // END FCMOD
+
                 if (var2 > 0 || var4 > 0)
                 {
                     boolean var5 = this.fallDistance > 0.0F && !this.onGround && !this.isOnLadder() && !this.isInWater() && !this.isPotionActive(Potion.blindness) && this.ridingEntity == null && par1Entity instanceof EntityLiving;
@@ -1204,6 +1316,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
                     this.addExhaustion(0.3F);
                 }
+                // FCMOD: Code added
+                else // else from "if (var2 > 0 || var4 > 0)" above, indicating zero damage attack
+                {
+            		OnZeroDamageAttack();
+                }
+                // END FCMOD
             }
         }
     }
@@ -1247,6 +1365,11 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
      */
     public EnumStatus sleepInBedAt(int par1, int par2, int par3)
     {
+    	// FCMOD: Code added
+        return EnumStatus.OTHER_PROBLEM;
+        // END FCMOD
+    	// FCMOD: Code removed
+        /*
         if (!this.worldObj.isRemote)
         {
             if (this.isPlayerSleeping() || !this.isEntityAlive())
@@ -1326,6 +1449,8 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         }
 
         return EnumStatus.OK;
+        */
+        // END FCMOD
     }
 
     private void func_71013_b(int par1)
@@ -1495,6 +1620,10 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
             this.spawnChunk = null;
             this.spawnForced = false;
         }
+        
+        // FCMOD: Code added
+        m_iSpawnDimension = 0;
+        // END FCMOD
     }
 
     /**
@@ -1518,6 +1647,8 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         super.jump();
         this.addStat(StatList.jumpStat, 1);
 
+        // FCMOD: Changed
+        /*
         if (this.isSprinting())
         {
             this.addExhaustion(0.8F);
@@ -1526,6 +1657,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             this.addExhaustion(0.2F);
         }
+        */
+        AddExhaustionForJump();
+        // END FCMOD
     }
 
     /**
@@ -1563,6 +1697,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             int var7;
 
+            // FCMOD: Added
+            if ( isInWater() && par3 > 0D && CanSwim() )
+            {
+                addExhaustion( 0.025F );
+            }
+            // END FCMOD
+            
             if (this.isInsideOfMaterial(Material.water))
             {
                 var7 = Math.round(MathHelper.sqrt_double(par1 * par1 + par3 * par3 + par5 * par5) * 100.0F);
@@ -1570,7 +1711,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 if (var7 > 0)
                 {
                     this.addStat(StatList.distanceDoveStat, var7);
+                    // FCMOD: Code change
+                    /*
                     this.addExhaustion(0.015F * (float)var7 * 0.01F);
+                    */
+                    this.AddExhaustionWithoutVisualFeedback(0.015F * (float)var7 * 0.01F);
+                    // END FCMOD
                 }
             }
             else if (this.isInWater())
@@ -1580,7 +1726,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 if (var7 > 0)
                 {
                     this.addStat(StatList.distanceSwumStat, var7);
+                    // FCMOD: Code change
+                    /*
                     this.addExhaustion(0.015F * (float)var7 * 0.01F);
+                    */
+                    this.AddExhaustionWithoutVisualFeedback(0.015F * (float)var7 * 0.01F);
+                    // END FCMOD
                 }
             }
             else if (this.isOnLadder())
@@ -1604,7 +1755,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                     }
                     else
                     {
+                        // FCMOD: Code change
+                        /*
                         this.addExhaustion(0.01F * (float)var7 * 0.01F);
+                        */
+                        this.AddExhaustionWithoutVisualFeedback(0.01F * (float)var7 * 0.01F);
+                        // END FCMOD
                     }
                 }
             }
@@ -1768,6 +1924,9 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
         {
             if (!this.worldObj.isRemote)
             {
+            	// FCMOD: Code added        	
+            	par1 *= GetArmorExhaustionModifier();
+        		// END FCMOD
                 this.foodStats.addExhaustion(par1);
             }
         }
@@ -1783,6 +1942,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
     public boolean canEat(boolean par1)
     {
+    	// FCMOD: Code added to prevent player from eating while having the hunger effect
+        if ( isPotionActive( Potion.hunger ) )
+        {
+        	return false;
+        }
+    	// END FCMOD
         return (par1 || this.foodStats.needFood()) && !this.capabilities.disableDamage;
     }
 
@@ -1837,7 +2002,12 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
                 {
                     ItemStack var6 = this.getCurrentEquippedItem();
 
+                    // FCMOD: Code change
+                    /*
                     if (var6.canHarvestBlock(var5) || var6.getStrVsBlock(var5) > 1.0F)
+                    */
+                    if (var6.canHarvestBlock(worldObj, var5, par1, par2, par3) || var6.getStrVsBlock(worldObj, var5, par1, par2, par3) > 1.0F)
+                	// END FCMOD
                     {
                         return true;
                     }
@@ -1850,6 +2020,13 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
 
     public boolean canPlayerEdit(int par1, int par2, int par3, int par4, ItemStack par5ItemStack)
     {
+    	// FCMOD: Code added to prevent the player from placing blocks while in mid air
+    	if ( !capabilities.isCreativeMode && !onGround && !inWater && !isOnLadder() && ridingEntity == null && !handleLavaMovement() )
+    	{
+    		return false;
+    	}
+    	// END FCMOD
+    	
         return this.capabilities.allowEdit ? true : (par5ItemStack != null ? par5ItemStack.func_82835_x() : false);
     }
 
@@ -2026,4 +2203,1072 @@ public abstract class EntityPlayer extends EntityLiving implements ICommandSende
     {
         return ScorePlayerTeam.func_96667_a(this.getTeam(), this.username);
     }
+
+    // FCMOD: Added New
+    public ChunkCoordinates m_HardcoreSpawnChunk;
+    
+    public long m_lTimeOfLastSpawnAssignment = 0;
+    public long m_lTimeOfLastDimensionSwitch = 0;
+    public long m_lRespawnAssignmentCooldownTimer = 0;
+    
+    public int m_iSpawnDimension = 0;
+    public int m_iTimesCraftedThisTick = 0;
+    public int m_iInGloomCounter = 0;
+    public int m_iAirRecoveryCountdown = 0;    
+    public int m_iTicksSinceEmoteSound = 0;
+    
+	protected float m_fCurrentMiningSpeedModifier = 1F;
+    
+    public static final int m_iGloomCounterBetweenStateChanges = 1200; // 1 minute
+    
+	private static final int m_iStongestMagneticPointForLocationIDataWatcherID = 22;
+	private static final int m_iStongestMagneticPointForLocationKDataWatcherID = 23;
+	private static final int m_iHasValidMagneticPointForLocationDataWatcherID = 24;
+	private static final int m_iGloomLevelDataWatcherID = 25;
+	private static final int m_iFatPenaltyLevelDataWatcherID = 26;
+	private static final int m_iHungerPenaltyLevelDataWatcherID = 27;
+	private static final int m_iHealthPenaltyLevelDataWatcherID = 28;
+    
+	private static final int m_iSpawnChunksVisualizationLocationIDataWatcherID = 29;
+	private static final int m_iSpawnChunksVisualizationLocationJDataWatcherID = 30;
+	private static final int m_iSpawnChunksVisualizationLocationKDataWatcherID = 31;
+	
+	private static final int m_iTicksBetweenEmoteSounds = 10;
+	
+	public static final float m_fExhaustionJumping = 0.2F;
+	public static final float m_fExhaustionJumpingSprinting = 1.0F;
+	
+    protected void ReadModDataFromNBT( NBTTagCompound tag )
+    {
+	    if ( tag.hasKey( "fcTimeOfLastSpawnAssignment" ) )
+	    {
+	    	m_lTimeOfLastSpawnAssignment = tag.getLong( "fcTimeOfLastSpawnAssignment" );
+	    }
+	    
+	    if ( tag.hasKey( "fcTimeOfLastDimensionSwitch" ) )
+	    {
+	    	m_lTimeOfLastDimensionSwitch = tag.getLong( "fcTimeOfLastDimensionSwitch" );
+	    }
+	    
+	    if ( tag.hasKey( "fcHCSpawnX" ) && tag.hasKey( "fcHCSpawnY" ) && tag.hasKey( "fcHCSpawnZ" ) )
+	    {
+	        m_HardcoreSpawnChunk = new ChunkCoordinates( tag.getInteger( "fcHCSpawnX" ), tag.getInteger( "fcHCSpawnY" ), tag.getInteger( "fcHCSpawnZ" ) );
+	    }
+	    
+	    if ( tag.hasKey( "fcSpawnDimension" ) )
+	    {
+	    	m_iSpawnDimension = tag.getInteger( "fcSpawnDimension" );
+	    }	    	    
+	    
+	    if ( tag.hasKey( "fcGloomLevel" ) )
+	    {
+	    	SetGloomLevel( tag.getInteger( "fcGloomLevel" ) );
+	    }
+	    
+	    if ( tag.hasKey( "fcGloomCounter" ) )
+	    {
+	    	m_iInGloomCounter = tag.getInteger( "fcGloomCounter" );
+	    }
+    }
+    
+    protected void WriteModDataToNBT( NBTTagCompound tag )
+    {
+	 	tag.setLong( "fcTimeOfLastSpawnAssignment", m_lTimeOfLastSpawnAssignment );
+	 	
+	 	tag.setLong( "fcTimeOfLastDimensionSwitch", m_lTimeOfLastDimensionSwitch );
+	    
+	    if ( m_HardcoreSpawnChunk != null )
+	    {
+	        tag.setInteger( "fcHCSpawnX", m_HardcoreSpawnChunk.posX );
+	        tag.setInteger( "fcHCSpawnY", m_HardcoreSpawnChunk.posY );
+	        tag.setInteger( "fcHCSpawnZ", m_HardcoreSpawnChunk.posZ );
+	    }
+	    
+	 	tag.setInteger( "fcSpawnDimension", m_iSpawnDimension );
+	 	
+	 	tag.setInteger( "fcGloomLevel", GetGloomLevel() );
+	 	tag.setInteger( "fcGloomCounter", m_iInGloomCounter );
+    }
+    
+    @Override
+    protected int decreaseAirSupply( int iAirSupply )
+    {
+        m_iAirRecoveryCountdown = 20;
+        
+        int iEnchantmentLevel = EnchantmentHelper.getRespiration(this);
+        
+        if ( iEnchantmentLevel > 0 && IsWearingSoulforgedHelm() )
+        {
+    		if ( this.worldObj.getWorldTime() % 100 == 0 )
+    		{
+    			worldObj.playSoundAtEntity( this, 
+            		"random.breath", 
+            		0.75F + rand.nextFloat() * 0.5F, 
+            		0.5F + rand.nextFloat() * 0.025F );
+    		}    		
+
+        	if ( rand.nextInt( ( iEnchantmentLevel * iEnchantmentLevel + 1 ) ) > 0 )
+        	{
+        		return iAirSupply;
+        	}
+        	else
+        	{
+                return iAirSupply - 1;
+        	}        	
+        }
+        else
+        {
+        	return super.decreaseAirSupply( iAirSupply );
+        }
+    }
+    
+    @Override
+    protected void RecoverAirSupply()
+    {
+    	if ( m_iAirRecoveryCountdown > 0 )
+    	{
+    		m_iAirRecoveryCountdown--;
+    		
+    	}
+    	else
+    	{
+        	int iCurrentAir = getAir();
+        	
+        	if ( iCurrentAir < 300 )
+        	{
+        		iCurrentAir += 10;
+        		
+        		if ( iCurrentAir > 300 )
+        		{
+        			iCurrentAir = 300;
+        		}
+        		setAir( iCurrentAir + 1 );
+        	}
+        	else
+        	{
+        		setAir(300);
+        	}
+    	}
+    }
+    
+	@Override
+    public boolean isOnLadder()
+    {
+		return GetHealthPenaltyLevel() < 4 && super.isOnLadder();
+    }
+	
+	@Override
+    public boolean CanJump()
+    {		
+    	return health > 4 && foodStats.getFoodLevel() > 12 && (int)foodStats.getSaturationLevel() < 18;
+    }
+	
+	@Override
+    public boolean CanSwim()
+    {		
+    	return !isWeighted() && health > 4;
+    }
+	
+	@Override
+	protected int GetWornArmorWeight()
+	{
+		int iWeight = 0;
+		
+        for ( int iSlot = 0; iSlot < inventory.armorInventory.length; iSlot++ )
+        {
+        	ItemStack tempStack = inventory.armorInventory[iSlot];
+        	
+            if ( tempStack != null )
+            {
+                iWeight += tempStack.getItem().GetWeightWhenWorn();
+            }
+        }
+        
+		return iWeight;
+	}
+	
+	public float GetArmorExhaustionModifier()
+	{
+		float fModifier = 1.0F;
+		
+		int iWeight = GetWornArmorWeight();
+		
+		if ( iWeight > 0 )
+		{
+			// set to cap at a 2 times modifier with full plate armor
+			
+			fModifier += (float)iWeight / 44F;
+		}
+		
+		return fModifier;
+	}
+	
+	
+	public boolean IsWearingFullSuitSoulforgedArmor()
+	{
+        for ( int iSlot = 0; iSlot < inventory.armorInventory.length; iSlot++ )
+        {
+            if ( inventory.armorInventory[iSlot] == null || !( inventory.armorInventory[iSlot].getItem() instanceof FCItemArmorRefined ) )
+            {
+                return false;
+            }
+        }
+        
+		return true;
+	}
+	
+    protected boolean IsWearingSoulforgedHelm()
+	{
+        return inventory.armorInventory[3] != null && 
+        	inventory.armorInventory[3].getItem().itemID == 
+    		FCBetterThanWolves.fcItemPlateHelm.itemID;
+	}
+	
+    protected boolean IsWearingSoulforgedBoots()
+	{
+        return inventory.armorInventory[0] != null && 
+        	inventory.armorInventory[0].getItem().itemID == 
+    		FCBetterThanWolves.fcItemPlateBoots.itemID;
+	}
+    
+    public boolean IsWearingEnderSpectacles()
+    {
+        return inventory.armorInventory[3] != null && 
+        	inventory.armorInventory[3].getItem().itemID == 
+    		FCBetterThanWolves.fcItemEnderSpectacles.itemID;
+    }
+    
+	@Override
+    protected void playStepSound( int i, int j, int k, int iBlockID )
+    {
+		float fHealthAndExhaustionModifier = GetHealthAndExhaustionModifier();
+		
+		if ( fHealthAndExhaustionModifier < 0.26F )
+		{
+			// play grunting along with step
+			
+			float fGruntVolume = ( 1F - fHealthAndExhaustionModifier ) * 0.75F;
+			
+			worldObj.playSoundAtEntity( this, 
+        		"random.classic_hurt", 0.5F, 
+        		1F + rand.nextFloat() * 0.1F);
+		}
+		
+		if ( IsWearingSoulforgedBoots() )
+		{
+	        int iBlockAboveID = worldObj.getBlockId( i, j + 1, k );
+	        Block blockAbove = Block.blocksList[iBlockAboveID];
+	        
+	        if ( blockAbove != null && blockAbove.IsGroundCover( ) )
+	        {
+	        	StepSound stepSound = blockAbove.stepSound;
+	            
+	            worldObj.playSoundAtEntity( this, stepSound.getStepSound(), stepSound.getVolume() * 0.3F, stepSound.getPitch() * 0.75F );
+	        }
+	        else if ( !Block.blocksList[iBlockID].blockMaterial.isLiquid() )
+	        {
+		        StepSound stepSound = Block.blocksList[iBlockID].GetStepSound( worldObj, i, j, k );    	
+
+	            worldObj.playSoundAtEntity( this, stepSound.getStepSound(), stepSound.getVolume() * 0.3F, stepSound.getPitch() * 0.5F );
+	        }
+		}
+		else
+		{
+			super.playStepSound( i, j, k, iBlockID );
+		}
+    }
+
+	@Override
+    protected float GetHealthAndExhaustionModifier()
+    {
+		float fModifier = 1.0F;
+
+		int iPenaltyLevel = GetMaximumStatusPenaltyLevel();
+		
+		if ( iPenaltyLevel >= 2 )
+		{
+			if ( iPenaltyLevel >= 3 )
+			{
+				if ( iPenaltyLevel >= 4 )
+				{
+					fModifier = 0.25F;
+				}
+				else
+				{
+					fModifier = 0.5F;
+				}
+			} 
+			else
+			{
+				fModifier = 0.75F;
+			}
+		}
+		
+    	return fModifier;
+    }
+    
+    protected float GetHealthAndExhaustionModifierWithSightlessModifier()
+    {
+		float fModifier = GetHealthAndExhaustionModifier();
+		
+		if ( GetGloomLevel() > 0 )
+		{
+			fModifier *= 0.5F;
+		}
+		
+    	return fModifier;
+    }
+    
+	@Override
+    protected float GetSwimmingHorizontalModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+	@Override
+    protected float GetLandMovementModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+	@Override
+    protected float GetLadderVerticalMovementModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }    
+    
+	protected float GetJumpingHorizontalMovementModifier()        
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+	protected void SetMiningSpeedModifier( float fModifier )
+	{
+		if ( fModifier > 1F )
+		{
+			// cap it just in case the client sends an invalid speed to the server
+			
+			fModifier = 1F;
+		}
+		
+		m_fCurrentMiningSpeedModifier = fModifier;
+	}
+	
+    protected float GetMiningSpeedModifier()
+    {
+		return m_fCurrentMiningSpeedModifier;
+    }
+    
+    protected float UpdateMiningSpeedModifier()
+    {
+    	m_fCurrentMiningSpeedModifier = GetHealthAndExhaustionModifierWithSightlessModifier();
+    	
+    	return m_fCurrentMiningSpeedModifier;
+    }
+    
+    protected float GetMeleeDamageModifier()
+    {
+		return GetHealthAndExhaustionModifierWithSightlessModifier();
+    }
+    
+    public float GetBowPullStrengthModifier()
+    {
+    	return GetHealthAndExhaustionModifier();
+    }
+    
+	public boolean HasStatusPenalty()
+	{
+        return getHealth() <= 10 || foodStats.getFoodLevel() <= 24 || (int)foodStats.getSaturationLevel() >= 12;
+	}
+	
+	public int GetMaximumStatusPenaltyLevel()
+	{
+		int iMaximumPenaltyLevel = GetHealthPenaltyLevel();
+		int iHungerPenaltyLevel = GetHungerPenaltyLevel();
+		
+		if ( iHungerPenaltyLevel > iMaximumPenaltyLevel )
+		{
+			iMaximumPenaltyLevel = iHungerPenaltyLevel;
+		}
+		
+		int iFatPenaltyLevel = GetFatPenaltyLevel();
+		
+		if ( iFatPenaltyLevel > iMaximumPenaltyLevel )
+		{
+			iMaximumPenaltyLevel = iFatPenaltyLevel;
+		}
+		
+		return iMaximumPenaltyLevel;
+	}
+	
+    protected boolean IsCarryingBlastingOil()
+    {	
+    	return inventory.hasItem( FCBetterThanWolves.fcItemBlastingOil.itemID );
+    }
+    
+	protected void DetonateCarriedBlastingOil()
+	{
+		if ( !worldObj.isRemote )
+		{
+	    	int iHellfireCount = FCUtilsInventory.CountItemsInInventory( inventory, FCBetterThanWolves.fcItemHellfireDust.itemID, -1 );
+	    	
+	    	float fExplosionSize = ( iHellfireCount * 10.0F ) / 64.0F;
+	    	
+	    	fExplosionSize += ( FCUtilsInventory.CountItemsInInventory( inventory, Item.gunpowder.itemID, -1 ) * 10.0F ) / 64.0F;
+	    	
+	    	fExplosionSize += ( FCUtilsInventory.CountItemsInInventory( inventory, FCBetterThanWolves.fcItemBlastingOil.itemID, -1 ) * 10.0F ) / 64.0F;
+	    	
+	    	int iTNTCount = FCUtilsInventory.CountItemsInInventory( inventory, Block.tnt.blockID, -1 );
+	    	
+	    	if ( iTNTCount > 0 )
+	    	{
+	    		if ( fExplosionSize < 4.0F )
+	    		{
+	    			fExplosionSize = 4.0F;
+	    		}
+	    		
+	        	fExplosionSize += FCUtilsInventory.CountItemsInInventory( inventory, Block.tnt.blockID, -1 );
+	    	}
+	    	
+	    	if ( fExplosionSize < 1.5F )
+	    	{
+	    		fExplosionSize = 1.5F;
+	    	}
+	    	else if ( fExplosionSize > 10.0F )
+	    	{
+	    		fExplosionSize = 10.0F;
+	    	}
+	    	
+	    	FCUtilsInventory.ClearInventoryContents( inventory );
+	    	
+			health = 0;
+			
+			onDeath( DamageSource.generic );
+			
+	        worldObj.createExplosion( null, posX, posY, posZ, fExplosionSize, true );
+		}		
+	}
+	
+	@Override
+    protected void dropHead()
+    {
+        EntityItem skullEntity = entityDropItem( new ItemStack( Item.skull.itemID, 1, 3 ), 0.0F );
+        
+        if ( skullEntity != null )
+        {
+        	// client
+        	ItemStack stack = skullEntity.getEntityItem();
+        	// server
+        	//ItemStack stack = skullEntity.func_92059_d();
+        	
+            NBTTagCompound tag = stack.getTagCompound();
+
+            if ( tag == null)
+            {
+                tag = new NBTTagCompound();
+                
+                stack.setTagCompound( tag );
+            }
+
+            tag.setString( "SkullOwner", username );
+        }
+    }
+    
+    public boolean HasValidMagneticPointForLocation()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHasValidMagneticPointForLocationDataWatcherID ) > 0;
+    }
+    
+    public int GetStongestMagneticPointForLocationI()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iStongestMagneticPointForLocationIDataWatcherID );
+    }
+    
+    public int GetStongestMagneticPointForLocationK()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iStongestMagneticPointForLocationKDataWatcherID );
+    }
+    
+    public void SetHasValidMagneticPointForLocation( boolean bValid )
+    {
+    	byte bValidByte = 0;
+    	
+    	if ( bValid )
+    	{
+    		bValidByte = 1;
+    	}
+    	
+        dataWatcher.updateObject( m_iHasValidMagneticPointForLocationDataWatcherID, Byte.valueOf( bValidByte ) );
+    }
+    
+    public void SetStongestMagneticPointForLocationI( int iLocationI )
+    {
+        dataWatcher.updateObject( m_iStongestMagneticPointForLocationIDataWatcherID, Integer.valueOf( iLocationI ) );
+    }
+    
+    public void SetStongestMagneticPointForLocationK( int iLocationK )
+    {
+        dataWatcher.updateObject( m_iStongestMagneticPointForLocationKDataWatcherID, Integer.valueOf( iLocationK ) );
+    }
+    
+    public int GetGloomLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iGloomLevelDataWatcherID );
+    }
+    
+    public void SetGloomLevel( int iGloomLevel )
+    {
+        dataWatcher.updateObject( m_iGloomLevelDataWatcherID, Byte.valueOf( (byte)iGloomLevel ) );
+    }
+    
+    public int GetFatPenaltyLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iFatPenaltyLevelDataWatcherID );
+    }
+    
+    public void SetFatPenaltyLevel( int iPenaltyLevel )
+    {
+        dataWatcher.updateObject( m_iFatPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
+    }
+    
+    public int GetHungerPenaltyLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHungerPenaltyLevelDataWatcherID );
+    }
+    
+    public void SetHungerPenaltyLevel( int iPenaltyLevel )
+    {
+        dataWatcher.updateObject( m_iHungerPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
+    }
+    
+    public int GetHealthPenaltyLevel()
+    {
+        return dataWatcher.getWatchableObjectByte( m_iHealthPenaltyLevelDataWatcherID );
+    }
+    
+    public void SetHealthPenaltyLevel( int iPenaltyLevel )
+    {
+        dataWatcher.updateObject( m_iHealthPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
+    }
+    
+    public int GetSpawnChunksVisualizationLocationI()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationIDataWatcherID );
+    }
+    
+    public int GetSpawnChunksVisualizationLocationJ()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationJDataWatcherID );
+    }
+    
+    public int GetSpawnChunksVisualizationLocationK()
+    {
+        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationKDataWatcherID );
+    }
+    
+    public void SetSpawnChunksVisualization( int iLocationI, int iLocationJ, int iLocationK )
+    {
+        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationIDataWatcherID, 
+        	Integer.valueOf( iLocationI ) );
+        
+        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationJDataWatcherID, 
+        	Integer.valueOf( iLocationJ ) );
+        
+        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationKDataWatcherID, 
+        	Integer.valueOf( iLocationK ) );
+    }
+    
+    public boolean HasRespawnCoordinates()
+    {
+    	return spawnChunk != null;
+    }
+    
+    /*
+     * returns zero if a valid spawn location is found
+     * 1 = invalid forced spawn location
+     * 2 = missing beacon
+     * 3 = Beacon is out of range
+     * 4 = Area around beacon is obstructed
+     */
+    public int GetValidatedRespawnCoordinates( World newWorld, ChunkCoordinates respawnLocation )
+    {
+    	int iReturnValue = 0;
+    	
+    	int iOldDimension = dimension;
+    	int iNewDimension = m_iSpawnDimension;
+    	
+        IChunkProvider chunkProvider = newWorld.getChunkProvider();
+        
+        ChunkCoordinates validatedCoords = null;
+        
+        chunkProvider.loadChunk( spawnChunk.posX - 4 >> 4, spawnChunk.posZ - 4 >> 4 );
+        chunkProvider.loadChunk( spawnChunk.posX + 4 >> 4, spawnChunk.posZ - 4 >> 4 );
+        chunkProvider.loadChunk( spawnChunk.posX - 4 >> 4, spawnChunk.posZ + 4 >> 4 );
+        chunkProvider.loadChunk( spawnChunk.posX + 4 >> 4, spawnChunk.posZ + 4 >> 4 );
+
+        if ( spawnForced )
+        {
+            Material targetMaterial = newWorld.getBlockMaterial( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ );
+            Material aboveTargetMaterial = newWorld.getBlockMaterial( spawnChunk.posX, spawnChunk.posY + 1, spawnChunk.posZ );
+            
+            boolean bValidTarget = !targetMaterial.isSolid() && !targetMaterial.isLiquid();
+            boolean bValidAboveTarget = !aboveTargetMaterial.isSolid() && !aboveTargetMaterial.isLiquid();
+            
+            if ( IsValidRespawnLocation( newWorld, spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ ) )
+            {
+            	validatedCoords = spawnChunk;
+            }
+            else
+            {
+            	iReturnValue = 1;
+            }
+        }
+        else
+        {        
+    		iReturnValue = 2;
+    		
+	        if ( newWorld.getBlockId( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ ) == Block.beacon.blockID )
+	        {
+	        	FCTileEntityBeacon beaconEnt = (FCTileEntityBeacon)newWorld.getBlockTileEntity( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ );
+	        	
+	        	if ( beaconEnt != null )
+	        	{
+	        		int iBeaconEffect = beaconEnt.getPrimaryEffect();
+	        		
+	        		if ( iBeaconEffect == FCTileEntityBeacon.m_iEffectIDSpawnPoint )
+	        		{
+	        			int iBeaconPowerLevel = beaconEnt.getLevels();
+	        		
+	        			if ( iBeaconPowerLevel > 0 )
+	        			{
+	        				iReturnValue = 3;
+	        				
+		        			if ( iBeaconPowerLevel >= 4 || iOldDimension == iNewDimension )
+		        			{
+		        				boolean bInRange = true;
+		        				
+		        				if ( iBeaconPowerLevel < 3 )
+		        				{
+		        					int iMaxRange = 160;
+		        					
+		        					if ( iBeaconPowerLevel == 2 )
+		        					{
+		        						iMaxRange = 2000;
+		        					}
+		        					
+		        					int iDeltaX = Math.abs( (int)posX - spawnChunk.posX );
+		        					
+		        					if ( iDeltaX > iMaxRange )
+		        					{
+		        						bInRange = false;
+		        					}
+		        					else
+		        					{
+			        					int iDeltaZ = Math.abs( (int)posZ - spawnChunk.posZ );
+			        					
+			        					if ( iDeltaZ > iMaxRange )
+			        					{
+			        						bInRange = false;
+			        					}
+		        					}
+		        				}
+		        				
+		        				if ( bInRange )
+		        				{	        				
+		        					validatedCoords = GetRandomValidSpawnAroundBeaconLocation( newWorld, spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ, iBeaconPowerLevel );
+		        					
+		        					if ( validatedCoords != null )
+		        					{
+		        						iReturnValue = 0;
+		        						beaconEnt.m_bPlayerRespawnedAtBeacon = true;
+		        					}
+		        					else
+		        					{
+		        						iReturnValue = 4;
+		        					}
+		        				}
+		        			}
+	        			}
+	        		}
+	        	}
+	        }
+	        
+	        if ( validatedCoords != null )
+	        {
+	        	respawnLocation.posX = validatedCoords.posX;
+	        	respawnLocation.posY = validatedCoords.posY;
+	        	respawnLocation.posZ = validatedCoords.posZ;
+	        }
+        }
+        
+        return iReturnValue;
+    }
+    
+    private boolean IsValidRespawnLocation( World world, int i, int j, int k )
+    {
+        Material targetMaterial = world.getBlockMaterial( i, j, k );
+        Material aboveTargetMaterial = world.getBlockMaterial( i, j + 1, k );
+        
+        boolean bValidTarget = !targetMaterial.isSolid() && !targetMaterial.isLiquid();
+        boolean bValidAboveTarget = !aboveTargetMaterial.isSolid() && !aboveTargetMaterial.isLiquid();
+        
+        return bValidTarget && bValidAboveTarget;
+	}
+    
+    private ChunkCoordinates GetRandomValidSpawnAroundBeaconLocation( World world, int i, int j, int k, int iBeaconLevel )
+    {
+    	for ( int iAttempt = 0; iAttempt < 20; iAttempt++ )
+    	{
+    		int iDistance = rand.nextInt( iBeaconLevel ) + 1;    		
+    		
+    		// generate a random point around the edge at the specified distance
+    		
+    		int iPrimaryOffset = rand.nextInt( 2 ) * iDistance;
+    		
+			if ( rand.nextInt( 2 ) == 0 )
+			{
+				iPrimaryOffset = -iPrimaryOffset;
+			}
+			
+    		int iSecondaryOffset = rand.nextInt( iBeaconLevel * 2 + 1 ) - iBeaconLevel;
+    		
+    		int iXOffset = iPrimaryOffset; 
+			int iYOffset = -( iDistance - 1 );
+    		int iZOffset = iSecondaryOffset;
+    		
+			if ( rand.nextInt( 2 ) == 0 )
+			{
+	    		iXOffset = iSecondaryOffset;
+	    		iZOffset = iPrimaryOffset;
+			}
+			
+			int iISpawn = i + iXOffset;
+			int iJSpawn = j + iYOffset;
+			int iKSpawn = k + iZOffset;
+			
+        	if ( world.doesBlockHaveSolidTopSurface( iISpawn, iJSpawn - 1, iKSpawn ) && IsValidRespawnLocation( world, iISpawn, iJSpawn, iKSpawn ) )
+        	{
+                return new ChunkCoordinates( iISpawn, iJSpawn, iKSpawn );
+            }
+    	}
+    	
+        return null;
+    }
+
+    // overloaded vanilla function with added dimension param
+    public void setSpawnChunk( ChunkCoordinates coords, boolean bForced, int iDimension )
+    {
+        if ( coords != null )
+        {
+            spawnChunk = new ChunkCoordinates(coords);
+            spawnForced = bForced;
+            m_iSpawnDimension = iDimension;
+        }
+        else
+        {
+            spawnChunk = null;
+            spawnForced = false;
+            m_iSpawnDimension = 0;            
+        }        
+    }
+    
+	public void AddRawChatMessage( String message )
+	{
+	}
+	
+	boolean IsCurrentToolEffectiveOnBlock( Block targetBlock, int i, int j, int k )
+	{
+        float var2 = 1.0F;
+
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+            return currentItemStack.getItem().IsEfficientVsBlock( currentItemStack, worldObj, targetBlock, i, j, k );
+        }
+
+		return false;
+	}
+    
+    public boolean canHarvestBlock( Block par1Block, int i, int j, int k )
+    {
+        return this.inventory.canHarvestBlock( worldObj, par1Block, i, j, k );
+    }
+    
+    public boolean AddStackToCurrentHeldStackIfEmpty( ItemStack stack )
+    {
+    	if ( getCurrentEquippedItem() == null )
+    	{
+    		inventory.setInventorySlotContents( inventory.currentItem, stack.copy() );
+    		
+    		return true;
+    	}
+    	
+    	return false;
+    }    
+    	
+    protected void UpdateModStatusVariables()
+    {
+    	UpdateGloomState();
+    	
+    	UpdateHungerPenaltyLevel();
+    	
+    	UpdateFatPenaltyLevel();
+    	
+    	UpdateHealthPenaltyLevel();
+    }
+
+    protected void UpdateGloomState() {}
+    
+	protected void UpdateHungerPenaltyLevel() {}
+	
+    protected void UpdateFatPenaltyLevel() {}
+	
+	protected void UpdateHealthPenaltyLevel() {}
+	
+	protected void OnBlockedDamage( DamageSource source, int iDamage )
+	{
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+        	currentItemStack.damageItem( 1, this );
+        }
+	}
+	
+    @Override
+    public double getMountedYOffset()
+    {
+        return (double)height * 0.025D;
+    }
+    
+    public void AddExhaustionWithoutVisualFeedback( float fAmount )
+    {
+        addExhaustion( fAmount );
+    }
+    
+    public void AddHarvestBlockExhaustion( int iBlockID, int iBlockI, int iBlockJ, int iBlockK, int iBlockMetadata )
+    {
+    	float fExhaustionConsumed = 0.025F; // default exhaustion amount
+    	
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+        	fExhaustionConsumed = currentItemStack.getItem().GetExhaustionOnUsedToHarvestBlock( iBlockID, worldObj, iBlockI, iBlockJ, iBlockK, iBlockMetadata );
+        }
+    	
+    	if ( fExhaustionConsumed > 0F )
+    	{
+    		addExhaustion( fExhaustionConsumed );
+    	}
+    }
+    
+    protected void OnZeroDamageAttack()
+    {
+    }
+    
+    protected boolean IsPlayerHoldingSail()
+    {
+        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
+        
+        if ( currentItemStack != null )
+        {
+    		return currentItemStack.itemID == FCBetterThanWolves.fcItemWindMillBlade.itemID;
+        }
+        
+        return false;
+    }
+    
+    @Override
+	public boolean AppliesConstantForceWhenRidingBoat()
+	{
+		return IsPlayerHoldingSail();
+	}
+	
+    @Override
+	public double MovementModifierWhenRidingBoat()
+	{
+        double dModifier = 0.35D;
+        
+        if ( IsPlayerHoldingSail() )
+        {
+			dModifier = 1.0D;
+    	}
+        
+		return dModifier;
+	}
+
+    @Override
+    public void unmountEntity( Entity riddenEntity )
+    {
+        double dUnmountX = posX;
+        double dUnmountY = posY;
+        double dUnmountZ = posZ;
+
+        if (riddenEntity != null)
+        {
+            dUnmountX = riddenEntity.posX;
+            dUnmountY = riddenEntity.boundingBox.minY + (double)riddenEntity.height;
+            dUnmountZ = riddenEntity.posZ;
+        }
+        
+        double dLookOffsetX = -MathHelper.cos( ( rotationYaw - 90 ) * (float)Math.PI / 180.0F );
+        double dLookOffsetZ = -MathHelper.sin( ( rotationYaw - 90 ) * (float)Math.PI / 180.0F );
+        
+        int iMaxSuitability = 0;
+        
+        for ( double dTempLookOffset = 2.0D; dTempLookOffset > 0.1D; dTempLookOffset -= 0.5D )
+        {
+        	double dTempXOffset = dLookOffsetX * dTempLookOffset;
+        	double dTempZOffset = dLookOffsetZ * dTempLookOffset;
+        	
+        	int iTempSuitability = GetDismountLocationSuitability( dTempXOffset, dTempZOffset );
+        	
+        	if (  iTempSuitability > iMaxSuitability )
+        	{
+                dUnmountX = posX + dTempXOffset;
+                dUnmountY = posY + 1.0D;
+                dUnmountZ = posZ + dTempZOffset;
+                
+                iMaxSuitability = iTempSuitability;
+        	}
+        }
+        
+        if ( iMaxSuitability <= 0 )
+        {
+	        for ( double dTempXOffset = -1.5D; dTempXOffset < 2.0D; ++dTempXOffset )
+	        {
+	            for ( double dTempZOffset = -1.5D; dTempZOffset < 2.0D; ++dTempZOffset )
+	            {
+	            	int iTempSuitability = GetDismountLocationSuitability( dTempXOffset, dTempZOffset );
+	            	
+	            	if (  iTempSuitability > iMaxSuitability )
+	            	{
+	                    dUnmountX = posX + dTempXOffset;
+	                    dUnmountY = posY + 1.0D;
+	                    dUnmountZ = posZ + dTempZOffset;
+	                    
+	                    iMaxSuitability = iTempSuitability;
+	            	}
+	            }
+	        }
+        }
+
+        setLocationAndAngles(dUnmountX, dUnmountY, dUnmountZ, this.rotationYaw, this.rotationPitch);
+    }
+    
+    private boolean IsSolidBlockToDismountOn( int i, int j, int k )
+    {
+    	return worldObj.doesBlockHaveSolidTopSurface( i , j, k )  || worldObj.getBlockMaterial( i, j, k ) == Material.ice;    
+	}
+    
+    /**
+     * Returns a value of zero or higher, with larger numbers indicating greater suitability
+     */
+    private int GetDismountLocationSuitability( double dPosOffsetX, double dPosOffsetZ )
+    {
+    	int i = MathHelper.floor_double( posX + dPosOffsetX );
+    	int j = MathHelper.floor_double( posY ); 
+    	int k = MathHelper.floor_double( posZ + dPosOffsetZ );
+    	
+        AxisAlignedBB dTempBoundingBox = boundingBox.getOffsetBoundingBox( dPosOffsetX, 1.0D, dPosOffsetZ );
+
+        if ( worldObj.getCollidingBlockBounds( dTempBoundingBox ).isEmpty() )
+        {
+	        if ( IsSolidBlockToDismountOn( i, j, k ) )
+	        {
+	            return 3;
+	        }
+	        else if ( IsSolidBlockToDismountOn( i, j - 1, k ) )
+	        {
+	            return 2;
+	            
+	        }
+	        else if ( worldObj.getBlockMaterial( i, j - 1, k ) == Material.water )
+	        {
+	        	return 1;
+	        }
+        }
+        
+        return 0;
+    }
+    
+    public void AddExhaustionForJump()
+    {
+	    if ( isSprinting() )
+	    {
+			addExhaustion( m_fExhaustionJumpingSprinting );
+	    }
+	    else
+	    {
+			addExhaustion( m_fExhaustionJumping );
+	    }
+    }
+    
+    public void SetItemInUseCount( int iCount )
+    {
+        itemInUseCount = iCount;
+    }
+    
+    @Override
+    public boolean GetCanBeHeadCrabbed( boolean bSquidInWater )
+    {
+    	return isEntityAlive() && !capabilities.disableDamage && 
+			riddenByEntity == null && ridingEntity == null;
+    }
+    
+    @Override
+    public boolean IsValidOngoingAttackTargetForSquid()
+    {
+    	return isEntityAlive();
+    }
+    
+    @Override
+	public boolean IsImmuneToHeadCrabDamage()
+	{
+		return IsWearingSoulforgedHelm();
+	}
+    
+    public boolean IsLocalPlayerAndHittingBlock()
+    {
+    	return false;
+    }
+	
+    @Override
+    public void MountEntityRemote( Entity entityToMount )
+    {
+    	// Fix described in MC-1291 for players dissapearing after riding boats in SMP
+    	// Bypasses toggle type behavior of mounting and dismounting if multiple packets
+    	// are received for a player.
+    	
+    	if ( ridingEntity != entityToMount )
+    	{
+    		super.mountEntity( entityToMount );
+    	}
+    }
+    
+    public boolean CanDrink()
+    {
+        return !isPotionActive( Potion.hunger );
+    }
+    
+    public void OnCantConsume()
+    {
+    	if ( !worldObj.isRemote && m_iTicksSinceEmoteSound >= m_iTicksBetweenEmoteSounds )    		
+    	{    		
+            worldObj.playAuxSFX( FCBetterThanWolves.m_iEatFailAuxFXID,           
+            	MathHelper.floor_double( posX ), 
+            	MathHelper.floor_double( posY ), 
+            	MathHelper.floor_double( posZ ), 0 );    
+            
+            m_iTicksSinceEmoteSound = 0;
+    	}
+    }
+    
+    static public boolean InstallationIntegrityTestPlayer()
+    {
+    	return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityPlayerMP.java b/minecraft_server/net/minecraft/src/EntityPlayerMP.java
index 867cf20..c7cf032 100644
--- a/minecraft_server/net/minecraft/src/EntityPlayerMP.java
+++ b/minecraft_server/net/minecraft/src/EntityPlayerMP.java
@@ -33,6 +33,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     public double managedPosZ;
 
     /** LinkedList that holds the loaded chunks. */
+    /**
+     * FCNOTE: Deprecated list used by vanilla PlayerInstance and PlayerManager to track watched
+     * chunks
+     */
     public final List loadedChunks = new LinkedList();
 
     /** entities added to this list will  be packet29'd to the player */
@@ -188,6 +192,8 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
             this.playerNetServerHandler.sendPacket(new Packet29DestroyEntity(var2));
         }
 
+        // FCMOD: Changed
+        /*
         if (!this.loadedChunks.isEmpty())
         {
             ArrayList var6 = new ArrayList();
@@ -209,23 +215,30 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
             if (!var6.isEmpty())
             {
                 this.playerNetServerHandler.sendPacket(new Packet56MapChunks(var6));
-                Iterator var10 = var8.iterator();
+                Iterator var11 = var8.iterator();
 
-                while (var10.hasNext())
+                while (var11.hasNext())
                 {
-                    TileEntity var5 = (TileEntity)var10.next();
+                    TileEntity var5 = (TileEntity)var11.next();
                     this.getTileEntityInfo(var5);
                 }
 
-                var10 = var6.iterator();
+                var11 = var6.iterator();
 
-                while (var10.hasNext())
+                while (var11.hasNext())
                 {
-                    Chunk var11 = (Chunk)var10.next();
-                    this.getServerForPlayer().getEntityTracker().func_85172_a(this, var11);
+                    Chunk var10 = (Chunk)var11.next();
+                    this.getServerForPlayer().getEntityTracker().func_85172_a(this, var10);
                 }
             }
         }
+        */
+        SendChunksToClient();
+        // END FCMOD
+
+        // FCMOD: Code Added
+        ModSpecificOnUpdate();
+        // END FCMOD
     }
 
     public void setEntityHealth(int par1)
@@ -262,12 +275,21 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
                 }
             }
 
+        	// FCMOD: Code changed to relay changes in food saturation
+        	/*
             if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry)
+        	*/
+        	if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry ||
+        		m_iLastFoodSaturation != (int)( foodStats.getSaturationLevel() * 8F ) )
+    		// END FCMOD
             {
                 this.playerNetServerHandler.sendPacket(new Packet8UpdateHealth(this.getHealth(), this.foodStats.getFoodLevel(), this.foodStats.getSaturationLevel()));
                 this.lastHealth = this.getHealth();
                 this.lastFoodLevel = this.foodStats.getFoodLevel();
                 this.wasHungry = this.foodStats.getSaturationLevel() == 0.0F;
+            	// FCMOD: Code added
+            	m_iLastFoodSaturation = (int)( foodStats.getSaturationLevel() * 8F );
+            	// END FCMOD
             }
 
             if (this.experienceTotal != this.lastExperience)
@@ -297,6 +319,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
             this.inventory.dropAllItems();
         }
 
+        // FCMOD: Code added
+        CustomModDrops( par1DamageSource );
+        // END FCMOD
+
         Collection var2 = this.worldObj.getScoreboard().func_96520_a(ScoreObjectiveCriteria.field_96642_c);
         Iterator var3 = var2.iterator();
 
@@ -402,7 +428,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     /**
      * gets description packets from all TileEntity's that override func_20070
      */
-    private void getTileEntityInfo(TileEntity par1TileEntity)
+    // FCMOD: Changed (server only) to match name on client
+    //private void getTileEntityInfo(TileEntity par1TileEntity)
+    private void sendTileEntityToPlayer(TileEntity par1TileEntity)
+    // END FCMOD
     {
         if (par1TileEntity != null)
         {
@@ -499,7 +528,10 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     {
         this.getNextWindowId();
         this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, 1, "Crafting", 9, true));
-        this.openContainer = new ContainerWorkbench(this.inventory, this.worldObj, par1, par2, par3);
+        // FCMOD: Changed
+        //this.openContainer = new ContainerWorkbench(this.inventory, this.worldObj, par1, par2, par3);
+        openContainer = new FCContainerWorkbench( inventory, worldObj, par1, par2, par3 );
+        // END FCMOD
         this.openContainer.windowId = this.currentWindowId;
         this.openContainer.onCraftGuiOpened(this);
     }
@@ -613,9 +645,16 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
         this.getNextWindowId();
         this.openContainer = new ContainerMerchant(this.inventory, par1IMerchant, this.worldObj);
         this.openContainer.windowId = this.currentWindowId;
+        // FCMOD: Code moved slightly later to avoid init order problems
+        /*
         this.openContainer.onCraftGuiOpened(this);
+        */
+        // END FCMOD
         InventoryMerchant var3 = ((ContainerMerchant)this.openContainer).getMerchantInventory();
         this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, 6, par2Str == null ? "" : par2Str, var3.getSizeInventory(), par2Str != null));
+        // FCMOD: Code moved from above to avoid init order problems
+        this.openContainer.onCraftGuiOpened(this);
+        // END FCMOD
         MerchantRecipeList var4 = par1IMerchant.getRecipes(this);
 
         if (var4 != null)
@@ -929,4 +968,560 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     {
         return new ChunkCoordinates(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + 0.5D), MathHelper.floor_double(this.posZ));
     }
+
+    // FCMOD: Added
+    public LinkedList<ChunkCoordIntPair> m_chunksToBeSentToClient = 
+    	new LinkedList<ChunkCoordIntPair>();
+    
+    private int m_iLastFoodSaturation = -99999999;
+	private int m_iExhaustionWithTimeCounter = 0;
+	
+	private static final int m_iExhaustionWithTimePeriod = 600; // once per 30 seconds
+	private static final float m_fExhaustionWithTimeAmount = 0.5F; // set with above to begin starving to death after 160 minutes if you're fully obese, losing 1 hunger every 4 minutes	
+    
+    private static final float m_fMinimumGloomBiteChance = 0.01F; 
+    private static final float m_fMaximumGloomBiteChance = 0.05F; // 1/second
+    
+	private static final int m_iDelayBetweenZeroDamageAttackSounds = 20; 
+	private long m_lTimeOfLastZeroDamageAttackSound = 0;
+	
+    @Override
+    protected void CheckForHeadDrop( DamageSource source, int iLootingModifier )
+    {
+	    Entity sourceEntity = source.getEntity();        
+	    int iHeadChance = this.rand.nextInt(200);        
+	    
+        iHeadChance -= iLootingModifier;
+    	
+	    if ( sourceEntity instanceof EntityPlayer)
+	    {
+	    	if ( ((EntityPlayer)sourceEntity).getHeldItem() != null && 
+	    		((EntityPlayer)sourceEntity).getHeldItem().getItem().itemID == FCBetterThanWolves.fcItemBattleAxe.itemID )
+	    	{
+	    		// 100% chance of decapitation with Battle Axe in PvP
+	    		
+	    		iHeadChance = 0;
+	    	}
+	    }
+	    else if ( source == FCDamageSourceCustom.m_DamageSourceChoppingBlock )
+	    {
+			iHeadChance = 0;
+	    }
+	    
+	    if ( iHeadChance < 5 )
+	    {
+	        dropHead();
+	    }
+    }
+    
+    private void CustomModDrops( DamageSource source )
+    {
+	    Entity sourceEntity = source.getEntity();        
+        int iLootingModifier = GetAmbientLootingModifier();
+
+        if ( sourceEntity instanceof EntityPlayer )
+        {
+            int iPlayerLootingModifier = EnchantmentHelper.getLootingModifier((EntityLiving)sourceEntity);
+            
+            if ( iPlayerLootingModifier > iLootingModifier )
+            {
+            	iLootingModifier = iPlayerLootingModifier;
+            }
+        }
+        
+        DropMysteryMeat( iLootingModifier );
+        
+        CheckForHeadDrop( source, iLootingModifier );
+    }
+    
+    private void DropMysteryMeat( int iLootingModifier )
+    {
+        if ( !HasHeadCrabbedSquid() )
+        {
+	    	// only drop mystery meat periodically to prevent people killing themselves repeatedly for food.
+	    	// With HC Spawn enabled, it only happens when the player will be moved to a new spawn location.
+	    	
+			long lOverworldTime = MinecraftServer.getServer().worldServers[0].getWorldTime();
+			
+			if ( m_lTimeOfLastSpawnAssignment == 0 || m_lTimeOfLastSpawnAssignment > lOverworldTime || 
+				lOverworldTime - m_lTimeOfLastSpawnAssignment >= FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
+			{
+				int iDropItemID = FCBetterThanWolves.fcItemRawMysteryMeat.itemID;
+				
+				if ( isBurning() )
+				{
+					iDropItemID = FCBetterThanWolves.fcItemMeatBurned.itemID;
+				}
+		    	
+		        int iFat = ( (int)foodStats.getSaturationLevel() ) / 2;
+		        
+		        int iNumDropped = 1 + iFat;
+		
+		        for ( int iTempCount = 0; iTempCount < iNumDropped; ++iTempCount )
+		        {        	
+		            dropItem( iDropItemID, 1 );
+		        }
+			}
+        }
+    }
+    
+    private void ModSpecificOnUpdate()
+    {
+        UpdateExhaustionWithTime();
+        
+        UpdateHealthAndHungerEffects();
+        
+        UpdateMagneticInfluences();
+        
+        UpdateSpawnChunksVisualization();
+        
+    	NotifyBlockWalkedOn();
+    }
+    
+	private void UpdateMagneticInfluences()
+	{
+		if ( ( worldObj.getTotalWorldTime() + entityId ) % 40 != 0 )
+		{
+			// stagger these updates as they can be performance intensive
+			 
+			return;
+		}
+		 
+		FCMagneticPoint strongestPoint = null;
+		double dStrongestFieldStrength = 0.0D;
+		 
+	    if ( worldObj.provider.isSurfaceWorld() )
+	    {
+	    	ChunkCoordinates spawnPos = worldObj.getSpawnPoint();
+	    	 
+	    	strongestPoint = new FCMagneticPoint( spawnPos.posX, 0, spawnPos.posZ, 2 );
+	    	 
+	    	dStrongestFieldStrength = strongestPoint.GetFieldStrengthRelativeToPosition( posX, posZ );
+	    	 
+	        Iterator pointIterator = worldObj.GetMagneticPointList().m_MagneticPoints.iterator();
+	         
+	        while ( pointIterator.hasNext() )
+	        {
+	        	FCMagneticPoint tempPoint = (FCMagneticPoint)pointIterator.next();
+	        	 
+	        	double dTempFieldStrength = tempPoint.GetFieldStrengthRelativeToPosition( posX, posZ );
+	        	 
+	        	if ( dTempFieldStrength > dStrongestFieldStrength )
+	        	{
+	        		strongestPoint = tempPoint;
+	        		dStrongestFieldStrength = dTempFieldStrength;
+	        	}
+	        }
+	    }
+	    else
+	    {
+	        Iterator pointIterator = worldObj.GetMagneticPointList().m_MagneticPoints.iterator();
+	         
+	        while ( pointIterator.hasNext() )
+	        {
+	        	FCMagneticPoint tempPoint = (FCMagneticPoint)pointIterator.next();
+	        	 
+	        	double dTempFieldStrength = tempPoint.GetFieldStrengthRelativeToPositionWithBackgroundNoise( posX, posZ );
+	        	 
+	        	if ( dTempFieldStrength > dStrongestFieldStrength )
+	        	{
+	        		strongestPoint = tempPoint;
+	        		dStrongestFieldStrength = dTempFieldStrength;
+	        	}
+	        }
+	    }         
+	     
+	    if ( strongestPoint != null )
+	    {
+	    	SetHasValidMagneticPointForLocation( true );
+	    	SetStongestMagneticPointForLocationI( strongestPoint.m_iIPos );
+	    	SetStongestMagneticPointForLocationK( strongestPoint.m_iKPos );
+	    }
+	    else
+	    {
+	    	SetHasValidMagneticPointForLocation( false );
+	    }
+	}
+	
+	private void UpdateSpawnChunksVisualization()
+	{
+		if ( worldObj.provider.dimensionId == 0 && ( IsWearingEnderSpectacles() || 
+			isPotionActive( FCBetterThanWolves.potionTrueSight ) ) )
+		{
+			SetSpawnChunksVisualization( worldObj.worldInfo.getSpawnX(),
+				worldObj.worldInfo.getSpawnY(), worldObj.worldInfo.getSpawnZ() );
+		}
+		else
+		{
+			SetSpawnChunksVisualization( 0, 0, 0 );
+		}
+	}
+	
+    private void UpdateExhaustionWithTime()
+    {
+    	m_iExhaustionWithTimeCounter++;
+    	
+    	if ( m_iExhaustionWithTimeCounter >= m_iExhaustionWithTimePeriod )
+    	{
+            if ( !capabilities.disableDamage ) // disable hunger drain in creative
+            {
+            	foodStats.addExhaustion( m_fExhaustionWithTimeAmount );
+            }
+            
+    		m_iExhaustionWithTimeCounter = 0;
+    	}
+    }
+    
+    private void UpdateHealthAndHungerEffects()
+    {
+    	if ( !isDead && ( worldObj.getTotalWorldTime() + (long)entityId ) % 80L == 0L )
+    	{
+    		if ( foodStats.getFoodLevel() <= 0 && foodStats.getSaturationLevel() <= 0F )
+    		{
+                addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
+    		}
+    		
+    		if ( health <= 2 )
+    		{
+                addPotionEffect( new PotionEffect( Potion.blindness.getId(), 180, 0, true ) );                            
+    		}
+    	}
+    }
+    
+    @Override
+    protected void UpdateGloomState()
+    {
+    	if ( !isDead )
+    	{
+    		if ( IsInGloom() )
+    		{
+    			m_iInGloomCounter++;
+    			
+    			if ( GetGloomLevel() == 0 || ( m_iInGloomCounter > m_iGloomCounterBetweenStateChanges && GetGloomLevel() < 3 ) )
+    			{
+    				SetGloomLevel( GetGloomLevel() + 1 );
+    				
+    				m_iInGloomCounter = 0;
+    			}
+    			
+    			if ( GetGloomLevel() >= 3 )
+    			{
+    		    	if ( ( worldObj.getTotalWorldTime() + (long)entityId ) % 80L == 0L )
+    		    	{
+		                addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
+    		    	}
+    		    	
+    		    	// gloom bites
+    		    	
+    	    		float fCounterProgress = (float)m_iInGloomCounter / (float)m_iGloomCounterBetweenStateChanges;
+    	    		
+    	    		if ( fCounterProgress > 1.0F )
+    	    		{
+    	    			fCounterProgress = 1.0F;
+    	    		}
+
+            		float fGloomBiteChance = m_fMinimumGloomBiteChance + ( m_fMaximumGloomBiteChance - m_fMinimumGloomBiteChance ) * fCounterProgress;        		
+    	    		
+            		if ( rand.nextFloat() < fGloomBiteChance )
+            		{
+            			if ( attackEntityFrom( FCDamageSourceCustom.m_DamageSourceGloom, 1 ) )
+            			{            			
+	            			if ( health <= 0 )
+	            			{
+	            	        	worldObj.playAuxSFX( FCBetterThanWolves.m_iBurpSoundAuxFXID, 
+	            	        		MathHelper.floor_double( posX ), MathHelper.floor_double( posY ), MathHelper.floor_double( posZ ), 0 );
+	            			}
+            			}
+            		}
+		    	}
+    		}
+    		else
+    		{
+        		SetGloomLevel( 0 );
+        		
+        		m_iInGloomCounter = 0;
+    		}   		    		
+    	}
+    }
+
+    @Override
+    protected void UpdateFatPenaltyLevel()
+    {
+        int iFat = (int)foodStats.getSaturationLevel();
+    	int iFatLevel = 4;
+        
+        if ( iFat < 12 )
+        {
+        	iFatLevel = 0;
+        }
+        else if ( iFat < 14 )
+        {
+        	iFatLevel = 1;
+        }
+        else if ( iFat < 16 )
+        {
+        	iFatLevel = 2;
+        }
+        else if ( iFat < 18 )
+        {
+        	iFatLevel = 3;
+        }
+    	
+    	SetFatPenaltyLevel( iFatLevel );
+    }
+	
+    @Override
+	protected void UpdateHungerPenaltyLevel()
+	{
+        int iHunger = foodStats.getFoodLevel();
+        int iPenaltyLevel = 5;
+        
+        if ( iHunger > 24 )
+        {
+        	iPenaltyLevel = 0;
+        }
+        else if ( iHunger > 18 )
+        {
+        	iPenaltyLevel = 1;
+        }
+        else if ( iHunger > 12 )
+        {
+        	iPenaltyLevel = 2;
+        }
+        else if ( iHunger > 6 )
+        {
+        	iPenaltyLevel = 3;
+        }
+        else if ( iHunger > 0 || foodStats.getSaturationLevel() > 0F )
+        {
+        	iPenaltyLevel = 4;
+        }
+        
+        SetHungerPenaltyLevel( iPenaltyLevel );
+	}
+	
+    @Override
+	protected void UpdateHealthPenaltyLevel()
+	{
+		int iHealth = getHealth();
+        int iPenaltyLevel = 5;
+        
+        if ( iHealth > 10 )
+        {
+        	iPenaltyLevel = 0;
+        }
+        else if ( iHealth > 8 )
+        {
+        	iPenaltyLevel = 1;
+        }
+        else if ( iHealth > 6 )
+        {
+        	iPenaltyLevel = 2;
+        }
+        else if ( iHealth > 4 )
+        {
+        	iPenaltyLevel = 3;
+        }
+        else if ( iHealth > 2 )
+        {
+        	iPenaltyLevel = 4;
+        }
+        
+        SetHealthPenaltyLevel( iPenaltyLevel );
+	}
+	
+    private boolean IsInGloom()
+    {
+        if ( !capabilities.disableDamage ) // disable darkness effects in creative
+        {
+	        if ( !isPotionActive( Potion.nightVision ) && worldObj.provider.dimensionId == 0 )
+	        {
+		        int i = MathHelper.floor_double( posX );
+		        int j = MathHelper.floor_double( posY - yOffset );
+		        int k = MathHelper.floor_double( posZ );
+		        
+		        int iOldSkylightSubtracted = worldObj.skylightSubtracted;
+		        
+		        float fSunBrightness = worldObj.ComputeOverworldSunBrightnessWithMoonPhases();
+		        
+		        if ( fSunBrightness < 0.02D )
+		        {
+		        	// world is in gloom, no skylight at all
+		        	worldObj.skylightSubtracted = 15;
+		        }
+		        else
+		        {
+		        	worldObj.skylightSubtracted = (int)( ( 1F - fSunBrightness ) * 11.9F );
+		        }
+
+		        float fBlockInLightValue = worldObj.getLightBrightness( i, j, k );
+		        
+		        float fBlockAboveLightValue = worldObj.getLightBrightness( i, j + 1, k );
+		        
+		        if ( fBlockAboveLightValue > fBlockInLightValue )
+		        {
+		        	fBlockInLightValue = fBlockAboveLightValue;
+		        }
+		        
+		        worldObj.skylightSubtracted = iOldSkylightSubtracted;
+		        
+		    	return fBlockInLightValue < 0.001F;
+	        }
+        }
+        
+        return false;
+    }
+    
+	@Override    
+	public void AddRawChatMessage( String message )
+	{
+		playerNetServerHandler.sendPacket( new Packet3Chat( message ) );
+	}
+
+	@Override
+    protected void OnZeroDamageAttack()
+    {
+		long lCurrentTime = worldObj.getWorldTime();
+		
+		if ( lCurrentTime > m_lTimeOfLastZeroDamageAttackSound + m_iDelayBetweenZeroDamageAttackSounds )
+		{
+			worldObj.playSoundAtEntity( this, 
+	    		"random.classic_hurt", 1.0F +  rand.nextFloat() * 0.25F, 
+	    		getSoundPitch() * 1.20F + rand.nextFloat() * 0.1F);
+			
+			m_lTimeOfLastZeroDamageAttackSound = lCurrentTime;
+		}
+    }
+
+	@Override
+    public void OnStruckByLightning( FCEntityLightningBolt boltEntity )
+    {
+        if ( !capabilities.disableDamage )
+        {
+            dealFireDamage( 12 );
+            
+            setFire( 8 );
+
+        	FlingAwayFromEntity( boltEntity, 2D );
+    		
+    		worldObj.playSoundAtEntity( this, 
+        		"random.classic_hurt", 1.0F +  rand.nextFloat() * 0.25F, 
+        		getSoundPitch() * 1.20F + rand.nextFloat() * 0.1F);
+    		
+            addPotionEffect( new PotionEffect( Potion.blindness.getId(), 90, 0, true ) );
+            
+            addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
+        }
+    }
+	
+    public int IncrementAndGetWindowID()
+    {
+        this.currentWindowId = this.currentWindowId % 100 + 1;
+        
+        return currentWindowId;
+    }
+    
+    private void NotifyBlockWalkedOn()
+    {
+        if ( onGround )
+        {
+        	int iGroundI = MathHelper.floor_double( posX );
+        	int iGroundJ = MathHelper.floor_double( posY - 0.03D - (double)yOffset ); // same calc used for step sound
+        	int iGroundK = MathHelper.floor_double( posZ );
+        	
+        	Block blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+
+        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+        	{
+        		float fHalfWidth = width / 2F;
+        		
+        		// block we are standing on directly is air or has no collision box.  Check the horizontal extents of our box for a movement modifier
+
+        		int iCenterGroundI = iGroundI;
+        		
+        		iGroundI = MathHelper.floor_double( posX + fHalfWidth );	        		
+	        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+	        	
+	        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+	        	{
+	        		iGroundI = MathHelper.floor_double( posX - fHalfWidth );
+		        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+		        	
+		        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+		        	{
+		        		iGroundI = iCenterGroundI;
+		        		
+		        		iGroundK = MathHelper.floor_double( posZ + fHalfWidth );
+			        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
+			        	
+			        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
+			        	{
+			        		iGroundK = MathHelper.floor_double( posZ - fHalfWidth );
+				        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];					        	
+			        	}
+		        	}
+	        	}	        	
+        	}
+        	
+        	if ( blockOn != null )
+        	{
+        		blockOn.OnPlayerWalksOnBlock( worldObj, iGroundI, iGroundJ, iGroundK, this );        		
+        	}
+        }        
+    }
+    
+    public void SendChunksToClient()
+    {
+        if ( !m_chunksToBeSentToClient.isEmpty() )
+        {
+            Iterator<ChunkCoordIntPair> coordIterator = m_chunksToBeSentToClient.iterator();
+            
+            ArrayList<Chunk> chunksToSend = new ArrayList<Chunk>();
+            ArrayList<TileEntity> tileEntitiesToSend = new ArrayList<TileEntity>();
+
+            while ( coordIterator.hasNext() && chunksToSend.size() < 5 )
+            {
+                ChunkCoordIntPair tempCoord = coordIterator.next();
+                coordIterator.remove();
+
+                if ( tempCoord != null && worldObj.chunkExists( 
+                	tempCoord.chunkXPos, tempCoord.chunkZPos ) )
+                {
+                    chunksToSend.add( worldObj.getChunkFromChunkCoords(
+                    	tempCoord.chunkXPos, tempCoord.chunkZPos ) );
+                    
+                    tileEntitiesToSend.addAll( getServerForPlayer().getAllTileEntityInBox(
+                    	tempCoord.chunkXPos * 16, 0, tempCoord.chunkZPos * 16, 
+                    	tempCoord.chunkXPos * 16 + 16, 256, tempCoord.chunkZPos * 16 + 16));
+                }
+            }
+
+            if ( !chunksToSend.isEmpty() )
+            {
+	        	FCUtilsWorld.SendPacketToPlayer( playerNetServerHandler, 
+	        		new Packet56MapChunks( chunksToSend ) );
+	        	
+                Iterator<TileEntity> tileIterator = tileEntitiesToSend.iterator();
+
+                while ( tileIterator.hasNext() )
+                {
+                    TileEntity tempTile = (TileEntity)tileIterator.next();
+                    
+                    sendTileEntityToPlayer( tempTile );
+                }
+
+                Iterator<Chunk> chunkIterator = chunksToSend.iterator();
+
+                while ( chunkIterator.hasNext() )
+                {
+                    Chunk var10 = chunkIterator.next();
+                    
+                    // the following call checks for entities in the chunk, and starts the player
+                    // watching them for updates
+                    getServerForPlayer().getEntityTracker().func_85172_a( this, var10 );
+                }
+            }
+        }
+    }
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntitySheep.java b/minecraft_server/net/minecraft/src/EntitySheep.java
index c0dafcf..ba5ad92 100644
--- a/minecraft_server/net/minecraft/src/EntitySheep.java
+++ b/minecraft_server/net/minecraft/src/EntitySheep.java
@@ -1,5 +1,9 @@
+// FCMOD: Class changes deprecated 07/23/2018
+
 package net.minecraft.src;
 
+import java.util.Iterator;
+import java.util.List;
 import java.util.Random;
 
 public class EntitySheep extends EntityAnimal
@@ -95,7 +99,7 @@ public class EntitySheep extends EntityAnimal
      */
     protected int getDropItemId()
     {
-        return Block.cloth.blockID;
+    	return Block.cloth.blockID;
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/EntitySilverfish.java b/minecraft_server/net/minecraft/src/EntitySilverfish.java
index c2c10b0..a46e4e1 100644
--- a/minecraft_server/net/minecraft/src/EntitySilverfish.java
+++ b/minecraft_server/net/minecraft/src/EntitySilverfish.java
@@ -177,7 +177,16 @@ public class EntitySilverfish extends EntityMob
 
                 if (BlockSilverfish.getPosingIdByMetadata(var5))
                 {
+                	// FCMOD: Code change
+                	/*
                     this.worldObj.setBlock(var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9], Block.silverfish.blockID, BlockSilverfish.getMetadataForBlockType(var5), 3);
+                    */
+                	int iNewBlockMetadata = FCBlockSilverfish.GetMetadataConversionOnInfest( var5, 
+                		worldObj.getBlockMetadata( var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9] ) );
+                	
+                    worldObj.setBlock(var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9], 
+                    	Block.silverfish.blockID, iNewBlockMetadata, 3);
+                	// END FCMOD
                     this.spawnExplosionParticle();
                     this.setDead();
                 }
@@ -241,4 +250,34 @@ public class EntitySilverfish extends EntityMob
     {
         return EnumCreatureAttribute.ARTHROPOD;
     }
+    
+    // FCMOD: Code added
+    @Override
+    protected void dropFewItems( boolean bKilledByPlayer, int iLootingModifier )
+    {
+    	if ( worldObj.provider.dimensionId == 1 )
+    	{
+	        int iDropChance = this.rand.nextInt( 5 ) - 3 + iLootingModifier;
+	
+	        if ( iDropChance > 0 )
+	        {
+	            dropItem( Item.clay.itemID, 1 );
+	        }
+    	}
+    }
+    
+    @Override
+    public void CheckForScrollDrop()
+    {    	
+    	if ( worldObj.provider.dimensionId == 1 )
+    	{
+	    	if ( rand.nextInt( 1000 ) == 0 )
+	    	{
+	    		ItemStack itemstack = new ItemStack( FCBetterThanWolves.fcItemArcaneScroll, 1, Enchantment.efficiency.effectId );
+	            
+	            entityDropItem(itemstack, 0.0F);
+	    	}
+    	}
+    }    
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntitySkeleton.java b/minecraft_server/net/minecraft/src/EntitySkeleton.java
index 3c479c8..373f0cd 100644
--- a/minecraft_server/net/minecraft/src/EntitySkeleton.java
+++ b/minecraft_server/net/minecraft/src/EntitySkeleton.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/26/2018
+
 package net.minecraft.src;
 
 import java.util.Calendar;
diff --git a/minecraft_server/net/minecraft/src/EntitySlime.java b/minecraft_server/net/minecraft/src/EntitySlime.java
index 8371a96..aedf053 100644
--- a/minecraft_server/net/minecraft/src/EntitySlime.java
+++ b/minecraft_server/net/minecraft/src/EntitySlime.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/24/2018
+
 package net.minecraft.src;
 
 public class EntitySlime extends EntityLiving implements IMob
@@ -161,7 +163,7 @@ public class EntitySlime extends EntityLiving implements IMob
             }
 
             this.moveStrafing = 1.0F - this.rand.nextFloat() * 2.0F;
-            this.moveForward = (float)(1 * this.getSlimeSize());
+            this.moveForward = (float)(1 * this.getSlimeSize());            
         }
         else
         {
@@ -205,8 +207,8 @@ public class EntitySlime extends EntityLiving implements IMob
 
             for (int var3 = 0; var3 < var2; ++var3)
             {
-                float var4 = ((float)(var3 % 2) - 0.5F) * (float)var1 / 4.0F;
-                float var5 = ((float)(var3 / 2) - 0.5F) * (float)var1 / 4.0F;
+                float var4 = ((float)(var3 % 2) - 0.5F) * (float)var1 / 40.0F;
+                float var5 = ((float)(var3 / 2) - 0.5F) * (float)var1 / 40.0F;
                 EntitySlime var6 = this.createInstance();
                 var6.setSlimeSize(var1 / 2);
                 var6.setLocationAndAngles(this.posX + (double)var4, this.posY + 0.5D, this.posZ + (double)var5, this.rand.nextFloat() * 360.0F, 0.0F);
diff --git a/minecraft_server/net/minecraft/src/EntitySnowman.java b/minecraft_server/net/minecraft/src/EntitySnowman.java
index 8726f0d..b1505cf 100644
--- a/minecraft_server/net/minecraft/src/EntitySnowman.java
+++ b/minecraft_server/net/minecraft/src/EntitySnowman.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 12/27/2018
+
 package net.minecraft.src;
 
 public class EntitySnowman extends EntityGolem implements IRangedAttackMob
diff --git a/minecraft_server/net/minecraft/src/EntitySpider.java b/minecraft_server/net/minecraft/src/EntitySpider.java
index 9855ce1..bfd58b1 100644
--- a/minecraft_server/net/minecraft/src/EntitySpider.java
+++ b/minecraft_server/net/minecraft/src/EntitySpider.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 public class EntitySpider extends EntityMob
diff --git a/minecraft_server/net/minecraft/src/EntityTameable.java b/minecraft_server/net/minecraft/src/EntityTameable.java
index 0e72f12..c2064e3 100644
--- a/minecraft_server/net/minecraft/src/EntityTameable.java
+++ b/minecraft_server/net/minecraft/src/EntityTameable.java
@@ -131,4 +131,17 @@ public abstract class EntityTameable extends EntityAnimal
     {
         return this.aiSit;
     }
+
+    // FCMOD: Code Added
+    @Override
+    public boolean IsSecondaryTargetForSquid()
+    {
+    	return false;
+    }
+    
+    public boolean IsAITryingToSit()
+    {
+    	return aiSit.IsTryingToSit();
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityThrowable.java b/minecraft_server/net/minecraft/src/EntityThrowable.java
index ffd1996..c86c3a4 100644
--- a/minecraft_server/net/minecraft/src/EntityThrowable.java
+++ b/minecraft_server/net/minecraft/src/EntityThrowable.java
@@ -131,7 +131,12 @@ public abstract class EntityThrowable extends Entity implements IProjectile
 
         Vec3 var16 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
         Vec3 var2 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
+        // FCMOD: Code change to ignore transparent type blocks like tall grass
+        /*
         MovingObjectPosition var3 = this.worldObj.rayTraceBlocks(var16, var2);
+        */
+        MovingObjectPosition var3 = this.worldObj.rayTraceBlocks_do_do(var16, var2, false, true);
+        // END FCMOD
         var16 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
         var2 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
 
@@ -298,4 +303,11 @@ public abstract class EntityThrowable extends Entity implements IProjectile
 
         return this.thrower;
     }
+    
+    // FCMOD: Code added
+    protected void SetThrower( EntityLiving throwerParam )
+    {
+    	thrower = throwerParam;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityTracker.java b/minecraft_server/net/minecraft/src/EntityTracker.java
index c59db5d..47e0af9 100644
--- a/minecraft_server/net/minecraft/src/EntityTracker.java
+++ b/minecraft_server/net/minecraft/src/EntityTracker.java
@@ -42,6 +42,17 @@ public class EntityTracker
                 }
             }
         }
+        // FCMOD: Code added
+        else if ( par1Entity instanceof FCIEntityPacketHandler )
+        {
+        	FCIEntityPacketHandler fcEntity = (FCIEntityPacketHandler)par1Entity;
+        	
+        	// client
+            //addEntityToTracker( par1Entity, fcEntity.GetTrackerViewDistance(), fcEntity.GetTrackerUpdateFrequency(), fcEntity.GetTrackMotion() );
+            // server
+            trackEntity( par1Entity, fcEntity.GetTrackerViewDistance(), fcEntity.GetTrackerUpdateFrequency(), fcEntity.GetTrackMotion() );
+        }
+        // END FCMOD
         else if (par1Entity instanceof EntityFishHook)
         {
             this.trackEntity(par1Entity, 64, 5, true);
@@ -98,15 +109,24 @@ public class EntityTracker
         {
             this.trackEntity(par1Entity, 80, 3, true);
         }
-        else if (par1Entity instanceof EntitySquid)
+        // FCMOD: Changed
+        //else if (par1Entity instanceof EntitySquid)
+        else if ( par1Entity instanceof FCEntitySquid )
+    	// END FCMOD
         {
             this.trackEntity(par1Entity, 64, 3, true);
         }
-        else if (par1Entity instanceof EntityWither)
+        // FCMOD: Changed
+        //else if (par1Entity instanceof EntityWither)
+        else if ( par1Entity instanceof FCEntityWither )
+    	// END FCMOD
         {
             this.trackEntity(par1Entity, 80, 3, false);
         }
-        else if (par1Entity instanceof EntityBat)
+        // FCMOD: Changed
+        //else if (par1Entity instanceof EntityBat)
+        else if ( par1Entity instanceof FCEntityBat )
+    	// END FCMOD
         {
             this.trackEntity(par1Entity, 80, 3, false);
         }
diff --git a/minecraft_server/net/minecraft/src/EntityTrackerEntry.java b/minecraft_server/net/minecraft/src/EntityTrackerEntry.java
index db5e6c9..2ef317f 100644
--- a/minecraft_server/net/minecraft/src/EntityTrackerEntry.java
+++ b/minecraft_server/net/minecraft/src/EntityTrackerEntry.java
@@ -105,7 +105,12 @@ public class EntityTrackerEntry
             if (var24 != null && var24.getItem() instanceof ItemMap)
             {
                 MapData var26 = Item.map.getMapData(var24, this.trackedEntity.worldObj);
+                // FCMOD: Code change to send map data to all visible players rather than tracked ones
+                /*
                 Iterator var29 = par1List.iterator();
+                */
+                Iterator var29 = trackingPlayers.iterator();
+                // END FCMOD
 
                 while (var29.hasNext())
                 {
@@ -115,21 +120,28 @@ public class EntityTrackerEntry
 
                     if (var31.playerNetServerHandler.getNumChunkDataPackets() <= 5)
                     {
+                    	// FCMOD: Code added so that players only receive data on their own position
+                    	var26.func_82568_a( var30 );
+                    	// END FCMOD
+
                         Packet var32 = Item.map.getUpdatePacket(var24, this.trackedEntity.worldObj, var31);
 
                         if (var32 != null)
                         {
                             var31.playerNetServerHandler.sendPacket(var32);
                         }
+                    	// FCMOD: Code added so that players only receive data on their own position
+                    	var26.playersVisibleOnMap.clear();
+                    	// END FCMOD
                     }
                 }
             }
 
-            DataWatcher var27 = this.trackedEntity.getDataWatcher();
+            DataWatcher var28 = this.trackedEntity.getDataWatcher();
 
-            if (var27.hasObjectChanged())
+            if (var28.hasObjectChanged())
             {
-                this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet40EntityMetadata(this.trackedEntity.entityId, var27, false));
+                this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet40EntityMetadata(this.trackedEntity.entityId, var28, false));
             }
         }
         else if (this.updateCounter % this.updateFrequency == 0 || this.trackedEntity.isAirBorne || this.trackedEntity.getDataWatcher().hasObjectChanged())
@@ -236,11 +248,11 @@ public class EntityTrackerEntry
                 this.encodedPosX = this.trackedEntity.myEntitySize.multiplyBy32AndRound(this.trackedEntity.posX);
                 this.encodedPosY = MathHelper.floor_double(this.trackedEntity.posY * 32.0D);
                 this.encodedPosZ = this.trackedEntity.myEntitySize.multiplyBy32AndRound(this.trackedEntity.posZ);
-                DataWatcher var28 = this.trackedEntity.getDataWatcher();
+                DataWatcher var27 = this.trackedEntity.getDataWatcher();
 
-                if (var28.hasObjectChanged())
+                if (var27.hasObjectChanged())
                 {
-                    this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet40EntityMetadata(this.trackedEntity.entityId, var28, false));
+                    this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet40EntityMetadata(this.trackedEntity.entityId, var27, false));
                 }
 
                 this.ridingEntity = true;
@@ -316,8 +328,12 @@ public class EntityTrackerEntry
 
             if (var2 >= (double)(-this.trackingDistanceThreshold) && var2 <= (double)this.trackingDistanceThreshold && var4 >= (double)(-this.trackingDistanceThreshold) && var4 <= (double)this.trackingDistanceThreshold)
             {
-                if (!this.trackingPlayers.contains(par1EntityPlayerMP) && (this.isPlayerWatchingThisChunk(par1EntityPlayerMP) || this.trackedEntity.field_98038_p))
-                {
+            	// client
+            	//if ((!this.trackingPlayers.contains(par1EntityPlayerMP) && (this.isPlayerWatchingThisChunk(par1EntityPlayerMP) || this.myEntity.field_98038_p))
+                //      || (Math.abs(par1EntityPlayerMP.posX - this.myEntity.posX) > 120 || Math.abs(par1EntityPlayerMP.posZ - this.myEntity.posZ) > 120)) {
+            	// server
+            	if ((!this.trackingPlayers.contains(par1EntityPlayerMP) && (this.isPlayerWatchingThisChunk(par1EntityPlayerMP) || this.trackedEntity.field_98038_p))
+                		|| (Math.abs(par1EntityPlayerMP.posX - this.trackedEntity.posX) > 120 || Math.abs(par1EntityPlayerMP.posZ - this.trackedEntity.posZ) > 120)) {
                     this.trackingPlayers.add(par1EntityPlayerMP);
                     Packet var6 = this.getSpawnPacket();
                     par1EntityPlayerMP.playerNetServerHandler.sendPacket(var6);
@@ -356,9 +372,9 @@ public class EntityTrackerEntry
 
                     if (this.trackedEntity instanceof EntityPlayer)
                     {
-                        EntityPlayer var10 = (EntityPlayer)this.trackedEntity;
+                        EntityPlayer var11 = (EntityPlayer)this.trackedEntity;
 
-                        if (var10.isPlayerSleeping())
+                        if (var11.isPlayerSleeping())
                         {
                             par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet17Sleep(this.trackedEntity, 0, MathHelper.floor_double(this.trackedEntity.posX), MathHelper.floor_double(this.trackedEntity.posY), MathHelper.floor_double(this.trackedEntity.posZ)));
                         }
@@ -366,8 +382,8 @@ public class EntityTrackerEntry
 
                     if (this.trackedEntity instanceof EntityLiving)
                     {
-                        EntityLiving var11 = (EntityLiving)this.trackedEntity;
-                        Iterator var12 = var11.getActivePotionEffects().iterator();
+                        EntityLiving var10 = (EntityLiving)this.trackedEntity;
+                        Iterator var12 = var10.getActivePotionEffects().iterator();
 
                         while (var12.hasNext())
                         {
@@ -387,7 +403,15 @@ public class EntityTrackerEntry
 
     private boolean isPlayerWatchingThisChunk(EntityPlayerMP par1EntityPlayerMP)
     {
-        return par1EntityPlayerMP.getServerForPlayer().getPlayerManager().isPlayerWatchingChunk(par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);
+    	// FCMOD: Changed    	
+        //return par1EntityPlayerMP.getServerForPlayer().getPlayerManager().isPlayerWatchingChunk(par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);
+        return par1EntityPlayerMP.getServerForPlayer().
+        	GetChunkTracker().IsChunkWatchedByPlayerAndSentToClient(
+        	// client 
+        	//par1EntityPlayerMP, this.myEntity.chunkCoordX, this.myEntity.chunkCoordZ);
+            // server
+    		par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);
+        // END FCMOD
     }
 
     public void updatePlayerEntities(List par1List)
@@ -405,6 +429,21 @@ public class EntityTrackerEntry
             this.trackedEntity.worldObj.getWorldLogAgent().func_98236_b("Fetching addPacket for removed entity");
         }
 
+        // FCMOD: Code added.  This is at the top of all the following code due to some mod entities inheriting from the ones below
+        // client
+        //if ( myEntity instanceof FCIEntityPacketHandler )
+    	// server
+        if ( trackedEntity instanceof FCIEntityPacketHandler )        	
+        {
+        	// client
+        	//FCIEntityPacketHandler packetHandler = (FCIEntityPacketHandler)myEntity;
+        	// server
+        	FCIEntityPacketHandler packetHandler = (FCIEntityPacketHandler)trackedEntity;
+        	
+    		return packetHandler.GetSpawnPacketForThisEntity();
+        }
+        // END FCMOD
+        
         if (this.trackedEntity instanceof EntityItem)
         {
             return new Packet23VehicleSpawn(this.trackedEntity, 2, 1);
diff --git a/minecraft_server/net/minecraft/src/EntityVillager.java b/minecraft_server/net/minecraft/src/EntityVillager.java
index b6610db..594cbab 100644
--- a/minecraft_server/net/minecraft/src/EntityVillager.java
+++ b/minecraft_server/net/minecraft/src/EntityVillager.java
@@ -1,3 +1,5 @@
+// FCMOD: Note that in the server version of this file, I've renamed functions to match the client
+
 package net.minecraft.src;
 
 import java.util.Collections;
@@ -17,22 +19,25 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
     private EntityPlayer buyingPlayer;
 
     /** Initialises the MerchantRecipeList.java */
-    private MerchantRecipeList buyingList;
-    private int timeUntilReset;
+    // FCMOD: Changed
+    //private MerchantRecipeList buyingList;
+    protected MerchantRecipeList buyingList;
+    // END FCMOD
 
+    private int timeUntilReset;
+    
     /** addDefaultEquipmentAndRecipies is called if this is true */
     private boolean needsInitilization;
+    
     private int wealth;
 
     /** Last player to trade with this villager, used for aggressivity. */
     private String lastBuyingPlayer;
+    
     private boolean field_82190_bM;
     private float field_82191_bN;
 
-    /** Selling list of Villagers items. */
-    private static final Map villagersSellingList = new HashMap();
-
-    /** Selling list of Blacksmith items. */
+    private static final Map villagerStockList = new HashMap();
     private static final Map blacksmithSellingList = new HashMap();
 
     public EntityVillager(World par1World)
@@ -414,7 +419,7 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
         switch (this.getProfession())
         {
             case 0:
-                addMerchantItem(var2, Item.wheat.itemID, this.rand, this.func_82188_j(0.9F));
+                addMerchantItem(var2, Item.wheat.itemID, this.rand, this.func_82188_j(0.9F));                
                 addMerchantItem(var2, Block.cloth.blockID, this.rand, this.func_82188_j(0.5F));
                 addMerchantItem(var2, Item.chickenRaw.itemID, this.rand, this.func_82188_j(0.5F));
                 addMerchantItem(var2, Item.fishCooked.itemID, this.rand, this.func_82188_j(0.4F));
@@ -562,7 +567,7 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
      */
     private static int getRandomCountForItem(int par0, Random par1Random)
     {
-        Tuple var2 = (Tuple)villagersSellingList.get(Integer.valueOf(par0));
+        Tuple var2 = (Tuple)villagerStockList.get(Integer.valueOf(par0));
         return var2 == null ? 1 : (((Integer)var2.getFirst()).intValue() >= ((Integer)var2.getSecond()).intValue() ? ((Integer)var2.getFirst()).intValue() : ((Integer)var2.getFirst()).intValue() + par1Random.nextInt(((Integer)var2.getSecond()).intValue() - ((Integer)var2.getFirst()).intValue()));
     }
 
@@ -622,25 +627,25 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
 
     static
     {
-        villagersSellingList.put(Integer.valueOf(Item.coal.itemID), new Tuple(Integer.valueOf(16), Integer.valueOf(24)));
-        villagersSellingList.put(Integer.valueOf(Item.ingotIron.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
-        villagersSellingList.put(Integer.valueOf(Item.ingotGold.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
-        villagersSellingList.put(Integer.valueOf(Item.diamond.itemID), new Tuple(Integer.valueOf(4), Integer.valueOf(6)));
-        villagersSellingList.put(Integer.valueOf(Item.paper.itemID), new Tuple(Integer.valueOf(24), Integer.valueOf(36)));
-        villagersSellingList.put(Integer.valueOf(Item.book.itemID), new Tuple(Integer.valueOf(11), Integer.valueOf(13)));
-        villagersSellingList.put(Integer.valueOf(Item.writtenBook.itemID), new Tuple(Integer.valueOf(1), Integer.valueOf(1)));
-        villagersSellingList.put(Integer.valueOf(Item.enderPearl.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
-        villagersSellingList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(2), Integer.valueOf(3)));
-        villagersSellingList.put(Integer.valueOf(Item.porkRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
-        villagersSellingList.put(Integer.valueOf(Item.beefRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
-        villagersSellingList.put(Integer.valueOf(Item.chickenRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
-        villagersSellingList.put(Integer.valueOf(Item.fishCooked.itemID), new Tuple(Integer.valueOf(9), Integer.valueOf(13)));
-        villagersSellingList.put(Integer.valueOf(Item.seeds.itemID), new Tuple(Integer.valueOf(34), Integer.valueOf(48)));
-        villagersSellingList.put(Integer.valueOf(Item.melonSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
-        villagersSellingList.put(Integer.valueOf(Item.pumpkinSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
-        villagersSellingList.put(Integer.valueOf(Item.wheat.itemID), new Tuple(Integer.valueOf(18), Integer.valueOf(22)));
-        villagersSellingList.put(Integer.valueOf(Block.cloth.blockID), new Tuple(Integer.valueOf(14), Integer.valueOf(22)));
-        villagersSellingList.put(Integer.valueOf(Item.rottenFlesh.itemID), new Tuple(Integer.valueOf(36), Integer.valueOf(64)));
+        villagerStockList.put(Integer.valueOf(Item.coal.itemID), new Tuple(Integer.valueOf(16), Integer.valueOf(24)));
+        villagerStockList.put(Integer.valueOf(Item.ingotIron.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
+        villagerStockList.put(Integer.valueOf(Item.ingotGold.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
+        villagerStockList.put(Integer.valueOf(Item.diamond.itemID), new Tuple(Integer.valueOf(4), Integer.valueOf(6)));
+        villagerStockList.put(Integer.valueOf(Item.paper.itemID), new Tuple(Integer.valueOf(24), Integer.valueOf(36)));
+        villagerStockList.put(Integer.valueOf(Item.book.itemID), new Tuple(Integer.valueOf(11), Integer.valueOf(13)));
+        villagerStockList.put(Integer.valueOf(Item.writtenBook.itemID), new Tuple(Integer.valueOf(1), Integer.valueOf(1)));
+        villagerStockList.put(Integer.valueOf(Item.enderPearl.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
+        villagerStockList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(2), Integer.valueOf(3)));
+        villagerStockList.put(Integer.valueOf(Item.porkRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
+        villagerStockList.put(Integer.valueOf(Item.beefRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
+        villagerStockList.put(Integer.valueOf(Item.chickenRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
+        villagerStockList.put(Integer.valueOf(Item.fishCooked.itemID), new Tuple(Integer.valueOf(9), Integer.valueOf(13)));
+        villagerStockList.put(Integer.valueOf(Item.seeds.itemID), new Tuple(Integer.valueOf(34), Integer.valueOf(48)));
+        villagerStockList.put(Integer.valueOf(Item.melonSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
+        villagerStockList.put(Integer.valueOf(Item.pumpkinSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
+        villagerStockList.put(Integer.valueOf(Item.wheat.itemID), new Tuple(Integer.valueOf(18), Integer.valueOf(22)));
+        villagerStockList.put(Integer.valueOf(Block.cloth.blockID), new Tuple(Integer.valueOf(14), Integer.valueOf(22)));
+        villagerStockList.put(Integer.valueOf(Item.rottenFlesh.itemID), new Tuple(Integer.valueOf(36), Integer.valueOf(64)));
         blacksmithSellingList.put(Integer.valueOf(Item.flintAndSteel.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
         blacksmithSellingList.put(Integer.valueOf(Item.shears.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
         blacksmithSellingList.put(Integer.valueOf(Item.swordIron.itemID), new Tuple(Integer.valueOf(7), Integer.valueOf(11)));
@@ -687,4 +692,21 @@ public class EntityVillager extends EntityAgeable implements INpc, IMerchant
         blacksmithSellingList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(7), Integer.valueOf(11)));
         blacksmithSellingList.put(Integer.valueOf(Item.arrow.itemID), new Tuple(Integer.valueOf(-12), Integer.valueOf(-8)));
     }
+    
+    // FCMOD: Added to satisfy IMerchant
+    public int GetCurrentTradeLevel() 
+    {
+    	return 0;
+    }
+    
+    public int GetCurrentTradeXP()
+    {
+    	return 0;
+    }
+    
+    public int GetCurrentTradeMaxXP()
+    {
+    	return 0;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityWaterMob.java b/minecraft_server/net/minecraft/src/EntityWaterMob.java
index 1073d02..ec8672a 100644
--- a/minecraft_server/net/minecraft/src/EntityWaterMob.java
+++ b/minecraft_server/net/minecraft/src/EntityWaterMob.java
@@ -52,7 +52,12 @@ public abstract class EntityWaterMob extends EntityCreature implements IAnimals
         int var1 = this.getAir();
         super.onEntityUpdate();
 
+        // FCMOD: Change to be more forgiving on whether the squid is in water or not 
+        /*
         if (this.isEntityAlive() && !this.isInsideOfMaterial(Material.water))
+        */
+        if (this.isEntityAlive() && !inWater)
+        // END FCMOD
         {
             --var1;
             this.setAir(var1);
diff --git a/minecraft_server/net/minecraft/src/EntityWitch.java b/minecraft_server/net/minecraft/src/EntityWitch.java
index df93b6a..e1511aa 100644
--- a/minecraft_server/net/minecraft/src/EntityWitch.java
+++ b/minecraft_server/net/minecraft/src/EntityWitch.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/23/2018
+
 package net.minecraft.src;
 
 import java.util.Iterator;
diff --git a/minecraft_server/net/minecraft/src/EntityWither.java b/minecraft_server/net/minecraft/src/EntityWither.java
index bc3b42d..223eefd 100644
--- a/minecraft_server/net/minecraft/src/EntityWither.java
+++ b/minecraft_server/net/minecraft/src/EntityWither.java
@@ -234,7 +234,11 @@ public class EntityWither extends EntityMob implements IRangedAttackMob
                 {
                     this.field_82223_h[var1 - 1] = this.ticksExisted + 10 + this.rand.nextInt(10);
 
+                    // FCMOD: Code removed so that skulls launch on easy difficulty
+                    /*
                     if (this.worldObj.difficultySetting >= 2)
+                    */
+                    // END FCMOD
                     {
                         int var10001 = var1 - 1;
                         int var10003 = this.field_82224_i[var1 - 1];
@@ -318,28 +322,34 @@ public class EntityWither extends EntityMob implements IRangedAttackMob
                     var1 = MathHelper.floor_double(this.posY);
                     var12 = MathHelper.floor_double(this.posX);
                     int var15 = MathHelper.floor_double(this.posZ);
-                    boolean var17 = false;
+                    boolean var18 = false;
 
-                    for (int var18 = -1; var18 <= 1; ++var18)
+                    for (int var17 = -1; var17 <= 1; ++var17)
                     {
                         for (int var19 = -1; var19 <= 1; ++var19)
                         {
                             for (int var7 = 0; var7 <= 3; ++var7)
                             {
-                                int var20 = var12 + var18;
+                                int var20 = var12 + var17;
                                 int var9 = var1 + var7;
                                 int var10 = var15 + var19;
                                 int var11 = this.worldObj.getBlockId(var20, var9, var10);
 
+                                // FCMOD: Change
+                                /*
                                 if (var11 > 0 && var11 != Block.bedrock.blockID && var11 != Block.endPortal.blockID && var11 != Block.endPortalFrame.blockID)
+                                */                                	
+                                if (var11 > 0 && var11 != Block.bedrock.blockID && var11 != Block.endPortal.blockID && var11 != Block.endPortalFrame.blockID &&
+                                	var11 != FCBetterThanWolves.fcSoulforgedSteelBlock.blockID )
+                            	// END FCMOD
                                 {
-                                    var17 = this.worldObj.destroyBlock(var20, var9, var10, true) || var17;
+                                    var18 = this.worldObj.destroyBlock(var20, var9, var10, true) || var18;
                                 }
                             }
                         }
                     }
 
-                    if (var17)
+                    if (var18)
                     {
                         this.worldObj.playAuxSFXAtEntity((EntityPlayer)null, 1012, (int)this.posX, (int)this.posY, (int)this.posZ, 0);
                     }
@@ -436,7 +446,10 @@ public class EntityWither extends EntityMob implements IRangedAttackMob
         double var15 = par2 - var9;
         double var17 = par4 - var11;
         double var19 = par6 - var13;
-        EntityWitherSkull var21 = new EntityWitherSkull(this.worldObj, this, var15, var17, var19);
+        // FCMOD: Changed
+        //EntityWitherSkull var21 = new EntityWitherSkull(this.worldObj, this, var15, var17, var19);
+        FCEntityWitherSkull var21 = new FCEntityWitherSkull(this.worldObj, this, var15, var17, var19);
+        // END FCMOD
 
         if (par8)
         {
diff --git a/minecraft_server/net/minecraft/src/EntityWitherSkull.java b/minecraft_server/net/minecraft/src/EntityWitherSkull.java
index b0db19e..6488de2 100644
--- a/minecraft_server/net/minecraft/src/EntityWitherSkull.java
+++ b/minecraft_server/net/minecraft/src/EntityWitherSkull.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 10/20/2018
+
 package net.minecraft.src;
 
 public class EntityWitherSkull extends EntityFireball
diff --git a/minecraft_server/net/minecraft/src/EntityWolf.java b/minecraft_server/net/minecraft/src/EntityWolf.java
index dd41a97..6db098f 100644
--- a/minecraft_server/net/minecraft/src/EntityWolf.java
+++ b/minecraft_server/net/minecraft/src/EntityWolf.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/10/2018
+
 package net.minecraft.src;
 
 public class EntityWolf extends EntityTameable
diff --git a/minecraft_server/net/minecraft/src/EntityXPOrb.java b/minecraft_server/net/minecraft/src/EntityXPOrb.java
index 0451fdd..4e94b1f 100644
--- a/minecraft_server/net/minecraft/src/EntityXPOrb.java
+++ b/minecraft_server/net/minecraft/src/EntityXPOrb.java
@@ -2,6 +2,10 @@ package net.minecraft.src;
 
 public class EntityXPOrb extends Entity
 {
+    // FCMOD: Code added
+    public boolean m_bNotPlayerOwned = false;
+    // END FCMOD
+    
     /**
      * A constantly increasing value that RenderXPOrb uses to control the colour shifting (Green / yellow)
      */
@@ -15,7 +19,12 @@ public class EntityXPOrb extends Entity
     private int xpOrbHealth = 5;
 
     /** This is how much XP this orb has. */
+    // FCMOD: Changed to public
+	/*
     private int xpValue;
+	*/
+    public int xpValue;
+    // END FCMOD
 
     /** The closest EntityPlayer to this orb. */
     private EntityPlayer closestPlayer;
@@ -23,10 +32,23 @@ public class EntityXPOrb extends Entity
     /** Threshold color for tracking players */
     private int xpTargetColor;
 
+    // FCMOD: Method added
+    public EntityXPOrb(World par1World, double par2, double par4, double par6, int par8, boolean bNotPlayerOwned )
+    {
+    	this( par1World, par2, par4, par6, par8 );
+        m_bNotPlayerOwned = bNotPlayerOwned;
+    }
+    // END FCMOD
+
     public EntityXPOrb(World par1World, double par2, double par4, double par6, int par8)
     {
         super(par1World);
+        // FCMOD: Line changed so XP orbs will fit through tight spaces (set to same size as items)
+		/*
         this.setSize(0.5F, 0.5F);
+		*/
+        setSize(0.25F, 0.25F);
+        // END FCMOD
         this.yOffset = this.height / 2.0F;
         this.setPosition(par2, par4, par6);
         this.rotationYaw = (float)(Math.random() * 360.0D);
@@ -79,13 +101,23 @@ public class EntityXPOrb extends Entity
             this.playSound("random.fizz", 0.4F, 2.0F + this.rand.nextFloat() * 0.4F);
         }
 
-        this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+        // FCMOD: Changed to reduce discrepancies between client and server by 
+        // pusing only on server
+        //this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+        if ( !worldObj.isRemote )
+        {
+            pushOutOfBlocks( posX, ( boundingBox.minY + boundingBox.maxY) / 2D, posZ );
+        }
+    	// END FCMOD
         double var1 = 8.0D;
 
         if (this.xpTargetColor < this.xpColor - 20 + this.entityId % 100)
         {
             if (this.closestPlayer == null || this.closestPlayer.getDistanceSqToEntity(this) > var1 * var1)
             {
+				// FCMOD: Added
+		        if ( !m_bNotPlayerOwned )
+	        	// END FCMOD
                 this.closestPlayer = this.worldObj.getClosestPlayerToEntity(this, var1);
             }
 
@@ -97,11 +129,21 @@ public class EntityXPOrb extends Entity
             double var3 = (this.closestPlayer.posX - this.posX) / var1;
             double var5 = (this.closestPlayer.posY + (double)this.closestPlayer.getEyeHeight() - this.posY) / var1;
             double var7 = (this.closestPlayer.posZ - this.posZ) / var1;
+            // FCMOD: Code Changed for optimization
+            /*
             double var9 = Math.sqrt(var3 * var3 + var5 * var5 + var7 * var7);
             double var11 = 1.0D - var9;
 
             if (var11 > 0.0D)
             {
+            */
+            double dDistanceSq = var3 * var3 + var5 * var5 + var7 * var7;
+
+            if (dDistanceSq < 1.0D)
+            {
+                double var9 = Math.sqrt( dDistanceSq );
+                double var11 = 1.0D - var9;
+            // 	END FCMOD
                 var11 *= var11;
                 this.motionX += var3 / var9 * var11 * 0.1D;
                 this.motionY += var5 / var9 * var11 * 0.1D;
@@ -189,6 +231,9 @@ public class EntityXPOrb extends Entity
         par1NBTTagCompound.setShort("Health", (short)((byte)this.xpOrbHealth));
         par1NBTTagCompound.setShort("Age", (short)this.xpOrbAge);
         par1NBTTagCompound.setShort("Value", (short)this.xpValue);
+        // FCMOD: Code added        
+        par1NBTTagCompound.setBoolean("m_bNotPlayerOwned", m_bNotPlayerOwned);
+        // END FCMOD
     }
 
     /**
@@ -199,6 +244,12 @@ public class EntityXPOrb extends Entity
         this.xpOrbHealth = par1NBTTagCompound.getShort("Health") & 255;
         this.xpOrbAge = par1NBTTagCompound.getShort("Age");
         this.xpValue = par1NBTTagCompound.getShort("Value");
+        // FCMOD: Code added        
+        if ( par1NBTTagCompound.hasKey( "m_bNotPlayerOwned" ) )
+        {
+        	m_bNotPlayerOwned = par1NBTTagCompound.getBoolean( "m_bNotPlayerOwned" );
+        }
+        // END FCMOD
     }
 
     /**
@@ -206,6 +257,12 @@ public class EntityXPOrb extends Entity
      */
     public void onCollideWithPlayer(EntityPlayer par1EntityPlayer)
     {
+        // FCMOD: Code added
+    	if ( m_bNotPlayerOwned )
+    	{
+    		return;
+    	}
+    	// END FCMOD
         if (!this.worldObj.isRemote)
         {
             if (this.field_70532_c == 0 && par1EntityPlayer.xpCooldown == 0)
@@ -242,4 +299,42 @@ public class EntityXPOrb extends Entity
     {
         return false;
     }
+    
+    // FCMOD: inherited function added so that blocks like Hoppers get collision events with items on top.  
+    // Copy of code from Entity.java, changes marked with FCMOD.
+    @Override
+    protected void doBlockCollisions()
+    {
+        int i = MathHelper.floor_double(boundingBox.minX + 0.001D);
+        // FCMOD: code change
+        /*
+        int j = MathHelper.floor_double(boundingBox.minY + 0.001D);
+        */
+        int j = MathHelper.floor_double(boundingBox.minY - 0.01D);
+        // END FCMOD
+        int k = MathHelper.floor_double(boundingBox.minZ + 0.001D);
+        int l = MathHelper.floor_double(boundingBox.maxX - 0.001D);
+        int i1 = MathHelper.floor_double(boundingBox.maxY - 0.001D);
+        int j1 = MathHelper.floor_double(boundingBox.maxZ - 0.001D);
+
+        if (worldObj.checkChunksExist(i, j, k, l, i1, j1))
+        {
+            for (int k1 = i; k1 <= l; k1++)
+            {
+                for (int l1 = j; l1 <= i1; l1++)
+                {
+                    for (int i2 = k; i2 <= j1; i2++)
+                    {
+                        int j2 = worldObj.getBlockId(k1, l1, i2);
+
+                        if (j2 > 0)
+                        {
+                            Block.blocksList[j2].onEntityCollidedWithBlock(worldObj, k1, l1, i2, this);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EntityZombie.java b/minecraft_server/net/minecraft/src/EntityZombie.java
index 45ecabc..2f0b5ba 100644
--- a/minecraft_server/net/minecraft/src/EntityZombie.java
+++ b/minecraft_server/net/minecraft/src/EntityZombie.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 06/15/2018
+
 package net.minecraft.src;
 
 import java.util.Calendar;
diff --git a/minecraft_server/net/minecraft/src/EnumAction.java b/minecraft_server/net/minecraft/src/EnumAction.java
index 1ea0780..3caa80d 100644
--- a/minecraft_server/net/minecraft/src/EnumAction.java
+++ b/minecraft_server/net/minecraft/src/EnumAction.java
@@ -6,5 +6,9 @@ public enum EnumAction
     eat,
     drink,
     block,
-    bow;
+    // FCMOD: Changed
+    //bow;
+    bow,
+    miscUse;
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/EnumArmorMaterial.java b/minecraft_server/net/minecraft/src/EnumArmorMaterial.java
index 9376b3d..20060c4 100644
--- a/minecraft_server/net/minecraft/src/EnumArmorMaterial.java
+++ b/minecraft_server/net/minecraft/src/EnumArmorMaterial.java
@@ -2,9 +2,16 @@ package net.minecraft.src;
 
 public enum EnumArmorMaterial
 {
+	// FCMOD: Change to increase durability of armors, and change iron enchantibility to equal diamond
+	/*
     CLOTH(5, new int[]{1, 3, 2, 1}, 15),
     CHAIN(15, new int[]{2, 5, 4, 1}, 12),
     IRON(15, new int[]{2, 6, 5, 2}, 9),
+    */
+    CLOTH(10, new int[]{1, 3, 2, 1}, 15),
+    CHAIN(20, new int[]{2, 5, 4, 1}, 12),
+    IRON(20, new int[]{2, 6, 5, 2}, 10),
+    // END FCMOD
     GOLD(7, new int[]{2, 5, 3, 1}, 25),
     DIAMOND(33, new int[]{3, 8, 6, 3}, 10);
 
diff --git a/minecraft_server/net/minecraft/src/EnumCreatureType.java b/minecraft_server/net/minecraft/src/EnumCreatureType.java
index c8ceaee..a8f16a3 100644
--- a/minecraft_server/net/minecraft/src/EnumCreatureType.java
+++ b/minecraft_server/net/minecraft/src/EnumCreatureType.java
@@ -2,7 +2,11 @@ package net.minecraft.src;
 
 public enum EnumCreatureType
 {
-    monster(IMob.class, 70, Material.air, false, false),
+	// FCMOD: Changed to increase mob cap to compensate for rectangular instead of spherical despawn
+	// volume causing decreased mob density	
+    //monster(IMob.class, 70, Material.air, false, false),
+    monster( IMob.class, 90, Material.air, false, false ),
+	// END FCMOD
     creature(EntityAnimal.class, 10, Material.air, true, true),
     ambient(EntityAmbientCreature.class, 15, Material.air, true, false),
     waterCreature(EntityWaterMob.class, 5, Material.water, true, false);
diff --git a/minecraft_server/net/minecraft/src/EnumToolMaterial.java b/minecraft_server/net/minecraft/src/EnumToolMaterial.java
index 26cdd91..d607b2c 100644
--- a/minecraft_server/net/minecraft/src/EnumToolMaterial.java
+++ b/minecraft_server/net/minecraft/src/EnumToolMaterial.java
@@ -2,11 +2,24 @@ package net.minecraft.src;
 
 public enum EnumToolMaterial
 {
+	// FCMOD: Change to rebalance value of early game tools and value of iron
+	/*
     WOOD(0, 59, 2.0F, 0, 15),
     STONE(1, 131, 4.0F, 1, 5),
     IRON(2, 250, 6.0F, 2, 14),
     EMERALD(3, 1561, 8.0F, 3, 10),
     GOLD(0, 32, 12.0F, 0, 22);
+    */
+	// FCNOTE: Min efficiency is slightly greater than 1 due to > 1 test elsewhere in the code, 
+	// There's one such test in EntityPlayer.getCurrentPlayerStrVsBlock() but I'm not sure 
+	// it's the only one I was referring to in this comment when first written    
+	WOOD( 0, 10, 1.01F, 0, 0, 20, 2 ),  // no vanilla enchant of wood
+    STONE( 1, 50, 1.01F, 1, 5, 10, 1 ), 
+    IRON( 2, 500, 6F, 2, 14, 25, 2 ),
+    EMERALD( 3, 1561, 8F, 3, 14, 30, 2 ),
+    GOLD( 0, 32, 12F, 0, 22, 30, 3 ),
+    SOULFORGED_STEEL( 4, 2250, 12F, 4, 0, 30, 4 );
+    // END FCMOD
 
     /**
      * The level of material this tool can harvest (3 = DIAMOND, 2 = IRON, 1 = STONE, 0 = IRON/GOLD)
@@ -29,6 +42,8 @@ public enum EnumToolMaterial
     /** Defines the natural enchantability factor of the material. */
     private final int enchantability;
 
+    // FCMOD: Changed
+    /*
     private EnumToolMaterial(int par3, int par4, float par5, int par6, int par7)
     {
         this.harvestLevel = par3;
@@ -37,6 +52,20 @@ public enum EnumToolMaterial
         this.damageVsEntity = par6;
         this.enchantability = par7;
     }
+    */
+    private EnumToolMaterial( int iHarvestLevel, int iMaxUses, float fEffeciency, int iWeaponDamage, 
+    	int iEnchantability, int iInfernalMaxEnchantmentCost, int iInfernalMaxNumEnchants )
+    {
+        harvestLevel = iHarvestLevel;
+        maxUses = iMaxUses;
+        efficiencyOnProperMaterial = fEffeciency;
+        damageVsEntity = iWeaponDamage;
+        enchantability = iEnchantability;
+        
+        m_iInfernalMaxEnchantmentCost = iInfernalMaxEnchantmentCost;
+        m_iInfernalMaxNumEnchants = iInfernalMaxNumEnchants;
+    }    
+    // END FCMOD
 
     /**
      * The number of uses this material allows. (wood = 59, stone = 131, iron = 250, diamond = 1561, gold = 32)
@@ -86,4 +115,19 @@ public enum EnumToolMaterial
     {
         return this == WOOD ? Block.planks.blockID : (this == STONE ? Block.cobblestone.blockID : (this == GOLD ? Item.ingotGold.itemID : (this == IRON ? Item.ingotIron.itemID : (this == EMERALD ? Item.diamond.itemID : 0))));
     }
+    
+    // FCMOD: Added New
+    private final int m_iInfernalMaxEnchantmentCost;
+    private final int m_iInfernalMaxNumEnchants;
+    
+    public int GetInfernalMaxEnchantmentCost()
+    {
+    	return m_iInfernalMaxEnchantmentCost;
+    }
+    
+    public int GetInfernalMaxNumEnchants()
+    {
+    	return m_iInfernalMaxNumEnchants;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Explosion.java b/minecraft_server/net/minecraft/src/Explosion.java
index 5bfa5fe..76ba09c 100644
--- a/minecraft_server/net/minecraft/src/Explosion.java
+++ b/minecraft_server/net/minecraft/src/Explosion.java
@@ -28,6 +28,10 @@ public class Explosion
     public List affectedBlockPositions = new ArrayList();
     private Map field_77288_k = new HashMap();
 
+    // FCMOD: Added
+    public boolean m_bSuppressFX = false;
+    // END FCMOD
+
     public Explosion(World par1World, Entity par2Entity, double par3, double par5, double par7, float par9)
     {
         this.worldObj = par1World;
@@ -82,7 +86,14 @@ public class Explosion
                             if (var25 > 0)
                             {
                                 Block var26 = Block.blocksList[var25];
+                                
+                                // FCMOD: Changed
+                                /*
                                 float var27 = this.exploder != null ? this.exploder.func_82146_a(this, this.worldObj, var22, var23, var24, var26) : var26.getExplosionResistance(this.exploder);
+                                */
+                                float var27 = this.exploder != null ? this.exploder.func_82146_a(this, this.worldObj, var22, var23, var24, var26) : 
+                                	var26.getExplosionResistance(this.exploder, worldObj, var22, var23, var24);
+                                // END FCMOD
                                 var14 -= (var27 + 0.3F) * var21;
                             }
 
@@ -121,15 +132,15 @@ public class Explosion
                 var15 = var32.posX - this.explosionX;
                 var17 = var32.posY + (double)var32.getEyeHeight() - this.explosionY;
                 var19 = var32.posZ - this.explosionZ;
-                double var33 = (double)MathHelper.sqrt_double(var15 * var15 + var17 * var17 + var19 * var19);
+                double var34 = (double)MathHelper.sqrt_double(var15 * var15 + var17 * var17 + var19 * var19);
 
-                if (var33 != 0.0D)
+                if (var34 != 0.0D)
                 {
-                    var15 /= var33;
-                    var17 /= var33;
-                    var19 /= var33;
-                    double var34 = (double)this.worldObj.getBlockDensity(var31, var32.boundingBox);
-                    double var35 = (1.0D - var13) * var34;
+                    var15 /= var34;
+                    var17 /= var34;
+                    var19 /= var34;
+                    double var33 = (double)this.worldObj.getBlockDensity(var31, var32.boundingBox);
+                    double var35 = (1.0D - var13) * var33;
                     var32.attackEntityFrom(DamageSource.setExplosionSource(this), (int)((var35 * var35 + var35) / 2.0D * 8.0D * (double)this.explosionSize + 1.0D));
                     double var36 = EnchantmentProtection.func_92092_a(var32, var35);
                     var32.motionX += var15 * var36;
@@ -152,6 +163,10 @@ public class Explosion
      */
     public void doExplosionB(boolean par1)
     {
+    	// FCMOD: Added
+    	if ( !m_bSuppressFX )
+    	{
+    	// END FCMOD
         this.worldObj.playSoundEffect(this.explosionX, this.explosionY, this.explosionZ, "random.explode", 4.0F, (1.0F + (this.worldObj.rand.nextFloat() - this.worldObj.rand.nextFloat()) * 0.2F) * 0.7F);
 
         if (this.explosionSize >= 2.0F && this.isSmoking)
@@ -162,6 +177,9 @@ public class Explosion
         {
             this.worldObj.spawnParticle("largeexplode", this.explosionX, this.explosionY, this.explosionZ, 1.0D, 0.0D, 0.0D);
         }
+    	// FCMOD: Added
+    	}
+    	// END FCMOD
 
         Iterator var2;
         ChunkPosition var3;
@@ -205,15 +223,26 @@ public class Explosion
 
                 if (var7 > 0)
                 {
-                    Block var24 = Block.blocksList[var7];
+                    Block var25 = Block.blocksList[var7];
 
-                    if (var24.canDropFromExplosion(this))
+                    // FCMOD: Changed
+                    /*
+                    if (var25.canDropFromExplosion(this))
                     {
-                        var24.dropBlockAsItemWithChance(this.worldObj, var4, var5, var6, this.worldObj.getBlockMetadata(var4, var5, var6), 1.0F / this.explosionSize, 0);
+                        var25.dropBlockAsItemWithChance(this.worldObj, var4, var5, var6, this.worldObj.getBlockMetadata(var4, var5, var6), 1.0F / this.explosionSize, 0);
                     }
+                    */
+                    var25.DropItemsOnDestroyedByExplosion( worldObj, var4, var5, var6, this );
+                    // END FCMOD
 
+                    // FCMOD: Changed to rearrange order so that blocks can still access their metadata when notified of an explosion
+                    /*
+                    this.worldObj.setBlock(var4, var5, var6, 0, 0, 3);
+                    var25.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
+                    */
+                    var25.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
                     this.worldObj.setBlock(var4, var5, var6, 0, 0, 3);
-                    var24.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
+                    // END FCMOD
                 }
             }
         }
@@ -225,18 +254,33 @@ public class Explosion
             while (var2.hasNext())
             {
                 var3 = (ChunkPosition)var2.next();
+                
+                // FCMOD: Changed
+                /*
                 var4 = var3.x;
                 var5 = var3.y;
                 var6 = var3.z;
                 var7 = this.worldObj.getBlockId(var4, var5, var6);
-                int var25 = this.worldObj.getBlockId(var4, var5 - 1, var6);
+                int var24 = this.worldObj.getBlockId(var4, var5 - 1, var6);
 
-                if (var7 == 0 && Block.opaqueCubeLookup[var25] && this.explosionRNG.nextInt(3) == 0)
+                if (var7 == 0 && Block.opaqueCubeLookup[var24] && this.explosionRNG.nextInt(3) == 0)
                 {
                     this.worldObj.setBlock(var4, var5, var6, Block.fire.blockID);
                 }
+                */
+                if ( explosionRNG.nextInt( 3 ) == 0 && 
+                	FCBlockFire.CanFireReplaceBlock( worldObj, var3.x, var3.y, var3.z ) && 
+                	Block.fire.canPlaceBlockAt( worldObj, var3.x, var3.y, var3.z ) )
+                {
+                    this.worldObj.setBlock( var3.x, var3.y, var3.z, Block.fire.blockID );
+                }
+                // END FCMOD
             }
         }
+        
+        // FCMOD: Added
+        PerformSecondaryExplosions();
+        // END FCMOD
     }
 
     public Map func_77277_b()
@@ -248,4 +292,41 @@ public class Explosion
     {
         return this.exploder == null ? null : (this.exploder instanceof EntityTNTPrimed ? ((EntityTNTPrimed)this.exploder).getTntPlacedBy() : (this.exploder instanceof EntityLiving ? (EntityLiving)this.exploder : null));
     }
+    
+    // FCMOD: Added
+    public List m_SecondaryExplosionList = null;
+    
+    public void AddSecondaryExplosionNoFX( double dPosX, double dPosY, double dPosZ, 
+    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
+    {
+    	if ( m_SecondaryExplosionList == null )
+    	{
+    		m_SecondaryExplosionList = new ArrayList();
+    	}
+    	
+        Explosion explosion = new Explosion( worldObj, null, dPosX, dPosY, dPosZ, fExplosionSize );
+        
+        explosion.isFlaming = bCreatesFlames;
+        explosion.isSmoking = bDestroysBlocks;
+        explosion.m_bSuppressFX = true;
+        
+        m_SecondaryExplosionList.add( explosion );
+    }
+    
+    private void PerformSecondaryExplosions()
+    {
+    	if ( m_SecondaryExplosionList != null )
+    	{
+    		Iterator tempIterator = m_SecondaryExplosionList.iterator();
+    		
+            while ( tempIterator.hasNext() )
+            {
+                Explosion tempExplosion = (Explosion)tempIterator.next();
+                
+                tempExplosion.doExplosionA();
+                tempExplosion.doExplosionB( false ); // false tells individual block destruction effects not to play
+            }
+    	}
+    }    
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/FoodStats.java b/minecraft_server/net/minecraft/src/FoodStats.java
index aa87ae8..4cd5628 100644
--- a/minecraft_server/net/minecraft/src/FoodStats.java
+++ b/minecraft_server/net/minecraft/src/FoodStats.java
@@ -3,38 +3,65 @@ package net.minecraft.src;
 public class FoodStats
 {
     /** The player's food level. */
+	// FCMOD: Code change to increase food meter resolution
+	/*
     private int foodLevel = 20;
+    */
+    private int foodLevel = 60;
+    // END FCMOD
 
     /** The player's food saturation. */
+    // FCMOD: Code change so that player spawns with zero fat
+    /*
     private float foodSaturationLevel = 5.0F;
+    */
+    private float foodSaturationLevel = 0F;
+    // END FCMOD
 
     /** The player's food exhaustion. */
     private float foodExhaustionLevel;
 
     /** The player's food timer value. */
     private int foodTimer = 0;
+    
+	// FCMOD: Code change to increase food meter resolution
+	/*
     private int prevFoodLevel = 20;
+    */
+    private int prevFoodLevel = 60;
+    // END FCMOD
 
     /**
      * Args: int foodLevel, float foodSaturationModifier
      */
+    // FCMOD: Code removed and replaced later by custom function
+    /*
     public void addStats(int par1, float par2)
     {
         this.foodLevel = Math.min(par1 + this.foodLevel, 20);
         this.foodSaturationLevel = Math.min(this.foodSaturationLevel + (float)par1 * par2 * 2.0F, (float)this.foodLevel);
     }
+	*/
+	// END FCMOD
 
     /**
      * Eat some food.
      */
     public void addStats(ItemFood par1ItemFood)
     {
+    	// FCMOD: Code change
+    	/*
         this.addStats(par1ItemFood.getHealAmount(), par1ItemFood.getSaturationModifier());
+        */
+        this.addStats(par1ItemFood.GetHungerRestored(), par1ItemFood.getSaturationModifier());
+        // END FCMOD
     }
 
     /**
      * Handles the food game logic.
      */
+    // FCMOD: Code removed and replaced later by custom function
+    /*
     public void onUpdate(EntityPlayer par1EntityPlayer)
     {
         int var2 = par1EntityPlayer.worldObj.difficultySetting;
@@ -83,6 +110,8 @@ public class FoodStats
             this.foodTimer = 0;
         }
     }
+	*/
+	// END FCMOD
 
     /**
      * Reads the food data for the player.
@@ -95,6 +124,26 @@ public class FoodStats
             this.foodTimer = par1NBTTagCompound.getInteger("foodTickTimer");
             this.foodSaturationLevel = par1NBTTagCompound.getFloat("foodSaturationLevel");
             this.foodExhaustionLevel = par1NBTTagCompound.getFloat("foodExhaustionLevel");
+            
+            // FCMOD: Code added
+            if ( !par1NBTTagCompound.hasKey("fcFoodLevelAdjusted"))
+            {
+            	foodLevel = foodLevel * 3;
+            	foodSaturationLevel = 0F;
+            }
+            
+            // sanity check the values as apparently they can get fucked up when importing from vanilla
+            
+            if ( foodLevel > 60 || foodLevel < 0 )
+            {
+            	foodLevel = 60;
+            }
+            
+            if ( foodSaturationLevel > 20F || foodSaturationLevel < 0F )
+            {
+            	foodSaturationLevel = 20F;
+            }
+            // END FCMOD
         }
     }
 
@@ -107,6 +156,10 @@ public class FoodStats
         par1NBTTagCompound.setInteger("foodTickTimer", this.foodTimer);
         par1NBTTagCompound.setFloat("foodSaturationLevel", this.foodSaturationLevel);
         par1NBTTagCompound.setFloat("foodExhaustionLevel", this.foodExhaustionLevel);
+        
+        // FCMOD: Code added
+        par1NBTTagCompound.setBoolean( "fcFoodLevelAdjusted", true );
+        // END FCMOD
     }
 
     /**
@@ -122,7 +175,12 @@ public class FoodStats
      */
     public boolean needFood()
     {
+    	// FCMOD: Code changed
+    	/*
         return this.foodLevel < 20;
+        */
+        return this.foodLevel < 60;    	
+        // END FCMOD
     }
 
     /**
@@ -140,4 +198,111 @@ public class FoodStats
     {
         return this.foodSaturationLevel;
     }
+
+    // FCMOD: Added to match client
+    public void setFoodLevel(int par1)
+    {
+        this.foodLevel = par1;
+    }
+    
+    public void setFoodSaturationLevel(float par1)
+    {
+        this.foodSaturationLevel = par1;
+    }    
+    // END FCMOD
+
+    // FCMOD: Added New
+    /**
+     * Note that iFoodGain is one third regular hunger gained, with 6 units being a full pip
+     */
+    public void addStats( int iFoodGain, float fFatMultiplier )
+    {
+    	int iPreviousFoodLevel = foodLevel;
+    	
+        foodLevel = Math.min( iFoodGain + foodLevel, 60);
+        
+        int iExcessFood = iFoodGain - ( foodLevel - iPreviousFoodLevel );
+        
+        if ( iExcessFood > 0 )
+        {
+        	// divide by 3 due to increased resolution
+        	
+            foodSaturationLevel = Math.min( foodSaturationLevel + (float)iExcessFood * fFatMultiplier / 3F, 20F );
+        }
+    }
+    
+    public void onUpdate( EntityPlayer player )
+    {
+    	// only called on server
+    	
+        int iDifficulty = player.worldObj.difficultySetting;
+        
+        prevFoodLevel = foodLevel;
+
+        if ( iDifficulty > 0 )
+        {
+	        // burn hunger
+	        
+	        while ( foodLevel > 0 && foodExhaustionLevel >= 1.33F && !ShouldBurnFatBeforeHunger() )
+	        {
+	            foodExhaustionLevel -= 1.33F;
+	            
+	            foodLevel = Math.max( foodLevel - 1, 0 );
+	        }
+	        
+	    	// burn fat
+	    	
+	        while ( foodExhaustionLevel >= 0.5F && ShouldBurnFatBeforeHunger() )
+	        {
+	    		foodExhaustionLevel -= 0.5F;
+	    		
+	            foodSaturationLevel = Math.max( foodSaturationLevel - 0.125F, 0F );
+	        }
+        }
+        else
+        {
+        	foodExhaustionLevel = 0F;
+        }
+
+        if ( foodLevel > 24 && player.shouldHeal() )
+        {
+            ++foodTimer;
+
+            if ( foodTimer >= 600 ) // once every 30 seconds
+            {
+                player.heal( 1 );
+                foodTimer = 0;
+            }
+        }
+        else if ( foodLevel <= 0 && foodSaturationLevel <= 0.01F )
+        {
+            ++foodTimer;
+
+            if ( foodTimer >= 80 )
+            {
+            	if ( iDifficulty > 0 )
+            	{
+            		player.attackEntityFrom( DamageSource.starve, 1 );
+            	}
+
+                foodTimer = 0;
+            }
+
+            // reset the exhaustion level so that it doesn't stack up while the player is starving
+            
+            foodExhaustionLevel = 0F;
+        }
+        else
+        {
+            foodTimer = 0;
+        }
+    }
+    
+    private boolean ShouldBurnFatBeforeHunger()
+    {
+    	// only burn fat when the corresponding hunger pip is completely depleted
+    	
+    	return foodSaturationLevel > (float)( ( foodLevel + 5 ) / 6 ) * 2F;    	
+    }
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/FurnaceRecipes.java b/minecraft_server/net/minecraft/src/FurnaceRecipes.java
index 9f6e65d..9027f07 100644
--- a/minecraft_server/net/minecraft/src/FurnaceRecipes.java
+++ b/minecraft_server/net/minecraft/src/FurnaceRecipes.java
@@ -45,11 +45,15 @@ public class FurnaceRecipes
     /**
      * Adds a smelting recipe.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public void addSmelting(int par1, ItemStack par2ItemStack, float par3)
     {
         this.smeltingList.put(Integer.valueOf(par1), par2ItemStack);
         this.experienceList.put(Integer.valueOf(par2ItemStack.itemID), Float.valueOf(par3));
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the smelting result of an item.
@@ -68,4 +72,32 @@ public class FurnaceRecipes
     {
         return this.experienceList.containsKey(Integer.valueOf(par1)) ? ((Float)this.experienceList.get(Integer.valueOf(par1))).floatValue() : 0.0F;
     }
+    
+    // FCMOD: Code added
+    private Map m_CookTimeBinaryShiftMap = new HashMap();
+    
+    public void addSmelting( int iInputItemID, ItemStack outputStack, float fExperience )
+    {
+    	addSmelting( iInputItemID, outputStack, fExperience, 0 );
+    }
+    
+    public void addSmelting( int iInputItemID, ItemStack outputStack, float fExperience, int iCookTimeBinaryShift )
+    {
+        smeltingList.put( Integer.valueOf( iInputItemID ), outputStack );
+        
+        experienceList.put( Integer.valueOf( outputStack.itemID ), Float.valueOf( fExperience ) );
+        
+        m_CookTimeBinaryShiftMap.put( Integer.valueOf( iInputItemID ), Integer.valueOf( iCookTimeBinaryShift ) );
+    }
+    
+    public int GetCookTimeBinaryShift( int iItemID )
+    {
+    	if ( m_CookTimeBinaryShiftMap.containsKey( Integer.valueOf( iItemID ) ) )
+    	{
+    		return ((Integer)m_CookTimeBinaryShiftMap.get( Integer.valueOf( iItemID ) ) ).intValue();
+    	}
+    	
+    	return 0;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/IMerchant.java b/minecraft_server/net/minecraft/src/IMerchant.java
index dd9915c..eb286f5 100644
--- a/minecraft_server/net/minecraft/src/IMerchant.java
+++ b/minecraft_server/net/minecraft/src/IMerchant.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 10/02/2018
+
 package net.minecraft.src;
 
 public interface IMerchant
@@ -9,4 +11,10 @@ public interface IMerchant
     MerchantRecipeList getRecipes(EntityPlayer var1);
 
     void useRecipe(MerchantRecipe var1);
+
+    // FCMOD: Added
+    public int GetCurrentTradeLevel(); 
+    public int GetCurrentTradeXP();
+    public int GetCurrentTradeMaxXP();
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/IRecipe.java b/minecraft_server/net/minecraft/src/IRecipe.java
index 0dc59af..1688e92 100644
--- a/minecraft_server/net/minecraft/src/IRecipe.java
+++ b/minecraft_server/net/minecraft/src/IRecipe.java
@@ -18,4 +18,14 @@ public interface IRecipe
     int getRecipeSize();
 
     ItemStack getRecipeOutput();
+    
+    // FCMOD: Added
+    public abstract boolean matches( IRecipe recipe );
+    
+    // NOTE: That secondary output is manually flagged rather than maintaining an internal 
+    // list of outputs because of SlotCrafting having no idea what recipe is being produced when 
+    // the output is collected.  It would be a mess of base class edits to change this.
+    
+    public abstract boolean HasSecondaryOutput();
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ISaveHandler.java b/minecraft_server/net/minecraft/src/ISaveHandler.java
index 03106a9..d471f69 100644
--- a/minecraft_server/net/minecraft/src/ISaveHandler.java
+++ b/minecraft_server/net/minecraft/src/ISaveHandler.java
@@ -45,4 +45,10 @@ public interface ISaveHandler
      * Returns the name of the directory where world information is saved.
      */
     String getWorldDirectoryName();
+
+    // FCMOD: Added
+    public void LoadModSpecificData( WorldServer world );
+    
+    public void SaveModSpecificData( WorldServer world );
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/InventoryMerchant.java b/minecraft_server/net/minecraft/src/InventoryMerchant.java
index 7acc2b2..3b65784 100644
--- a/minecraft_server/net/minecraft/src/InventoryMerchant.java
+++ b/minecraft_server/net/minecraft/src/InventoryMerchant.java
@@ -228,6 +228,10 @@ public class InventoryMerchant implements IInventory
                 }
             }
         }
+        
+        // FCMOD: Code added
+        ResetRecipeAndSlotsModProcessing();
+        // END FCMOD
     }
 
     public MerchantRecipe getCurrentRecipe()
@@ -240,4 +244,37 @@ public class InventoryMerchant implements IInventory
         this.currentRecipeIndex = par1;
         this.resetRecipeAndSlots();
     }
+    
+    // FCMOD: Code added
+    private void ResetRecipeAndSlotsModProcessing()
+    {
+    	ItemStack outputStack = theInventory[2];
+    	
+		if ( outputStack != null && outputStack.itemID == FCBetterThanWolves.fcItemAncientProphecy.itemID )
+		{
+			ItemStack manuscriptStack = theInventory[0];
+			
+			if ( manuscriptStack.itemID != Item.enchantedBook.itemID )
+			{
+				manuscriptStack = theInventory[1];
+			}
+			
+			int iEnchantmentID = -1;
+			
+			NBTTagList enchantmentTagList = Item.enchantedBook.func_92110_g( manuscriptStack );
+			
+			if ( enchantmentTagList != null && enchantmentTagList.tagCount() > 0 )
+			{
+                short iTempID = ((NBTTagCompound)enchantmentTagList.tagAt( 0 ) ).getShort("id");
+
+                if (Enchantment.enchantmentsList[iTempID] != null)
+                {
+                	iEnchantmentID = iTempID;                	
+                }
+			}
+			
+			((FCItemAncientProphecy)FCBetterThanWolves.fcItemAncientProphecy).InitializeProphecyDataFromEnchantmentID( outputStack, iEnchantmentID );
+		}
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/InventoryPlayer.java b/minecraft_server/net/minecraft/src/InventoryPlayer.java
index f4aa117..ee2b922 100644
--- a/minecraft_server/net/minecraft/src/InventoryPlayer.java
+++ b/minecraft_server/net/minecraft/src/InventoryPlayer.java
@@ -407,13 +407,23 @@ public class InventoryPlayer implements IInventory
     /**
      * Gets the strength of the current item (tool) against the specified block, 1.0f if not holding anything.
      */
+    // FCMOD: Code change
+    /*
     public float getStrVsBlock(Block par1Block)
+    */
+    public float getStrVsBlock( World world, Block par1Block, int i, int j, int k )
+    // END FCMOD
     {
         float var2 = 1.0F;
 
         if (this.mainInventory[this.currentItem] != null)
         {
+            // FCMOD: Code change
+            /*
             var2 *= this.mainInventory[this.currentItem].getStrVsBlock(par1Block);
+            */
+            var2 *= this.mainInventory[this.currentItem].getStrVsBlock( world, par1Block, i, j, k );
+        	// END FCMOD
         }
 
         return var2;
@@ -544,7 +554,12 @@ public class InventoryPlayer implements IInventory
     /**
      * Returns whether the current item (tool) can harvest from the specified block (actually get a result).
      */
+    // FCMOD: Code change
+    /*
     public boolean canHarvestBlock(Block par1Block)
+    */
+    public boolean canHarvestBlock(World world, Block par1Block, int i, int j, int k)
+    // END FCMOD
     {
         if (par1Block.blockMaterial.isToolNotRequired())
         {
@@ -553,7 +568,12 @@ public class InventoryPlayer implements IInventory
         else
         {
             ItemStack var2 = this.getStackInSlot(this.currentItem);
+            // FCMOD: Code change
+            /*
             return var2 != null ? var2.canHarvestBlock(par1Block) : false;
+            */
+            return var2 != null ? var2.canHarvestBlock(world, par1Block, i, j, k) : false;
+            // END FCMOD
         }
     }
 
diff --git a/minecraft_server/net/minecraft/src/Item.java b/minecraft_server/net/minecraft/src/Item.java
index 8ad0953..3d32833 100644
--- a/minecraft_server/net/minecraft/src/Item.java
+++ b/minecraft_server/net/minecraft/src/Item.java
@@ -11,183 +11,187 @@ public class Item
 
     /** A 32000 elements Item array. */
     public static Item[] itemsList = new Item[32000];
-    public static Item shovelIron = (new ItemSpade(0, EnumToolMaterial.IRON)).setUnlocalizedName("shovelIron");
-    public static Item pickaxeIron = (new ItemPickaxe(1, EnumToolMaterial.IRON)).setUnlocalizedName("pickaxeIron");
-    public static Item axeIron = (new ItemAxe(2, EnumToolMaterial.IRON)).setUnlocalizedName("hatchetIron");
-    public static Item flintAndSteel = (new ItemFlintAndSteel(3)).setUnlocalizedName("flintAndSteel");
-    public static Item appleRed = (new ItemFood(4, 4, 0.3F, false)).setUnlocalizedName("apple");
-    public static ItemBow bow = (ItemBow)(new ItemBow(5)).setUnlocalizedName("bow");
-    public static Item arrow = (new Item(6)).setUnlocalizedName("arrow").setCreativeTab(CreativeTabs.tabCombat);
-    public static Item coal = (new ItemCoal(7)).setUnlocalizedName("coal");
-    public static Item diamond = (new Item(8)).setUnlocalizedName("diamond").setCreativeTab(CreativeTabs.tabMaterials);
+    
+    public static final int m_iFilterable_NoProperties = 0;
+    public static final int m_iFilterable_SolidBlock = 1;
+    public static final int m_iFilterable_Small = 2;
+    public static final int m_iFilterable_Narrow = 4;
+    public static final int m_iFilterable_Fine = 8;
+    public static final int m_iFilterable_Thin = 16;
+    
+    public static Item shovelIron = ( new FCItemShovel( 0, EnumToolMaterial.IRON ) ).setUnlocalizedName( "shovelIron" );
+    public static Item pickaxeIron = ( new FCItemPickaxe( 1, EnumToolMaterial.IRON ) ).setUnlocalizedName( "pickaxeIron" );
+    public static Item axeIron = ( new FCItemAxe( 2, EnumToolMaterial.IRON ) ).setUnlocalizedName( "hatchetIron" );
+    public static Item flintAndSteel = ( new FCItemFlintAndSteel( 3 ) ).setUnlocalizedName( "flintAndSteel" );
+    public static Item appleRed = ( new ItemFood( 4, 1, 0F, false ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "apple" );
+    public static ItemBow bow = new FCItemBow( 5 );
+    public static Item arrow = new FCItemArrow( 6 );
+    public static Item coal = ( new ItemCoal( 7 ) ).SetIncineratedInCrucible().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.COAL ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "coal" );
+    public static Item diamond = ( new Item( 8 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "diamond" ).setCreativeTab( CreativeTabs.tabMaterials );
     public static Item ingotIron = (new Item(9)).setUnlocalizedName("ingotIron").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item ingotGold = (new Item(10)).setUnlocalizedName("ingotGold").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item swordIron = (new ItemSword(11, EnumToolMaterial.IRON)).setUnlocalizedName("swordIron");
-    public static Item swordWood = (new ItemSword(12, EnumToolMaterial.WOOD)).setUnlocalizedName("swordWood");
-    public static Item shovelWood = (new ItemSpade(13, EnumToolMaterial.WOOD)).setUnlocalizedName("shovelWood");
-    public static Item pickaxeWood = (new ItemPickaxe(14, EnumToolMaterial.WOOD)).setUnlocalizedName("pickaxeWood");
-    public static Item axeWood = (new ItemAxe(15, EnumToolMaterial.WOOD)).setUnlocalizedName("hatchetWood");
-    public static Item swordStone = (new ItemSword(16, EnumToolMaterial.STONE)).setUnlocalizedName("swordStone");
-    public static Item shovelStone = (new ItemSpade(17, EnumToolMaterial.STONE)).setUnlocalizedName("shovelStone");
-    public static Item pickaxeStone = (new ItemPickaxe(18, EnumToolMaterial.STONE)).setUnlocalizedName("pickaxeStone");
-    public static Item axeStone = (new ItemAxe(19, EnumToolMaterial.STONE)).setUnlocalizedName("hatchetStone");
-    public static Item swordDiamond = (new ItemSword(20, EnumToolMaterial.EMERALD)).setUnlocalizedName("swordDiamond");
-    public static Item shovelDiamond = (new ItemSpade(21, EnumToolMaterial.EMERALD)).setUnlocalizedName("shovelDiamond");
-    public static Item pickaxeDiamond = (new ItemPickaxe(22, EnumToolMaterial.EMERALD)).setUnlocalizedName("pickaxeDiamond");
-    public static Item axeDiamond = (new ItemAxe(23, EnumToolMaterial.EMERALD)).setUnlocalizedName("hatchetDiamond");
-    public static Item stick = (new Item(24)).setFull3D().setUnlocalizedName("stick").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bowlEmpty = (new Item(25)).setUnlocalizedName("bowl").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bowlSoup = (new ItemSoup(26, 6)).setUnlocalizedName("mushroomStew");
-    public static Item swordGold = (new ItemSword(27, EnumToolMaterial.GOLD)).setUnlocalizedName("swordGold");
-    public static Item shovelGold = (new ItemSpade(28, EnumToolMaterial.GOLD)).setUnlocalizedName("shovelGold");
-    public static Item pickaxeGold = (new ItemPickaxe(29, EnumToolMaterial.GOLD)).setUnlocalizedName("pickaxeGold");
-    public static Item axeGold = (new ItemAxe(30, EnumToolMaterial.GOLD)).setUnlocalizedName("hatchetGold");
-    public static Item silk = (new ItemReed(31, Block.tripWire)).setUnlocalizedName("string").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item feather = (new Item(32)).setUnlocalizedName("feather").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item gunpowder = (new Item(33)).setUnlocalizedName("sulphur").setPotionEffect(PotionHelper.gunpowderEffect).setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item hoeWood = (new ItemHoe(34, EnumToolMaterial.WOOD)).setUnlocalizedName("hoeWood");
-    public static Item hoeStone = (new ItemHoe(35, EnumToolMaterial.STONE)).setUnlocalizedName("hoeStone");
-    public static Item hoeIron = (new ItemHoe(36, EnumToolMaterial.IRON)).setUnlocalizedName("hoeIron");
-    public static Item hoeDiamond = (new ItemHoe(37, EnumToolMaterial.EMERALD)).setUnlocalizedName("hoeDiamond");
-    public static Item hoeGold = (new ItemHoe(38, EnumToolMaterial.GOLD)).setUnlocalizedName("hoeGold");
-    public static Item seeds = (new ItemSeeds(39, Block.crops.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds");
-    public static Item wheat = (new Item(40)).setUnlocalizedName("wheat").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bread = (new ItemFood(41, 5, 0.6F, false)).setUnlocalizedName("bread");
-    public static ItemArmor helmetLeather = (ItemArmor)(new ItemArmor(42, EnumArmorMaterial.CLOTH, 0, 0)).setUnlocalizedName("helmetCloth");
-    public static ItemArmor plateLeather = (ItemArmor)(new ItemArmor(43, EnumArmorMaterial.CLOTH, 0, 1)).setUnlocalizedName("chestplateCloth");
-    public static ItemArmor legsLeather = (ItemArmor)(new ItemArmor(44, EnumArmorMaterial.CLOTH, 0, 2)).setUnlocalizedName("leggingsCloth");
-    public static ItemArmor bootsLeather = (ItemArmor)(new ItemArmor(45, EnumArmorMaterial.CLOTH, 0, 3)).setUnlocalizedName("bootsCloth");
-    public static ItemArmor helmetChain = (ItemArmor)(new ItemArmor(46, EnumArmorMaterial.CHAIN, 1, 0)).setUnlocalizedName("helmetChain");
-    public static ItemArmor plateChain = (ItemArmor)(new ItemArmor(47, EnumArmorMaterial.CHAIN, 1, 1)).setUnlocalizedName("chestplateChain");
-    public static ItemArmor legsChain = (ItemArmor)(new ItemArmor(48, EnumArmorMaterial.CHAIN, 1, 2)).setUnlocalizedName("leggingsChain");
-    public static ItemArmor bootsChain = (ItemArmor)(new ItemArmor(49, EnumArmorMaterial.CHAIN, 1, 3)).setUnlocalizedName("bootsChain");
-    public static ItemArmor helmetIron = (ItemArmor)(new ItemArmor(50, EnumArmorMaterial.IRON, 2, 0)).setUnlocalizedName("helmetIron");
-    public static ItemArmor plateIron = (ItemArmor)(new ItemArmor(51, EnumArmorMaterial.IRON, 2, 1)).setUnlocalizedName("chestplateIron");
-    public static ItemArmor legsIron = (ItemArmor)(new ItemArmor(52, EnumArmorMaterial.IRON, 2, 2)).setUnlocalizedName("leggingsIron");
-    public static ItemArmor bootsIron = (ItemArmor)(new ItemArmor(53, EnumArmorMaterial.IRON, 2, 3)).setUnlocalizedName("bootsIron");
-    public static ItemArmor helmetDiamond = (ItemArmor)(new ItemArmor(54, EnumArmorMaterial.DIAMOND, 3, 0)).setUnlocalizedName("helmetDiamond");
-    public static ItemArmor plateDiamond = (ItemArmor)(new ItemArmor(55, EnumArmorMaterial.DIAMOND, 3, 1)).setUnlocalizedName("chestplateDiamond");
-    public static ItemArmor legsDiamond = (ItemArmor)(new ItemArmor(56, EnumArmorMaterial.DIAMOND, 3, 2)).setUnlocalizedName("leggingsDiamond");
-    public static ItemArmor bootsDiamond = (ItemArmor)(new ItemArmor(57, EnumArmorMaterial.DIAMOND, 3, 3)).setUnlocalizedName("bootsDiamond");
-    public static ItemArmor helmetGold = (ItemArmor)(new ItemArmor(58, EnumArmorMaterial.GOLD, 4, 0)).setUnlocalizedName("helmetGold");
-    public static ItemArmor plateGold = (ItemArmor)(new ItemArmor(59, EnumArmorMaterial.GOLD, 4, 1)).setUnlocalizedName("chestplateGold");
-    public static ItemArmor legsGold = (ItemArmor)(new ItemArmor(60, EnumArmorMaterial.GOLD, 4, 2)).setUnlocalizedName("leggingsGold");
-    public static ItemArmor bootsGold = (ItemArmor)(new ItemArmor(61, EnumArmorMaterial.GOLD, 4, 3)).setUnlocalizedName("bootsGold");
-    public static Item flint = (new Item(62)).setUnlocalizedName("flint").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item porkRaw = (new ItemFood(63, 3, 0.3F, true)).setUnlocalizedName("porkchopRaw");
-    public static Item porkCooked = (new ItemFood(64, 8, 0.8F, true)).setUnlocalizedName("porkchopCooked");
-    public static Item painting = (new ItemHangingEntity(65, EntityPainting.class)).setUnlocalizedName("painting");
-    public static Item appleGold = (new ItemAppleGold(66, 4, 1.2F, false)).setAlwaysEdible().setPotionEffect(Potion.regeneration.id, 5, 0, 1.0F).setUnlocalizedName("appleGold");
-    public static Item sign = (new ItemSign(67)).setUnlocalizedName("sign");
-    public static Item doorWood = (new ItemDoor(68, Material.wood)).setUnlocalizedName("doorWood");
-    public static Item bucketEmpty = (new ItemBucket(69, 0)).setUnlocalizedName("bucket").setMaxStackSize(16);
-    public static Item bucketWater = (new ItemBucket(70, Block.waterMoving.blockID)).setUnlocalizedName("bucketWater").setContainerItem(bucketEmpty);
-    public static Item bucketLava = (new ItemBucket(71, Block.lavaMoving.blockID)).setUnlocalizedName("bucketLava").setContainerItem(bucketEmpty);
-    public static Item minecartEmpty = (new ItemMinecart(72, 0)).setUnlocalizedName("minecart");
-    public static Item saddle = (new ItemSaddle(73)).setUnlocalizedName("saddle");
+    public static Item swordIron = ( new FCItemSword( 11, EnumToolMaterial.IRON ) ).setUnlocalizedName( "swordIron" );
+    public static Item swordWood = ( new FCItemSword( 12, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "swordWood" );
+    public static Item shovelWood = ( new FCItemShovel( 13, EnumToolMaterial.WOOD ) ).SetDamageVsEntity( 2 ).setUnlocalizedName( "shovelWood" );
+    public static Item pickaxeWood = ( new FCItemPickaxe( 14, EnumToolMaterial.WOOD, 1 ) ).setUnlocalizedName( "pickaxeWood" );
+    public static Item axeWood = ( new FCItemAxe( 15, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "hatchetWood" );
+    public static Item swordStone = ( new FCItemSword( 16, EnumToolMaterial.STONE ) ).setUnlocalizedName( "swordStone" );	    
+    public static Item shovelStone = new FCItemShovelStone( 17 );
+    public static Item pickaxeStone = ( new FCItemPickaxe( 18, EnumToolMaterial.STONE ) ).setUnlocalizedName( "pickaxeStone" );
+    public static Item axeStone = ( new FCItemAxe( 19, EnumToolMaterial.STONE ) ).setUnlocalizedName( "hatchetStone" );
+    public static Item swordDiamond = ( new FCItemSword( 20, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "swordDiamond" );	    
+    public static Item shovelDiamond = ( new FCItemShovel( 21, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "shovelDiamond" );
+    public static Item pickaxeDiamond = ( new FCItemPickaxe( 22, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "pickaxeDiamond" );	    
+    public static Item axeDiamond = ( new FCItemAxe( 23, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "hatchetDiamond" );
+    public static Item stick = new FCItemShaft( 24 );    
+    public static Item bowlEmpty = ( new Item( 25 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "bowl" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item bowlSoup = ( new FCItemMushroomSoup( 26, 3 ) ).setUnlocalizedName( "mushroomStew" );
+    public static Item swordGold = ( new FCItemSword( 27, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "swordGold" );
+    public static Item shovelGold = ( new FCItemShovel( 28, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "shovelGold" );
+    public static Item pickaxeGold = ( new FCItemPickaxe( 29, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "pickaxeGold" );	    
+    public static Item axeGold = ( new FCItemAxe( 30, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "hatchetGold" );
+    public static Item silk = ( new Item( 31 ) ).SetBuoyant().SetBellowsBlowDistance( 2 ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "string" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item feather = ( new Item( 32 ) ).SetBuoyant().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "feather" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item gunpowder = ( new Item( 33 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "sulphur" ).setPotionEffect( PotionHelper.gunpowderEffect ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item hoeWood = ( new FCItemHoe( 34, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "hoeWood" );
+    public static Item hoeStone = ( new FCItemHoe( 35, EnumToolMaterial.STONE ) ).setUnlocalizedName( "hoeStone" );
+    public static Item hoeIron = ( new FCItemHoe( 36, EnumToolMaterial.IRON ) ).setUnlocalizedName( "hoeIron" );
+    public static Item hoeDiamond = ( new FCItemHoe( 37, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "hoeDiamond" );
+    public static Item hoeGold = ( new FCItemHoe( 38, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "hoeGold" );
+    public static Item seeds = ( new FCItemSeeds( 39, Block.crops.blockID ) ).SetAsBasicChickenFood().setUnlocalizedName( "seeds" ).setCreativeTab( null );
+    public static Item wheat = new FCItemWheatLegacy( 40 );
+    public static Item bread = ( new ItemFood( 41, 3, 0.25F, false ) ).setUnlocalizedName( "bread" );
+    public static ItemArmor helmetLeather = (ItemArmor)( new FCItemArmorLeather( 42, 0 ) ).setUnlocalizedName( "helmetCloth" );
+    public static ItemArmor plateLeather = (ItemArmor)( new FCItemArmorLeather( 43, 1 ) ).setUnlocalizedName( "chestplateCloth" );
+    public static ItemArmor legsLeather = (ItemArmor)( new FCItemArmorLeather( 44, 2 ) ).setUnlocalizedName( "leggingsCloth" );
+    public static ItemArmor bootsLeather = (ItemArmor)( new FCItemArmorLeather( 45, 3 ) ).setUnlocalizedName( "bootsCloth" );    
+    public static ItemArmor helmetChain = (ItemArmor)( new FCItemArmorChain( 46, 0, 3 ) ).setUnlocalizedName( "helmetChain" );
+    public static ItemArmor plateChain = (ItemArmor)( new FCItemArmorChain( 47, 1, 4 ) ).setUnlocalizedName( "chestplateChain" );
+    public static ItemArmor legsChain = (ItemArmor)( new FCItemArmorChain( 48, 2, 4 ) ).setUnlocalizedName( "leggingsChain" );
+    public static ItemArmor bootsChain = (ItemArmor)( new FCItemArmorChain( 49, 3, 2 ) ).setUnlocalizedName( "bootsChain" );
+    public static ItemArmor helmetIron = (ItemArmor)( new FCItemArmorIron( 50, 0, 5 ) ).setUnlocalizedName( "helmetIron" );
+    public static ItemArmor plateIron = (ItemArmor)( new FCItemArmorIron( 51, 1, 8 ) ).setUnlocalizedName( "chestplateIron" );
+    public static ItemArmor legsIron = (ItemArmor)( new FCItemArmorIron( 52, 2, 7 ) ).setUnlocalizedName( "leggingsIron" );
+    public static ItemArmor bootsIron = (ItemArmor)( new FCItemArmorIron( 53, 3, 4 ) ).setUnlocalizedName( "bootsIron" );
+    public static ItemArmor helmetDiamond = (ItemArmor)( new FCItemArmorDiamond( 54, 0, 5 ) ).setUnlocalizedName( "helmetDiamond" );
+    public static ItemArmor plateDiamond = (ItemArmor)( new FCItemArmorDiamond( 55, 1, 8 ) ).setUnlocalizedName( "chestplateDiamond" );
+    public static ItemArmor legsDiamond = (ItemArmor)( new FCItemArmorDiamond( 56, 2, 7 ) ).setUnlocalizedName( "leggingsDiamond" );
+    public static ItemArmor bootsDiamond = (ItemArmor)( new FCItemArmorDiamond( 57, 3, 4 ) ).setUnlocalizedName( "bootsDiamond" );
+    public static ItemArmor helmetGold = (ItemArmor)( new FCItemArmorGold( 58, 0, 5 ) ).setUnlocalizedName( "helmetGold" );
+    public static ItemArmor plateGold = (ItemArmor)( new FCItemArmorGold( 59, 1, 8 ) ).setUnlocalizedName( "chestplateGold" );
+    public static ItemArmor legsGold = (ItemArmor)( new FCItemArmorGold( 60, 2, 7 ) ).setUnlocalizedName( "leggingsGold" );
+    public static ItemArmor bootsGold = (ItemArmor)( new FCItemArmorGold( 61, 3, 4 ) ).setUnlocalizedName( "bootsGold" );
+    public static Item flint = new FCItemFlint( 62 );
+    public static Item porkRaw = ( new FCItemFood( 63, FCItemFood.m_iPorkChopRawHungerHealed, FCItemFood.m_fPorkChopSaturationModifier, true, "porkchopRaw", true ) ).SetStandardFoodPoisoningEffect();    
+    public static Item porkCooked = ( new ItemFood( 64, FCItemFood.m_iPorkChopCookedHungerHealed, FCItemFood.m_fPorkChopSaturationModifier, true ) ).setUnlocalizedName( "porkchopCooked" );    
+    public static Item painting = ( new ItemHangingEntity( 65, EntityPainting.class ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "painting" );
+    public static Item appleGold = ( new ItemAppleGold( 66, 1, 0F, false ) ).setAlwaysEdible().setPotionEffect( Potion.regeneration.id, 5, 0, 1F ).SetNonBuoyant().SetNotIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "appleGold" );
+    public static Item sign = new FCItemSign( 67 );
+    public static Item doorWood = new FCItemDoorWood( 68 );	    
+    public static Item bucketEmpty = new FCItemBucketEmpty( 69 );
+    public static Item bucketWater = new FCItemBucketWater( 70 );
+    public static Item bucketLava = new FCItemBucketLava( 71 );
+    public static Item minecartEmpty = ( new FCItemMinecart( 72, 0 ) ).setUnlocalizedName( "minecart" );
+    public static Item saddle = ( new ItemSaddle( 73 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "saddle" );
     public static Item doorIron = (new ItemDoor(74, Material.iron)).setUnlocalizedName("doorIron");
-    public static Item redstone = (new ItemRedstone(75)).setUnlocalizedName("redstone").setPotionEffect(PotionHelper.redstoneEffect);
-    public static Item snowball = (new ItemSnowball(76)).setUnlocalizedName("snowball");
-    public static Item boat = (new ItemBoat(77)).setUnlocalizedName("boat");
-    public static Item leather = (new Item(78)).setUnlocalizedName("leather").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item bucketMilk = (new ItemBucketMilk(79)).setUnlocalizedName("milk").setContainerItem(bucketEmpty);
-    public static Item brick = (new Item(80)).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item clay = (new Item(81)).setUnlocalizedName("clay").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item reed = (new ItemReed(82, Block.reed)).setUnlocalizedName("reeds").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item paper = (new Item(83)).setUnlocalizedName("paper").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item book = (new ItemBook(84)).setUnlocalizedName("book").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item slimeBall = (new Item(85)).setUnlocalizedName("slimeball").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item minecartCrate = (new ItemMinecart(86, 1)).setUnlocalizedName("minecartChest");
-    public static Item minecartPowered = (new ItemMinecart(87, 2)).setUnlocalizedName("minecartFurnace");
-    public static Item egg = (new ItemEgg(88)).setUnlocalizedName("egg");
+    public static Item redstone = new FCItemRedstone( 75 );
+    public static Item snowball = new FCItemSnowball( 76 );
+    public static Item boat = new FCItemBoat( 77 );
+    public static Item leather = ( new Item( 78 ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Thin ).setUnlocalizedName( "leather" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item bucketMilk = new FCItemBucketMilk( 79 );    	
+    public static Item brick = new FCItemBrick( 80 );
+    public static Item clay = new FCItemClay( 81 );
+    public static Item reed = ( new ItemReed( 82, Block.reed ) ).SetBuoyant().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Narrow ).setUnlocalizedName( "reeds" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item paper = ( new Item( 83 ) ).SetBuoyant().SetBellowsBlowDistance( 3 ).SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "paper" ).setCreativeTab( CreativeTabs.tabMisc );
+    public static Item book = new FCItemBook( 84 );
+    public static Item slimeBall = new FCItemSlimeball( 85 );
+    public static Item minecartCrate = ( new FCItemMinecart( 86, 1 ) ).setUnlocalizedName( "minecartChest" );
+    public static Item minecartPowered = ( new FCItemMinecart( 87, 2 ) ).setUnlocalizedName( "minecartFurnace" );
+    public static Item egg = new FCItemEgg( 88 );
     public static Item compass = (new Item(89)).setUnlocalizedName("compass").setCreativeTab(CreativeTabs.tabTools);
-    public static ItemFishingRod fishingRod = (ItemFishingRod)(new ItemFishingRod(90)).setUnlocalizedName("fishingRod");
+    public static ItemFishingRod fishingRod = new FCItemFishingRod( 90 );
     public static Item pocketSundial = (new Item(91)).setUnlocalizedName("clock").setCreativeTab(CreativeTabs.tabTools);
-    public static Item lightStoneDust = (new Item(92)).setUnlocalizedName("yellowDust").setPotionEffect(PotionHelper.glowstoneEffect).setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item fishRaw = (new ItemFood(93, 2, 0.3F, false)).setUnlocalizedName("fishRaw");
-    public static Item fishCooked = (new ItemFood(94, 5, 0.6F, false)).setUnlocalizedName("fishCooked");
-    public static Item dyePowder = (new ItemDye(95)).setUnlocalizedName("dyePowder");
-    public static Item bone = (new Item(96)).setUnlocalizedName("bone").setFull3D().setCreativeTab(CreativeTabs.tabMisc);
-    public static Item sugar = (new Item(97)).setUnlocalizedName("sugar").setPotionEffect(PotionHelper.sugarEffect).setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item cake = (new ItemReed(98, Block.cake)).setMaxStackSize(1).setUnlocalizedName("cake").setCreativeTab(CreativeTabs.tabFood);
-    public static Item bed = (new ItemBed(99)).setMaxStackSize(1).setUnlocalizedName("bed");
-    public static Item redstoneRepeater = (new ItemReed(100, Block.redstoneRepeaterIdle)).setUnlocalizedName("diode").setCreativeTab(CreativeTabs.tabRedstone);
-    public static Item cookie = (new ItemFood(101, 2, 0.1F, false)).setUnlocalizedName("cookie");
-    public static ItemMap map = (ItemMap)(new ItemMap(102)).setUnlocalizedName("map");
-
-    /**
-     * Item introduced on 1.7 version, is a shear to cut leaves (you can keep the block) or get wool from sheeps.
-     */
-    public static ItemShears shears = (ItemShears)(new ItemShears(103)).setUnlocalizedName("shears");
-    public static Item melon = (new ItemFood(104, 2, 0.3F, false)).setUnlocalizedName("melon");
-    public static Item pumpkinSeeds = (new ItemSeeds(105, Block.pumpkinStem.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds_pumpkin");
-    public static Item melonSeeds = (new ItemSeeds(106, Block.melonStem.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds_melon");
-    public static Item beefRaw = (new ItemFood(107, 3, 0.3F, true)).setUnlocalizedName("beefRaw");
-    public static Item beefCooked = (new ItemFood(108, 8, 0.8F, true)).setUnlocalizedName("beefCooked");
-    public static Item chickenRaw = (new ItemFood(109, 2, 0.3F, true)).setPotionEffect(Potion.hunger.id, 30, 0, 0.3F).setUnlocalizedName("chickenRaw");
-    public static Item chickenCooked = (new ItemFood(110, 6, 0.6F, true)).setUnlocalizedName("chickenCooked");
-    public static Item rottenFlesh = (new ItemFood(111, 4, 0.1F, true)).setPotionEffect(Potion.hunger.id, 30, 0, 0.8F).setUnlocalizedName("rottenFlesh");
-    public static Item enderPearl = (new ItemEnderPearl(112)).setUnlocalizedName("enderPearl");
-    public static Item blazeRod = (new Item(113)).setUnlocalizedName("blazeRod").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item ghastTear = (new Item(114)).setUnlocalizedName("ghastTear").setPotionEffect(PotionHelper.ghastTearEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item goldNugget = (new Item(115)).setUnlocalizedName("goldNugget").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item netherStalkSeeds = (new ItemSeeds(116, Block.netherStalk.blockID, Block.slowSand.blockID)).setUnlocalizedName("netherStalkSeeds").setPotionEffect("+4");
-    public static ItemPotion potion = (ItemPotion)(new ItemPotion(117)).setUnlocalizedName("potion");
-    public static Item glassBottle = (new ItemGlassBottle(118)).setUnlocalizedName("glassBottle");
-    public static Item spiderEye = (new ItemFood(119, 2, 0.8F, false)).setPotionEffect(Potion.poison.id, 5, 0, 1.0F).setUnlocalizedName("spiderEye").setPotionEffect(PotionHelper.spiderEyeEffect);
-    public static Item fermentedSpiderEye = (new Item(120)).setUnlocalizedName("fermentedSpiderEye").setPotionEffect(PotionHelper.fermentedSpiderEyeEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item blazePowder = (new Item(121)).setUnlocalizedName("blazePowder").setPotionEffect(PotionHelper.blazePowderEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item magmaCream = (new Item(122)).setUnlocalizedName("magmaCream").setPotionEffect(PotionHelper.magmaCreamEffect).setCreativeTab(CreativeTabs.tabBrewing);
+    public static Item lightStoneDust = ( new Item( 92 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "yellowDust" ).setCreativeTab( CreativeTabs.tabMaterials );    
+    public static Item fishRaw = ( new FCItemFood( 93, FCItemFood.m_iFishRawHungerHealed, FCItemFood.m_fFishSaturationModifier, false, "fishRaw" ) ).SetStandardFoodPoisoningEffect();
+    public static Item fishCooked = ( new ItemFood( 94, FCItemFood.m_iFishCookedHungerHealed, FCItemFood.m_fFishSaturationModifier, false ) ).setUnlocalizedName( "fishCooked" );
+    public static Item dyePowder = new FCItemDye( 95 );
+    public static Item bone = new FCItemBone( 96 );
+    public static Item sugar = ( new Item( 97 ) ).SetBuoyant().SetBellowsBlowDistance( 3 ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "sugar" ).setCreativeTab( CreativeTabs.tabMaterials );	    
+    public static Item cake = ( new ItemReed( 98, Block.cake ) ).SetBuoyant().SetIncineratedInCrucible().setMaxStackSize( 1 ).setUnlocalizedName( "cake" ).setCreativeTab( CreativeTabs.tabFood );
+    public static Item bed = ( new ItemBed( 99 ) ).SetBuoyant().SetIncineratedInCrucible().setMaxStackSize( 1 ).setUnlocalizedName( "bed" );
+    public static Item redstoneRepeater = new FCItemRedstoneRepeater( 100 );
+    public static Item cookie = ( new ItemFood( 101, 1, 1F, false ) ).setAlwaysEdible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "cookie" );
+    public static ItemMap map = new FCItemMap( 102 );
+    public static ItemShears shears = (ItemShears)( new FCItemShears( 103 ) ).setUnlocalizedName( "shears" );
+    public static Item melon = new FCItemFoodHighRes( 104, 2, 0F, false, "melon" );
+    public static Item pumpkinSeeds = ( new FCItemSeedFood( 105, 1, 0F, Block.pumpkinStem.blockID ) ).SetAsBasicChickenFood().SetBellowsBlowDistance( 2 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "seeds_pumpkin" );
+    public static Item melonSeeds = ( new FCItemSeeds( 106, Block.melonStem.blockID ) ).SetAsBasicChickenFood().setUnlocalizedName( "seeds_melon" );
+    public static Item beefRaw = ( new FCItemFood( 107, FCItemFood.m_iBeefRawHungerHealed, FCItemFood.m_fBeefSaturationModifier, true, "beefRaw", true ) ).SetStandardFoodPoisoningEffect();    
+    public static Item beefCooked = ( new ItemFood( 108, FCItemFood.m_iBeefCookedHungerHealed, FCItemFood.m_fBeefSaturationModifier, true ) ).setUnlocalizedName("beefCooked");
+    public static Item chickenRaw = ( new FCItemFood( 109, FCItemFood.m_iChickenRawHungerHealed, FCItemFood.m_fChickenSaturationModifier, true, "chickenRaw" ) ).SetStandardFoodPoisoningEffect();    
+    public static Item chickenCooked = (new ItemFood( 110, FCItemFood.m_iChickenCookedHungerHealed, FCItemFood.m_fChickenSaturationModifier, true ) ).setUnlocalizedName( "chickenCooked" );    
+    public static Item rottenFlesh = new FCItemRottenFlesh( 111 );
+    public static Item enderPearl = ( new ItemEnderPearl( 112 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "enderPearl" );
+    public static Item blazeRod = ( new Item( 113 ) ).SetFurnaceBurnTime( FCEnumFurnaceBurnTime.BLAZE_ROD ).SetFilterableProperties( m_iFilterable_Narrow ).setUnlocalizedName( "blazeRod" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item ghastTear = ( new Item( 114 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "ghastTear" ).setPotionEffect( PotionHelper.ghastTearEffect ).setCreativeTab( CreativeTabs.tabBrewing );
+    public static Item goldNugget = ( new Item( 115 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "goldNugget" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item netherStalkSeeds = ( new FCItemSeeds( 116, Block.netherStalk.blockID ) ).SetBellowsBlowDistance( 1 ).setUnlocalizedName( "netherStalkSeeds" ).setPotionEffect( "+4" );
+    public static ItemPotion potion = new FCItemPotion( 117 );
+    public static Item glassBottle = ( new FCItemGlassBottle( 118 ) ).SetBuoyant().setUnlocalizedName( "glassBottle" );
+    public static Item spiderEye = ( (new ItemFood( 119, 2, 0.8F, false ) ).setPotionEffect( Potion.poison.id, 5, 0, 1F ) ).SetNeutralBuoyant().SetFilterableProperties( m_iFilterable_Small ).setPotionEffect( PotionHelper.goldenCarrotEffect ).setUnlocalizedName( "spiderEye" );
+    public static Item fermentedSpiderEye = ( new Item( 120 ) ).SetNeutralBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "fermentedSpiderEye" ).setPotionEffect( PotionHelper.fermentedSpiderEyeEffect ).setCreativeTab( CreativeTabs.tabBrewing );
+    public static Item blazePowder = ( new Item( 121 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "blazePowder" ).setPotionEffect( PotionHelper.blazePowderEffect ).setCreativeTab( CreativeTabs.tabBrewing );
+    public static Item magmaCream = ( new Item( 122 ) ).SetNeutralBuoyant().setUnlocalizedName( "magmaCream" ).setPotionEffect( PotionHelper.magmaCreamEffect ).setCreativeTab( CreativeTabs.tabBrewing );
     public static Item brewingStand = (new ItemReed(123, Block.brewingStand)).setUnlocalizedName("brewingStand").setCreativeTab(CreativeTabs.tabBrewing);
     public static Item cauldron = (new ItemReed(124, Block.cauldron)).setUnlocalizedName("cauldron").setCreativeTab(CreativeTabs.tabBrewing);
-    public static Item eyeOfEnder = (new ItemEnderEye(125)).setUnlocalizedName("eyeOfEnder");
-    public static Item speckledMelon = (new Item(126)).setUnlocalizedName("speckledMelon").setPotionEffect(PotionHelper.speckledMelonEffect).setCreativeTab(CreativeTabs.tabBrewing);
+    public static Item eyeOfEnder = ( new ItemEnderEye( 125 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "eyeOfEnder" );
+    public static Item speckledMelon = ( new Item( 126 ) ).setUnlocalizedName( "speckledMelon" ).setCreativeTab( CreativeTabs.tabFood );
     public static Item monsterPlacer = (new ItemMonsterPlacer(127)).setUnlocalizedName("monsterPlacer");
 
     /**
      * Bottle o' Enchanting. Drops between 1 and 3 experience orbs when thrown.
      */
     public static Item expBottle = (new ItemExpBottle(128)).setUnlocalizedName("expBottle");
-
-    /**
-     * Fire Charge. When used in a dispenser it fires a fireball similiar to a Ghast's.
-     */
-    public static Item fireballCharge = (new ItemFireball(129)).setUnlocalizedName("fireball");
-    public static Item writableBook = (new ItemWritableBook(130)).setUnlocalizedName("writingBook").setCreativeTab(CreativeTabs.tabMisc);
-    public static Item writtenBook = (new ItemEditableBook(131)).setUnlocalizedName("writtenBook");
+    public static Item fireballCharge = new FCItemFireCharge( 129 );
+    public static Item writableBook = ( new ItemWritableBook( 130 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "writingBook" ).setCreativeTab( CreativeTabs.tabMisc );
+    public static Item writtenBook = ( new ItemEditableBook( 131 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "writtenBook" );
     public static Item emerald = (new Item(132)).setUnlocalizedName("emerald").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item itemFrame = (new ItemHangingEntity(133, EntityItemFrame.class)).setUnlocalizedName("frame");
-    public static Item flowerPot = (new ItemReed(134, Block.flowerPot)).setUnlocalizedName("flowerPot").setCreativeTab(CreativeTabs.tabDecorations);
-    public static Item carrot = (new ItemSeedFood(135, 4, 0.6F, Block.carrot.blockID, Block.tilledField.blockID)).setUnlocalizedName("carrots");
-    public static Item potato = (new ItemSeedFood(136, 1, 0.3F, Block.potato.blockID, Block.tilledField.blockID)).setUnlocalizedName("potato");
-    public static Item bakedPotato = (new ItemFood(137, 6, 0.6F, false)).setUnlocalizedName("potatoBaked");
-    public static Item poisonousPotato = (new ItemFood(138, 2, 0.3F, false)).setPotionEffect(Potion.poison.id, 5, 0, 0.6F).setUnlocalizedName("potatoPoisonous");
-    public static ItemEmptyMap emptyMap = (ItemEmptyMap)(new ItemEmptyMap(139)).setUnlocalizedName("emptyMap");
-    public static Item goldenCarrot = (new ItemFood(140, 6, 1.2F, false)).setUnlocalizedName("carrotGolden").setPotionEffect(PotionHelper.goldenCarrotEffect);
-    public static Item skull = (new ItemSkull(141)).setUnlocalizedName("skull");
-    public static Item carrotOnAStick = (new ItemCarrotOnAStick(142)).setUnlocalizedName("carrotOnAStick");
-    public static Item netherStar = (new ItemSimpleFoiled(143)).setUnlocalizedName("netherStar").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item pumpkinPie = (new ItemFood(144, 8, 0.3F, false)).setUnlocalizedName("pumpkinPie").setCreativeTab(CreativeTabs.tabFood);
+    public static Item itemFrame = ( new ItemHangingEntity( 133, EntityItemFrame.class ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "frame" );
+    public static Item flowerPot = ( new ItemReed( 134, Block.flowerPot ) ).SetBuoyant().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "flowerPot" ).setCreativeTab( CreativeTabs.tabDecorations );
+    public static Item carrot = ( new FCItemSeedFood( 135, 3, 0F, Block.carrot.blockID ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "carrots" );
+    public static Item potato = ( new FCItemSeedFood( 136, 3, 0F, Block.potato.blockID ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "potato" );
+    public static Item bakedPotato = ( new ItemFood( 137, 2, 0F, false ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "potatoBaked" );	    
+    public static Item poisonousPotato = ( new ItemFood( 138, 1, 0F, false ) ).setPotionEffect( Potion.poison.id, 5, 0, 0.6F ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "potatoPoisonous" );
+    public static ItemEmptyMap emptyMap = new FCItemEmptyMap( 139 );
+    public static Item goldenCarrot = ( new ItemFood( 140, 1, 0F, false ) ).SetNonBuoyant().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "carrotGolden" );
+    public static Item skull = ( new ItemSkull( 141 ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "skull" );
+    public static Item carrotOnAStick = new FCItemCarrotOnAStick( 142 );
+    public static Item netherStar = new FCItemNetherStar( 143 );
+    public static Item pumpkinPie = ( new ItemFood( 144, 2, 2.5F, false ) ).setAlwaysEdible().setUnlocalizedName( "pumpkinPie" ).setCreativeTab( CreativeTabs.tabFood );
     public static Item firework = (new ItemFirework(145)).setUnlocalizedName("fireworks");
     public static Item fireworkCharge = (new ItemFireworkCharge(146)).setUnlocalizedName("fireworksCharge").setCreativeTab(CreativeTabs.tabMisc);
-    public static ItemEnchantedBook enchantedBook = (ItemEnchantedBook)(new ItemEnchantedBook(147)).setMaxStackSize(1).setUnlocalizedName("enchantedBook");
-    public static Item comparator = (new ItemReed(148, Block.redstoneComparatorIdle)).setUnlocalizedName("comparator").setCreativeTab(CreativeTabs.tabRedstone);
-    public static Item netherrackBrick = (new Item(149)).setUnlocalizedName("netherbrick").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item netherQuartz = (new Item(150)).setUnlocalizedName("netherquartz").setCreativeTab(CreativeTabs.tabMaterials);
-    public static Item tntMinecart = (new ItemMinecart(151, 3)).setUnlocalizedName("minecartTnt");
-    public static Item hopperMinecart = (new ItemMinecart(152, 5)).setUnlocalizedName("minecartHopper");
+    public static ItemEnchantedBook enchantedBook = (ItemEnchantedBook)( new FCItemEnchantedBook( 147 ) ).setMaxStackSize( 1 ).setUnlocalizedName( "enchantedBook" );
+    public static Item comparator = (new FCItemPlacesAsBlock(148, Block.redstoneComparatorIdle.blockID)).setUnlocalizedName("comparator").setCreativeTab(CreativeTabs.tabRedstone);
+    public static Item netherrackBrick = ( new Item(149 ) ).setUnlocalizedName( "netherbrick" );
+    public static Item netherQuartz = ( new FCItemNetherQuartz( 150 ) ).setUnlocalizedName( "netherquartz" ).setCreativeTab( CreativeTabs.tabMaterials );
+    public static Item minecartTnt = ( new FCItemStub( 151 ) ).setUnlocalizedName( "minecartTnt" );
+    public static Item minecartHopper = ( new FCItemStub( 152 ) ).setUnlocalizedName( "minecartHopper" );
+    // Added aliases to avoid annoying naming differences between client and server
+    public static Item tntMinecart = minecartTnt;
+    public static Item hopperMinecart = minecartHopper;
+    
     public static Item record13 = (new ItemRecord(2000, "13")).setUnlocalizedName("record");
-    public static Item recordCat = (new ItemRecord(2001, "cat")).setUnlocalizedName("record");
-    public static Item recordBlocks = (new ItemRecord(2002, "blocks")).setUnlocalizedName("record");
-    public static Item recordChirp = (new ItemRecord(2003, "chirp")).setUnlocalizedName("record");
-    public static Item recordFar = (new ItemRecord(2004, "far")).setUnlocalizedName("record");
-    public static Item recordMall = (new ItemRecord(2005, "mall")).setUnlocalizedName("record");
-    public static Item recordMellohi = (new ItemRecord(2006, "mellohi")).setUnlocalizedName("record");
-    public static Item recordStal = (new ItemRecord(2007, "stal")).setUnlocalizedName("record");
-    public static Item recordStrad = (new ItemRecord(2008, "strad")).setUnlocalizedName("record");
-    public static Item recordWard = (new ItemRecord(2009, "ward")).setUnlocalizedName("record");
-    public static Item record11 = (new ItemRecord(2010, "11")).setUnlocalizedName("record");
-    public static Item recordWait = (new ItemRecord(2011, "wait")).setUnlocalizedName("record");
+    public static Item recordCat = (new ItemRecord(2001, "cat")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordBlocks = (new ItemRecord(2002, "blocks")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordChirp = (new ItemRecord(2003, "chirp")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordFar = (new ItemRecord(2004, "far")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordMall = (new ItemRecord(2005, "mall")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordMellohi = (new ItemRecord(2006, "mellohi")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordStal = (new ItemRecord(2007, "stal")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordStrad = (new ItemRecord(2008, "strad")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordWard = (new ItemRecord(2009, "ward")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item record11 = (new ItemRecord(2010, "11")).setUnlocalizedName("record").setCreativeTab( null );
+    public static Item recordWait = (new ItemRecord(2011, "wait")).setUnlocalizedName("record").setCreativeTab((CreativeTabs)null);
 
     /** The ID of this item. */
     public final int itemID;
@@ -206,19 +210,21 @@ public class Item
      */
     protected boolean hasSubtypes = false;
     private Item containerItem = null;
-
-    /**
-     * The string representing this item's effect on a potion when used as an ingredient.
-     */
     private String potionEffect = null;
 
     /** The unlocalized name of this item. */
     private String unlocalizedName;
+    
+    public static final boolean[] itemReplaced = new boolean[32000];
+    private Class entityClass = EntityItem.class;
 
     protected Item(int par1)
     {
         this.itemID = 256 + par1;
 
+        // FCMOD: Code added
+        if ( !m_bSuppressConflictWarnings )
+    	// END FCMOD
         if (itemsList[256 + par1] != null)
         {
             System.out.println("CONFLICT @ " + par1);
@@ -246,10 +252,14 @@ public class Item
      * Returns the strength of the stack against a given block. 1.0F base, (Quality+1)*2 if correct blocktype, 1.5F if
      * sword
      */
+    // FCMOD: Removed and replaced later
+    /*
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return 1.0F;
     }
+    */
+    // END FCMOD
 
     /**
      * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
@@ -338,10 +348,14 @@ public class Item
     /**
      * Returns if the item (tool) can harvest results from the block type.
      */
+    // FCMOD: Removed and replaced
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return false;
     }
+    */
+    // END FCMOD
 
     /**
      * Called when a player right clicks an entity with an item.
@@ -445,7 +459,10 @@ public class Item
      * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and
      * update it's contents.
      */
-    public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5) {}
+    // FCMOD: Changed
+    //public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5) {}
+    public void onUpdate( ItemStack stack, World world, EntityPlayer entity, int iInventorySlot, boolean bIsHandHeldItem ) {}
+    // END FCMOD
 
     /**
      * Called when item is crafted/smelted. Used only by maps so far.
@@ -573,4 +590,509 @@ public class Item
     {
         StatList.initStats();
     }
+
+	// FCMOD: Added New
+    public static boolean m_bSuppressConflictWarnings = false;
+    
+    /**
+     * Method which replaces canPlaceItemBlockOnSide() in ItemBlock. Allows the client to prevent item usage before it is relayed
+     * to the server by returning false.  Only called on client.
+     */    
+    public boolean CanItemBeUsedByPlayer( World world, int i, int j, int k, int iFacing, EntityPlayer player, ItemStack stack )
+    {
+    	return true;    	
+    }
+    
+    public boolean DoZombiesConsume()
+    {
+    	return false;
+    }
+    
+    public boolean IsEfficientVsBlock( ItemStack stack, World world, Block block, int i, int j, int k )
+    {
+        return false;
+    }
+    
+    public boolean canHarvestBlock( ItemStack stack, World world, Block block, int i, int j, int k )
+    {
+        return false;
+    }
+    
+    public float getStrVsBlock( ItemStack stack, World world, Block block, int i, int j, int k )
+    {
+        return 1F;
+    }
+    
+    public boolean IsMultiUsePerClick()
+    {
+    	return true;
+    }
+    
+    public float GetExhaustionOnUsedToHarvestBlock( int iBlockID, World world, int i, int j, int k, int iBlockMetadata )
+    {
+    	return 0.025F; // standard default exhaustion amount
+    }
+    
+    public void InitializeStackOnGiveCommand( Random rand, ItemStack stack )
+    {
+    }
+    
+    public void UpdateUsingItem( ItemStack stack, World world, EntityPlayer player )
+    {
+    }
+    
+    public int GetItemUseWarmupDuration()
+    {
+    	return 7;
+    }
+    
+    public boolean IgnoreDamageWhenComparingDuringUse()
+    {
+    	return false;
+    }
+	
+    //------------ Addon interfacing related functionality ----------//
+
+    /**
+     * Replaces a reference to an existing block (vanilla or btw)
+     * @param id The block id to be replaced
+     * @param newClass The class of the new item
+     * @param parameters Optional additional parameters to pass to the item, not including the id.
+     */
+    public static Item replaceItem(int id, Class newClass, Object ... parameters) {
+    	if (itemReplaced[id]) {
+    		throw new RuntimeException("Multiple addons attempting to replace item " + itemsList[id]);
+    	}
+    	else {
+    		m_bSuppressConflictWarnings = true;
+    		
+    		Item newItem = null;
+    		
+    		Class[] parameterTypes = new Class[parameters.length + 1];
+    		Object[] parameterValues = new Object[parameters.length + 1];
+    		
+    		parameterTypes[0] = Integer.TYPE;
+    		parameterValues[0] = id - 256;
+    		
+    		for (int i = 0; i < parameters.length; i++) {
+    			Class<?> type = parameters[i].getClass();
+    			
+    			if (type == Integer.class) {
+    				type = Integer.TYPE;
+    			}
+    			else if (type == Boolean.class) {
+    				type = Boolean.TYPE;
+    			}
+    			else if (type == Float.class) {
+    				type = Float.TYPE;
+    			}
+    			else if (type == Double.class) {
+    				type = Double.TYPE;
+    			}
+    			else if (Block.class.isAssignableFrom(type)) {
+    				type = Block.class;
+    			}
+    			else if (Item.class.isAssignableFrom(type)) {
+    				type = Item.class;
+    			}
+    			
+    			parameterTypes[i + 1] = type;
+    			parameterValues[i + 1] = parameters[i];
+    		}
+    		
+    			try {
+					newItem = (Item) newClass.getConstructor(parameterTypes).newInstance(parameterValues);
+				} catch (InstantiationException e) {
+					throw new RuntimeException("A problem has occured attempting to instantiate replacement for " + itemsList[id]);
+				} catch (IllegalArgumentException e) {
+					throw new RuntimeException("Incompatible types passed to specified constructor for " + itemsList[id]);
+				} catch (NoSuchMethodException e) {
+					throw new RuntimeException("No appropriate constructor found for " + itemsList[id] + ". Constructors must be public to be used in replacement.");
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+    		
+    		itemReplaced[id] = true;
+    		Item original = itemsList[id];
+    		itemsList[id] = null;
+    		
+    		newItem.SetFilterableProperties(original.m_iFilterablePropertiesBitfield).SetBuoyancy(original.GetBuoyancy(0));
+    		
+    		if (original.IsIncineratedInCrucible())
+    			newItem.SetIncineratedInCrucible();
+    		else
+    			newItem.SetNotIncineratedInCrucible();
+    		
+    		itemsList[id] = newItem;
+    		
+    		m_bSuppressConflictWarnings = false;
+    		
+    		return newItem;
+    	}
+    }
+    
+    //----------- Animal Food related functionality -----------//
+    
+    public static final int m_iBaseHerbivoreItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 4 );
+    public static final int m_iBasePigItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 4 );
+    public static final int m_iBaseChickenItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 8 );
+
+    private int m_iHerbivoreFoodValue = 0;
+    private int m_iBirdFoodValue = 0;
+    private int m_iPigFoodValue = 0;
+    
+    public int GetHerbivoreFoodValue( int iItemDamage )
+    {
+    	return m_iHerbivoreFoodValue;
+    }
+    
+    public Item SetHerbivoreFoodValue( int iFoodValue )
+    {
+    	m_iHerbivoreFoodValue = iFoodValue;
+    	
+    	return this;
+    }
+    
+    public Item SetAsBasicHerbivoreFood()
+    {
+    	return SetHerbivoreFoodValue( m_iBaseHerbivoreItemFoodValue );
+    }
+    
+    public int GetChickenFoodValue( int iItemDamage )
+    {
+    	return m_iBirdFoodValue;
+    }
+    
+    public Item SetChickenFoodValue( int iFoodValue )
+    {
+    	m_iBirdFoodValue = iFoodValue;
+    	
+    	return this;
+    }
+    
+    public Item SetAsBasicChickenFood()
+    {
+    	return SetChickenFoodValue( m_iBaseChickenItemFoodValue );
+    }
+    
+    public int GetPigFoodValue( int iItemDamage )
+    {
+    	return m_iPigFoodValue;
+    }
+    
+    public Item SetPigFoodValue( int iFoodValue )
+    {
+    	m_iPigFoodValue = iFoodValue;
+    	
+    	return this;
+    }
+    
+    public Item SetAsBasicPigFood()
+    {
+    	return SetPigFoodValue( m_iBasePigItemFoodValue );
+    }
+    
+    public boolean IsWolfFood()
+    {
+    	return false;
+    }
+    
+    public int GetWolfHealAmount()
+    {
+    	return 0;
+    }
+    
+    //------------- Buoyancy related functionality ------------//
+    
+	private float m_fBuoyancy = -1.0F;
+	
+    public Item SetBuoyancy( float fBuoyancy )
+    {
+    	m_fBuoyancy = fBuoyancy;
+    	
+    	return this;
+    }
+    
+    public Item SetBuoyant() { return SetBuoyancy( 1F ); }
+    public Item SetNonBuoyant() { return SetBuoyancy( -1F ); }
+    public Item SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
+    
+    public float GetBuoyancy( int iItemDamage )
+    {
+    	return m_fBuoyancy;
+    }
+    
+    public int GetWeightWhenWorn()
+    {
+    	return 0;
+    }
+    
+    //------------- Bellows related functionality ------------//
+    
+	private int m_iBellowsBlowDistance = 0;
+	
+	/**
+	 * 3 = light powders or light large surface objects like paper or bat wings
+	 * 2 = seeds, dyes, fibers, chunkier powders like ground netherrack or sand, 
+	 * 	   heavier sheets like bark or wicker
+	 * 1 = fabric or wool, small leather like straps, arrows, heavier small mobsdrops like creeper 
+	 * 	   oysters, and witch wart, dirt and gravel, heavy seeds like cocoa beans and netherwart
+	 * 0 = everything else
+	 */
+    public Item SetBellowsBlowDistance( int iDistance )
+    {
+    	m_iBellowsBlowDistance = iDistance;
+    	
+    	return this;
+    }
+    
+    public int GetBellowsBlowDistance( int iItemDamage )
+    {
+    	return m_iBellowsBlowDistance;
+    }
+    
+    //------------- Enchanting related functionality ------------//
+    
+	private int m_iInfernalMaxNumEnchants = 0;
+	private int m_iInfernalMaxEnchantmentCost = 0;
+	
+    public Item SetInfernalMaxNumEnchants( int iMaxNumEnchants )
+    {
+    	m_iInfernalMaxNumEnchants = iMaxNumEnchants;
+    	
+    	return this;
+    }
+    
+    public int GetInfernalMaxNumEnchants()
+    {
+    	return m_iInfernalMaxNumEnchants;
+    }    
+    
+    public Item SetInfernalMaxEnchantmentCost( int iMaxEnchantmentCost )
+    {
+    	m_iInfernalMaxEnchantmentCost = iMaxEnchantmentCost;
+    	
+    	return this;
+    }
+    
+    public int GetInfernalMaxEnchantmentCost()
+    {
+    	return m_iInfernalMaxEnchantmentCost;
+    }    
+    
+    public boolean IsEnchantmentApplicable( Enchantment enchantment )
+    {
+    	return enchantment.type == EnumEnchantmentType.all;
+    }
+    
+    //------------- Crafting related functionality ------------//
+    
+    protected int m_iDefaultFurnaceBurnTime = 0;
+    protected boolean m_bIsInceratedInCrucible = false;
+    
+    public boolean IsConsumedInCrafting()
+    {
+    	return true;
+    }
+    
+    public boolean IsDamagedInCrafting()
+    {
+    	return false;
+    }    
+    
+    public void OnUsedInCrafting( int iItemDamage, EntityPlayer player, ItemStack outputStack )
+    {
+    	OnUsedInCrafting( player, outputStack );
+    }
+    
+    public void OnUsedInCrafting( EntityPlayer player, ItemStack outputStack )
+    {
+    }
+    
+    public void OnDamagedInCrafting( EntityPlayer player )
+    {
+    }
+    
+    public void OnBrokenInCrafting( EntityPlayer player )
+    {
+    }
+    
+    public int GetFurnaceBurnTime( int iItemDamage )
+    {
+    	return m_iDefaultFurnaceBurnTime;
+    }
+    
+    public Item SetFurnaceBurnTime( int iBurnTime )
+    {
+    	m_iDefaultFurnaceBurnTime = iBurnTime;
+    	
+    	return this;
+    }
+    
+    public Item SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
+    {
+    	SetFurnaceBurnTime( burnTime.m_iBurnTime );
+    	
+    	return this;
+    }
+    
+    public int GetCampfireBurnTime( int iItemDamage )
+    {
+    	return GetFurnaceBurnTime( iItemDamage );
+    }
+    
+    /**
+     * Used to override default activation behavior on certain blocks like accessing inventory on furnace and campfires 
+     */
+    public boolean GetCanItemStartFireOnUse( int iItemDamage )
+    {
+    	return false;
+    }    
+    
+    /**
+     * Used to override default activation behavior on certain blocks like accessing inventory on furnace and campfires 
+     */
+    public boolean GetCanItemBeSetOnFireOnUse( int iItemDamage )
+    {
+    	return false;
+    }
+    
+    public boolean GetCanBeFedDirectlyIntoCampfire( int iItemDamage )
+    {
+		return !GetCanItemBeSetOnFireOnUse( iItemDamage ) && !GetCanItemStartFireOnUse( iItemDamage ) &&
+			GetCampfireBurnTime( iItemDamage ) > 0;
+    }
+    
+    public boolean GetCanBeFedDirectlyIntoBrickOven( int iItemDamage )
+    {
+		return !GetCanItemBeSetOnFireOnUse( iItemDamage ) && !GetCanItemStartFireOnUse( iItemDamage ) &&
+			GetFurnaceBurnTime( iItemDamage ) > 0;
+    }
+    
+    public boolean IsIncineratedInCrucible()
+    {
+    	return m_bIsInceratedInCrucible;
+    }
+    
+    public Item SetIncineratedInCrucible()
+    {
+    	m_bIsInceratedInCrucible = true;
+    	
+    	return this;
+    }
+    
+    public Item SetNotIncineratedInCrucible()
+    {
+    	m_bIsInceratedInCrucible = false;
+    	
+    	return this;
+    }
+    
+    public boolean DoesConsumeContainerItemWhenCrafted( Item containerItem )
+    {
+    	return false;
+    }
+    
+    //------------- Piston Packing related functionality ------------//
+    
+    public boolean IsPistonPackable( ItemStack stack )
+    {
+    	return false;
+    }
+    
+    public int GetRequiredItemCountToPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
+    {
+    	return 0;
+    }
+    
+    //------------- Hopper Filtering Functionality -----------//
+    
+    protected int m_iFilterablePropertiesBitfield = 0;
+    
+    public boolean CanItemPassIfFilter( ItemStack filteredItem )
+    {
+    	return true;
+    }
+    
+    public int GetFilterableProperties( ItemStack stack )
+    {
+    	return m_iFilterablePropertiesBitfield;
+    }
+    
+    public Item SetFilterableProperties( int iProperties )
+    {
+    	m_iFilterablePropertiesBitfield = iProperties;
+    	
+    	return this;
+    }
+    
+    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
+    {
+    	return false;
+    }
+    
+    //------------- Deprecated tool functionality ------------//
+    
+    public static void SetAllPicksToBeEffectiveVsBlock( Block block )
+    {
+    	block.SetPicksEffectiveOn( true );
+    }
+    
+    public static void SetAllAxesToBeEffectiveVsBlock( Block block )
+    {
+    	block.SetAxesEffectiveOn( true );
+    }
+    
+    public static void SetAllShovelsToBeEffectiveVsBlock( Block block )
+    {
+    	block.SetShovelsEffectiveOn( true );
+    }
+    
+    //----- Block Dispenser Related Functionality -----//
+    
+	/**
+	 * This method should return true if the item is successfully placed (in which case the BD will 
+	 * consume the corresponding item in its inventory), false otherwise.  Co-ordinates specify
+	 * the BD position.
+	 */
+	public boolean OnItemUsedByBlockDispenser( ItemStack stack, World world, 
+		int i, int j, int k, int iFacing )
+	{
+		FCBetterThanWolves.fcBlockDispenser.SpitOutItem( world, i, j, k, stack );
+		
+        world.playAuxSFX( 1000, i, j, k, 0 ); // normal pitch click							        
+        
+		return true;
+	}
+    
+    //------- Item Entity Related Functionality -------//
+    
+    public boolean hasCustomItemEntity() {
+    	return this.entityClass != EntityItem.class;
+    }
+    
+    public Class getCustomItemEntity() {
+    	return this.entityClass;
+    }
+    
+    public void setCustomItemEntity(Class entityClass) {
+    	this.entityClass = entityClass;
+    }
+    
+    public EntityItem createItemAsEntityInWorld(World world, double x, double y, double z, ItemStack stack) {
+    	return null;
+    }
+	
+	//----------- Client Side Functionality -----------//
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/ItemArmor.java b/minecraft_server/net/minecraft/src/ItemArmor.java
index fc88642..8ce0567 100644
--- a/minecraft_server/net/minecraft/src/ItemArmor.java
+++ b/minecraft_server/net/minecraft/src/ItemArmor.java
@@ -14,7 +14,12 @@ public class ItemArmor extends Item
     public final int armorType;
 
     /** Holds the amount of damage that the armor reduces at full durability. */
+    // FCMOD: Changed to remove final
+    /*
     public final int damageReduceAmount;
+    */
+    public int damageReduceAmount;
+    // END FCMOD
 
     /**
      * Used on RenderPlayer to select the correspondent armor to be rendered on the player: 0 is cloth, 1 is chain, 2 is
@@ -35,7 +40,11 @@ public class ItemArmor extends Item
         this.setMaxDamage(par2EnumArmorMaterial.getDurability(par4));
         this.maxStackSize = 1;
         this.setCreativeTab(CreativeTabs.tabCombat);
+        // FCMOD: Code removed
+        /*
         BlockDispenser.dispenseBehaviorRegistry.putObject(this, field_96605_cw);
+        */
+        // END FCMOD
     }
 
     /**
@@ -168,4 +177,33 @@ public class ItemArmor extends Item
     {
         return maxDamageArray;
     }
+    
+    // FCMOD: Added New
+    @Override
+    public boolean IsEnchantmentApplicable( Enchantment enchantment )
+    {
+    	if ( enchantment.type == EnumEnchantmentType.armor )
+    	{
+    		return true;
+    	}
+    	else if ( enchantment.type == EnumEnchantmentType.armor_head )
+    	{		
+    		return armorType == 0;
+    	}		
+    	else if ( enchantment.type == EnumEnchantmentType.armor_torso )
+    	{		
+    		return armorType == 1;
+    	}		
+    	else if ( enchantment.type == EnumEnchantmentType.armor_legs )
+    	{		
+    		return armorType == 2;
+    	}		
+    	else if ( enchantment.type == EnumEnchantmentType.armor_feet )
+    	{		
+    		return armorType == 3;
+    	}
+    	
+    	return super.IsEnchantmentApplicable( enchantment );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemAxe.java b/minecraft_server/net/minecraft/src/ItemAxe.java
index 824f929..bc8bf7b 100644
--- a/minecraft_server/net/minecraft/src/ItemAxe.java
+++ b/minecraft_server/net/minecraft/src/ItemAxe.java
@@ -7,7 +7,7 @@ public class ItemAxe extends ItemTool
 
     protected ItemAxe(int par1, EnumToolMaterial par2EnumToolMaterial)
     {
-        super(par1, 3, par2EnumToolMaterial, blocksEffectiveAgainst);
+        super(par1, 3, par2EnumToolMaterial, blocksEffectiveAgainst);        
     }
 
     /**
@@ -17,5 +17,5 @@ public class ItemAxe extends ItemTool
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return par2Block != null && (par2Block.blockMaterial == Material.wood || par2Block.blockMaterial == Material.plants || par2Block.blockMaterial == Material.vine) ? this.efficiencyOnProperMaterial : super.getStrVsBlock(par1ItemStack, par2Block);
-    }
+    }    
 }
diff --git a/minecraft_server/net/minecraft/src/ItemBlock.java b/minecraft_server/net/minecraft/src/ItemBlock.java
index dae6a09..b152861 100644
--- a/minecraft_server/net/minecraft/src/ItemBlock.java
+++ b/minecraft_server/net/minecraft/src/ItemBlock.java
@@ -1,6 +1,9 @@
 package net.minecraft.src;
 
-public class ItemBlock extends Item
+//FCMOD: Changed
+//public class ItemBlock extends Item
+public class ItemBlock extends FCItemPlacesAsBlock
+//END FCMOD
 {
     /** The block ID of the Block associated with this ItemBlock */
     private int blockID;
@@ -23,6 +26,8 @@ public class ItemBlock extends Item
      * Callback for item usage. If the item does something special on right clicking, he will have one of those. Return
      * True if something happen and false if it don't. This is for ITEMS, not BLOCKS
      */
+    // FCMOD: Removed and replaced in parent class
+    /*
     public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
     {
         int var11 = par3World.getBlockId(par4, par5, par6);
@@ -101,6 +106,8 @@ public class ItemBlock extends Item
             return false;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the unlocalized name of this item. This version accepts an ItemStack so different stacks can have
@@ -118,4 +125,138 @@ public class ItemBlock extends Item
     {
         return Block.blocksList[this.blockID].getUnlocalizedName();
     }
+    
+    // FCMOD: Added New
+    private boolean m_bHasOldNamePrefix = false;
+    
+    @Override
+    public float GetBuoyancy( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetBuoyancy( iItemDamage );
+    }
+    
+    @Override
+    public Item SetBuoyancy( float fBuoyancy )
+    {
+    	Block.blocksList[blockID].SetBuoyancy( fBuoyancy );
+    	
+    	return super.SetBuoyancy( fBuoyancy );
+    }
+    
+    @Override
+    public boolean IsPistonPackable( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].IsPistonPackable( stack );
+    }
+    
+    @Override
+    public int GetRequiredItemCountToPistonPack( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetRequiredItemCountToPistonPack( stack );
+    }
+    
+    @Override
+    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetResultingBlockIDOnPistonPack( stack );
+    }
+    
+    @Override
+    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetResultingBlockMetadataOnPistonPack( stack );
+    }
+
+    @Override
+    public int GetFurnaceBurnTime( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetFurnaceBurnTime( iItemDamage );
+    }
+    
+    @Override
+    public Item SetFurnaceBurnTime( int iBurnTime )
+    {
+    	Block.blocksList[blockID].SetFurnaceBurnTime( iBurnTime );
+    	
+    	return super.SetFurnaceBurnTime( iBurnTime );
+    }
+    
+    @Override
+    public int GetHerbivoreFoodValue( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetHerbivoreItemFoodValue( iItemDamage );
+    }
+    
+    @Override
+    public Item SetHerbivoreFoodValue( int iFoodValue )
+    {
+    	Block.blocksList[blockID].SetHerbivoreItemFoodValue( iFoodValue );
+    	
+    	return super.SetHerbivoreFoodValue( iFoodValue );
+    }
+    
+    @Override
+    public int GetChickenFoodValue( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetChickenItemFoodValue( iItemDamage );
+    }
+    
+    @Override
+    public Item SetChickenFoodValue( int iFoodValue )
+    {
+    	Block.blocksList[blockID].SetChickenItemFoodValue( iFoodValue );
+    	
+    	return super.SetChickenFoodValue( iFoodValue );
+    }
+    
+    @Override
+    public int GetPigFoodValue( int iItemDamage )
+    {
+    	return Block.blocksList[blockID].GetPigItemFoodValue( iItemDamage );
+    }
+    
+    @Override
+    public Item SetPigFoodValue( int iFoodValue )
+    {
+    	Block.blocksList[blockID].SetPigItemFoodValue( iFoodValue );
+    	
+    	return super.SetPigFoodValue( iFoodValue );
+    }
+    
+    @Override
+    public boolean IsIncineratedInCrucible()
+    {
+    	return Block.blocksList[blockID].IsIncineratedInCrucible();
+    }
+    
+    @Override
+    public FCItemPlacesAsBlock SetAssociatedBlockID( int iBlockID )
+    {
+    	blockID = iBlockID;
+    	
+    	return super.SetAssociatedBlockID( iBlockID );
+    }
+    
+    @Override
+    public boolean CanItemPassIfFilter( ItemStack filteredItem )
+    {
+    	return Block.blocksList[blockID].CanItemPassIfFilter( filteredItem );
+    }
+    
+    @Override
+    public int GetFilterableProperties( ItemStack stack )
+    {
+    	return Block.blocksList[blockID].GetFilterableProperties( stack );
+    }
+    
+    @Override
+    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
+    {
+    	return Block.blocksList[blockID].CanTransformItemIfFilter( filteredItem );
+    }
+    
+    //------------- Class Specific Methods ------------//
+    
+	//----------- Client Side Functionality -----------//
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemBucket.java b/minecraft_server/net/minecraft/src/ItemBucket.java
index ce41e47..63b5fc2 100644
--- a/minecraft_server/net/minecraft/src/ItemBucket.java
+++ b/minecraft_server/net/minecraft/src/ItemBucket.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 09/01/2018
+
 package net.minecraft.src;
 
 public class ItemBucket extends Item
diff --git a/minecraft_server/net/minecraft/src/ItemEnderPearl.java b/minecraft_server/net/minecraft/src/ItemEnderPearl.java
index 3a7a657..4acf33a 100644
--- a/minecraft_server/net/minecraft/src/ItemEnderPearl.java
+++ b/minecraft_server/net/minecraft/src/ItemEnderPearl.java
@@ -14,11 +14,7 @@ public class ItemEnderPearl extends Item
      */
     public ItemStack onItemRightClick(ItemStack par1ItemStack, World par2World, EntityPlayer par3EntityPlayer)
     {
-        if (par3EntityPlayer.capabilities.isCreativeMode)
-        {
-            return par1ItemStack;
-        }
-        else if (par3EntityPlayer.ridingEntity != null)
+        if (par3EntityPlayer.ridingEntity != null)
         {
             return par1ItemStack;
         }
@@ -35,4 +31,24 @@ public class ItemEnderPearl extends Item
             return par1ItemStack;
         }
     }
+    
+    @Override
+    public boolean IsPistonPackable(ItemStack stack) {
+    	return true;
+    }
+    
+	@Override
+    public int GetRequiredItemCountToPistonPack(ItemStack stack) {
+    	return 9;
+    }
+    
+	@Override
+    public int GetResultingBlockIDOnPistonPack(ItemStack stack) {
+    	return FCBetterThanWolves.fcAestheticOpaque.blockID;
+    }
+    
+	@Override
+    public int GetResultingBlockMetadataOnPistonPack(ItemStack stack) {
+    	return ((FCBlockAestheticOpaque) FCBetterThanWolves.fcAestheticOpaque).m_iSubtypeEnderBlock;
+    }
 }
diff --git a/minecraft_server/net/minecraft/src/ItemFood.java b/minecraft_server/net/minecraft/src/ItemFood.java
index 65029eb..24b48ac 100644
--- a/minecraft_server/net/minecraft/src/ItemFood.java
+++ b/minecraft_server/net/minecraft/src/ItemFood.java
@@ -39,6 +39,11 @@ public class ItemFood extends Item
         this.isWolfsFavoriteMeat = par4;
         this.saturationModifier = par3;
         this.setCreativeTab(CreativeTabs.tabFood);
+        // FCMOD: Added
+        maxStackSize = 16;
+        SetBuoyant();     
+        SetIncineratedInCrucible();
+        // END FCMOD
     }
 
     public ItemFood(int par1, int par2, boolean par3)
@@ -88,6 +93,12 @@ public class ItemFood extends Item
         {
             par3EntityPlayer.setItemInUse(par1ItemStack, this.getMaxItemUseDuration(par1ItemStack));
         }
+        // FCMOD: Added
+    	else
+    	{
+    		par3EntityPlayer.OnCantConsume();
+    	}
+        // END FCMOD
 
         return par1ItemStack;
     }
@@ -134,4 +145,46 @@ public class ItemFood extends Item
         this.alwaysEdible = true;
         return this;
     }
+    
+    // FCMOD: Added New    
+    private boolean m_bDoZombiesConsume = false;
+    
+    public ItemFood( int iItemID, int iHealAmount, float fSaturationModifier, boolean bWolfsFavoriteMeat, boolean bZombiesConsume )
+    {
+    	this( iItemID, iHealAmount, fSaturationModifier, bWolfsFavoriteMeat );
+    	
+    	m_bDoZombiesConsume = bZombiesConsume;
+    }
+    
+    @Override
+    public boolean DoZombiesConsume()
+    {
+    	return m_bDoZombiesConsume;
+    }
+    
+    @Override
+    public boolean IsMultiUsePerClick()
+    {
+    	return false;
+    }
+
+    @Override
+    public boolean IsWolfFood()
+    {
+    	return isWolfsFavoriteMeat();
+    }
+    
+    @Override
+    public int GetWolfHealAmount()
+    {
+    	return getHealAmount();
+    }
+    
+    public int GetHungerRestored()
+    {
+    	// multiply original values by 3 to take into account increased hunger resolution 
+    	
+    	return healAmount * 3;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemInWorldManager.java b/minecraft_server/net/minecraft/src/ItemInWorldManager.java
index b6da51f..af9d253 100644
--- a/minecraft_server/net/minecraft/src/ItemInWorldManager.java
+++ b/minecraft_server/net/minecraft/src/ItemInWorldManager.java
@@ -27,6 +27,9 @@ public class ItemInWorldManager
     private int posZ;
     private int field_73093_n;
     private int durabilityRemainingOnBlock;
+    // FCMOD: Added
+    private int m_iHarvestingFromFacing;
+    // END FCMOD
 
     public ItemInWorldManager(World par1World)
     {
@@ -99,7 +102,10 @@ public class ItemInWorldManager
                 if (var4 >= 1.0F)
                 {
                     this.receivedFinishDiggingPacket = false;
-                    this.tryHarvestBlock(this.posX, this.posY, this.posZ);
+                    // FCMOD: Changed
+                    //this.tryHarvestBlock(this.posX, this.posY, this.posZ);
+                    this.tryHarvestBlock(this.posX, this.posY, this.posZ, this.m_iHarvestingFromFacing);
+                    // END FCMOD
                 }
             }
         }
@@ -141,12 +147,17 @@ public class ItemInWorldManager
             {
                 if (!this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4))
                 {
-                    this.tryHarvestBlock(par1, par2, par3);
+                	// FCMOD: Changed
+                    //this.tryHarvestBlock(par1, par2, par3);
+                    this.tryHarvestBlock(par1, par2, par3, par4);
+                    // END FCMOD
                 }
             }
             else
             {
-                this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4);
+            	// FCMOD: Removed
+                //this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4);
+            	// END FCMOD
                 this.initialDamage = this.curblockDamage;
                 float var5 = 1.0F;
                 int var6 = this.theWorld.getBlockId(par1, par2, par3);
@@ -159,7 +170,10 @@ public class ItemInWorldManager
 
                 if (var6 > 0 && var5 >= 1.0F)
                 {
-                    this.tryHarvestBlock(par1, par2, par3);
+                	// FCMOD: Changed
+                    //this.tryHarvestBlock(par1, par2, par3);
+                    this.tryHarvestBlock(par1, par2, par3, par4);
+                    // END FCMOD
                 }
                 else
                 {
@@ -175,7 +189,11 @@ public class ItemInWorldManager
         }
     }
 
-    public void blockRemoving(int par1, int par2, int par3)
+	// FCMOD: Changed (function name differs between client and server ), "overloaded" function required for DemoWorldManager
+    //public void blockRemoving(int par1, int par2, int par3)    
+    public void blockRemoving(int par1, int par2, int par3 ) { blockRemoving( par1, par2, par3, 1 ); }
+    public void blockRemoving(int par1, int par2, int par3, int iFromFacing)
+    // END FCMOD
     {
         if (par1 == this.curBlockX && par2 == this.curBlockY && par3 == this.curBlockZ)
         {
@@ -191,7 +209,10 @@ public class ItemInWorldManager
                 {
                     this.isDestroyingBlock = false;
                     this.theWorld.destroyBlockInWorldPartially(this.thisPlayerMP.entityId, par1, par2, par3, -1);
-                    this.tryHarvestBlock(par1, par2, par3);
+                    // FCMOD: Changed
+                    //this.tryHarvestBlock(par1, par2, par3);
+                    this.tryHarvestBlock(par1, par2, par3, iFromFacing);
+                    // END FCMOD
                 }
                 else if (!this.receivedFinishDiggingPacket)
                 {
@@ -201,6 +222,9 @@ public class ItemInWorldManager
                     this.posY = par2;
                     this.posZ = par3;
                     this.field_73093_n = this.initialDamage;
+                    // FCMOD: Added
+                    m_iHarvestingFromFacing = iFromFacing;
+                    // END FCMOD
                 }
             }
         }
@@ -233,6 +257,10 @@ public class ItemInWorldManager
         if (var4 != null && var6)
         {
             var4.onBlockDestroyedByPlayer(this.theWorld, par1, par2, par3, var5);
+            
+            // FCMOD: Panick animals when blocks are destroyed near them
+            theWorld.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( thisPlayerMP, var4, par1, par2, par3 );            
+            // END FCMOD
         }
 
         return var6;
@@ -241,6 +269,8 @@ public class ItemInWorldManager
     /**
      * Attempts to harvest a block at the given coordinate
      */
+    // FCMOD: Removed and replaced later
+    /*
     public boolean tryHarvestBlock(int par1, int par2, int par3)
     {
         if (this.gameType.isAdventure() && !this.thisPlayerMP.canCurrentToolHarvestBlock(par1, par2, par3))
@@ -282,6 +312,8 @@ public class ItemInWorldManager
             return var6;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Attempts to right-click use an item by the given EntityPlayer in the given World
@@ -367,5 +399,96 @@ public class ItemInWorldManager
     public void setWorld(WorldServer par1WorldServer)
     {
         this.theWorld = par1WorldServer;
+    }   
+    
+    // FCMOD: Added
+    
+	// "overloaded" function required for DemoWorldManager
+    public boolean tryHarvestBlock( int i, int j, int k ) { return tryHarvestBlock( i, j, k, 1 ); }
+    public boolean tryHarvestBlock( int i, int j, int k, int iFromSide )
+    {
+        if ( gameType.isAdventure() && !thisPlayerMP.canCurrentToolHarvestBlock( i, j, k ) )
+        {
+            return false;
+        }
+        else if ( isCreative() )
+        {
+            int iBlockID = theWorld.getBlockId( i, j, k );
+            int iBlockMetadata = theWorld.getBlockMetadata( i, j, k );
+            
+            theWorld.playAuxSFXAtEntity( thisPlayerMP, 2001, i, j, k, iBlockID + ( theWorld.getBlockMetadata( i, j, k ) << 12 ) );
+            
+            boolean bBlockRemoved = removeBlock( i, j, k );
+
+            FCUtilsWorld.SendPacketToPlayer( thisPlayerMP.playerNetServerHandler, new Packet53BlockChange(i, j, k, this.theWorld) );
+
+            return bBlockRemoved;
+        }
+        else
+        {
+    		return SurvivalTryHarvestBlock( i, j, k, iFromSide );
+        }
+    }
+    
+    public boolean SurvivalTryHarvestBlock( int i, int j, int k, int iFromSide )
+    {
+        int iBlockID = theWorld.getBlockId(i, j, k);
+    	Block block = Block.blocksList[iBlockID];
+    	
+    	if ( block == null )
+    	{
+    		return false;
+    	}
+    	
+        int iMetadata = theWorld.getBlockMetadata(i, j, k);
+        
+        theWorld.playAuxSFXAtEntity( thisPlayerMP, 2001, i, j, k, iBlockID + ( iMetadata << 12 ) );
+        
+        ItemStack currentStack = thisPlayerMP.getCurrentEquippedItem();
+        
+        boolean bRemovingBlock = true;
+        boolean bConvertingBlock = false;
+        
+        boolean bHarvestingBlock = thisPlayerMP.canHarvestBlock( Block.blocksList[iBlockID], i, j, k );
+        
+        if ( !bHarvestingBlock )
+        {
+        	bConvertingBlock = block.CanConvertBlock( currentStack, theWorld, i, j, k );
+        	
+        	if ( bConvertingBlock )
+        	{
+                bRemovingBlock = !( block.ConvertBlock( currentStack, theWorld, i, j, k, iFromSide ) );
+        	}
+        }
+
+        if ( bRemovingBlock )
+        {
+        	bRemovingBlock = removeBlock( i, j, k );
+
+            if ( bRemovingBlock && !bConvertingBlock )
+            {
+    	        if ( bHarvestingBlock )
+    	        {
+    	            Block.blocksList[iBlockID].harvestBlock( theWorld, thisPlayerMP, i, j, k, iMetadata );
+    	        }
+    	        else 
+    	        {
+    	        	Block.blocksList[iBlockID].OnBlockDestroyedWithImproperTool( theWorld, thisPlayerMP, i, j, k, iMetadata );
+    	        }
+            }
+        }
+
+        if ( currentStack != null )
+        {
+            currentStack.onBlockDestroyed( theWorld, iBlockID, i, j, k, thisPlayerMP );
+
+            if ( currentStack.stackSize == 0 )
+            {
+                thisPlayerMP.destroyCurrentEquippedItem();
+            }
+        }
+
+        return bRemovingBlock;
     }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemMap.java b/minecraft_server/net/minecraft/src/ItemMap.java
index 83e5a53..64cd3de 100644
--- a/minecraft_server/net/minecraft/src/ItemMap.java
+++ b/minecraft_server/net/minecraft/src/ItemMap.java
@@ -50,6 +50,12 @@ public class ItemMap extends ItemMapBase
 
             MapInfo var12 = par3MapData.func_82568_a((EntityPlayer)par2Entity);
             ++var12.field_82569_d;
+            
+            // FCMOD: Changed
+            // Moved array allocation 
+            int[] var24 = new int[4096];
+            int[][] metaArray = new int[4096][16];
+            // END FCMOD
 
             for (int var13 = var9 - var11 + 1; var13 < var9 + var11; ++var13)
             {
@@ -68,7 +74,17 @@ public class ItemMap extends ItemMapBase
                             boolean var21 = var19 * var19 + var20 * var20 > (var11 - 2) * (var11 - 2);
                             int var22 = (var7 / var6 + var13 - var4 / 2) * var6;
                             int var23 = (var8 / var6 + var18 - var5 / 2) * var6;
-                            int[] var24 = new int[256];
+                            // FCMOD: Modified memory allocation
+                            //int[] var24 = new int[256];
+                            for (int i = 0; i < 4096; i++) {
+                            	var24[i] = 0;
+                            	
+                            	for (int j = 0; j < 16; j++) {
+                            		metaArray[i][j] = 0;
+                            	}
+                            }
+                            
+                            // END FCMOD
                             Chunk var25 = par1World.getChunkFromBlockCoords(var22, var23);
 
                             if (!var25.isEmpty())
@@ -106,6 +122,7 @@ public class ItemMap extends ItemMapBase
                                         {
                                             var33 = var25.getHeightValue(var31 + var26, var32 + var27) + 1;
                                             int var34 = 0;
+                                            int meta = 0;
 
                                             if (var33 > 1)
                                             {
@@ -115,6 +132,7 @@ public class ItemMap extends ItemMapBase
                                                 {
                                                     var35 = true;
                                                     var34 = var25.getBlockID(var31 + var26, var33 - 1, var32 + var27);
+                                                    meta = var25.getBlockMetadata(var31 + var26, var33 - 1, var32 + var27);
 
                                                     if (var34 == 0)
                                                     {
@@ -143,28 +161,32 @@ public class ItemMap extends ItemMapBase
                                                 {
                                                     var36 = var33 - 1;
                                                     boolean var37 = false;
-                                                    int var41;
+                                                    int var43;
 
                                                     do
                                                     {
-                                                        var41 = var25.getBlockID(var31 + var26, var36--, var32 + var27);
+                                                        var43 = var25.getBlockID(var31 + var26, var36--, var32 + var27);
                                                         ++var28;
                                                     }
-                                                    while (var36 > 0 && var41 != 0 && Block.blocksList[var41].blockMaterial.isLiquid());
+                                                    while (var36 > 0 && var43 != 0 && Block.blocksList[var43].blockMaterial.isLiquid());
                                                 }
                                             }
 
                                             var29 += (double)var33 / (double)(var6 * var6);
-                                            ++var24[var34];
+                                            var24[var34]++;
+                                            metaArray[var34][meta]++;
                                         }
                                     }
                                 }
 
                                 var28 /= var6 * var6;
-                                var31 = 0;
+                                var31 = 0; 
                                 var32 = 0;
 
-                                for (var33 = 0; var33 < 256; ++var33)
+                                // FCMOD: Change
+                                //for (var33 = 0; var33 < 256; ++var33)
+                                for (var33 = 0; var33 < 4096; ++var33)
+                                // END FCMOD
                                 {
                                     if (var24[var33] > var31)
                                     {
@@ -173,38 +195,53 @@ public class ItemMap extends ItemMapBase
                                     }
                                 }
 
-                                double var39 = (var29 - var16) * 4.0D / (double)(var6 + 4) + ((double)(var13 + var18 & 1) - 0.5D) * 0.4D;
-                                byte var40 = 1;
+                                // FCMOD: Added
+                                int greatestMeta = 0;
+                                int greatestMetaCount = 0;
+                                
+                                for (int i = 0; i < 16; i++) {
+                                	if (metaArray[var32][i] > greatestMetaCount) {
+                                		greatestMeta = i;
+                                		greatestMetaCount = metaArray[var32][i];
+                                	}
+                                }
+                                // END FCMOD
+
+                                double var40 = (var29 - var16) * 4.0D / (double)(var6 + 4) + ((double)(var13 + var18 & 1) - 0.5D) * 0.4D;
+                                byte var39 = 1;
 
-                                if (var39 > 0.6D)
+                                if (var40 > 0.6D)
                                 {
-                                    var40 = 2;
+                                    var39 = 2;
                                 }
 
-                                if (var39 < -0.6D)
+                                if (var40 < -0.6D)
                                 {
-                                    var40 = 0;
+                                    var39 = 0;
                                 }
 
                                 var36 = 0;
 
                                 if (var32 > 0)
                                 {
-                                    MapColor var42 = Block.blocksList[var32].blockMaterial.materialMapColor;
+                                	// FCMOD: Changed
+                                    //MapColor var42 = Block.blocksList[var32].blockMaterial.materialMapColor;
+                                    MapColor var42 = Block.blocksList[var32].getMapColor(greatestMeta);
+                                    // END FCMOD
 
                                     if (var42 == MapColor.waterColor)
                                     {
-                                        var39 = (double)var28 * 0.1D + (double)(var13 + var18 & 1) * 0.2D;
-                                        var40 = 1;
+                                        var40 = (double)var28 * 0.1D + (double)(var13 + var18 & 1) * 0.2D;
+                                        var39 = 1;
 
-                                        if (var39 < 0.5D)
+                                        if (var40 < 0.5D)
                                         {
-                                            var40 = 2;
+                                            var39 = 2;
                                         }
 
-                                        if (var39 > 0.9D)
+                                        if (var40 > 0.9D)
                                         {
-                                            var40 = 0;
+                                            var39 = 0;
                                         }
                                     }
 
@@ -215,10 +252,10 @@ public class ItemMap extends ItemMapBase
 
                                 if (var18 >= 0 && var19 * var19 + var20 * var20 < var11 * var11 && (!var21 || (var13 + var18 & 1) != 0))
                                 {
-                                    byte var43 = par3MapData.colors[var13 + var18 * var4];
-                                    byte var38 = (byte)(var36 * 4 + var40);
+                                    byte var41 = par3MapData.colors[var13 + var18 * var4];
+                                    byte var38 = (byte)(var36 * 4 + var39);
 
-                                    if (var43 != var38)
+                                    if (var41 != var38)
                                     {
                                         if (var14 > var18)
                                         {
@@ -250,7 +287,11 @@ public class ItemMap extends ItemMapBase
      * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and
      * update it's contents.
      */
-    public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5)
+    // FCMOD: Changed
+    //public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5)
+    @Override
+    public void onUpdate(ItemStack par1ItemStack, World par2World, EntityPlayer par3Entity, int par4, boolean par5)
+    // END FCMOD
     {
         if (!par2World.isRemote)
         {
diff --git a/minecraft_server/net/minecraft/src/ItemReed.java b/minecraft_server/net/minecraft/src/ItemReed.java
index 895a470..e3b359b 100644
--- a/minecraft_server/net/minecraft/src/ItemReed.java
+++ b/minecraft_server/net/minecraft/src/ItemReed.java
@@ -1,20 +1,39 @@
 package net.minecraft.src;
 
-public class ItemReed extends Item
+// FCMOD: Changed to consolidate functionality in parent class
+//public class ItemReed extends Item
+public class ItemReed extends FCItemPlacesAsBlock
+// END FCMOD
 {
     /** The ID of the block the reed will spawn when used from inventory bar. */
-    private int spawnID;
+	// FCMOD: Removed
+    //private int spawnID;
+	// END FCMOD
 
     public ItemReed(int par1, Block par2Block)
     {
+    	// FCMOD: Changed
+    	/*
         super(par1);
         this.spawnID = par2Block.blockID;
+        */
+    	super( par1, par2Block.blockID );
+    	// END FCMOD
     }
 
+    // FCMOD: Added
+    public ItemReed( int iItemID, int iBlockID )
+    {
+    	super( iItemID, iBlockID );
+    }
+    // END FCMOD
+
     /**
      * Callback for item usage. If the item does something special on right clicking, he will have one of those. Return
      * True if something happen and false if it don't. This is for ITEMS, not BLOCKS
      */
+	// FCMOD: Removed
+    /*
     public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
     {
         int var11 = par3World.getBlockId(par4, par5, par6);
@@ -87,4 +106,6 @@ public class ItemReed extends Item
             return true;
         }
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemSeeds.java b/minecraft_server/net/minecraft/src/ItemSeeds.java
index e7a89a8..a462ee1 100644
--- a/minecraft_server/net/minecraft/src/ItemSeeds.java
+++ b/minecraft_server/net/minecraft/src/ItemSeeds.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 02/06/2019
+
 package net.minecraft.src;
 
 public class ItemSeeds extends Item
diff --git a/minecraft_server/net/minecraft/src/ItemShears.java b/minecraft_server/net/minecraft/src/ItemShears.java
index e429b13..8d1629e 100644
--- a/minecraft_server/net/minecraft/src/ItemShears.java
+++ b/minecraft_server/net/minecraft/src/ItemShears.java
@@ -10,6 +10,8 @@ public class ItemShears extends Item
         this.setCreativeTab(CreativeTabs.tabTools);
     }
 
+    // FCMOD: Removed and replaced in child class
+    /*
     public boolean onBlockDestroyed(ItemStack par1ItemStack, World par2World, int par3, int par4, int par5, int par6, EntityLiving par7EntityLiving)
     {
         if (par3 != Block.leaves.blockID && par3 != Block.web.blockID && par3 != Block.tallGrass.blockID && par3 != Block.vine.blockID && par3 != Block.tripWire.blockID)
@@ -22,21 +24,31 @@ public class ItemShears extends Item
             return true;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Returns if the item (tool) can harvest results from the block type.
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return par1Block.blockID == Block.web.blockID || par1Block.blockID == Block.redstoneWire.blockID || par1Block.blockID == Block.tripWire.blockID;
     }
+    */
+    // END FCMOD
 
     /**
      * Returns the strength of the stack against a given block. 1.0F base, (Quality+1)*2 if correct blocktype, 1.5F if
      * sword
      */
+    // FCMOD: Removed and replaced in child class
+    /*
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return par2Block.blockID != Block.web.blockID && par2Block.blockID != Block.leaves.blockID ? (par2Block.blockID == Block.cloth.blockID ? 5.0F : super.getStrVsBlock(par1ItemStack, par2Block)) : 15.0F;
     }
+    */
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemSkull.java b/minecraft_server/net/minecraft/src/ItemSkull.java
index 742e639..45ed912 100644
--- a/minecraft_server/net/minecraft/src/ItemSkull.java
+++ b/minecraft_server/net/minecraft/src/ItemSkull.java
@@ -2,8 +2,14 @@ package net.minecraft.src;
 
 public class ItemSkull extends Item
 {
+	// FCMOD: Changed to add Infused Skull
+	/*
     private static final String[] skullTypes = new String[] {"skeleton", "wither", "zombie", "char", "creeper"};
     public static final String[] field_94587_a = new String[] {"skull_skeleton", "skull_wither", "skull_zombie", "skull_char", "skull_creeper"};
+    */
+    private static final String[] skullTypes = new String[] {"skeleton", "wither", "zombie", "char", "creeper", "infused"};
+    public static final String[] field_94587_a = new String[] {"skull_skeleton", "skull_wither", "skull_zombie", "skull_char", "skull_creeper", "fcItemSkullInfused"};
+	// END FCMOD
 
     public ItemSkull(int par1)
     {
@@ -23,7 +29,11 @@ public class ItemSkull extends Item
         {
             return false;
         }
-        else if (!par3World.getBlockMaterial(par4, par5, par6).isSolid())
+        // FCMOD: Change
+        //else if (!par3World.getBlockMaterial(par4, par5, par6).isSolid())
+        else if ( !par3World.getBlockMaterial( par4, par5, par6 ).isSolid() && 
+        	!( par7 == 1 && FCUtilsWorld.DoesBlockHaveSmallCenterHardpointToFacing( par3World, par4, par5, par6, 1 ) ) )
+    	// END FCMOD
         {
             return false;
         }
@@ -64,7 +74,10 @@ public class ItemSkull extends Item
             }
             else
             {
-                par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 2);
+            	// FCMOD: Changed to notify neighbors
+                //par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 2);
+                par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 3);
+                // END FCMOD
                 int var11 = 0;
 
                 if (par7 == 1)
diff --git a/minecraft_server/net/minecraft/src/ItemStack.java b/minecraft_server/net/minecraft/src/ItemStack.java
index c41f338..0c7c526 100644
--- a/minecraft_server/net/minecraft/src/ItemStack.java
+++ b/minecraft_server/net/minecraft/src/ItemStack.java
@@ -122,10 +122,14 @@ public final class ItemStack
     /**
      * Returns the strength of the stack against a given block.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public float getStrVsBlock(Block par1Block)
     {
         return this.getItem().getStrVsBlock(this, par1Block);
     }
+    */
+    // END FCMOD
 
     /**
      * Called whenever this item stack is equipped and right clicked. Returns the new item stack to put in the position
@@ -167,6 +171,15 @@ public final class ItemStack
         this.stackSize = par1NBTTagCompound.getByte("Count");
         this.itemDamage = par1NBTTagCompound.getShort("Damage");
 
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcDamEx" ) )
+        {
+        	// legacy support for one release where I had exended damage on wool knit representing color
+        	
+        	itemDamage = FCItemWool.GetClosestColorIndex( par1NBTTagCompound.getInteger( "fcDamEx" ) );
+        }
+        // END FCMOD
+        
         if (this.itemDamage < 0)
         {
             this.itemDamage = 0;
@@ -282,7 +295,12 @@ public final class ItemStack
             }
 
             this.itemDamage += par1;
+            // FCMOD: Code change so that items break at 0 damage, not -1
+            /*
             return this.itemDamage > this.getMaxDamage();
+            */
+            return this.itemDamage >= this.getMaxDamage();
+            // END FCMOD
         }
     }
 
@@ -351,10 +369,14 @@ public final class ItemStack
     /**
      * Checks if the itemStack object can harvest a specified block
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return Item.itemsList[this.itemID].canHarvestBlock(par1Block);
     }
+    */
+    // END FCMOD
 
     public boolean interactWith(EntityLiving par1EntityLiving)
     {
@@ -428,7 +450,10 @@ public final class ItemStack
      * Called each tick as long the ItemStack in on player inventory. Used to progress the pickup animation and update
      * maps.
      */
-    public void updateAnimation(World par1World, Entity par2Entity, int par3, boolean par4)
+    // FCMOD: Changed
+    //public void updateAnimation(World par1World, Entity par2Entity, int par3, boolean par4)
+    public void updateAnimation(World par1World, EntityPlayer par2Entity, int par3, boolean par4)
+    // END FCMOD
     {
         if (this.animationsToGo > 0)
         {
@@ -634,4 +659,56 @@ public final class ItemStack
 
         this.stackTagCompound.setInteger("RepairCost", par1);
     }
+    
+    // FCMOD: Added
+    public boolean canHarvestBlock( World world, Block block, int i, int j, int k )
+    {
+        return Item.itemsList[this.itemID].canHarvestBlock( this, world, block, i, j, k );
+    }
+    
+    public float getStrVsBlock( World world, Block par1Block, int i, int j, int k )
+    {
+        return getItem().getStrVsBlock( this, world, par1Block, i, j, k );
+    }
+    
+    public long GetTimeOfLastUse()
+    {
+    	if ( hasTagCompound() && this.stackTagCompound.hasKey( "fcLastUse" ) ) 
+    	{
+    		return stackTagCompound.getLong( "fcLastUse" );
+    	}
+    	
+        return -1;
+    }
+    
+    public void SetTimeOfLastUse( long lTime )
+    {
+        if ( !hasTagCompound() )
+        {
+            stackTagCompound = new NBTTagCompound( "tag" );
+        }
+
+        stackTagCompound.setLong( "fcLastUse", lTime );
+    }
+    
+    public float GetAccumulatedChance( float fDefault )
+    {
+    	if ( hasTagCompound() && this.stackTagCompound.hasKey( "fcChance" ) ) 
+    	{
+    		return stackTagCompound.getFloat( "fcChance" );
+    	}
+    	
+        return fDefault;
+    }
+    
+    public void SetAccumulatedChance( float fChance )
+    {
+        if ( !hasTagCompound() )
+        {
+            stackTagCompound = new NBTTagCompound( "tag" );
+        }
+
+        stackTagCompound.setFloat( "fcChance", fChance );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ItemSword.java b/minecraft_server/net/minecraft/src/ItemSword.java
index 6498596..c5ca72c 100644
--- a/minecraft_server/net/minecraft/src/ItemSword.java
+++ b/minecraft_server/net/minecraft/src/ItemSword.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 07/05/2018
+
 package net.minecraft.src;
 
 public class ItemSword extends Item
diff --git a/minecraft_server/net/minecraft/src/ItemTool.java b/minecraft_server/net/minecraft/src/ItemTool.java
index 7e98bf9..1eaf70b 100644
--- a/minecraft_server/net/minecraft/src/ItemTool.java
+++ b/minecraft_server/net/minecraft/src/ItemTool.java
@@ -92,4 +92,4 @@ public class ItemTool extends Item
     {
         return this.toolMaterial.getToolCraftingMaterial() == par2ItemStack.itemID ? true : super.getIsRepairable(par1ItemStack, par2ItemStack);
     }
-}
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/LongHashMap.java b/minecraft_server/net/minecraft/src/LongHashMap.java
index 3d02476..3255edc 100644
--- a/minecraft_server/net/minecraft/src/LongHashMap.java
+++ b/minecraft_server/net/minecraft/src/LongHashMap.java
@@ -3,7 +3,17 @@ package net.minecraft.src;
 public class LongHashMap
 {
     /** the array of all elements in the hash */
-    private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[16];
+	// FCMOD: Changed so that it's most common use (loaded chunks) doesn't constantly resize 
+    //private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[16];
+
+	// 882 chunks will typical be loaded SP / 0.75, for 1176, with extra wiggle room
+	// there's only a few of these instantiated in the entire game, at 8K a piece for 2000 elements
+	// so really no need to be stingy.
+	private final int m_iDefaultSize = 2000; 
+    private final float percentUseable = 0.75F;
+	
+    private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[m_iDefaultSize];	
+	// END FCMOD
 
     /** the number of elements in the hash array */
     private transient int numHashElements;
@@ -11,12 +21,17 @@ public class LongHashMap
     /**
      * the maximum amount of elements in the hash (probably 3/4 the size due to meh hashing function)
      */
-    private int capacity = 12;
+    // FCMOD: Changed
+    //private int capacity = 12;
+    private int capacity = (int)( (float)m_iDefaultSize * percentUseable );
+    // END FCMOD
 
     /**
      * percent of the hasharray that can be used without hash colliding probably
      */
-    private final float percentUseable = 0.75F;
+    // FCMOD: Removed and replaced above due to declaration order    
+    //private final float percentUseable = 0.75F;
+    // END FCMOD
 
     /** count of times elements have been added/removed */
     private transient volatile int modCount;
@@ -26,8 +41,13 @@ public class LongHashMap
      */
     private static int getHashedKey(long par0)
     {
-        return hash((int)(par0 ^ par0 >>> 32));
-    }
+    	// FCMOD: Changed to avoid excessive collisions between what is just
+    	// XORing the X and Z values that comprise the key for chunk coords
+    	// discussion of this can be found here: https://bugs.mojang.com/browse/MC-12964
+        //return hash((int)(par0 ^ par0 >>> 32));
+        return hash( (int)( par0 ^ ( ( par0 >>> 32 ) * 31 ) ) );
+        // END FCMOD
+}
 
     /**
      * the hash function
diff --git a/minecraft_server/net/minecraft/src/MapData.java b/minecraft_server/net/minecraft/src/MapData.java
index 26d256e..91c0f48 100644
--- a/minecraft_server/net/minecraft/src/MapData.java
+++ b/minecraft_server/net/minecraft/src/MapData.java
@@ -105,6 +105,29 @@ public class MapData extends WorldSavedData
      */
     public void updateVisiblePlayers(EntityPlayer par1EntityPlayer, ItemStack par2ItemStack)
     {
+    	// FCMOD: Added to handle maps in frames entirely independent of player held
+    	
+    	// clear the visible players every update to prevent players from receiving data about others
+    	
+        playersVisibleOnMap.clear();
+        
+        if ( par2ItemStack.isOnItemFrame() )
+        {
+        	if ( IsEntityLocationVisibleOnMap( par2ItemStack.getItemFrame() ) )
+        	{
+        		// the following code adds the "you are here" marker
+        		
+                func_82567_a( 1, par1EntityPlayer.worldObj, "frame-" + par2ItemStack.getItemFrame().entityId, 
+                	(double)par2ItemStack.getItemFrame().xPosition, (double)par2ItemStack.getItemFrame().zPosition, 
+                	(double)(par2ItemStack.getItemFrame().hangingDirection * 90 + 180 ));
+                
+        		return;
+        	}
+            
+            return;
+        }
+    	// END FCMOD
+    	
         if (!this.playersHashMap.containsKey(par1EntityPlayer))
         {
             MapInfo var3 = new MapInfo(this, par1EntityPlayer);
@@ -112,6 +135,16 @@ public class MapData extends WorldSavedData
             this.playersArrayList.add(var3);
         }
 
+        // FCMOD: Code added for custom handling of players on map, only processing the player holding it
+        if ( !par1EntityPlayer.isDead && par1EntityPlayer.inventory.hasItemStack(par2ItemStack) && IsEntityLocationVisibleOnMap( par1EntityPlayer ) &&
+        	par1EntityPlayer.dimension == dimension )
+        {
+            func_82567_a( 0, par1EntityPlayer.worldObj, par1EntityPlayer.getCommandSenderName(), par1EntityPlayer.posX, par1EntityPlayer.posZ, par1EntityPlayer.rotationYaw);
+        }
+    	// END FCMOD
+        
+        // FCMOD: Code removed
+        /*
         if (!par1EntityPlayer.inventory.hasItemStack(par2ItemStack))
         {
             this.playersVisibleOnMap.remove(par1EntityPlayer.getCommandSenderName());
@@ -139,6 +172,8 @@ public class MapData extends WorldSavedData
         {
             this.func_82567_a(1, par1EntityPlayer.worldObj, "frame-" + par2ItemStack.getItemFrame().entityId, (double)par2ItemStack.getItemFrame().xPosition, (double)par2ItemStack.getItemFrame().zPosition, (double)(par2ItemStack.getItemFrame().hangingDirection * 90));
         }
+        */
+        // END FCMOD
     }
 
     private void func_82567_a(int par1, World par2World, String par3Str, double par4, double par6, double par8)
@@ -243,4 +278,50 @@ public class MapData extends WorldSavedData
 
         return var2;
     }
+    
+    // FCMOD: Code added
+    public boolean IsEntityLocationVisibleOnMap( Entity entity )
+    {
+        int i = MathHelper.floor_double( entity.posX );
+        int j = MathHelper.floor_double( entity.posY ) + 2;
+        int k = MathHelper.floor_double( entity.posZ );
+        
+        if ( entity.dimension == dimension )
+        {
+        	return IsLocationVisibleOnMap( entity.worldObj, i, j, k );
+        }
+        
+        return false;        
+    }
+    
+    public boolean IsLocationVisibleOnMap( World world, int i, int j, int k )    
+    {
+    	// check if location is within map bounds
+    	
+        int iMapScale = 1 << this.scale;
+        float fRelativeI = (float)((double)i - (double)this.xCenter) / (float)iMapScale;
+        float fRelativeK = (float)((double)k - (double)this.zCenter) / (float)iMapScale;
+        
+        if ( Math.abs( fRelativeI ) > 64F || Math.abs( fRelativeK ) > 64F )
+        {
+        	return false;
+        }
+        
+        // check if location is above ground
+        
+    	if ( !world.canBlockSeeTheSky( i, j, k ) && !( world.getTopSolidOrLiquidBlock( i, k ) <= j )  )
+        {
+        	return false;
+        }
+        
+        Material material = world.getBlockMaterial( i, j, k );
+        
+        if ( material != null && material.isLiquid() )
+        {
+        	return false;
+        }
+        
+    	return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/MapGenNetherBridge.java b/minecraft_server/net/minecraft/src/MapGenNetherBridge.java
index 77a4fbf..8f7a178 100644
--- a/minecraft_server/net/minecraft/src/MapGenNetherBridge.java
+++ b/minecraft_server/net/minecraft/src/MapGenNetherBridge.java
@@ -1,3 +1,5 @@
+// FCMOD: Class changes deprecated 10/01/2018
+
 package net.minecraft.src;
 
 import java.util.ArrayList;
diff --git a/minecraft_server/net/minecraft/src/MapGenScatteredFeature.java b/minecraft_server/net/minecraft/src/MapGenScatteredFeature.java
index 15e6f0a..b074bcf 100644
--- a/minecraft_server/net/minecraft/src/MapGenScatteredFeature.java
+++ b/minecraft_server/net/minecraft/src/MapGenScatteredFeature.java
@@ -26,7 +26,11 @@ public class MapGenScatteredFeature extends MapGenStructure
         this.scatteredFeatureSpawnList = new ArrayList();
         this.maxDistanceBetweenScatteredFeatures = 32;
         this.minDistanceBetweenScatteredFeatures = 8;
+        // FCMOD: Code removed
+        /*
         this.scatteredFeatureSpawnList.add(new SpawnListEntry(EntityWitch.class, 1, 1, 1));
+        */
+        // END FCMOD
     }
 
     public MapGenScatteredFeature(Map par1Map)
diff --git a/minecraft_server/net/minecraft/src/Material.java b/minecraft_server/net/minecraft/src/Material.java
index 1a7029c..e2dc98c 100644
--- a/minecraft_server/net/minecraft/src/Material.java
+++ b/minecraft_server/net/minecraft/src/Material.java
@@ -5,36 +5,68 @@ public class Material
     public static final Material air = new MaterialTransparent(MapColor.airColor);
 
     /** The material used by BlockGrass. */
-    public static final Material grass = new Material(MapColor.grassColor);
-    public static final Material ground = new Material(MapColor.dirtColor);
-    public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
+    // FCMOD: Changed
+    //public static final Material grass = new Material(MapColor.grassColor);
+    //public static final Material ground = new Material(MapColor.dirtColor);
+    //public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
+    public static final Material grass = (new Material(MapColor.grassColor)).setRequiresTool();
+    public static final Material ground = (new Material(MapColor.dirtColor)).setRequiresTool();
+    public static final Material wood = (new Material(MapColor.woodColor)).setBurning().SetMobsCantSpawnOn().SetAxesEfficientOn();
+    // END FCMOD
     public static final Material rock = (new Material(MapColor.stoneColor)).setRequiresTool();
+    // FCMOD: Changed
+    //public static final Material iron = (new Material(MapColor.ironColor)).setRequiresTool();
+    //public static final Material anvil = (new Material(MapColor.ironColor)).setRequiresTool().setImmovableMobility();
     public static final Material iron = (new Material(MapColor.ironColor)).setRequiresTool();
     public static final Material anvil = (new Material(MapColor.ironColor)).setRequiresTool().setImmovableMobility();
+    // END FCMOD
     public static final Material water = (new MaterialLiquid(MapColor.waterColor)).setNoPushMobility();
     public static final Material lava = (new MaterialLiquid(MapColor.tntColor)).setNoPushMobility();
-    public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility();
-    public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
-    public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable();
+    // FCMOD: Changed
+    //public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility();
+    //public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
+    //public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable();
+    public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility().SetAxesEfficientOn().SetAxesTreatAsVegetation();
+    public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility().SetAxesEfficientOn().SetAxesTreatAsVegetation();
+    public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable().SetAxesEfficientOn().SetAxesTreatAsVegetation();
+    // END FCMOD
     public static final Material sponge = new Material(MapColor.clothColor);
-    public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
+    // FCMOD: Changed
+    //public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
+    public static final Material cloth = (new Material(MapColor.clothColor)).setBurning().SetAxesEfficientOn();
+    // END FCMOD
     public static final Material fire = (new MaterialTransparent(MapColor.airColor)).setNoPushMobility();
-    public static final Material sand = new Material(MapColor.sandColor);
+    // FCMOD: Changed
+    //public static final Material sand = new Material(MapColor.sandColor);
+    public static final Material sand = (new Material(MapColor.sandColor)).setRequiresTool();
+    // END FCMOD
     public static final Material circuits = (new MaterialLogic(MapColor.airColor)).setNoPushMobility();
+    // FCMOD: Changed
+    //public static final Material glass = (new Material(MapColor.airColor)).setTranslucent().setAlwaysHarvested();
     public static final Material glass = (new Material(MapColor.airColor)).setTranslucent().setAlwaysHarvested();
+    // END FCMOD
     public static final Material redstoneLight = (new Material(MapColor.airColor)).setAlwaysHarvested();
+    // FCMOD: Changed
+    //public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setTranslucent();
     public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setTranslucent();
+    // END FCMOD
     public static final Material coral = (new Material(MapColor.foliageColor)).setNoPushMobility();
     public static final Material ice = (new Material(MapColor.iceColor)).setTranslucent().setAlwaysHarvested();
     public static final Material snow = (new MaterialLogic(MapColor.snowColor)).setReplaceable().setTranslucent().setRequiresTool().setNoPushMobility();
 
     /** The material for crafted snow. */
     public static final Material craftedSnow = (new Material(MapColor.snowColor)).setRequiresTool();
-    public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility();
+    // FCMOD: Changed
+    //public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility();
+    public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility().SetMobsCantSpawnOn();    
+    // END FCMOD
     public static final Material clay = new Material(MapColor.clayColor);
 
     /** pumpkin */
-    public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
+    // FCMOD: Changed
+    //public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
+    public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility().SetAxesEfficientOn();
+    // END FCMOD
     public static final Material dragonEgg = (new Material(MapColor.foliageColor)).setNoPushMobility();
 
     /** Material used for portals */
@@ -113,7 +145,10 @@ public class Material
     /**
      * Marks the material as translucent
      */
-    private Material setTranslucent()
+    // FCMOD: Changed
+    //private Material setTranslucent()
+    protected Material setTranslucent()
+    // END FCMOD
     {
         this.isTranslucent = true;
         return this;
@@ -221,4 +256,63 @@ public class Material
     {
         return this.field_85159_M;
     }
+    
+    // FCMOD: Added New
+    private boolean m_bMobsCanSpawnOn = true;
+    private boolean m_bNetherMobsCanSpawnOn = false;
+    private boolean m_bAxesEfficientOn = false;
+    private boolean m_bAxesTreatAsVegetation = false;
+    
+    public boolean GetMobsCanSpawnOn( int iDimension )
+    {
+    	if ( iDimension == -1 )
+    	{
+    		return m_bNetherMobsCanSpawnOn;
+    	}
+    	
+    	return m_bMobsCanSpawnOn;
+    }
+    
+    public Material SetMobsCantSpawnOn()
+    {
+    	m_bMobsCanSpawnOn = false;
+    	
+    	return this;
+    }
+    
+    public Material SetNetherMobsCanSpawnOn()
+    {
+    	m_bNetherMobsCanSpawnOn = true;
+    	
+    	return this;
+    }
+    
+    public boolean GetAxesEfficientOn()
+    {
+    	return m_bAxesEfficientOn;
+    }
+    
+    public Material SetAxesEfficientOn()
+    {
+    	m_bAxesEfficientOn = true;
+    	
+    	return this;
+    }
+    
+    /**
+     * If true, this material doesn't damage axes or consume hunger if the 
+     * harvesting axe is of sufficient quality 
+     */
+    public boolean GetAxesTreatAsVegetation()
+    {
+    	return m_bAxesTreatAsVegetation;    	
+    }
+    
+    public Material SetAxesTreatAsVegetation()
+    {
+    	m_bAxesTreatAsVegetation = true;
+    	
+    	return this;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/MerchantRecipe.java b/minecraft_server/net/minecraft/src/MerchantRecipe.java
index ebd3c07..5d32410 100644
--- a/minecraft_server/net/minecraft/src/MerchantRecipe.java
+++ b/minecraft_server/net/minecraft/src/MerchantRecipe.java
@@ -18,8 +18,10 @@ public class MerchantRecipe
 
     /** Maximum times this trade can be used. */
     private int maxTradeUses;
+    
+    private boolean isMandatory;
 
-    public MerchantRecipe(NBTTagCompound par1NBTTagCompound)
+	public MerchantRecipe(NBTTagCompound par1NBTTagCompound)
     {
         this.readFromTags(par1NBTTagCompound);
     }
@@ -29,7 +31,13 @@ public class MerchantRecipe
         this.itemToBuy = par1ItemStack;
         this.secondItemToBuy = par2ItemStack;
         this.itemToSell = par3ItemStack;
+        // FCMOD: Change
+        /*
         this.maxTradeUses = 7;
+        */
+        maxTradeUses = 1;
+        m_iTradeLevel = 1;
+        // END FCMOD
     }
 
     public MerchantRecipe(ItemStack par1ItemStack, ItemStack par2ItemStack)
@@ -105,6 +113,11 @@ public class MerchantRecipe
         return this.toolUses >= this.maxTradeUses;
     }
 
+    public void func_82785_h()
+    {
+        this.toolUses = this.maxTradeUses;
+    }
+
     public void readFromTags(NBTTagCompound par1NBTTagCompound)
     {
         NBTTagCompound var2 = par1NBTTagCompound.getCompoundTag("buy");
@@ -128,8 +141,24 @@ public class MerchantRecipe
         }
         else
         {
+            // FCMOD: Change
+            /*
             this.maxTradeUses = 7;
+            */
+        	maxTradeUses = 1;
+        	// END FCMOD
+        }
+        
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcTradeLevel" ) )
+        {
+            m_iTradeLevel = par1NBTTagCompound.getInteger("fcTradeLevel");
         }
+        else
+        {
+        	m_iTradeLevel = 1;
+        }
+        // END FCMOD
     }
 
     public NBTTagCompound writeToTags()
@@ -145,6 +174,40 @@ public class MerchantRecipe
 
         var1.setInteger("uses", this.toolUses);
         var1.setInteger("maxUses", this.maxTradeUses);
+        
+        // FCMOD: Added
+        var1.setInteger( "fcTradeLevel", m_iTradeLevel );
+        // END FCMOD
+        
         return var1;
     }
-}
+    
+    // FCMOD: Added
+    public int m_iTradeLevel;    
+    
+    public MerchantRecipe( ItemStack inputStack1, ItemStack inputStack2, ItemStack outputStack, int iTradeLevel )
+    {
+        this( inputStack1, inputStack2, outputStack );
+        
+        m_iTradeLevel = iTradeLevel;
+    }
+    
+    public MerchantRecipe( ItemStack inputStack, ItemStack outputStack, int iTradeLevel )
+    {
+        this( inputStack, (ItemStack)null, outputStack, iTradeLevel );
+    }
+
+    public MerchantRecipe( ItemStack inputStack, Item outputItem, int iTradeLevel )
+    {
+        this( inputStack, new ItemStack( outputItem ), iTradeLevel );
+    }
+
+    public boolean isMandatory() {
+		return isMandatory;
+	}
+
+	public void setMandatory() {
+		this.isMandatory = true;
+	}
+    // END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/MerchantRecipeList.java b/minecraft_server/net/minecraft/src/MerchantRecipeList.java
index 25c126e..4dc75b9 100644
--- a/minecraft_server/net/minecraft/src/MerchantRecipeList.java
+++ b/minecraft_server/net/minecraft/src/MerchantRecipeList.java
@@ -16,6 +16,8 @@ public class MerchantRecipeList extends ArrayList
     /**
      * can par1,par2 be used to in crafting recipe par3
      */
+    // FCMOD: Code removed and replaced later
+    /*
     public MerchantRecipe canRecipeBeUsed(ItemStack par1ItemStack, ItemStack par2ItemStack, int par3)
     {
         if (par3 > 0 && par3 < this.size())
@@ -38,6 +40,8 @@ public class MerchantRecipeList extends ArrayList
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * checks if there is a recipie for the same ingredients already on the list, and replaces it. otherwise, adds it
@@ -50,10 +54,14 @@ public class MerchantRecipeList extends ArrayList
 
             if (par1MerchantRecipe.hasSameIDsAs(var3))
             {
+            	// FCMOD: Removed to avoid problems with similar items, like skulls or colored candles, replacing each other
+            	/*
                 if (par1MerchantRecipe.hasSameItemsAs(var3))
                 {
                     this.set(var2, par1MerchantRecipe);
                 }
+                */
+            	// END FCMOD
 
                 return;
             }
@@ -80,6 +88,10 @@ public class MerchantRecipeList extends ArrayList
             }
 
             par1DataOutputStream.writeBoolean(var3.func_82784_g());
+            
+            // FCMOD: Code added
+            par1DataOutputStream.writeShort( var3.m_iTradeLevel );
+            // END FCMOD
         }
     }
 
@@ -108,4 +120,77 @@ public class MerchantRecipeList extends ArrayList
         var1.setTag("Recipes", var2);
         return var1;
     }
+    
+    // FCMOD: Code added
+    public MerchantRecipe canRecipeBeUsed( ItemStack inputStack1, ItemStack inputStack2, int iRecipeIndex )
+    {
+        if ( iRecipeIndex >= 0 && iRecipeIndex < size() )
+        {
+            MerchantRecipe recipe = (MerchantRecipe)get(iRecipeIndex);
+            
+            if (IsStackValidForFirstSlotOfRecipe( inputStack1, recipe ) && IsStackValidForSecondSlotOfRecipe( inputStack2, recipe ) )
+            {
+            	return recipe;
+            }
+        }
+        else
+        {
+            for ( int iTempRecipeIndex = 0; iTempRecipeIndex < size(); ++iTempRecipeIndex )
+            {
+                MerchantRecipe tempRecipe = (MerchantRecipe)get( iTempRecipeIndex );
+
+                if (IsStackValidForFirstSlotOfRecipe( inputStack1, tempRecipe ) && IsStackValidForSecondSlotOfRecipe( inputStack2, tempRecipe ) )
+                {
+                	return tempRecipe;
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    private boolean IsStackValidForFirstSlotOfRecipe( ItemStack stack, MerchantRecipe recipe )
+    {
+    	if ( stack.itemID == recipe.getItemToBuy().itemID && stack.stackSize >= recipe.getItemToBuy().stackSize )
+    	{
+    		if ( recipe.getItemToBuy().getHasSubtypes() )
+    		{
+    			return stack.getItemDamage() == recipe.getItemToBuy().getItemDamage(); 
+    		}
+    		else
+    		{
+    			return true;
+    		}
+    	}
+    	
+    	return false;
+    }
+    
+    private boolean IsStackValidForSecondSlotOfRecipe( ItemStack stack, MerchantRecipe recipe )
+    {
+    	if ( recipe.hasSecondItemToBuy() )
+    	{
+    		if ( stack != null )
+    		{
+	        	if ( stack.itemID == recipe.getSecondItemToBuy().itemID && stack.stackSize >= recipe.getSecondItemToBuy().stackSize )
+	        	{
+	        		if ( recipe.getSecondItemToBuy().getHasSubtypes() )
+	        		{
+	        			return stack.getItemDamage() == recipe.getSecondItemToBuy().getItemDamage(); 
+	        		}
+	        		else
+	        		{
+	        			return true;
+	        		}
+	        	}
+    		}
+    	}
+    	else if ( stack == null )
+    	{
+    		return true;
+    	}
+    	
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/MobSpawnerBaseLogic.java b/minecraft_server/net/minecraft/src/MobSpawnerBaseLogic.java
index 4a867be..ff6fd8b 100644
--- a/minecraft_server/net/minecraft/src/MobSpawnerBaseLogic.java
+++ b/minecraft_server/net/minecraft/src/MobSpawnerBaseLogic.java
@@ -118,6 +118,12 @@ public abstract class MobSpawnerBaseLogic
                     double var7 = (double)(this.getSpawnerY() + this.getSpawnerWorld().rand.nextInt(3) - 1);
                     double var9 = (double)this.getSpawnerZ() + (this.getSpawnerWorld().rand.nextDouble() - this.getSpawnerWorld().rand.nextDouble()) * (double)this.spawnRange;
                     EntityLiving var11 = var13 instanceof EntityLiving ? (EntityLiving)var13 : null;
+                    // FCMOD: Added
+                    if ( var11 != null )
+                    {
+                    	var11.PreInitCreature();
+                    }
+                    // END FCMOD
                     var13.setLocationAndAngles(var5, var7, var9, this.getSpawnerWorld().rand.nextFloat() * 360.0F, 0.0F);
 
                     if (var11 == null || var11.getCanSpawnHere())
@@ -193,7 +199,12 @@ public abstract class MobSpawnerBaseLogic
         }
         else if (par1Entity instanceof EntityLiving && par1Entity.worldObj != null)
         {
+        	// FCMOD: Code change to prevent mobs spawning with armor and weapons
+        	/*
             ((EntityLiving)par1Entity).initCreature();
+            */
+            ((EntityLiving)par1Entity).SpawnerInitCreature();
+        	// END FCMOD
             this.getSpawnerWorld().spawnEntityInWorld(par1Entity);
         }
 
diff --git a/minecraft_server/net/minecraft/src/NetHandler.java b/minecraft_server/net/minecraft/src/NetHandler.java
index 2895c2a..3701773 100644
--- a/minecraft_server/net/minecraft/src/NetHandler.java
+++ b/minecraft_server/net/minecraft/src/NetHandler.java
@@ -458,4 +458,11 @@ public abstract class NetHandler
     {
         this.unexpectedPacket(par1Packet63WorldParticles);
     }
+    
+    // FCMOD: Added
+    public void HandleStartBlockHarvest( FCPacket166StartBlockHarvest packet )
+    {
+        unexpectedPacket( packet );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/NetServerHandler.java b/minecraft_server/net/minecraft/src/NetServerHandler.java
index b330766..6fe9f4e 100644
--- a/minecraft_server/net/minecraft/src/NetServerHandler.java
+++ b/minecraft_server/net/minecraft/src/NetServerHandler.java
@@ -8,13 +8,20 @@ import java.util.Iterator;
 import java.util.Random;
 import net.minecraft.server.MinecraftServer;
 
+// FCMOD: Added
+import java.util.List;
+// END FCMOD
+
 public class NetServerHandler extends NetHandler
 {
     /** The underlying network manager for this server handler. */
     public final INetworkManager netManager;
 
     /** Reference to the MinecraftServer object. */
-    private final MinecraftServer mcServer;
+    // FCMOD: Changed to public for simplicity with add-on authors
+    //private final MinecraftServer mcServer;
+    public final MinecraftServer mcServer;
+    // END FCMOD
 
     /** This is set to true whenever a player disconnects from the server. */
     public boolean connectionClosed = false;
@@ -264,11 +271,22 @@ public class NetServerHandler extends NetHandler
                 }
 
                 float var27 = 0.0625F;
+	            // FCMOD: Line changed so that players don't warp through platforms
+	            /*
                 boolean var28 = var2.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var27, (double)var27, (double)var27)).isEmpty();
+	            */
+	            boolean var28 = getCollidingBoundingBoxesIgnoreSpecifiedEntities( var2, playerEntity, playerEntity.boundingBox.copy().contract(var27, var27, var27)).isEmpty();
+	            // END FCMOD
 
                 if (this.playerEntity.onGround && !par1Packet10Flying.onGround && var15 > 0.0D)
                 {
-                    this.playerEntity.addExhaustion(0.2F);
+                	// FCMOD: Changed to take sprinting into account when jumping on server
+                    //this.playerEntity.addExhaustion(0.2F);
+                	if ( !playerEntity.isOnLadder() )
+                	{
+                		playerEntity.AddExhaustionForJump();
+                	}
+                    // END FCMOD
                 }
 
                 this.playerEntity.moveEntity(var13, var15, var17);
@@ -294,7 +312,12 @@ public class NetServerHandler extends NetHandler
                 }
 
                 this.playerEntity.setPositionAndRotation(var5, var7, var9, var11, var12);
+	            // FCMOD: Line changed so that players don't warp through platforms
+	            /*
                 boolean var32 = var2.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var27, (double)var27, (double)var27)).isEmpty();
+	            */
+	            boolean var32 = getCollidingBoundingBoxesIgnoreSpecifiedEntities( var2, playerEntity, playerEntity.boundingBox.copy().contract(var27, var27, var27)).isEmpty();
+	            // END FCMOD
 
                 if (var28 && (var31 || !var32) && !this.playerEntity.isPlayerSleeping())
                 {
@@ -304,7 +327,13 @@ public class NetServerHandler extends NetHandler
 
                 AxisAlignedBB var33 = this.playerEntity.boundingBox.copy().expand((double)var27, (double)var27, (double)var27).addCoord(0.0D, -0.55D, 0.0D);
 
+                // FCMOD: Line change to prevent player being kicked while standing on entities like Wind Mills or Platforms
+                /*
                 if (!this.mcServer.isFlightAllowed() && !this.playerEntity.theItemInWorldManager.isCreative() && !var2.checkBlockCollision(var33))
+                */
+                if (!mcServer.isFlightAllowed() && !playerEntity.theItemInWorldManager.isCreative() && !var2.checkBlockCollision(var33) && 
+            		var2.checkNoEntityCollision( var33, playerEntity ) )
+            	// END FCMOD
                 {
                     if (var29 >= -0.03125D)
                     {
@@ -413,7 +442,10 @@ public class NetServerHandler extends NetHandler
             }
             else if (par1Packet14BlockDig.status == 2)
             {
-                this.playerEntity.theItemInWorldManager.blockRemoving(var4, var5, var6);
+            	// FCMOD: Changed (function name differs between client and server )
+                //this.playerEntity.theItemInWorldManager.blockRemoving(var4, var5, var6);
+                this.playerEntity.theItemInWorldManager.blockRemoving(var4, var5, var6, par1Packet14BlockDig.face);
+                // END FCMOD
 
                 if (var2.getBlockId(var4, var5, var6) != 0)
                 {
@@ -723,6 +755,16 @@ public class NetServerHandler extends NetHandler
                 var5 = 9.0D;
             }
 
+        	// FCMOD: Code added to prevent funkiness in interacting with Wind Mills due to size            	
+        	if ( var3 instanceof FCIEntityPacketHandler )
+        	{
+        		if ( ((FCIEntityPacketHandler)var3).ShouldServerTreatAsOversized() )
+        		{
+	        		var4 = true;
+	        		var5 = 256D;
+        		}
+        	}
+        	// END FCMOD
             if (this.playerEntity.getDistanceSqToEntity(var3) < var5)
             {
                 if (par1Packet7UseEntity.isLeftClick == 0)
@@ -805,6 +847,32 @@ public class NetServerHandler extends NetHandler
                 this.playerEntity.openContainer.detectAndSendChanges();
                 this.playerEntity.updateHeldItem();
                 this.playerEntity.isChangingQuantityOnly = false;
+                // FCMOD: Added fix for items falling out of sync when player uses numerical hotkeys to swap items to the hotbar
+                // by mousing over in inventory (this is what the 2 indicates)
+                if ( par1Packet102WindowClick.holdingShift == 2 ) 
+                {
+                	int iSlotTo = par1Packet102WindowClick.mouseClick;
+
+                	if ( iSlotTo >= 0 && iSlotTo < 9 )
+                	{
+	                	int iSlotFrom = par1Packet102WindowClick.inventorySlot;
+	                	
+	                	playerEntity.sendSlotContents( playerEntity.openContainer, iSlotFrom, 
+	                		(ItemStack)playerEntity.openContainer.inventoryItemStacks.get( iSlotFrom ) );
+
+	                	// The following assumes the player's hotbar occupies the last 9 slots of all containers, but should be
+	                	// harmless if not, as it'll just refresh some other slot.
+	                	
+                		iSlotTo += playerEntity.openContainer.inventorySlots.size() - 9;
+                		
+                		if ( iSlotTo >= 0 && iSlotTo < playerEntity.openContainer.inventorySlots.size() )
+                		{
+		                	playerEntity.sendSlotContents( playerEntity.openContainer, iSlotTo,
+		                		(ItemStack)playerEntity.openContainer.inventoryItemStacks.get( iSlotTo ) );
+                		}
+                	}
+                }
+                // END FCMOD
             }
             else
             {
@@ -993,6 +1061,24 @@ public class NetServerHandler extends NetHandler
     public void handleClientInfo(Packet204ClientInfo par1Packet204ClientInfo)
     {
         this.playerEntity.updateClientInfo(par1Packet204ClientInfo);
+        
+        // FCMOD: Code added to encode whether BTW is installed in the game difficulty
+        if ( !par1Packet204ClientInfo.IsBTWInstalled() )
+        {
+        	playerEntity.playerNetServerHandler.sendPacket( new Packet3Chat( (new StringBuilder()).append( "\2474"). // red text
+	    		append("WARNING: You do not currently have Better Than Wolves installed on your system." ).toString() ) );
+            	
+	    	playerEntity.playerNetServerHandler.sendPacket( new Packet3Chat( (new StringBuilder()).append( "\2474"). // red text
+	    		append( "This server requires all clients to have Better Than Wolves version ").
+	    		append( FCBetterThanWolves.fcVersionString).toString() ) );
+                	
+			// client
+	    	//mcServer.getLogAgent().logInfo( (new StringBuilder()).
+    		// server
+	    	mcServer.getLogAgent().func_98233_a( (new StringBuilder()).	    		
+	    		append( playerEntity.username ).append( " logged in without BTW installed" ).toString() );
+        }
+        // END FCMOD
     }
 
     public void handleCustomPayload(Packet250CustomPayload par1Packet250CustomPayload)
@@ -1054,19 +1140,19 @@ public class NetServerHandler extends NetHandler
         }
         else
         {
-            int var13;
+            int var14;
 
             if ("MC|TrSel".equals(par1Packet250CustomPayload.channel))
             {
                 try
                 {
                     var2 = new DataInputStream(new ByteArrayInputStream(par1Packet250CustomPayload.data));
-                    var13 = var2.readInt();
-                    Container var15 = this.playerEntity.openContainer;
+                    var14 = var2.readInt();
+                    Container var16 = this.playerEntity.openContainer;
 
-                    if (var15 instanceof ContainerMerchant)
+                    if (var16 instanceof ContainerMerchant)
                     {
-                        ((ContainerMerchant)var15).setCurrentRecipeIndex(var13);
+                        ((ContainerMerchant)var16).setCurrentRecipeIndex(var14);
                     }
                 }
                 catch (Exception var10)
@@ -1076,7 +1162,7 @@ public class NetServerHandler extends NetHandler
             }
             else
             {
-                int var17;
+                int var18;
 
                 if ("MC|AdvCdm".equals(par1Packet250CustomPayload.channel))
                 {
@@ -1089,16 +1175,16 @@ public class NetServerHandler extends NetHandler
                         try
                         {
                             var2 = new DataInputStream(new ByteArrayInputStream(par1Packet250CustomPayload.data));
-                            var13 = var2.readInt();
-                            var17 = var2.readInt();
+                            var14 = var2.readInt();
+                            var18 = var2.readInt();
                             int var5 = var2.readInt();
                             String var6 = Packet.readString(var2, 256);
-                            TileEntity var7 = this.playerEntity.worldObj.getBlockTileEntity(var13, var17, var5);
+                            TileEntity var7 = this.playerEntity.worldObj.getBlockTileEntity(var14, var18, var5);
 
                             if (var7 != null && var7 instanceof TileEntityCommandBlock)
                             {
                                 ((TileEntityCommandBlock)var7).setCommand(var6);
-                                this.playerEntity.worldObj.markBlockForUpdate(var13, var17, var5);
+                                this.playerEntity.worldObj.markBlockForUpdate(var14, var18, var5);
                                 this.playerEntity.sendChatToPlayer("Command set: " + var6);
                             }
                         }
@@ -1119,17 +1205,17 @@ public class NetServerHandler extends NetHandler
                         try
                         {
                             var2 = new DataInputStream(new ByteArrayInputStream(par1Packet250CustomPayload.data));
-                            var13 = var2.readInt();
-                            var17 = var2.readInt();
-                            ContainerBeacon var18 = (ContainerBeacon)this.playerEntity.openContainer;
-                            Slot var19 = var18.getSlot(0);
+                            var14 = var2.readInt();
+                            var18 = var2.readInt();
+                            ContainerBeacon var17 = (ContainerBeacon)this.playerEntity.openContainer;
+                            Slot var19 = var17.getSlot(0);
 
                             if (var19.getHasStack())
                             {
                                 var19.decrStackSize(1);
-                                TileEntityBeacon var20 = var18.getBeacon();
-                                var20.setPrimaryEffect(var13);
-                                var20.setSecondaryEffect(var17);
+                                TileEntityBeacon var20 = var17.getBeacon();
+                                var20.setPrimaryEffect(var14);
+                                var20.setSecondaryEffect(var18);
                                 var20.onInventoryChanged();
                             }
                         }
@@ -1141,23 +1227,143 @@ public class NetServerHandler extends NetHandler
                 }
                 else if ("MC|ItemName".equals(par1Packet250CustomPayload.channel) && this.playerEntity.openContainer instanceof ContainerRepair)
                 {
-                    ContainerRepair var14 = (ContainerRepair)this.playerEntity.openContainer;
+                    ContainerRepair var13 = (ContainerRepair)this.playerEntity.openContainer;
 
                     if (par1Packet250CustomPayload.data != null && par1Packet250CustomPayload.data.length >= 1)
                     {
-                        String var16 = ChatAllowedCharacters.filerAllowedCharacters(new String(par1Packet250CustomPayload.data));
+                        String var15 = ChatAllowedCharacters.filerAllowedCharacters(new String(par1Packet250CustomPayload.data));
 
-                        if (var16.length() <= 30)
+                        if (var15.length() <= 30)
                         {
-                            var14.updateItemName(var16);
+                            var13.updateItemName(var15);
                         }
                     }
                     else
                     {
-                        var14.updateItemName("");
+                        var13.updateItemName("");
                     }
                 }
+                // FCMOD: Added
+                else
+                {
+                	FCAddOnHandler.ServerCustomPacketReceived( this, par1Packet250CustomPayload );
+                }
+                // END FCMOD
             }
         }
     }
+
+	// FCMOD: Added
+	public List getCollidingBoundingBoxesIgnoreSpecifiedEntities( World world, Entity par1Entity, AxisAlignedBB par2AxisAlignedBB)
+	{
+		// Copied over from World.java with modifications 
+
+	    ArrayList collidingBoundingBoxes = new ArrayList();
+	    
+	    int i = MathHelper.floor_double(par2AxisAlignedBB.minX);
+	    int j = MathHelper.floor_double(par2AxisAlignedBB.maxX + 1.0D);
+	    int k = MathHelper.floor_double(par2AxisAlignedBB.minY);
+	    int l = MathHelper.floor_double(par2AxisAlignedBB.maxY + 1.0D);
+	    int i1 = MathHelper.floor_double(par2AxisAlignedBB.minZ);
+	    int j1 = MathHelper.floor_double(par2AxisAlignedBB.maxZ + 1.0D);
+	
+	    for (int k1 = i; k1 < j; k1++)
+	    {
+	        for (int l1 = i1; l1 < j1; l1++)
+	        {
+	            if (!world.blockExists(k1, 64, l1))
+	            {
+	                continue;
+	            }
+	
+	            for (int i2 = k - 1; i2 < l; i2++)
+	            {
+	                Block block = Block.blocksList[world.getBlockId(k1, i2, l1)];
+	
+	                if (block != null)
+	                {
+	                    block.addCollisionBoxesToList(world, k1, i2, l1, par2AxisAlignedBB, collidingBoundingBoxes, par1Entity);
+	                }
+	            }
+	        }
+	    }
+	
+	    double d = 0.25D;
+	    // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
+		/*
+	    List list = getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d, d, d));
+		*/
+	    List list = world.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d, 2.0, d));
+	    // END FCMOD
+	    Iterator iterator = list.iterator();
+	
+	    do
+	    {
+	        if (!iterator.hasNext())
+	        {
+	            break;
+	        }
+	
+	        Entity entity = (Entity)iterator.next();
+	        
+	        if ( !( entity instanceof FCIEntityIgnoreServerValidation ) )
+			{
+	            AxisAlignedBB axisalignedbb = entity.getBoundingBox();
+	
+	            if (axisalignedbb != null && axisalignedbb.intersectsWith(par2AxisAlignedBB))
+	            {
+	                collidingBoundingBoxes.add(axisalignedbb);
+	            }
+	
+	            axisalignedbb = par1Entity.getCollisionBox(entity);
+	
+	            if (axisalignedbb != null && axisalignedbb.intersectsWith(par2AxisAlignedBB))
+	            {
+	                collidingBoundingBoxes.add(axisalignedbb);
+	            }
+			}
+	    }
+	    while (true);
+	
+	    return collidingBoundingBoxes;
+	}
+	
+    public void HandleStartBlockHarvest( FCPacket166StartBlockHarvest packet )
+    {
+        WorldServer world = mcServer.worldServerForDimension( playerEntity.dimension );
+
+        int i = packet.iIPos;
+        int j = packet.iJPos;
+        int k = packet.iKPos;
+
+        double dDeltaX = playerEntity.posX - ( (double)i + 0.5D );
+        double dDeltaY = playerEntity.posY - ( (double)j + 0.5D ) + 1.5D;
+        double dDeltaZ = playerEntity.posZ - ( (double)k + 0.5D );
+        
+        double dDistSq = dDeltaX * dDeltaX + dDeltaY * dDeltaY + dDeltaZ * dDeltaZ;
+
+        if ( dDistSq <= 36D && j < mcServer.getBuildLimit() )
+        {
+	        if ( !IsBlockWithinSpawnProtection( world, i, j, k ) )
+	        {
+	        	playerEntity.SetMiningSpeedModifier( packet.GetMiningSpeedModifier() );
+	        	
+	            playerEntity.theItemInWorldManager.onBlockClicked(i, j, k, packet.iFace );
+	        }
+	        else
+	        {
+	        	// I assume the following resets the block harvest on the player's client
+
+	        	FCUtilsWorld.SendPacketToPlayer( playerEntity.playerNetServerHandler, new Packet53BlockChange( i, j, k, world ) );
+	        }
+        }
+    }
+    
+    private boolean IsBlockWithinSpawnProtection( World world, int i, int j, int k )
+    {
+    	// func_96290_a checks if the block is within the spawn protection area on dedicated servers
+    	
+    	return mcServer.func_96290_a( world, i, j, k, playerEntity );
+    }
+	// END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Packet15Place.java b/minecraft_server/net/minecraft/src/Packet15Place.java
index 13e8c51..65b9030 100644
--- a/minecraft_server/net/minecraft/src/Packet15Place.java
+++ b/minecraft_server/net/minecraft/src/Packet15Place.java
@@ -33,9 +33,16 @@ public class Packet15Place extends Packet
         this.zPosition = par1DataInputStream.readInt();
         this.direction = par1DataInputStream.read();
         this.itemStack = readItemStack(par1DataInputStream);
+        // FCMOD: Code change to fix rounding errors
+        /*
         this.xOffset = (float)par1DataInputStream.read() / 16.0F;
         this.yOffset = (float)par1DataInputStream.read() / 16.0F;
         this.zOffset = (float)par1DataInputStream.read() / 16.0F;
+        */
+        this.xOffset = (float)par1DataInputStream.readShort() / 32000F;
+        this.yOffset = (float)par1DataInputStream.readShort() / 32000F;
+        this.zOffset = (float)par1DataInputStream.readShort() / 32000F;
+        // END FCMOD
     }
 
     /**
@@ -48,9 +55,16 @@ public class Packet15Place extends Packet
         par1DataOutputStream.writeInt(this.zPosition);
         par1DataOutputStream.write(this.direction);
         writeItemStack(this.itemStack, par1DataOutputStream);
+        // FCMOD: Code change to fix rounding errors
+        /*
         par1DataOutputStream.write((int)(this.xOffset * 16.0F));
         par1DataOutputStream.write((int)(this.yOffset * 16.0F));
         par1DataOutputStream.write((int)(this.zOffset * 16.0F));
+        */
+        par1DataOutputStream.writeShort((int)(this.xOffset * 32000F + 0.5F));
+        par1DataOutputStream.writeShort((int)(this.yOffset * 32000F + 0.5F));
+        par1DataOutputStream.writeShort((int)(this.zOffset * 32000F + 0.5F));
+        // END FCMOD        
     }
 
     /**
@@ -66,7 +80,12 @@ public class Packet15Place extends Packet
      */
     public int getPacketSize()
     {
+    	// FCMOD: Code change
+    	/*
         return 19;
+        */
+        return 22;
+        // END FCMOD
     }
 
     public int getXPosition()
diff --git a/minecraft_server/net/minecraft/src/Packet204ClientInfo.java b/minecraft_server/net/minecraft/src/Packet204ClientInfo.java
index a51c0b4..ce93c59 100644
--- a/minecraft_server/net/minecraft/src/Packet204ClientInfo.java
+++ b/minecraft_server/net/minecraft/src/Packet204ClientInfo.java
@@ -77,6 +77,12 @@ public class Packet204ClientInfo extends Packet
 
     public int getDifficulty()
     {
+        // FCMOD: Code added to encode whether BTW is installed in the game difficulty
+    	if ( gameDifficulty >= 10 )
+    	{
+    		return gameDifficulty - 10;
+    	}
+    	// END FCMOD
         return this.gameDifficulty;
     }
 
@@ -101,4 +107,11 @@ public class Packet204ClientInfo extends Packet
     {
         return true;
     }
+    
+    // FCMOD: Function added to encode whether BTW is installed in the game difficulty
+    public boolean IsBTWInstalled()
+    {
+    	return gameDifficulty >= 10;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Packet24MobSpawn.java b/minecraft_server/net/minecraft/src/Packet24MobSpawn.java
index a81ba73..3dd0bb9 100644
--- a/minecraft_server/net/minecraft/src/Packet24MobSpawn.java
+++ b/minecraft_server/net/minecraft/src/Packet24MobSpawn.java
@@ -43,7 +43,12 @@ public class Packet24MobSpawn extends Packet
     public Packet24MobSpawn(EntityLiving par1EntityLiving)
     {
         this.entityId = par1EntityLiving.entityId;
+        // FCMOD: Code change to avoid truncation
+        /*
         this.type = (byte)EntityList.getEntityID(par1EntityLiving);
+        */
+        this.type = EntityList.getEntityID(par1EntityLiving);
+        // END FCMOD
         this.xPosition = par1EntityLiving.myEntitySize.multiplyBy32AndRound(par1EntityLiving.posX);
         this.yPosition = MathHelper.floor_double(par1EntityLiving.posY * 32.0D);
         this.zPosition = par1EntityLiving.myEntitySize.multiplyBy32AndRound(par1EntityLiving.posZ);
@@ -97,7 +102,7 @@ public class Packet24MobSpawn extends Packet
     public void readPacketData(DataInputStream par1DataInputStream) throws IOException
     {
         this.entityId = par1DataInputStream.readInt();
-        this.type = par1DataInputStream.readByte() & 255;
+        this.type = par1DataInputStream.readInt();
         this.xPosition = par1DataInputStream.readInt();
         this.yPosition = par1DataInputStream.readInt();
         this.zPosition = par1DataInputStream.readInt();
@@ -116,7 +121,7 @@ public class Packet24MobSpawn extends Packet
     public void writePacketData(DataOutputStream par1DataOutputStream) throws IOException
     {
         par1DataOutputStream.writeInt(this.entityId);
-        par1DataOutputStream.writeByte(this.type & 255);
+        par1DataOutputStream.writeInt(this.type);
         par1DataOutputStream.writeInt(this.xPosition);
         par1DataOutputStream.writeInt(this.yPosition);
         par1DataOutputStream.writeInt(this.zPosition);
@@ -144,4 +149,14 @@ public class Packet24MobSpawn extends Packet
     {
         return 26;
     }
+
+    public List getMetadata()
+    {
+        if (this.metadata == null)
+        {
+            this.metadata = this.metaData.getAllWatched();
+        }
+
+        return this.metadata;
+    }
 }
diff --git a/minecraft_server/net/minecraft/src/Packet26EntityExpOrb.java b/minecraft_server/net/minecraft/src/Packet26EntityExpOrb.java
index 4664b22..c7e2f8d 100644
--- a/minecraft_server/net/minecraft/src/Packet26EntityExpOrb.java
+++ b/minecraft_server/net/minecraft/src/Packet26EntityExpOrb.java
@@ -6,6 +6,10 @@ import java.io.IOException;
 
 public class Packet26EntityExpOrb extends Packet
 {
+    // FCMOD: Code added
+    public boolean m_bNotPlayerOwned;
+    // END FCMOD
+
     /** Entity ID for the XP Orb */
     public int entityId;
     public int posX;
@@ -24,6 +28,9 @@ public class Packet26EntityExpOrb extends Packet
         this.posY = MathHelper.floor_double(par1EntityXPOrb.posY * 32.0D);
         this.posZ = MathHelper.floor_double(par1EntityXPOrb.posZ * 32.0D);
         this.xpValue = par1EntityXPOrb.getXpValue();
+        // FCMOD: Code added
+        m_bNotPlayerOwned = par1EntityXPOrb.m_bNotPlayerOwned;
+        // END FCMOD
     }
 
     /**
@@ -36,6 +43,9 @@ public class Packet26EntityExpOrb extends Packet
         this.posY = par1DataInputStream.readInt();
         this.posZ = par1DataInputStream.readInt();
         this.xpValue = par1DataInputStream.readShort();
+        // FCMOD: Code added
+        m_bNotPlayerOwned = par1DataInputStream.readBoolean();
+        // END FCMOD
     }
 
     /**
@@ -48,6 +58,9 @@ public class Packet26EntityExpOrb extends Packet
         par1DataOutputStream.writeInt(this.posY);
         par1DataOutputStream.writeInt(this.posZ);
         par1DataOutputStream.writeShort(this.xpValue);
+        // FCMOD: Code added
+        par1DataOutputStream.writeBoolean( m_bNotPlayerOwned );
+        // END FCMOD
     }
 
     /**
@@ -63,6 +76,11 @@ public class Packet26EntityExpOrb extends Packet
      */
     public int getPacketSize()
     {
+    	// FCMOD: Code changed
+    	/*
         return 18;
+        */
+        return 19;
+        // END FCMOD
     }
 }
diff --git a/minecraft_server/net/minecraft/src/Packet41EntityEffect.java b/minecraft_server/net/minecraft/src/Packet41EntityEffect.java
index aebfa87..fe6ef78 100644
--- a/minecraft_server/net/minecraft/src/Packet41EntityEffect.java
+++ b/minecraft_server/net/minecraft/src/Packet41EntityEffect.java
@@ -12,6 +12,9 @@ public class Packet41EntityEffect extends Packet
     /** The effect's amplifier. */
     public byte effectAmplifier;
     public short duration;
+    // FCMOD: Code added
+    public byte m_bIsAmbient;
+    // END FCMOD
 
     public Packet41EntityEffect() {}
 
@@ -29,6 +32,14 @@ public class Packet41EntityEffect extends Packet
         {
             this.duration = (short)par2PotionEffect.getDuration();
         }
+
+        // FCMOD: Code added
+        m_bIsAmbient = 0;
+        if ( par2PotionEffect.getIsAmbient() )
+        {
+        	m_bIsAmbient = 1;
+        }
+        // END FCMOD
     }
 
     /**
@@ -40,6 +51,9 @@ public class Packet41EntityEffect extends Packet
         this.effectId = par1DataInputStream.readByte();
         this.effectAmplifier = par1DataInputStream.readByte();
         this.duration = par1DataInputStream.readShort();
+        // FCMOD: Code added
+        m_bIsAmbient = par1DataInputStream.readByte();
+        // END FCMOD
     }
 
     /**
@@ -51,6 +65,9 @@ public class Packet41EntityEffect extends Packet
         par1DataOutputStream.writeByte(this.effectId);
         par1DataOutputStream.writeByte(this.effectAmplifier);
         par1DataOutputStream.writeShort(this.duration);
+        // FCMOD: Code added
+        par1DataOutputStream.writeByte(m_bIsAmbient);
+        // END FCMOD
     }
 
     /**
@@ -66,7 +83,12 @@ public class Packet41EntityEffect extends Packet
      */
     public int getPacketSize()
     {
+    	// FCMOD: Code change
+    	/*
         return 8;
+        */
+    	return 9;
+    	// END FCMOD
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/PathFinder.java b/minecraft_server/net/minecraft/src/PathFinder.java
index 1309109..72dfcba 100644
--- a/minecraft_server/net/minecraft/src/PathFinder.java
+++ b/minecraft_server/net/minecraft/src/PathFinder.java
@@ -54,6 +54,8 @@ public class PathFinder
     /**
      * Internal implementation of creating a path from an entity to a point
      */
+    // FCMOD: Removed and replaced
+    /*
     private PathEntity createEntityPathTo(Entity par1Entity, double par2, double par4, double par6, float par8)
     {
         this.path.clearPath();
@@ -85,6 +87,8 @@ public class PathFinder
         this.isPathingInWater = var9;
         return var14;
     }
+    */
+    // END FCMOD
 
     /**
      * Adds a path from start to end and returns the whole path (args: unused, start, end, unused, maxDistance)
@@ -280,11 +284,27 @@ public class PathFinder
      */
     public int getVerticalOffset(Entity par1Entity, int par2, int par3, int par4, PathPoint par5PathPoint)
     {
+    	// FCMOD: Code changed to call custom function
+    	/*
         return func_82565_a(par1Entity, par2, par3, par4, par5PathPoint, this.isPathingInWater, this.isMovementBlockAllowed, this.isWoddenDoorAllowed);
+        */
+    	int pathWeight = GetPathWeightAtLocation( par1Entity, par2, par3, par4, par5PathPoint );
+    	
+    	// Stop babies from pathing up solid blocks
+    	if (pathWeight == 0 
+    			&& par1Entity instanceof EntityAnimal 
+    			&& ((EntityAnimal)par1Entity).getGrowingAge() < 0
+    			&& FCUtilsWorld.DoesBlockHaveSmallCenterHardpointToFacing(par1Entity.worldObj, par2, par3, par4, 1)) {
+    		pathWeight = -3;
+    	}
+    	
+    	return pathWeight;
+    	// END FCMOD
     }
 
     public static int func_82565_a(Entity par0Entity, int par1, int par2, int par3, PathPoint par4PathPoint, boolean par5, boolean par6, boolean par7)
     {
+    	// FCNOTE: *Mostly* dead code.  The mod prevents it being called above, but it's still called from EntityAIControlledByPlayer 
         boolean var8 = false;
 
         for (int var9 = par1; var9 < par1 + par4PathPoint.xCoord; ++var9)
@@ -303,7 +323,10 @@ public class PathFinder
                         }
                         else if (var12 != Block.waterMoving.blockID && var12 != Block.waterStill.blockID)
                         {
-                            if (!par7 && var12 == Block.doorWood.blockID)
+                        	// FCMOD: Changed
+                            //if (!par7 && var12 == Block.doorWood.blockID)
+                            if (!par7 && ( var12 == Block.doorWood.blockID || var12 == FCBetterThanWolves.fcBlockDoorWood.blockID ) )
+                        	// END FCMOD
                             {
                                 return 0;
                             }
@@ -321,6 +344,7 @@ public class PathFinder
                         Block var13 = Block.blocksList[var12];
                         int var14 = var13.getRenderType();
 
+                        // FCNOTE: 9 is the render type of BlockRailBase
                         if (par0Entity.worldObj.blockGetRenderType(var9, var10, var11) == 9)
                         {
                             int var18 = MathHelper.floor_double(par0Entity.posX);
@@ -334,6 +358,7 @@ public class PathFinder
                         }
                         else if (!var13.getBlocksMovement(par0Entity.worldObj, var9, var10, var11) && (!par6 || var12 != Block.doorWood.blockID))
                         {
+                        	// FCNOTE: 11 is the render type of BlockFence, 32 is that of BlockWall
                             if (var14 == 11 || var12 == Block.fenceGate.blockID || var14 == 32)
                             {
                                 return -3;
@@ -389,4 +414,175 @@ public class PathFinder
 
         return new PathEntity(var5);
     }
+    
+    // FCMOD: Added New
+    public int GetPathWeightAtLocation( Entity entity, int i, int j, int k, PathPoint pathPoint )
+    {
+    	boolean bAvoidsWater = isPathingInWater;
+    	boolean bPathThroughClosedWoodDoor = isMovementBlockAllowed;
+    	boolean bPathThroughOpenWoodDoor = isWoddenDoorAllowed;
+    	
+    	// this is pathfinding's inner loop, and has been rewritten to optimize
+    	
+    	World world = entity.worldObj;
+        int iReturnWeight = 1;
+        
+        int iMaxI = i + pathPoint.xCoord;
+        int iMaxJ = j + pathPoint.yCoord;
+        int iMaxK = k + pathPoint.zCoord;
+
+        for ( int iTempI = i; iTempI < iMaxI; ++iTempI )
+        {
+            for ( int iTempJ = j; iTempJ < iMaxJ; ++iTempJ )
+            {
+                for ( int iTempK = k; iTempK < iMaxK; ++iTempK )
+                {
+                    int iTempBlockID = world.getBlockId( iTempI, iTempJ, iTempK );
+
+                    if ( iTempBlockID > 0 )
+                    {
+                        Block tempBlock = Block.blocksList[iTempBlockID];
+
+                        if ( !tempBlock.CanPathThroughBlock( world, iTempI, iTempJ, iTempK, entity, this ) )
+                        {                        	
+                        	return tempBlock.GetWeightOnPathBlocked( world, iTempI, iTempJ, iTempK );
+                        }
+                        else
+                        {
+                        	iReturnWeight = tempBlock.AdjustPathWeightOnNotBlocked( iReturnWeight );
+                        }
+                    }
+                }
+            }
+        }
+
+        return iReturnWeight;
+    }
+    
+    public boolean CanPathThroughClosedWoodDoor()
+    {
+    	return isMovementBlockAllowed;
+    }
+    
+    public boolean CanPathThroughOpenWoodDoor()
+    {
+    	return isWoddenDoorAllowed;
+    }
+    
+    public boolean CanPathThroughWater()
+    {
+    	return !isPathingInWater; // member variable is misnamed
+    }
+    
+    private PathEntity createEntityPathTo( Entity entity, double dDestX, double dDestY, 
+    	double dDestZ, float fTolerance )
+    {
+        path.clearPath();
+        pointMap.clearMap();
+        
+        boolean bTempPathingInWater = isPathingInWater; // not sure what's up with how this is used
+        
+        int iIStart = MathHelper.floor_double( entity.boundingBox.minX );
+        int iJStart = MathHelper.floor_double( entity.boundingBox.minY + 0.5D );        
+        int iKStart = MathHelper.floor_double( entity.boundingBox.minZ );
+        
+        if ( canEntityDrown && entity.isInWater() )
+        {
+            iJStart = (int)entity.boundingBox.minY;
+
+            for ( int iTempBlockID = worldMap.getBlockId( MathHelper.floor_double( entity.posX ), 
+            	iJStart, MathHelper.floor_double( entity.posZ ) ); 
+            	iTempBlockID == Block.waterMoving.blockID || 
+            	iTempBlockID == Block.waterStill.blockID; 
+            	iTempBlockID = worldMap.getBlockId( MathHelper.floor_double( entity.posX ), 
+        		iJStart, MathHelper.floor_double( entity.posZ ) ) )
+            {
+                ++iJStart;
+            }
+
+            bTempPathingInWater = isPathingInWater;
+            
+            isPathingInWater = false;
+        }        
+        else if ( ShouldOffsetPositionIfPathingOutOfBlock( iIStart, iJStart, iKStart, entity ) )
+		{
+    		// smaller entities can get stuck on fence corners and such.  This bit
+        	// offsets the start point for pathing to open neighboring blocks.
+        	// Intentionally uses horizontal center of entity to determine offset.
+
+    		double dPartialX = entity.posX - (double)iIStart;
+    		
+    		int iIOffset = iIStart + ( dPartialX < 0.5 ? -1: 1 );
+
+        	if ( !CanPathThroughBlock( iIOffset, iJStart, iKStart, entity ) )
+    		{
+        		double dPartialZ = entity.posZ - (double)iKStart;	            		
+        		
+        		int iKOffset = iKStart + ( dPartialZ < 0.5 ? -1: 1 );
+        		
+            	if ( !CanPathThroughBlock( iIStart, iJStart, iKOffset, entity ) )
+        		{
+            		if ( CanPathThroughBlock( iIOffset, iJStart, iKOffset, entity ) )
+            		{
+                		iIStart = iIOffset;
+                		iKStart = iKOffset;
+            		}
+        		}
+            	else
+            	{
+            		iKStart = iKOffset;
+            	}
+    		}
+        	else
+        	{
+        		iIStart = iIOffset;
+        	}
+        }
+
+        PathPoint startPoint = openPoint( iIStart, iJStart, iKStart ); 
+        
+        PathPoint endPoint = openPoint( 
+        	MathHelper.floor_double( dDestX - ( entity.width / 2F ) ), 
+        	MathHelper.floor_double( dDestY ), 
+        	MathHelper.floor_double( dDestZ - ( entity.width / 2F ) ) );
+        
+        PathPoint spaceNeeded = new PathPoint( MathHelper.floor_float( entity.width + 1F ), 
+        	MathHelper.floor_float( entity.height + 1F ), 
+        	MathHelper.floor_float( entity.width + 1F ) );
+        
+        PathEntity path = addToPath( entity, startPoint, endPoint, spaceNeeded, fTolerance );
+        
+        isPathingInWater = bTempPathingInWater;
+        
+        return path;
+    }
+    
+    private boolean ShouldOffsetPositionIfPathingOutOfBlock( int i, int j, int k, Entity entity )
+    {
+        int iStartBlockID = worldMap.getBlockId( i, j, k );
+
+        if ( iStartBlockID > 0 )
+        {
+	        Block startBlock = Block.blocksList[iStartBlockID];
+	    	
+	        return startBlock.ShouldOffsetPositionIfPathingOutOf( worldMap, i, j, k, entity, this );
+        }
+        
+        return false;
+    }
+    
+    private boolean CanPathThroughBlock( int i, int j, int k, Entity entity )
+    {
+        int iStartBlockID = worldMap.getBlockId( i, j, k );
+
+        if ( iStartBlockID > 0 )
+        {
+	        Block startBlock = Block.blocksList[iStartBlockID];
+	    	
+	        return startBlock.CanPathThroughBlock( worldMap, i, j, k, entity, this );
+        }
+        
+        return true;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/PathNavigate.java b/minecraft_server/net/minecraft/src/PathNavigate.java
index 1f57bdf..18da351 100644
--- a/minecraft_server/net/minecraft/src/PathNavigate.java
+++ b/minecraft_server/net/minecraft/src/PathNavigate.java
@@ -226,6 +226,8 @@ public class PathNavigate
             }
         }
 
+        // FCMOD: Changed to use rectangular bounds to reduce spazziness.
+        /*
         float var8 = this.theEntity.width * this.theEntity.width;
         int var4;
 
@@ -236,6 +238,24 @@ public class PathNavigate
                 this.currentPath.setCurrentPathIndex(var4 + 1);
             }
         }
+        */
+        // slightly less than a half block width to ensure the creature is actually within the
+        // destination block, which is important for stuff like eating grass
+        
+        for ( int iTempIndex = currentPath.getCurrentPathIndex(); iTempIndex < var2; iTempIndex++ )
+        {
+        	Vec3 currentDest = currentPath.getVectorFromIndex( theEntity, iTempIndex );
+        	
+            if ( Math.abs( var1.xCoord - currentDest.xCoord ) < 0.49D && 
+            	Math.abs( var1.zCoord - currentDest.zCoord ) < 0.49D &&
+            	Math.abs( var1.yCoord - currentDest.yCoord ) < 0.49D )
+            {
+                currentPath.setCurrentPathIndex( iTempIndex + 1 );
+            }
+        }
+        
+        int var4;
+        // END FCMOD
 
         var4 = MathHelper.ceiling_float_int(this.theEntity.width);
         int var5 = (int)this.theEntity.height + 1;
@@ -516,4 +536,43 @@ public class PathNavigate
 
         return true;
     }
+    
+    // FCMOD: Added New
+    public boolean tryMoveToXYZ( int i, int j, int k, float fSpeed )
+    {
+    	// int based version of vanilla double based function, to avoid unnecessary type casts
+    	
+        PathEntity path = getPathToXYZ( i, j, k );
+        
+        return setPath( path, fSpeed );
+    }
+    
+    public PathEntity getPathToXYZ( int i, int j, int k )
+    {
+    	// int based version of vanilla double based function, to avoid unnecessary type casts
+    	
+    	if ( canNavigate() )
+    	{
+    		return worldObj.getEntityPathToXYZ( theEntity, i, j, k,  
+    			pathSearchRange, canPassOpenWoodenDoors, canPassClosedWoodenDoors, 
+    			avoidsWater, canSwim);
+    	}
+    	
+    	return null;
+    }
+    
+    public PathEntity GetPathToEntity( Entity toEntity )
+    {
+        return !canNavigate() ? null : worldObj.getPathEntityToEntity( theEntity, 
+        	toEntity, pathSearchRange, canPassOpenWoodenDoors, canPassClosedWoodenDoors, 
+        	avoidsWater, canSwim);
+    }
+
+    public boolean TryMoveToEntity( Entity toEntity, float fMoveSpeed )
+    {
+        PathEntity newPath = GetPathToEntity( toEntity );
+        
+        return newPath != null ? setPath( newPath, fMoveSpeed ) : false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Potion.java b/minecraft_server/net/minecraft/src/Potion.java
index ecc286c..ecad135 100644
--- a/minecraft_server/net/minecraft/src/Potion.java
+++ b/minecraft_server/net/minecraft/src/Potion.java
@@ -135,6 +135,8 @@ public class Potion
         {
             ((EntityPlayer)par1EntityLiving).addExhaustion(0.025F * (float)(par2 + 1));
         }
+        // FCMOD: Changed this to get rid of whole "healing hurts undead, harming helps them" thing
+        /*
         else if ((this.id != heal.id || par1EntityLiving.isEntityUndead()) && (this.id != harm.id || !par1EntityLiving.isEntityUndead()))
         {
             if (this.id == harm.id && !par1EntityLiving.isEntityUndead() || this.id == heal.id && par1EntityLiving.isEntityUndead())
@@ -146,6 +148,16 @@ public class Potion
         {
             par1EntityLiving.heal(6 << par2);
         }
+        */
+        else if ( this.id == harm.id )
+        {
+            par1EntityLiving.attackEntityFrom(DamageSource.magic, 6 << par2);
+        }
+        else if ( this.id == heal.id )
+        {
+            par1EntityLiving.heal(6 << par2);
+        }
+        // END FCMOD
     }
 
     /**
@@ -155,6 +167,8 @@ public class Potion
     {
         int var6;
 
+        // FCMOD: Code change to get rid of special casing of undead in potion use
+        /*
         if ((this.id != heal.id || par2EntityLiving.isEntityUndead()) && (this.id != harm.id || !par2EntityLiving.isEntityUndead()))
         {
             if (this.id == harm.id && !par2EntityLiving.isEntityUndead() || this.id == heal.id && par2EntityLiving.isEntityUndead())
@@ -172,6 +186,22 @@ public class Potion
             }
         }
         else
+        */
+        if ( this.id == harm.id )
+        {
+            var6 = (int)(par4 * (double)(6 << par3) + 0.5D);
+
+            if (par1EntityLiving == null)
+            {
+                par2EntityLiving.attackEntityFrom(DamageSource.magic, var6);
+            }
+            else
+            {
+                par2EntityLiving.attackEntityFrom(DamageSource.causeIndirectMagicDamage(par2EntityLiving, par1EntityLiving), var6);
+            }
+        }
+        else if ( this.id == heal.id )
+        // END FCMOD        
         {
             var6 = (int)(par4 * (double)(6 << par3) + 0.5D);
             par2EntityLiving.heal(var6);
diff --git a/minecraft_server/net/minecraft/src/RandomPositionGenerator.java b/minecraft_server/net/minecraft/src/RandomPositionGenerator.java
index ba689f2..120a191 100644
--- a/minecraft_server/net/minecraft/src/RandomPositionGenerator.java
+++ b/minecraft_server/net/minecraft/src/RandomPositionGenerator.java
@@ -67,9 +67,14 @@ public class RandomPositionGenerator
 
         for (int var16 = 0; var16 < 10; ++var16)
         {
-            int var12 = var4.nextInt(2 * par1) - par1;
-            int var17 = var4.nextInt(2 * par2) - par2;
-            int var14 = var4.nextInt(2 * par1) - par1;
+        	// FCMOD: Changed to fix bias towards the northwest
+            //int var12 = var4.nextInt(2 * par1) - par1;
+            //int var17 = var4.nextInt(2 * par2) - par2;
+            //int var14 = var4.nextInt(2 * par1) - par1;
+            int var12 = var4.nextInt( 2 * par1 + 1 ) - par1;
+            int var17 = var4.nextInt( 2 * par2 + 1 ) - par2;
+            int var14 = var4.nextInt( 2 * par1 + 1 ) - par1;
+            // END FCMOD
 
             if (par3Vec3 == null || (double)var12 * par3Vec3.xCoord + (double)var14 * par3Vec3.zCoord >= 0.0D)
             {
diff --git a/minecraft_server/net/minecraft/src/RecipeFireworks.java b/minecraft_server/net/minecraft/src/RecipeFireworks.java
index a7cb60e..a9ecc28 100644
--- a/minecraft_server/net/minecraft/src/RecipeFireworks.java
+++ b/minecraft_server/net/minecraft/src/RecipeFireworks.java
@@ -77,8 +77,8 @@ public class RecipeFireworks implements IRecipe
 
         if (var4 <= 3 && var3 <= 1)
         {
-            NBTTagCompound var16;
-            NBTTagCompound var19;
+            NBTTagCompound var15;
+            NBTTagCompound var18;
 
             if (var4 >= 1 && var3 == 1 && var7 == 0)
             {
@@ -86,8 +86,8 @@ public class RecipeFireworks implements IRecipe
 
                 if (var6 > 0)
                 {
-                    var16 = new NBTTagCompound();
-                    var19 = new NBTTagCompound("Fireworks");
+                    var15 = new NBTTagCompound();
+                    var18 = new NBTTagCompound("Fireworks");
                     NBTTagList var25 = new NBTTagList("Explosions");
 
                     for (int var22 = 0; var22 < par1InventoryCrafting.getSizeInventory(); ++var22)
@@ -100,10 +100,10 @@ public class RecipeFireworks implements IRecipe
                         }
                     }
 
-                    var19.setTag("Explosions", var25);
-                    var19.setByte("Flight", (byte)var4);
-                    var16.setTag("Fireworks", var19);
-                    this.field_92102_a.setTagCompound(var16);
+                    var18.setTag("Explosions", var25);
+                    var18.setByte("Flight", (byte)var4);
+                    var15.setTag("Fireworks", var18);
+                    this.field_92102_a.setTagCompound(var15);
                 }
 
                 return true;
@@ -111,9 +111,9 @@ public class RecipeFireworks implements IRecipe
             else if (var4 == 1 && var3 == 0 && var6 == 0 && var5 > 0 && var8 <= 1)
             {
                 this.field_92102_a = new ItemStack(Item.fireworkCharge);
-                var16 = new NBTTagCompound();
-                var19 = new NBTTagCompound("Explosion");
-                byte var23 = 0;
+                var15 = new NBTTagCompound();
+                var18 = new NBTTagCompound("Explosion");
+                byte var21 = 0;
                 ArrayList var12 = new ArrayList();
 
                 for (int var13 = 0; var13 < par1InventoryCrafting.getSizeInventory(); ++var13)
@@ -128,27 +128,27 @@ public class RecipeFireworks implements IRecipe
                         }
                         else if (var14.itemID == Item.lightStoneDust.itemID)
                         {
-                            var19.setBoolean("Flicker", true);
+                            var18.setBoolean("Flicker", true);
                         }
                         else if (var14.itemID == Item.diamond.itemID)
                         {
-                            var19.setBoolean("Trail", true);
+                            var18.setBoolean("Trail", true);
                         }
                         else if (var14.itemID == Item.fireballCharge.itemID)
                         {
-                            var23 = 1;
+                            var21 = 1;
                         }
                         else if (var14.itemID == Item.feather.itemID)
                         {
-                            var23 = 4;
+                            var21 = 4;
                         }
                         else if (var14.itemID == Item.goldNugget.itemID)
                         {
-                            var23 = 2;
+                            var21 = 2;
                         }
                         else if (var14.itemID == Item.skull.itemID)
                         {
-                            var23 = 3;
+                            var21 = 3;
                         }
                     }
                 }
@@ -160,25 +160,25 @@ public class RecipeFireworks implements IRecipe
                     var24[var27] = ((Integer)var12.get(var27)).intValue();
                 }
 
-                var19.setIntArray("Colors", var24);
-                var19.setByte("Type", var23);
-                var16.setTag("Explosion", var19);
-                this.field_92102_a.setTagCompound(var16);
+                var18.setIntArray("Colors", var24);
+                var18.setByte("Type", var21);
+                var15.setTag("Explosion", var18);
+                this.field_92102_a.setTagCompound(var15);
                 return true;
             }
             else if (var4 == 0 && var3 == 0 && var6 == 1 && var5 > 0 && var5 == var7)
             {
-                ArrayList var15 = new ArrayList();
+                ArrayList var16 = new ArrayList();
 
-                for (int var17 = 0; var17 < par1InventoryCrafting.getSizeInventory(); ++var17)
+                for (int var20 = 0; var20 < par1InventoryCrafting.getSizeInventory(); ++var20)
                 {
-                    ItemStack var11 = par1InventoryCrafting.getStackInSlot(var17);
+                    ItemStack var11 = par1InventoryCrafting.getStackInSlot(var20);
 
                     if (var11 != null)
                     {
                         if (var11.itemID == Item.dyePowder.itemID)
                         {
-                            var15.add(Integer.valueOf(ItemDye.dyeColors[var11.getItemDamage()]));
+                            var16.add(Integer.valueOf(ItemDye.dyeColors[var11.getItemDamage()]));
                         }
                         else if (var11.itemID == Item.fireworkCharge.itemID)
                         {
@@ -188,24 +188,24 @@ public class RecipeFireworks implements IRecipe
                     }
                 }
 
-                int[] var18 = new int[var15.size()];
+                int[] var17 = new int[var16.size()];
 
-                for (int var20 = 0; var20 < var18.length; ++var20)
+                for (int var19 = 0; var19 < var17.length; ++var19)
                 {
-                    var18[var20] = ((Integer)var15.get(var20)).intValue();
+                    var17[var19] = ((Integer)var16.get(var19)).intValue();
                 }
 
                 if (this.field_92102_a != null && this.field_92102_a.hasTagCompound())
                 {
-                    NBTTagCompound var21 = this.field_92102_a.getTagCompound().getCompoundTag("Explosion");
+                    NBTTagCompound var23 = this.field_92102_a.getTagCompound().getCompoundTag("Explosion");
 
-                    if (var21 == null)
+                    if (var23 == null)
                     {
                         return false;
                     }
                     else
                     {
-                        var21.setIntArray("FadeColors", var18);
+                        var23.setIntArray("FadeColors", var17);
                         return true;
                     }
                 }
@@ -245,4 +245,18 @@ public class RecipeFireworks implements IRecipe
     {
         return this.field_92102_a;
     }
+    
+    // FCMOD: Function added
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return false;
+    }    
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/RecipesArmorDyes.java b/minecraft_server/net/minecraft/src/RecipesArmorDyes.java
index 582d01c..6d7bc27 100644
--- a/minecraft_server/net/minecraft/src/RecipesArmorDyes.java
+++ b/minecraft_server/net/minecraft/src/RecipesArmorDyes.java
@@ -22,7 +22,19 @@ public class RecipesArmorDyes implements IRecipe
                 {
                     ItemArmor var7 = (ItemArmor)var6.getItem();
 
+                    // FCMOD: Code change
+                    /*
                     if (var7.getArmorMaterial() != EnumArmorMaterial.CLOTH || var3 != null)
+                    */                    
+                    if ( var7 instanceof FCItemArmorMod )
+                    {
+                    	if ( !((FCItemArmorMod)var7).HasCustomColors() || var3 != null )
+                    	{
+                    		return false;
+                    	}
+                    }
+                    else if (var7.getArmorMaterial() != EnumArmorMaterial.CLOTH || var3 != null)
+                	// END FCMOD
                     {
                         return false;
                     }
@@ -69,8 +81,19 @@ public class RecipesArmorDyes implements IRecipe
                 if (var8.getItem() instanceof ItemArmor)
                 {
                     var6 = (ItemArmor)var8.getItem();
-
+                    // FCMOD: Code change
+                    /*
                     if (var6.getArmorMaterial() != EnumArmorMaterial.CLOTH || var2 != null)
+                    */                    
+                    if ( var6 instanceof FCItemArmorMod )
+                    {
+                    	if ( !((FCItemArmorMod)var6).HasCustomColors() || var2 != null )
+                    	{
+                    		return null;
+                    	}
+                    }
+                    else if (var6.getArmorMaterial() != EnumArmorMaterial.CLOTH || var2 != null)
+                	// END FCMOD
                     {
                         return null;
                     }
@@ -99,12 +122,12 @@ public class RecipesArmorDyes implements IRecipe
                     }
 
                     float[] var14 = EntitySheep.fleeceColorTable[BlockCloth.getBlockFromDye(var8.getItemDamage())];
-                    int var15 = (int)(var14[0] * 255.0F);
-                    int var16 = (int)(var14[1] * 255.0F);
+                    int var16 = (int)(var14[0] * 255.0F);
+                    int var15 = (int)(var14[1] * 255.0F);
                     var17 = (int)(var14[2] * 255.0F);
-                    var4 += Math.max(var15, Math.max(var16, var17));
-                    var3[0] += var15;
-                    var3[1] += var16;
+                    var4 += Math.max(var16, Math.max(var15, var17));
+                    var3[0] += var16;
+                    var3[1] += var15;
                     var3[2] += var17;
                     ++var5;
                 }
@@ -144,4 +167,18 @@ public class RecipesArmorDyes implements IRecipe
     {
         return null;
     }
+    
+    // FCMOD: Function added
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/RecipesMapCloning.java b/minecraft_server/net/minecraft/src/RecipesMapCloning.java
index 24c89c7..ad918a3 100644
--- a/minecraft_server/net/minecraft/src/RecipesMapCloning.java
+++ b/minecraft_server/net/minecraft/src/RecipesMapCloning.java
@@ -104,4 +104,18 @@ public class RecipesMapCloning implements IRecipe
     {
         return null;
     }
+    
+    // FCMOD: Function added
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/SaveHandler.java b/minecraft_server/net/minecraft/src/SaveHandler.java
index 427cf6c..a30cdff 100644
--- a/minecraft_server/net/minecraft/src/SaveHandler.java
+++ b/minecraft_server/net/minecraft/src/SaveHandler.java
@@ -342,4 +342,34 @@ public class SaveHandler implements ISaveHandler, IPlayerFileData
     {
         return this.saveDirectoryName;
     }
+    
+    // FCMOD: Added
+    @Override
+    public void LoadModSpecificData( WorldServer world )
+    {
+        world.loadWorldDataFromNBT(GetDimensionDirectory(world));
+    }
+    
+    @Override
+    public void SaveModSpecificData( WorldServer world )
+    {
+        world.saveWorldDataToNBT(GetDimensionDirectory(world));
+    }
+    
+    private File GetDimensionDirectory( WorldServer world )
+    {
+        if ( world.provider.dimensionId == -1 ) // nether
+        {
+            return new File( worldDirectory, "DIM-1");
+        }
+        else if ( world.provider.dimensionId == 1 ) // the end
+        {
+        	return new File( worldDirectory, "DIM1");
+        }
+        else
+        {
+            return worldDirectory;
+        }        
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ServerCommandManager.java b/minecraft_server/net/minecraft/src/ServerCommandManager.java
index 528314c..6e31458 100644
--- a/minecraft_server/net/minecraft/src/ServerCommandManager.java
+++ b/minecraft_server/net/minecraft/src/ServerCommandManager.java
@@ -1,10 +1,14 @@
 package net.minecraft.src;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import net.minecraft.server.MinecraftServer;
 
 public class ServerCommandManager extends CommandHandler implements IAdminCommand
 {
+	private static ArrayList<ICommand> commandsClient = new ArrayList<ICommand>();
+	private static ArrayList<ICommand> commandsServer = new ArrayList<ICommand>();
+	
     public ServerCommandManager()
     {
         this.registerCommand(new CommandTime());
@@ -30,6 +34,7 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
         this.registerCommand(new CommandClearInventory());
         this.registerCommand(new ServerCommandTestFor());
         this.registerCommand(new ServerCommandScoreboard());
+        this.registerCommand(new FCCommandServerLoc());
 
         if (MinecraftServer.getServer().isDedicatedServer())
         {
@@ -47,10 +52,18 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
             this.registerCommand(new CommandServerKick());
             this.registerCommand(new CommandServerList());
             this.registerCommand(new CommandServerWhitelist());
+            
+            for (ICommand command : commandsServer) {
+    			this.registerCommand(command);
+    		}
         }
         else
         {
             this.registerCommand(new CommandServerPublishLocal());
+            
+            for (ICommand command : commandsClient) {
+    			this.registerCommand(command);
+    		}
         }
 
         CommandBase.setAdminCommander(this);
@@ -86,7 +99,7 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
 
         if (par1ICommandSender != MinecraftServer.getServer())
         {
-            MinecraftServer.getServer().getLogAgent().func_98233_a("[" + par1ICommandSender.getCommandSenderName() + ": " + MinecraftServer.getServer().translateString(par3Str, par4ArrayOfObj) + "]");
+            MinecraftServer.getServer().getLogAgent().func_98236_b("[" + par1ICommandSender.getCommandSenderName() + ": " + MinecraftServer.getServer().translateString(par3Str, par4ArrayOfObj) + "]");
         }
 
         if ((par2 & 1) != 1)
@@ -94,4 +107,29 @@ public class ServerCommandManager extends CommandHandler implements IAdminComman
             par1ICommandSender.sendChatToPlayer(par1ICommandSender.translateString(par3Str, par4ArrayOfObj));
         }
     }
+	
+    /**
+     * Register a command for both client and server
+     * @param command
+     */
+	public static void registerAddonCommand(ICommand command) {
+		commandsClient.add(command);
+		commandsServer.add(command);
+	}
+	
+	/**
+	 * Register a client only command
+	 * @param command
+	 */
+	public static void registerAddonCommandClient(ICommand command) {
+		commandsClient.add(command);
+	}
+	
+	/**
+	 * Register a server only command
+	 * @param command
+	 */
+	public static void registerAddonCommandServer(ICommand command) {
+		commandsClient.add(command);
+	}
 }
diff --git a/minecraft_server/net/minecraft/src/ServerConfigurationManager.java b/minecraft_server/net/minecraft/src/ServerConfigurationManager.java
index 0bddb63..36f6dea 100644
--- a/minecraft_server/net/minecraft/src/ServerConfigurationManager.java
+++ b/minecraft_server/net/minecraft/src/ServerConfigurationManager.java
@@ -116,6 +116,8 @@ public abstract class ServerConfigurationManager
                 var10.field_98038_p = false;
             }
         }
+        
+        FCAddOnHandler.serverPlayerConnectionInitialized(var7, par2EntityPlayerMP);
     }
 
     protected void func_96456_a(ServerScoreboard par1ServerScoreboard, EntityPlayerMP par2EntityPlayerMP)
@@ -163,16 +165,25 @@ public abstract class ServerConfigurationManager
 
         if (par2WorldServer != null)
         {
-            par2WorldServer.getPlayerManager().removePlayer(par1EntityPlayerMP);
+        	// FCMOD: Changed
+            //par2WorldServer.getPlayerManager().removePlayer(par1EntityPlayerMP);
+            par2WorldServer.GetChunkTracker().RemovePlayer(par1EntityPlayerMP);
+            // END FCMOD
         }
 
-        var3.getPlayerManager().addPlayer(par1EntityPlayerMP);
+    	// FCMOD: Changed
+        //var3.getPlayerManager().addPlayer(par1EntityPlayerMP);
+        var3.GetChunkTracker().AddPlayer(par1EntityPlayerMP);
+        // END FCMOD
         var3.theChunkProviderServer.loadChunk((int)par1EntityPlayerMP.posX >> 4, (int)par1EntityPlayerMP.posZ >> 4);
     }
 
     public int getEntityViewDistance()
     {
-        return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
+    	// FCMOD: Changed    	
+        //return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
+        return FCChunkTracker.GetFurthestViewableBlock( getViewDistance() );
+    	// END FCMOD
     }
 
     /**
@@ -226,9 +237,16 @@ public abstract class ServerConfigurationManager
     /**
      * using player's dimension, update their movement when in a vehicle (e.g. cart, boat)
      */
+    /** 
+     * FCNOTE: This is totally misnamed.  It is called for all moving players, not just mounted ones
+     */
     public void serverUpdateMountedMovingPlayer(EntityPlayerMP par1EntityPlayerMP)
     {
-        par1EntityPlayerMP.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(par1EntityPlayerMP);
+    	// FCMOD: Changed
+        //par1EntityPlayerMP.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(par1EntityPlayerMP);
+        par1EntityPlayerMP.getServerForPlayer().GetChunkTracker().UpdateMovingPlayer(
+        	par1EntityPlayerMP);
+        // END FCMOD
     }
 
     /**
@@ -246,7 +264,10 @@ public abstract class ServerConfigurationManager
         }
 
         var2.removeEntity(par1EntityPlayerMP);
-        var2.getPlayerManager().removePlayer(par1EntityPlayerMP);
+        // FCMOD: Changed
+        //var2.getPlayerManager().removePlayer(par1EntityPlayerMP);
+        var2.GetChunkTracker().RemovePlayer(par1EntityPlayerMP);
+        // END FCMOD
         this.playerEntityList.remove(par1EntityPlayerMP);
         this.sendPacketToAllPlayers(new Packet201PlayerInfo(par1EntityPlayerMP.username, false, 9999));
     }
@@ -340,6 +361,8 @@ public abstract class ServerConfigurationManager
     /**
      * Called on respawn
      */
+    // FCMOD: Function removed and replaced later
+    /*
     public EntityPlayerMP recreatePlayerEntity(EntityPlayerMP par1EntityPlayerMP, int par2, boolean par3)
     {
         par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(par1EntityPlayerMP);
@@ -404,6 +427,9 @@ public abstract class ServerConfigurationManager
         var7.setEntityHealth(var7.getHealth());
         return var7;
     }
+	*/
+	// FCMOD
+
 
     /**
      * moves provided player from overworld to nether or vice versa
@@ -430,6 +456,11 @@ public abstract class ServerConfigurationManager
             PotionEffect var7 = (PotionEffect)var6.next();
             par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet41EntityEffect(par1EntityPlayerMP.entityId, var7));
         }
+        
+        // FCMOD: Added
+        par1EntityPlayerMP.FlagAllWatchedObjectsDirty();
+        par1EntityPlayerMP.m_lTimeOfLastDimensionSwitch = var5.getWorldTime();
+        // END FCMOD
     }
 
     /**
@@ -502,10 +533,21 @@ public abstract class ServerConfigurationManager
 
             if (par1Entity.isEntityAlive())
             {
+            	// FCMOD: Code change to fix other players not showing up when going through a portal in SMP
+            	/*
                 par4WorldServer.spawnEntityInWorld(par1Entity);
                 par1Entity.setLocationAndAngles(var5, par1Entity.posY, var7, par1Entity.rotationYaw, par1Entity.rotationPitch);
                 par4WorldServer.updateEntityWithOptionalForce(par1Entity, false);
                 par4WorldServer.getDefaultTeleporter().placeInPortal(par1Entity, var11, var13, var15, var17);
+                */
+                par1Entity.setLocationAndAngles(var5, par1Entity.posY, var7, par1Entity.rotationYaw, par1Entity.rotationPitch);
+                
+                FlagChunksAroundTeleportingEntityForCheckForUnload( par4WorldServer, par1Entity );
+                
+                par4WorldServer.getDefaultTeleporter().placeInPortal(par1Entity, var11, var13, var15, var17);
+                par4WorldServer.spawnEntityInWorld(par1Entity);
+                par4WorldServer.updateEntityWithOptionalForce(par1Entity, false);
+                // END FCMOD
             }
 
             par3WorldServer.theProfiler.endSection();
@@ -886,8 +928,20 @@ public abstract class ServerConfigurationManager
 
         if (par2WorldServer.isRaining())
         {
+        	// FCMOD: Code change so that initial rain strength is set to full on client
+        	/*
             par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet70GameEvent(1, 0));
+            */
+            par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet70GameEvent(1, 1));
+        	// END FCMOD
         }
+        
+        // FCMOD: Code added
+        if (par2WorldServer.worldInfo.isThundering())
+        {
+            par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet70GameEvent(7, 1));
+        }        
+        // END FCMOD
     }
 
     /**
@@ -1006,4 +1060,164 @@ public abstract class ServerConfigurationManager
         this.mcServer.logInfo(par1Str);
         this.sendPacketToAllPlayers(new Packet3Chat(par1Str));
     }
+
+    // FCMOD: Added    
+    // client
+    //public EntityPlayerMP respawnPlayer( EntityPlayerMP oldPlayer, int iDefaultDimension, boolean bPlayerLeavingTheEnd )
+    // server
+    public EntityPlayerMP recreatePlayerEntity( EntityPlayerMP oldPlayer, int iDefaultDimension, boolean bPlayerLeavingTheEnd )
+    {
+        oldPlayer.getServerForPlayer().getEntityTracker().removePlayerFromTrackers( oldPlayer );
+        
+    	// client
+        //oldPlayer.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers( oldPlayer );
+    	// server    	
+    	oldPlayer.getServerForPlayer().getEntityTracker().untrackEntity( oldPlayer );
+        
+        oldPlayer.getServerForPlayer().GetChunkTracker().RemovePlayer( oldPlayer );
+        
+        playerEntityList.remove( oldPlayer );
+        
+        mcServer.worldServerForDimension( oldPlayer.dimension ).removePlayerEntityDangerously( oldPlayer );
+        
+        ChunkCoordinates verifiedRespawnCoords = null;
+        boolean bRetainPreviousSpawn = false;
+
+    	String sSpawnFailMessage = null;
+    	
+    	int iNewDimension = iDefaultDimension;
+    	
+        if ( oldPlayer.HasRespawnCoordinates() )
+        {
+            if ( !bPlayerLeavingTheEnd )
+            {
+	        	ChunkCoordinates rawRespawnCoords = new ChunkCoordinates();
+	        	
+	            int iReturnValue = oldPlayer.GetValidatedRespawnCoordinates( mcServer.worldServerForDimension( oldPlayer.m_iSpawnDimension ), rawRespawnCoords );
+	
+	            if ( iReturnValue == 0 )
+	            {
+	            	verifiedRespawnCoords = rawRespawnCoords;	
+	            	iNewDimension = oldPlayer.m_iSpawnDimension;
+	            }
+	            else
+	            {
+		            if ( iReturnValue == 1 )
+		            {
+		            	sSpawnFailMessage = "Your respawn location was invalid";
+		            }
+		            else if ( iReturnValue == 2 )
+		            {
+		            	sSpawnFailMessage = "The beacon to which you were bound is no longer present";
+		            }
+		            else if ( iReturnValue == 3 )
+		            {
+		            	sSpawnFailMessage = "The beacon to which you are bound was too far away";
+		            	bRetainPreviousSpawn = true;
+		            }
+		            else if ( iReturnValue == 4 )
+		            {
+		            	sSpawnFailMessage = "The beacon to which you are bound was obstructed";
+		            	bRetainPreviousSpawn = true;
+		            }
+		            else
+		            {
+		            	sSpawnFailMessage = "Your respawn failed for an unknown reason";
+		            }
+		            
+	            }
+	        }
+            else
+            {
+            	// retain the player's previous respawn location when you pop back from the end
+            	
+            	bRetainPreviousSpawn = true;
+            }
+        }
+
+        ItemInWorldManager worldManager;
+
+        if (this.mcServer.isDemo())
+        {
+            worldManager = new DemoWorldManager(this.mcServer.worldServerForDimension( iNewDimension ) );
+        }
+        else
+        {
+            worldManager = new ItemInWorldManager(this.mcServer.worldServerForDimension( iNewDimension ) );
+        }
+
+        EntityPlayerMP newPlayer = new EntityPlayerMP( mcServer, mcServer.worldServerForDimension( iNewDimension ), oldPlayer.username, worldManager );
+        
+        newPlayer.playerNetServerHandler = oldPlayer.playerNetServerHandler;
+        
+        oldPlayer.dimension = iNewDimension;        
+        newPlayer.clonePlayer( oldPlayer, bPlayerLeavingTheEnd );
+        newPlayer.entityId = oldPlayer.entityId;
+        
+        WorldServer newWorldServer = mcServer.worldServerForDimension( oldPlayer.dimension );
+        
+        func_72381_a( newPlayer, oldPlayer, newWorldServer ); // initializes the game type
+        
+        if ( verifiedRespawnCoords != null )
+        {
+            newPlayer.setLocationAndAngles((double)((float)verifiedRespawnCoords.posX + 0.5F), (double)((float)verifiedRespawnCoords.posY + 0.1F), (double)((float)verifiedRespawnCoords.posZ + 0.5F), 0.0F, 0.0F);
+            
+            bRetainPreviousSpawn = true;
+            
+        }
+        else if ( !bPlayerLeavingTheEnd )
+        {
+    		FCUtilsHardcoreSpawn.HandleHardcoreSpawn( mcServer, oldPlayer, newPlayer );
+        }
+        
+        if ( bRetainPreviousSpawn )
+        {
+            newPlayer.setSpawnChunk( oldPlayer.getBedLocation(), oldPlayer.isSpawnForced(), oldPlayer.m_iSpawnDimension );
+        }
+        
+        if ( sSpawnFailMessage != null )
+        {
+            FCUtilsWorld.SendPacketToPlayer( newPlayer.playerNetServerHandler, new Packet3Chat( sSpawnFailMessage ) );
+        }
+        
+        newWorldServer.theChunkProviderServer.loadChunk((int)newPlayer.posX >> 4, (int)newPlayer.posZ >> 4);
+
+        while (!newWorldServer.getCollidingBoundingBoxes(newPlayer, newPlayer.boundingBox).isEmpty())
+        {
+            newPlayer.setPosition(newPlayer.posX, newPlayer.posY + 1.0D, newPlayer.posZ);
+        }
+
+        newPlayer.playerNetServerHandler.sendPacket(new Packet9Respawn(newPlayer.dimension, (byte)newPlayer.worldObj.difficultySetting, newPlayer.worldObj.getWorldInfo().getTerrainType(), newPlayer.worldObj.getHeight(), newPlayer.theItemInWorldManager.getGameType()));
+        verifiedRespawnCoords = newWorldServer.getSpawnPoint();
+        newPlayer.playerNetServerHandler.sendPacket(new Packet6SpawnPosition(verifiedRespawnCoords.posX, verifiedRespawnCoords.posY, verifiedRespawnCoords.posZ));
+        newPlayer.playerNetServerHandler.sendPacket(new Packet43Experience(newPlayer.experience, newPlayer.experienceTotal, newPlayer.experienceLevel));
+        this.updateTimeAndWeatherForPlayer(newPlayer, newWorldServer);
+        newWorldServer.GetChunkTracker().AddPlayer(newPlayer);
+        newWorldServer.spawnEntityInWorld(newPlayer);
+        this.playerEntityList.add(newPlayer);
+        newPlayer.addSelfToInternalCraftingInventory();
+        newPlayer.setEntityHealth(newPlayer.getHealth());
+        
+        // Code moved relative to vanilla version so that some loading occurs before loading screen dissapears
+        newPlayer.playerNetServerHandler.setPlayerLocation(newPlayer.posX, newPlayer.posY, newPlayer.posZ, newPlayer.rotationYaw, newPlayer.rotationPitch);
+        
+        return newPlayer;
+    }
+    
+    private void FlagChunksAroundTeleportingEntityForCheckForUnload( WorldServer world, Entity entity )
+    {
+        // flag area checked for teleport for unload check as the Teleporter 
+        // class potentially loads a whole bunch of chunks in the placeInPortal() call.
+    	
+    	int iChunkX = MathHelper.floor_double( entity.posX / 16D ); 
+    	int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
+    	
+    	// Teleporter.placeInExistingPortal() checks out to 128 blocks, or 8 chunks
+    	
+    	int iChunkRange = 9;
+    	
+    	world.AddChunkRangeToCheckForUnloadList( iChunkX - iChunkRange, iChunkZ - iChunkRange,
+    		iChunkX + iChunkRange, iChunkZ + iChunkRange );        
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/ShapedRecipes.java b/minecraft_server/net/minecraft/src/ShapedRecipes.java
index 9f198cd..840696f 100644
--- a/minecraft_server/net/minecraft/src/ShapedRecipes.java
+++ b/minecraft_server/net/minecraft/src/ShapedRecipes.java
@@ -37,10 +37,18 @@ public class ShapedRecipes implements IRecipe
      */
     public boolean matches(InventoryCrafting par1InventoryCrafting, World par2World)
     {
+    	// FCMOD: Changed the following to support 4X4 crafting grid
+    	/*
         for (int var3 = 0; var3 <= 3 - this.recipeWidth; ++var3)
         {
             for (int var4 = 0; var4 <= 3 - this.recipeHeight; ++var4)
             {
+        */    	
+        for (int var3 = 0; var3 <= 4 - this.recipeWidth; ++var3)
+        {
+            for (int var4 = 0; var4 <= 4 - this.recipeHeight; ++var4)
+            {
+    	// END FCMOD
                 if (this.checkMatch(par1InventoryCrafting, var3, var4, true))
                 {
                     return true;
@@ -61,10 +69,18 @@ public class ShapedRecipes implements IRecipe
      */
     private boolean checkMatch(InventoryCrafting par1InventoryCrafting, int par2, int par3, boolean par4)
     {
+    	// FCMOD: Changed the following to support 4X4 crafting grid
+    	/*
         for (int var5 = 0; var5 < 3; ++var5)
         {
             for (int var6 = 0; var6 < 3; ++var6)
             {
+        */
+        for (int var5 = 0; var5 < 4; ++var5)
+        {
+            for (int var6 = 0; var6 < 4; ++var6)
+            {
+    	// END FCMOD
                 int var7 = var5 - par2;
                 int var8 = var6 - par3;
                 ItemStack var9 = null;
@@ -83,6 +99,13 @@ public class ShapedRecipes implements IRecipe
 
                 ItemStack var10 = par1InventoryCrafting.getStackInRowAndColumn(var5, var6);
 
+                // FCMOD: Code added to ignore Moulds                
+                if ( var10 != null && var10.itemID == FCBetterThanWolves.fcItemMould.itemID )
+                {
+                	var10 = null;
+                }
+                // END FCMOD
+                
                 if (var10 != null || var9 != null)
                 {
                     if (var10 == null && var9 != null || var10 != null && var9 == null)
@@ -142,4 +165,63 @@ public class ShapedRecipes implements IRecipe
         this.field_92101_f = true;
         return this;
     }
+
+    // FCMOD: Added
+    private boolean m_bHasSecondaryOutput = false;
+    
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	if ( recipe instanceof ShapedRecipes )
+    	{
+    		ShapedRecipes shapedRecipe = (ShapedRecipes)recipe;
+    		
+    		if ( recipeWidth == shapedRecipe.recipeWidth  && recipeHeight == shapedRecipe.recipeHeight )
+    		{
+    			if ( recipeOutputItemID == shapedRecipe.recipeOutputItemID &&
+    				recipeOutput.stackSize == shapedRecipe.recipeOutput.stackSize && 
+    				recipeOutput.getItemDamage() == shapedRecipe.recipeOutput.getItemDamage() )
+    			{
+    				if ( recipeItems.length == shapedRecipe.recipeItems.length )
+    				{
+	    				for ( int iTempIndex = 0; iTempIndex < recipeItems.length; iTempIndex++ )
+	    				{
+	    					ItemStack item1 = recipeItems[iTempIndex];
+	    					ItemStack item2 = shapedRecipe.recipeItems[iTempIndex]; 
+	    						
+	    					if ( item1 == null || item2 == null )
+	    					{
+	    						if ( item1 != null || item2 != null )
+	    						{
+	    							return false;
+	    						}
+	    					}
+	    					else if ( item1.getItem().itemID != item2.getItem().itemID ||
+	    							item1.stackSize != item2.stackSize ||
+	    							item1.getItemDamage() != item2.getItemDamage() )
+	    					{
+	    						return false;
+	    					}
+	    				}
+	    				
+	    				return true;
+    				}
+    			}
+    		}
+    	}
+    	
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return m_bHasSecondaryOutput;
+    }
+    
+    public void SetHasSecondaryOutput( boolean bHasSecondaryOutput )
+    {
+    	m_bHasSecondaryOutput = bHasSecondaryOutput;
+    }
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/ShapelessRecipes.java b/minecraft_server/net/minecraft/src/ShapelessRecipes.java
index 246e439..8ea034d 100644
--- a/minecraft_server/net/minecraft/src/ShapelessRecipes.java
+++ b/minecraft_server/net/minecraft/src/ShapelessRecipes.java
@@ -30,14 +30,29 @@ public class ShapelessRecipes implements IRecipe
     {
         ArrayList var3 = new ArrayList(this.recipeItems);
 
+    	// FCMOD: Changed to support 4X4 crafting
+		/*
         for (int var4 = 0; var4 < 3; ++var4)
         {
             for (int var5 = 0; var5 < 3; ++var5)
             {
+        */
+        for (int var4 = 0; var4 < 4; ++var4)
+        {
+            for (int var5 = 0; var5 < 4; ++var5)
+            {
+    	// END FCMOD
                 ItemStack var6 = par1InventoryCrafting.getStackInRowAndColumn(var5, var4);
 
                 if (var6 != null)
                 {
+                    // FCMOD: Code added to ignore Moulds                
+                    if ( var6.itemID == FCBetterThanWolves.fcItemMould.itemID )
+                    {
+                    	continue;
+                    }
+                    // END FCMOD
+                    
                     boolean var7 = false;
                     Iterator var8 = var3.iterator();
 
@@ -79,4 +94,60 @@ public class ShapelessRecipes implements IRecipe
     {
         return this.recipeItems.size();
     }
-}
+    
+    // FCMOD: Added
+    private boolean m_bHasSecondaryOutput = false;
+    
+    @Override
+    public boolean matches( IRecipe recipe )
+    {
+    	if ( recipe instanceof ShapelessRecipes )
+    	{
+    		ShapelessRecipes shapelessRecipe = (ShapelessRecipes)recipe;
+    		
+			if ( recipeOutput.getItem().itemID == shapelessRecipe.recipeOutput.getItem().itemID &&
+				recipeOutput.stackSize == shapelessRecipe.recipeOutput.stackSize && 
+				recipeOutput.getItemDamage() == shapelessRecipe.recipeOutput.getItemDamage() )
+			{
+				if ( recipeItems.size() == shapelessRecipe.recipeItems.size() )
+				{
+    				for ( int iTempIndex = 0; iTempIndex < recipeItems.size(); iTempIndex++ )
+    				{
+    					ItemStack item1 = (ItemStack)recipeItems.get( iTempIndex );
+    					ItemStack item2 = (ItemStack)shapelessRecipe.recipeItems.get( iTempIndex ); 
+    						
+    					if ( item1 == null || item2 == null )
+    					{
+    						if ( item1 != null || item2 != null )
+    						{
+    							return false;
+    						}
+    					}
+    					else if ( item1.getItem().itemID != item2.getItem().itemID ||
+    							item1.stackSize != item2.stackSize ||
+    							item1.getItemDamage() != item2.getItemDamage() )
+    					{
+    						return false;
+    					}
+    				}
+    				
+    				return true;
+				}
+    		}
+    	}
+    	
+    	return false;
+    }
+    
+    @Override
+    public boolean HasSecondaryOutput()
+    {
+    	return m_bHasSecondaryOutput;
+    }
+    
+    public void SetHasSecondaryOutput( boolean bHasSecondaryOutput )
+    {
+    	m_bHasSecondaryOutput = bHasSecondaryOutput;
+    }
+    // END FCMOD    
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/SlotCrafting.java b/minecraft_server/net/minecraft/src/SlotCrafting.java
index 02079e8..8c669c5 100644
--- a/minecraft_server/net/minecraft/src/SlotCrafting.java
+++ b/minecraft_server/net/minecraft/src/SlotCrafting.java
@@ -112,10 +112,43 @@ public class SlotCrafting extends Slot
 
             if (var4 != null)
             {
+            	// FCMOD: Added            	
+            	var4.getItem().OnUsedInCrafting( var4.getItemDamage(), par1EntityPlayer, 
+            		par2ItemStack );
+            	
+            	if ( !var4.getItem().IsConsumedInCrafting() )
+            	{
+            		continue;
+            	}
+            	else if ( var4.getItem().IsDamagedInCrafting() )
+            	{
+            		if ( var4.getItemDamage() >= var4.getMaxDamage() - 1 )
+            		{
+            			var4.getItem().OnBrokenInCrafting( par1EntityPlayer );
+            			
+                        craftMatrix.decrStackSize(var3, 1);
+            		}
+            		else
+            		{
+            			var4.getItem().OnDamagedInCrafting( par1EntityPlayer );
+            			
+            			var4.damageItem( 1, par1EntityPlayer );
+            		}
+
+            		continue;
+            	}            	
+        		// END FCMOD
                 this.craftMatrix.decrStackSize(var3, 1);
 
                 if (var4.getItem().hasContainerItem())
                 {
+                    // FCMOD: Code added
+                    if ( par2ItemStack.getItem().DoesConsumeContainerItemWhenCrafted( var4.getItem().getContainerItem() ) )
+                    {
+                    	continue;
+                    }
+                    // END FCMOD
+
                     ItemStack var5 = new ItemStack(var4.getItem().getContainerItem());
 
                     if (!var4.getItem().doesContainerItemLeaveCraftingGrid(var4) || !this.thePlayer.inventory.addItemStackToInventory(var5))
@@ -132,5 +165,9 @@ public class SlotCrafting extends Slot
                 }
             }
         }
+        
+        // FCMOD: Code added
+        par1EntityPlayer.m_iTimesCraftedThisTick++;
+        // END FCMOD
     }
 }
diff --git a/minecraft_server/net/minecraft/src/SlotFurnace.java b/minecraft_server/net/minecraft/src/SlotFurnace.java
index 263670a..20be13f 100644
--- a/minecraft_server/net/minecraft/src/SlotFurnace.java
+++ b/minecraft_server/net/minecraft/src/SlotFurnace.java
@@ -79,12 +79,16 @@ public class SlotFurnace extends Slot
                 var2 = var4;
             }
 
+            // FCMOD: Code removed
+            /*
             while (var2 > 0)
             {
                 var4 = EntityXPOrb.getXPSplit(var2);
                 var2 -= var4;
                 this.thePlayer.worldObj.spawnEntityInWorld(new EntityXPOrb(this.thePlayer.worldObj, this.thePlayer.posX, this.thePlayer.posY + 0.5D, this.thePlayer.posZ + 0.5D, var4));
             }
+            */
+            // END FCMOD
         }
 
         this.field_75228_b = 0;
@@ -98,5 +102,13 @@ public class SlotFurnace extends Slot
         {
             this.thePlayer.addStat(AchievementList.cookFish, 1);
         }
+        
+        // FCMOD: Code added
+		if ( par1ItemStack.getItem().itemID == Item.bread.itemID )
+		{
+            thePlayer.addStat( AchievementList.makeBread, 1 );
+		}
+		// END FCMOD
+        
     }
 }
diff --git a/minecraft_server/net/minecraft/src/SpawnerAnimals.java b/minecraft_server/net/minecraft/src/SpawnerAnimals.java
index 75ec4f5..3058add 100644
--- a/minecraft_server/net/minecraft/src/SpawnerAnimals.java
+++ b/minecraft_server/net/minecraft/src/SpawnerAnimals.java
@@ -1,42 +1,51 @@
 package net.minecraft.src;
 
+import java.lang.reflect.InvocationTargetException;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 
 public final class SpawnerAnimals
 {
-    /** The 17x17 area around the player where mobs can spawn */
-    private static HashMap eligibleChunksForSpawning = new HashMap();
-
-    /** An array of entity classes that spawn at night. */
-    protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
-
-    /**
-     * Given a chunk, find a random position in it.
-     */
-    protected static ChunkPosition getRandomSpawningPointInChunk(World par0World, int par1, int par2)
-    {
-        Chunk var3 = par0World.getChunkFromChunkCoords(par1, par2);
-        int var4 = par1 * 16 + par0World.rand.nextInt(16);
-        int var5 = par2 * 16 + par0World.rand.nextInt(16);
-        int var6 = par0World.rand.nextInt(var3 == null ? par0World.getActualHeight() : var3.getTopFilledSegment() + 16 - 1);
-        return new ChunkPosition(var4, var6, var5);
-    }
-
-    /**
-     * adds all chunks within the spawn radius of the players to eligibleChunksForSpawning. pars: the world,
-     * hostileCreatures, passiveCreatures. returns number of eligible chunks.
-     */
-    public static final int findChunksForSpawning(WorldServer par0WorldServer, boolean par1, boolean par2, boolean par3)
-    {
-        if (!par1 && !par2)
-        {
-            return 0;
-        }
-        else
-        {
+	/** The 17x17 area around the player where mobs can spawn */
+	// FCMOD: Removed in favor of using the world's active chunk list	
+	//private static HashMap eligibleChunksForSpawning = new HashMap();
+	// END FCMOD
+
+	/** An array of entity classes that spawn at night. */
+	// FCMOD: Removed due to deprecation
+	//protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
+	// END FCMOD
+
+	/**
+	 * Given a chunk, find a random position in it.
+	 */
+	protected static ChunkPosition getRandomSpawningPointInChunk(World par0World, int par1, int par2)
+	{
+		Chunk var3 = par0World.getChunkFromChunkCoords(par1, par2);
+		int var4 = par1 * 16 + par0World.rand.nextInt(16);
+		int var5 = par2 * 16 + par0World.rand.nextInt(16);
+		int var6 = par0World.rand.nextInt(var3 == null ? par0World.getActualHeight() : var3.getTopFilledSegment() + 16 - 1);
+		return new ChunkPosition(var4, var6, var5);
+	}
+
+	/**
+	 * adds all chunks within the spawn radius of the players to eligibleChunksForSpawning. pars: the world,
+	 * hostileCreatures, passiveCreatures. returns number of eligible chunks.
+	 */
+	public static final int findChunksForSpawning(WorldServer par0WorldServer, boolean par1, boolean par2, boolean par3)
+	{
+		if (!par1 && !par2)
+		{
+			return 0;
+		}
+		else
+		{
+			// FCMOD: Changed
+			/*
             eligibleChunksForSpawning.clear();
             int var4;
             int var7;
@@ -66,134 +75,179 @@ public final class SpawnerAnimals
                     }
                 }
             }
-
-            var4 = 0;
-            ChunkCoordinates var32 = par0WorldServer.getSpawnPoint();
-            EnumCreatureType[] var33 = EnumCreatureType.values();
-            var7 = var33.length;
-
-            for (int var34 = 0; var34 < var7; ++var34)
-            {
-                EnumCreatureType var35 = var33[var34];
-
-                if ((!var35.getPeacefulCreature() || par2) && (var35.getPeacefulCreature() || par1) && (!var35.getAnimal() || par3) && par0WorldServer.countEntities(var35.getCreatureClass()) <= var35.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256)
-                {
-                    Iterator var36 = eligibleChunksForSpawning.keySet().iterator();
-                    label110:
-
-                    while (var36.hasNext())
-                    {
-                        ChunkCoordIntPair var37 = (ChunkCoordIntPair)var36.next();
-
-                        if (!((Boolean)eligibleChunksForSpawning.get(var37)).booleanValue())
-                        {
-                            ChunkPosition var38 = getRandomSpawningPointInChunk(par0WorldServer, var37.chunkXPos, var37.chunkZPos);
-                            int var13 = var38.x;
-                            int var14 = var38.y;
-                            int var15 = var38.z;
-
-                            if (!par0WorldServer.isBlockNormalCube(var13, var14, var15) && par0WorldServer.getBlockMaterial(var13, var14, var15) == var35.getCreatureMaterial())
-                            {
-                                int var16 = 0;
-                                int var17 = 0;
-
-                                while (var17 < 3)
-                                {
-                                    int var18 = var13;
-                                    int var19 = var14;
-                                    int var20 = var15;
-                                    byte var21 = 6;
-                                    SpawnListEntry var22 = null;
-                                    int var23 = 0;
-
-                                    while (true)
-                                    {
-                                        if (var23 < 4)
-                                        {
-                                            label103:
-                                            {
-                                                var18 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
-                                                var19 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
-                                                var20 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
-
-                                                if (canCreatureTypeSpawnAtLocation(var35, par0WorldServer, var18, var19, var20))
-                                                {
-                                                    float var24 = (float)var18 + 0.5F;
-                                                    float var25 = (float)var19;
-                                                    float var26 = (float)var20 + 0.5F;
-
-                                                    if (par0WorldServer.getClosestPlayer((double)var24, (double)var25, (double)var26, 24.0D) == null)
-                                                    {
+			 */
+			LinkedList<ChunkCoordIntPair> activeChunks = par0WorldServer.GetActiveChunksCoordsList();
+
+			int var4;
+			int var7;
+			// END FCMOD
+
+			var4 = 0;
+			// FCMOD: Removed
+			//ChunkCoordinates var32 = par0WorldServer.getSpawnPoint();
+			// END FCMOD
+			EnumCreatureType[] var33 = EnumCreatureType.values();
+			var7 = var33.length;
+
+			for (int var34 = 0; var34 < var7; ++var34)
+			{
+				EnumCreatureType var35 = var33[var34];
+
+				// FCMOD: Changed to use custom spawn cap counting
+				//if ((!var35.getPeacefulCreature() || par2) && (var35.getPeacefulCreature() || par1) && (!var35.getAnimal() || par3) && par0WorldServer.countEntities(var35.getCreatureClass()) <= var35.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256)
+				if ( ( !var35.getPeacefulCreature() || par2 ) && 
+						( var35.getPeacefulCreature() || par1 ) && 
+						( !var35.getAnimal() || par3 ) && 
+						par0WorldServer.CountEntitiesThatApplyToSpawnCap( var35.getCreatureClass() ) <= 
+						var35.getMaxNumberOfCreature() * activeChunks.size() / 256 )
+					// END FCMOD
+				{
+					// FCMOD: Changed
+					//Iterator var37 = eligibleChunksForSpawning.keySet().iterator();
+					Iterator var37 = activeChunks.iterator();                    
+					// END FCMOD
+					label110:
+
+						while (var37.hasNext())
+						{
+							ChunkCoordIntPair var36 = (ChunkCoordIntPair)var37.next();
+
+							// FCMOD: Removed
+							//if (!((Boolean)eligibleChunksForSpawning.get(var36)).booleanValue())
+							// END FCMOD
+							{
+								ChunkPosition var38 = getRandomSpawningPointInChunk(par0WorldServer, var36.chunkXPos, var36.chunkZPos);
+								int var13 = var38.x;
+								int var14 = var38.y;
+								int var15 = var38.z;
+
+								// FCMOD: Changed as this was preventing spawns in weird circumstances
+								// like superflat worlds with snow cover.
+								//if (!par0WorldServer.isBlockNormalCube(var13, var14, var15) && par0WorldServer.getBlockMaterial(var13, var14, var15) == var35.getCreatureMaterial())
+								if ( !par0WorldServer.isBlockNormalCube(var13, var14, var15) && 
+										CanCreatureTypeSpawnInMaterial( var35, 
+												par0WorldServer.getBlockMaterial( var13, var14, var15 ) ) )
+									// END FCMOD
+								{
+									int var16 = 0;
+									int var17 = 0;
+
+									while (var17 < 3)
+									{
+										int var18 = var13;
+										int var19 = var14;
+										int var20 = var15;
+										byte var21 = 6;
+										SpawnListEntry var22 = null;
+										int var23 = 0;
+
+										while (true)
+										{
+											if (var23 < 4)
+											{
+												label103:
+												{
+												var18 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
+												// FCNOTE: The following results in 0 all the time.  
+												// Bug?  Check if leaves world bounds if fix?
+												var19 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
+												var20 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
+
+												if (canCreatureTypeSpawnAtLocation(var35, par0WorldServer, var18, var19, var20))
+												{
+													float var24 = (float)var18 + 0.5F;
+													float var25 = (float)var19;
+													// FCMOD: Added
+													var25 += GetVerticalOffsetForPos( var35, par0WorldServer, var18, var19, var20 );
+													var25 += 0.01F; // wiggle
+													// END FCMOD
+													float var26 = (float)var20 + 0.5F;
+
+													if (par0WorldServer.getClosestPlayer((double)var24, (double)var25, (double)var26, 24.0D) == null)
+													{
+														// FCCHUNK: Decide on updates around original spawn
+														// FCMOD: Removed distance check from creature to 
+														// original spawn which prevents spawning 
+														// within 24 blocks (root of 576)
+														/*
                                                         float var27 = var24 - (float)var32.posX;
                                                         float var28 = var25 - (float)var32.posY;
                                                         float var29 = var26 - (float)var32.posZ;
                                                         float var30 = var27 * var27 + var28 * var28 + var29 * var29;
 
                                                         if (var30 >= 576.0F)
-                                                        {
-                                                            if (var22 == null)
-                                                            {
-                                                                var22 = par0WorldServer.spawnRandomCreature(var35, var18, var19, var20);
-
-                                                                if (var22 == null)
-                                                                {
-                                                                    break label103;
-                                                                }
-                                                            }
-
-                                                            EntityLiving var39;
-
-                                                            try
-                                                            {
-                                                                var39 = (EntityLiving)var22.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0WorldServer});
-                                                            }
-                                                            catch (Exception var31)
-                                                            {
-                                                                var31.printStackTrace();
-                                                                return var4;
-                                                            }
-
-                                                            var39.setLocationAndAngles((double)var24, (double)var25, (double)var26, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
-
-                                                            if (var39.getCanSpawnHere())
-                                                            {
-                                                                ++var16;
-                                                                par0WorldServer.spawnEntityInWorld(var39);
-                                                                creatureSpecificInit(var39, par0WorldServer, var24, var25, var26);
-
-                                                                if (var16 >= var39.getMaxSpawnedInChunk())
-                                                                {
-                                                                    continue label110;
-                                                                }
-                                                            }
-
-                                                            var4 += var16;
-                                                        }
-                                                    }
-                                                }
-
-                                                ++var23;
-                                                continue;
-                                            }
-                                        }
-
-                                        ++var17;
-                                        break;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            return var4;
-        }
-    }
-
-    /**
-     * Returns whether or not the specified creature type can spawn at the specified location.
-     */
+														 */
+														// END FCMOD
+														{
+															if (var22 == null)
+															{
+																var22 = par0WorldServer.spawnRandomCreature(var35, var18, var19, var20);
+
+																if (var22 == null)
+																{
+																	break label103;
+																}
+															}
+
+															EntityLiving var39;
+
+															try
+															{
+																var39 = (EntityLiving)var22.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0WorldServer});
+															}
+															catch (Exception var31)
+															{
+																var31.printStackTrace();
+																return var4;
+															}
+
+															// FCMOD: Added
+															var39.PreInitCreature();
+															// END FCMOD
+
+															var39.setLocationAndAngles((double)var24, (double)var25, (double)var26, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
+
+															if (var39.getCanSpawnHere())
+															{
+																++var16;
+																par0WorldServer.spawnEntityInWorld(var39);
+																creatureSpecificInit(var39, par0WorldServer, var24, var25, var26);
+
+																if (var16 >= var39.getMaxSpawnedInChunk())
+																{
+																	continue label110;
+																}
+															}
+
+															var4 += var16;
+														}
+													}
+												}
+
+												++var23;
+												continue;
+												}
+											}
+
+											++var17;
+											break;
+										}
+									}
+								}
+							}
+						}
+				}
+			}
+
+			return var4;
+		}
+	}
+
+	/**
+	 * Returns whether or not the specified creature type can spawn at the specified location.
+	 */
+	// FCMOD: Removed and replaced
+	/*
     public static boolean canCreatureTypeSpawnAtLocation(EnumCreatureType par0EnumCreatureType, World par1World, int par2, int par3, int par4)
     {
         if (par0EnumCreatureType.getCreatureMaterial() == Material.water)
@@ -210,73 +264,212 @@ public final class SpawnerAnimals
             return var5 != Block.bedrock.blockID && !par1World.isBlockNormalCube(par2, par3, par4) && !par1World.getBlockMaterial(par2, par3, par4).isLiquid() && !par1World.isBlockNormalCube(par2, par3 + 1, par4);
         }
     }
-
-    /**
-     * determines if a skeleton spawns on a spider, and if a sheep is a different color
-     */
-    private static void creatureSpecificInit(EntityLiving par0EntityLiving, World par1World, float par2, float par3, float par4)
-    {
-        par0EntityLiving.initCreature();
+	 */
+	// END FCMOD
+
+	/**
+	 * determines if a skeleton spawns on a spider, and if a sheep is a different color
+	 */
+	private static void creatureSpecificInit(EntityLiving par0EntityLiving, World par1World, float par2, float par3, float par4)
+	{
+		par0EntityLiving.initCreature();
+	}
+
+	/**
+	 * Called during chunk generation to spawn initial creatures.
+	 */
+	public static void performWorldGenSpawning(World par0World, BiomeGenBase par1BiomeGenBase, int par2, int par3, int par4, int par5, Random par6Random)
+	{
+		List var7 = par1BiomeGenBase.getSpawnableList(EnumCreatureType.creature);
+
+		if (!var7.isEmpty())
+		{
+			while (par6Random.nextFloat() < par1BiomeGenBase.getSpawningChance())
+			{
+				SpawnListEntry var8 = (SpawnListEntry)WeightedRandom.getRandomItem(par0World.rand, var7);
+				int var9 = var8.minGroupCount + par6Random.nextInt(1 + var8.maxGroupCount - var8.minGroupCount);
+				int var10 = par2 + par6Random.nextInt(par4);
+				int var11 = par3 + par6Random.nextInt(par5);
+				int var12 = var10;
+				int var13 = var11;
+
+				for (int var14 = 0; var14 < var9; ++var14)
+				{
+					boolean var15 = false;
+
+					for (int var16 = 0; !var15 && var16 < 4; ++var16)
+					{
+						int var17 = par0World.getTopSolidOrLiquidBlock(var10, var11);
+
+						if (checkIfAnimalCanSpawn(var8, par0World, var10, var17, var11))
+						{
+							float var18 = (float)var10 + 0.5F;
+							float var19 = (float)var17;
+							float var20 = (float)var11 + 0.5F;
+							EntityLiving var21;
+
+							try
+							{
+								var21 = (EntityLiving)var8.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0World});
+							}
+							catch (Exception var23)
+							{
+								var23.printStackTrace();
+								continue;
+							}
+
+							// FCMOD: Added
+							var21.PreInitCreature();
+							// END FCMOD
+							var21.setLocationAndAngles((double)var18, (double)var19, (double)var20, par6Random.nextFloat() * 360.0F, 0.0F);
+							par0World.spawnEntityInWorld(var21);
+							creatureSpecificInit(var21, par0World, var18, var19, var20);
+							var15 = true;
+						}
+
+						var10 += par6Random.nextInt(5) - par6Random.nextInt(5);
+
+						for (var11 += par6Random.nextInt(5) - par6Random.nextInt(5); var10 < par2 || var10 >= par2 + par4 || var11 < par3 || var11 >= par3 + par4; var11 = var13 + par6Random.nextInt(5) - par6Random.nextInt(5))
+						{
+							var10 = var12 + par6Random.nextInt(5) - par6Random.nextInt(5);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public static boolean checkIfAnimalCanSpawn(SpawnListEntry entry, World world, int x, int y, int z) {
+		return canEntitySpawnDuringWorldGen(entry.entityClass, world, x, y, z);
+	}
+
+	public static boolean canCreatureTypeSpawnAtLocation( EnumCreatureType type, 
+			World world, int i, int j, int k )
+	{
+		if ( type.getCreatureMaterial() == Material.water )
+		{
+			return world.getBlockMaterial( i, j, k ).isLiquid() && 
+					world.getBlockMaterial( i, j - 1, k ).isLiquid() && 
+					!world.isBlockNormalCube( i, j + 1, k );
+		}
+
+		if ( !world.isBlockNormalCube( i, j, k ) && 
+				!world.getBlockMaterial( i, j, k ).isLiquid() )
+		{
+			Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+
+			return blockBelow != null && blockBelow.CanMobsSpawnOn( world, i, j - 1, k );
+		}
+
+		return false;
+	}
+
+	public static float GetVerticalOffsetForPos( EnumCreatureType type, 
+			World world, int i, int j, int k )
+	{
+		if ( type.getCreatureMaterial() != Material.water )
+		{
+			Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
+
+			if ( blockBelow != null )
+			{
+				return blockBelow.MobSpawnOnVerticalOffset( world, i, j - 1, k );
+			}
+		}
+
+		return 0F;
+	}
+
+	public static boolean CanCreatureTypeSpawnInMaterial( EnumCreatureType type, Material material ) 
+	{
+		if ( material == Material.water )
+		{
+			return type.getCreatureMaterial() == Material.water;
+		}
+		else
+		{
+			return type.getCreatureMaterial() != Material.water;
+		}
+	}
+    
+    //------ World Gen Spawning Behavior ------//
+    private static SpawnBehavior defaultSpawnBehavior;
+    private static Map<Class<? extends EntityLiving>, SpawnBehavior> worldGenSpawnBehaviors = new HashMap();
+    
+    static {
+    	defaultSpawnBehavior = new SpawnBehavior() {
+			@Override
+			public boolean canSpawnAtLocationDuringWorldGen(World world, int x, int y, int z) {
+				// modified and trimmed down version of canCreatureTypeSpawnAtLocation() so that animals 
+		    	// don't initially spawn buried in leaves and to reduce the overall number of tests 
+		    	// performed
+		    	
+		    	int blockID = world.getBlockId(x, y, z);
+		    	
+		    	if (!Block.isNormalCube(blockID) && !world.getBlockMaterial(x, y, z).isLiquid() && blockID != Block.leaves.blockID)
+		    	{
+		    		int blockAboveID = world.getBlockId(x, y + 1, z);
+		    		
+		    		if (!Block.isNormalCube(blockAboveID) && blockAboveID != Block.leaves.blockID)
+		    		{
+			            int blockBelowID = world.getBlockId(x, y - 1, z);
+			            
+			            return Block.isNormalCube(blockBelowID) && blockBelowID != Block.bedrock.blockID;
+		    		}
+		    	}
+		        
+		        return false;
+			}
+		};
+		
+		setWorldGenSpawnBehavior(FCEntityWitch.class, new SpawnBehavior() {
+			@Override
+			public boolean canSpawnAtLocationDuringWorldGen(World world, int x, int y, int z) {
+				// modified version of default spawn behavior that allows
+				// witches to spawn over water and leaves to maximize chances they'll find a spot
+				// around generated witch huts
+		    	
+		    	int blockID = world.getBlockId(x, y, z);
+		    	
+		    	if (!Block.isNormalCube(blockID) && !world.getBlockMaterial(x, y, z).isLiquid() && blockID != Block.leaves.blockID)
+		    	{
+		    		int blockAboveID = world.getBlockId(x, y + 1, z);
+		    		
+		    		if (!Block.isNormalCube(blockAboveID) && blockAboveID != Block.leaves.blockID)
+		    		{
+			            int blockBelowID = world.getBlockId(x, y - 1, z);
+			            
+			            return blockBelowID != Block.bedrock.blockID && (Block.isNormalCube(blockBelowID) || world.getBlockMaterial(x, y - 1, z) == Material.water || blockBelowID == Block.leaves.blockID);
+		    		}
+		    	}
+		        
+		        return false;
+			}
+		});
     }
-
-    /**
-     * Called during chunk generation to spawn initial creatures.
-     */
-    public static void performWorldGenSpawning(World par0World, BiomeGenBase par1BiomeGenBase, int par2, int par3, int par4, int par5, Random par6Random)
-    {
-        List var7 = par1BiomeGenBase.getSpawnableList(EnumCreatureType.creature);
-
-        if (!var7.isEmpty())
-        {
-            while (par6Random.nextFloat() < par1BiomeGenBase.getSpawningChance())
-            {
-                SpawnListEntry var8 = (SpawnListEntry)WeightedRandom.getRandomItem(par0World.rand, var7);
-                int var9 = var8.minGroupCount + par6Random.nextInt(1 + var8.maxGroupCount - var8.minGroupCount);
-                int var10 = par2 + par6Random.nextInt(par4);
-                int var11 = par3 + par6Random.nextInt(par5);
-                int var12 = var10;
-                int var13 = var11;
-
-                for (int var14 = 0; var14 < var9; ++var14)
-                {
-                    boolean var15 = false;
-
-                    for (int var16 = 0; !var15 && var16 < 4; ++var16)
-                    {
-                        int var17 = par0World.getTopSolidOrLiquidBlock(var10, var11);
-
-                        if (canCreatureTypeSpawnAtLocation(EnumCreatureType.creature, par0World, var10, var17, var11))
-                        {
-                            float var18 = (float)var10 + 0.5F;
-                            float var19 = (float)var17;
-                            float var20 = (float)var11 + 0.5F;
-                            EntityLiving var21;
-
-                            try
-                            {
-                                var21 = (EntityLiving)var8.entityClass.getConstructor(new Class[] {World.class}).newInstance(new Object[] {par0World});
-                            }
-                            catch (Exception var23)
-                            {
-                                var23.printStackTrace();
-                                continue;
-                            }
-
-                            var21.setLocationAndAngles((double)var18, (double)var19, (double)var20, par6Random.nextFloat() * 360.0F, 0.0F);
-                            par0World.spawnEntityInWorld(var21);
-                            creatureSpecificInit(var21, par0World, var18, var19, var20);
-                            var15 = true;
-                        }
-
-                        var10 += par6Random.nextInt(5) - par6Random.nextInt(5);
-
-                        for (var11 += par6Random.nextInt(5) - par6Random.nextInt(5); var10 < par2 || var10 >= par2 + par4 || var11 < par3 || var11 >= par3 + par4; var11 = var13 + par6Random.nextInt(5) - par6Random.nextInt(5))
-                        {
-                            var10 = var12 + par6Random.nextInt(5) - par6Random.nextInt(5);
-                        }
-                    }
-                }
-            }
-        }
+    
+    public static boolean canEntitySpawnDuringWorldGen(Class<? extends EntityLiving> entityClass, World world, int x, int y, int z) {
+    	SpawnBehavior spawnBehavior = worldGenSpawnBehaviors.get(entityClass);
+    	
+    	if (spawnBehavior != null) {
+    		return spawnBehavior.canSpawnAtLocationDuringWorldGen(world, x, y, z);
+    	}
+    	else {
+    		return defaultSpawnBehavior.canSpawnAtLocationDuringWorldGen(world, x, y, z);
+    	}
+    }
+    
+    public static void setWorldGenSpawnBehavior(Class<? extends EntityLiving> entityClass, SpawnBehavior spawnBehavior) {
+    	worldGenSpawnBehaviors.put(entityClass, spawnBehavior);
+    }
+    
+    public static void removeCustomWorldGenSpawnBehavior(Class<? extends EntityLiving> entityClass) {
+    	worldGenSpawnBehaviors.remove(entityClass);
     }
-}
+	
+	public static abstract class SpawnBehavior {
+		public abstract boolean canSpawnAtLocationDuringWorldGen(World world, int x, int y, int z);
+	}
+	
+	// END FCMOD
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/StatList.java b/minecraft_server/net/minecraft/src/StatList.java
index 67c28ed..c839a88 100644
--- a/minecraft_server/net/minecraft/src/StatList.java
+++ b/minecraft_server/net/minecraft/src/StatList.java
@@ -173,9 +173,16 @@ public class StatList
      */
     private static StatBase[] initMinableStats(String par0Str, int par1)
     {
+    	// FCMOD: Change to accomodate extended block IDs 
+    	/*
         StatBase[] var2 = new StatBase[256];
 
         for (int var3 = 0; var3 < 256; ++var3)
+        */
+        StatBase[] var2 = new StatBase[4096];
+
+        for (int var3 = 0; var3 < 4096; ++var3)
+    	// END FCMOD
         {
             if (Block.blocksList[var3] != null && Block.blocksList[var3].getEnableStats())
             {
diff --git a/minecraft_server/net/minecraft/src/StringTranslate.java b/minecraft_server/net/minecraft/src/StringTranslate.java
index c0fad6b..f32e71e 100644
--- a/minecraft_server/net/minecraft/src/StringTranslate.java
+++ b/minecraft_server/net/minecraft/src/StringTranslate.java
@@ -9,6 +9,7 @@ import java.util.Enumeration;
 import java.util.IllegalFormatException;
 import java.util.Properties;
 import java.util.TreeMap;
+import java.util.zip.ZipEntry;
 
 public class StringTranslate
 {
@@ -154,6 +155,10 @@ public class StringTranslate
 
             this.currentLanguage = par1Str;
             this.translateTable = var3;
+
+            // FCMOD: Code added
+            FCAddOnHandler.OnLanguageLoaded( this );
+            // END FCMOD
         }
     }
 
@@ -197,4 +202,49 @@ public class StringTranslate
     {
         return this.translateTable.getProperty(par1Str + ".name", "");
     }
+
+    // FCMOD
+    public Properties GetTranslateTable()
+    {
+    	return translateTable;
+    }
+    
+    public void LoadAddonLanguageExtension( String sAddonPrefix )
+    {
+    	SafeLoadLanguage( sAddonPrefix + "_" + "en_US" );
+    	
+        SafeLoadLanguage( sAddonPrefix + "_" + currentLanguage );
+    }
+    
+    private void SafeLoadLanguage( String sLanguageName )
+    {
+        if ( StringTranslate.class.getResource( "/lang/" + sLanguageName + ".lang" ) != null )
+        {
+	        try
+	        {
+	            loadLanguage( translateTable, sLanguageName );
+	        }
+	        catch ( IOException exception )
+	        {
+	            ;
+	        }
+        }
+    }
+    
+    public void DebugOutputCurrentLanguage()
+    {
+        Enumeration var4 = translateTable.propertyNames();
+
+        while ( var4.hasMoreElements() )
+        {
+            Object var5 = var4.nextElement();
+            Object var6 = translateTable.get(var5);
+
+            if (var6 != null)
+            {
+                System.out.println( var5.toString() + "=" + var6.toString() );
+            }
+        }
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/StructureComponent.java b/minecraft_server/net/minecraft/src/StructureComponent.java
index 089a64c..d368e62 100644
--- a/minecraft_server/net/minecraft/src/StructureComponent.java
+++ b/minecraft_server/net/minecraft/src/StructureComponent.java
@@ -210,7 +210,10 @@ public abstract class StructureComponent
                 return 1;
             }
         }
-        else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID)
+        // FCMOD: Changed
+        //else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID)
+        else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID && par1 != FCBetterThanWolves.fcBlockDoorWood.blockID)
+    	// END FCMOD
         {
             if (par1 != Block.stairsCobblestone.blockID && par1 != Block.stairsWoodOak.blockID && par1 != Block.stairsNetherBrick.blockID && par1 != Block.stairsStoneBrick.blockID && par1 != Block.stairsSandStone.blockID)
             {
@@ -770,9 +773,17 @@ public abstract class StructureComponent
         int var10 = this.getYWithOffset(par5);
         int var11 = this.getZWithOffset(par4, par6);
 
+        // FCMOD: Changed
+        /*
         if (par2StructureBoundingBox.isVecInside(var9, var10, var11) && par1World.getBlockId(var9, var10, var11) != Block.chest.blockID)
         {
             par1World.setBlock(var9, var10, var11, Block.chest.blockID, 0, 2);
+        */
+        if (par2StructureBoundingBox.isVecInside(var9, var10, var11) && 
+        	par1World.getBlockId(var9, var10, var11) != FCBetterThanWolves.fcBlockChest.blockID)
+        {
+            par1World.setBlock(var9, var10, var11, FCBetterThanWolves.fcBlockChest.blockID, 0, 2);
+        // END FCMOD
             TileEntityChest var12 = (TileEntityChest)par1World.getBlockTileEntity(var9, var10, var11);
 
             if (var12 != null)
@@ -823,7 +834,10 @@ public abstract class StructureComponent
 
         if (par2StructureBoundingBox.isVecInside(var8, var9, var10))
         {
-            ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, Block.doorWood);
+            // FCMOD: Changed
+            //ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, Block.doorWood);
+            ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, FCBetterThanWolves.fcBlockDoorWood);
+            // END FCMOD
         }
     }
 }
diff --git a/minecraft_server/net/minecraft/src/TileEntity.java b/minecraft_server/net/minecraft/src/TileEntity.java
index e0b452d..facea03 100644
--- a/minecraft_server/net/minecraft/src/TileEntity.java
+++ b/minecraft_server/net/minecraft/src/TileEntity.java
@@ -36,7 +36,12 @@ public class TileEntity
     /**
      * Adds a new two-way mapping between the class and its string name in both hashmaps.
      */
+    // FCMOD: Code change
+    /*
     private static void addMapping(Class par0Class, String par1Str)
+    */
+    public static void addMapping(Class par0Class, String par1Str)
+    // END FCMOD
     {
         if (nameToClassMap.containsKey(par1Str))
         {
@@ -267,4 +272,19 @@ public class TileEntity
         addMapping(TileEntityHopper.class, "Hopper");
         addMapping(TileEntityComparator.class, "Comparator");
     }
+    
+    // FCMOD: Code added
+    public static void ReplaceVanillaMapping( Class vanillaClass, Class newClass, String name )
+    {
+    	removeTileEntityMapping( vanillaClass, name );
+    	
+    	addMapping( newClass, name );
+    }
+    
+    public static void removeTileEntityMapping( Class className, String sTileEntityName )
+    {
+        nameToClassMap.remove( sTileEntityName );
+        classToNameMap.remove( className );
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/TileEntityBeacon.java b/minecraft_server/net/minecraft/src/TileEntityBeacon.java
index e83f962..8b155d6 100644
--- a/minecraft_server/net/minecraft/src/TileEntityBeacon.java
+++ b/minecraft_server/net/minecraft/src/TileEntityBeacon.java
@@ -349,4 +349,31 @@ public class TileEntityBeacon extends TileEntity implements IInventory
     {
         return par2ItemStack.itemID == Item.emerald.itemID || par2ItemStack.itemID == Item.diamond.itemID || par2ItemStack.itemID == Item.ingotGold.itemID || par2ItemStack.itemID == Item.ingotIron.itemID;
     }
+    
+    // FCMOD: Code added
+    protected boolean IsOn()
+    {
+    	return isBeaconActive;
+    }
+    
+    protected void SetIsOn( boolean bOn )
+    {
+    	isBeaconActive = bOn;
+    }
+    
+    protected void SetPrimaryEffect( int iEffect )
+    {
+    	primaryEffect = iEffect;
+    }
+    
+    public void setLevelsServerSafe(int par1)
+    {
+        levels = par1;
+    }
+    
+    public boolean IsHomeBeacon()
+    {
+    	return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/TileEntityFurnace.java b/minecraft_server/net/minecraft/src/TileEntityFurnace.java
index 2c74698..be778f7 100644
--- a/minecraft_server/net/minecraft/src/TileEntityFurnace.java
+++ b/minecraft_server/net/minecraft/src/TileEntityFurnace.java
@@ -9,7 +9,10 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
     /**
      * The ItemStacks that hold the items currently being used in the furnace
      */
-    private ItemStack[] furnaceItemStacks = new ItemStack[3];
+    // FCMOD: Changed
+    //private ItemStack[] furnaceItemStacks = new ItemStack[3];
+    protected ItemStack[] furnaceItemStacks = new ItemStack[3];
+    // END FCMOD
 
     /** The number of ticks that the furnace will keep burning */
     public int furnaceBurnTime = 0;
@@ -154,6 +157,19 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
         {
             this.field_94130_e = par1NBTTagCompound.getString("CustomName");
         }
+        
+        // FCMOD: Code added to track extended burn times
+        if ( par1NBTTagCompound.hasKey( "fcBurnTimeEx" ) )
+        {
+	        furnaceBurnTime = par1NBTTagCompound.getInteger( "fcBurnTimeEx" );
+	        furnaceCookTime = par1NBTTagCompound.getInteger( "fcCookTimeEx" );
+	        
+	        if ( par1NBTTagCompound.hasKey( "fcItemBurnTimeEx" ) )
+	        {
+	            currentItemBurnTime = par1NBTTagCompound.getInteger( "fcItemBurnTimeEx" );
+	        }
+        }
+        // END FCMOD
     }
 
     /**
@@ -183,6 +199,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
         {
             par1NBTTagCompound.setString("CustomName", this.field_94130_e);
         }
+        
+        // FCMOD: Code added to track extended burn times
+        par1NBTTagCompound.setInteger( "fcBurnTimeEx", furnaceBurnTime );
+        par1NBTTagCompound.setInteger( "fcCookTimeEx", furnaceCookTime );
+        par1NBTTagCompound.setInteger( "fcItemBurnTimeEx", currentItemBurnTime );
+        // END FCMOD
     }
 
     /**
@@ -218,7 +240,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
 
         if (!this.worldObj.isRemote)
         {
+        	// FCMOD: Code change to consume fuel regardless of whether you can smelt
+        	/*
             if (this.furnaceBurnTime == 0 && this.canSmelt())
+            */
+            if (this.furnaceBurnTime == 0)
+        	// END FCMOD
             {
                 this.currentItemBurnTime = this.furnaceBurnTime = getItemBurnTime(this.furnaceItemStacks[1]);
 
@@ -243,7 +270,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
             {
                 ++this.furnaceCookTime;
 
+            	// FCMOD: Change to double burn times
+                /*
                 if (this.furnaceCookTime == 200)
+                */
+                if (this.furnaceCookTime >= GetCookTimeForCurrentItem())
+            	// END FCMOD
                 {
                     this.furnaceCookTime = 0;
                     this.smeltItem();
@@ -255,11 +287,34 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
                 this.furnaceCookTime = 0;
             }
 
+            // FCMOD: Added
+            boolean bHasVisibleContents = furnaceItemStacks[0] != null || furnaceItemStacks[2] != null;
+            
+            FCBlockFurnace furnaceBlock = (FCBlockFurnace)Block.blocksList[worldObj.getBlockId( xCoord, yCoord, zCoord )];            
+            // END FCMOD
+            
             if (var1 != this.furnaceBurnTime > 0)
             {
                 var2 = true;
+                
+                // FCMOD: Changed
+                /*
                 BlockFurnace.updateFurnaceBlockState(this.furnaceBurnTime > 0, this.worldObj, this.xCoord, this.yCoord, this.zCoord);
+                */
+                furnaceBlock.updateFurnaceBlockState( furnaceBurnTime > 0, worldObj, xCoord, yCoord, zCoord, bHasVisibleContents );
+                // END FCMOD
+            }
+            // FCMOD: Added
+            else
+            {
+            	boolean bPreviousContentsState = ( worldObj.getBlockMetadata( xCoord, yCoord, zCoord ) & 8 ) != 0;
+            	
+            	if ( bPreviousContentsState != bHasVisibleContents )
+            	{
+            		furnaceBlock.updateFurnaceBlockState( furnaceBurnTime > 0, worldObj, xCoord, yCoord, zCoord, bHasVisibleContents );
+            	}
             }
+            // END FCMOD            
         }
 
         if (var2)
@@ -271,7 +326,10 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
     /**
      * Returns true if the furnace can smelt an item, i.e. has a source item, destination stack isn't full, etc.
      */
-    private boolean canSmelt()
+    // FCMOD: Changed    
+    //private boolean canSmelt()
+    protected boolean canSmelt()
+    // END FCMOD
     {
         if (this.furnaceItemStacks[0] == null)
         {
@@ -280,7 +338,36 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
         else
         {
             ItemStack var1 = FurnaceRecipes.smelting().getSmeltingResult(this.furnaceItemStacks[0].getItem().itemID);
+            // FCMOD: Change to take into account variable output stack sizes
+            /*
             return var1 == null ? false : (this.furnaceItemStacks[2] == null ? true : (!this.furnaceItemStacks[2].isItemEqual(var1) ? false : (this.furnaceItemStacks[2].stackSize < this.getInventoryStackLimit() && this.furnaceItemStacks[2].stackSize < this.furnaceItemStacks[2].getMaxStackSize() ? true : this.furnaceItemStacks[2].stackSize < var1.getMaxStackSize())));
+            */
+            if ( var1 == null )
+            {
+            	return false;
+            }
+            else if ( this.furnaceItemStacks[2] == null )
+            {
+            	return true;
+            }
+            else if ( !this.furnaceItemStacks[2].isItemEqual(var1) )
+            {
+            	return false;
+            }
+            else 
+            {
+            	int iOutputStackSizeIfCooked = furnaceItemStacks[2].stackSize + var1.stackSize;
+            	
+            	if ( iOutputStackSizeIfCooked <= getInventoryStackLimit() && iOutputStackSizeIfCooked <= furnaceItemStacks[2].getMaxStackSize()  )
+            	{
+            		return true;
+            	}
+                else
+                {            	
+                	return iOutputStackSizeIfCooked <= var1.getMaxStackSize();
+                }
+            }            
+            // END FCMOD
         }
     }
 
@@ -299,7 +386,12 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
             }
             else if (this.furnaceItemStacks[2].itemID == var1.itemID)
             {
+            	// FCMOD: Code change so that output can be greater than 1
+            	/*
                 ++this.furnaceItemStacks[2].stackSize;
+                */
+                furnaceItemStacks[2].stackSize += var1.stackSize;
+                // END FCMOD
             }
 
             --this.furnaceItemStacks[0].stackSize;
@@ -315,6 +407,8 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
      * Returns the number of ticks that the supplied fuel item will keep the furnace burning, or 0 if the item isn't
      * fuel
      */
+    // FCMOD: Removed and replaced
+    /*
     public static int getItemBurnTime(ItemStack par0ItemStack)
     {
         if (par0ItemStack == null)
@@ -344,13 +438,18 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
             return var2 instanceof ItemTool && ((ItemTool)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemSword && ((ItemSword)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemHoe && ((ItemHoe)var2).getMaterialName().equals("WOOD") ? 200 : (var1 == Item.stick.itemID ? 100 : (var1 == Item.coal.itemID ? 1600 : (var1 == Item.bucketLava.itemID ? 20000 : (var1 == Block.sapling.blockID ? 100 : (var1 == Item.blazeRod.itemID ? 2400 : 0)))))));
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Return true if item is a fuel source (getItemBurnTime() > 0).
      */
     public static boolean isItemFuel(ItemStack par0ItemStack)
     {
-        return getItemBurnTime(par0ItemStack) > 0;
+    	// FCMOD: Changed
+        //return getItemBurnTime(par0ItemStack) > 0;
+    	return par0ItemStack.getItem().GetFurnaceBurnTime( par0ItemStack.getItemDamage() ) > 0;
+    	// END FCMOD
     }
 
     /**
@@ -398,4 +497,33 @@ public class TileEntityFurnace extends TileEntity implements ISidedInventory
     {
         return par3 != 0 || par1 != 1 || par2ItemStack.itemID == Item.bucketEmpty.itemID;
     }
+
+    // FCMOD: Added
+    public static final int m_iDefaultCookTime = 400;
+    public static final int m_iBaseBurnTimeMultiplier = 2;
+    
+    protected int GetCookTimeForCurrentItem()
+    {
+    	int iCookTimeShift = 0;
+    	
+    	if ( furnaceItemStacks[0] != null )
+    	{
+    		iCookTimeShift = FurnaceRecipes.smelting().GetCookTimeBinaryShift( 
+    			furnaceItemStacks[0].getItem().itemID );    		
+    	}
+    	
+    	return m_iDefaultCookTime << iCookTimeShift;
+    }
+    
+    public int getItemBurnTime( ItemStack stack )
+    {
+        if ( stack != null )
+        {
+        	return stack.getItem().GetFurnaceBurnTime( stack.getItemDamage() ) * 
+        		m_iBaseBurnTimeMultiplier;            
+        }
+        
+        return 0;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/TileEntityPiston.java b/minecraft_server/net/minecraft/src/TileEntityPiston.java
index 097a277..43fa7b5 100644
--- a/minecraft_server/net/minecraft/src/TileEntityPiston.java
+++ b/minecraft_server/net/minecraft/src/TileEntityPiston.java
@@ -21,6 +21,17 @@ public class TileEntityPiston extends TileEntity
     private float lastProgress;
     private List pushedObjects = new ArrayList();
 
+    // FCMOD: Added
+    private boolean m_bShoveledBlock = false;
+    
+    public TileEntityPiston( int iBlockID, int iMetadata, int iFacing, boolean bExtending, boolean bShouldHeadBeRendered, boolean bShoveledBlock )
+    {
+    	this( iBlockID, iMetadata, iFacing, bExtending, bShouldHeadBeRendered );
+    	
+    	m_bShoveledBlock = true;    	
+    }
+    // END FCMOD
+
     public TileEntityPiston() {}
 
     public TileEntityPiston(int par1, int par2, int par3, boolean par4, boolean par5)
@@ -121,6 +132,15 @@ public class TileEntityPiston extends TileEntity
 
             if (this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord) == Block.pistonMoving.blockID)
             {
+            	// FCMOD: Added
+            	if ( DestroyAndDropIfShoveled() )
+            	{
+            		return;
+            	}
+            	
+            	PreBlockPlaced();
+            	// END FCMOD
+            	
                 this.worldObj.setBlock(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID, this.storedMetadata, 3);
                 this.worldObj.notifyBlockOfNeighborChange(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID);
             }
@@ -138,11 +158,25 @@ public class TileEntityPiston extends TileEntity
         if (this.lastProgress >= 1.0F)
         {
             this.updatePushedObjects(1.0F, 0.25F);
+            
+            // FCMOD: Added
+            AttemptToPackItems();
+            // END FCMOD
+            
             this.worldObj.removeBlockTileEntity(this.xCoord, this.yCoord, this.zCoord);
             this.invalidate();
 
             if (this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord) == Block.pistonMoving.blockID)
             {
+            	// FCMOD: Added
+            	if ( DestroyAndDropIfShoveled() )
+            	{
+            		return;
+            	}
+            	
+            	PreBlockPlaced();
+            	// END FCMOD
+            	
                 this.worldObj.setBlock(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID, this.storedMetadata, 3);
                 this.worldObj.notifyBlockOfNeighborChange(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID);
             }
@@ -174,6 +208,13 @@ public class TileEntityPiston extends TileEntity
         this.storedOrientation = par1NBTTagCompound.getInteger("facing");
         this.lastProgress = this.progress = par1NBTTagCompound.getFloat("progress");
         this.extending = par1NBTTagCompound.getBoolean("extending");
+
+        // FCMOD: Added
+        if ( par1NBTTagCompound.hasKey( "fcShovel" ) )
+        {
+        	m_bShoveledBlock = par1NBTTagCompound.getBoolean( "fcShovel" );
+        }
+        // END FCMOD        
     }
 
     /**
@@ -187,5 +228,238 @@ public class TileEntityPiston extends TileEntity
         par1NBTTagCompound.setInteger("facing", this.storedOrientation);
         par1NBTTagCompound.setFloat("progress", this.lastProgress);
         par1NBTTagCompound.setBoolean("extending", this.extending);
+        
+        // FCMOD: Added
+        par1NBTTagCompound.setBoolean( "fcShovel", m_bShoveledBlock );
+        // END FCMOD        
+    }
+    
+    // FCMOD: Added
+    private void AttemptToPackItems()
+    {
+    	if ( !worldObj.isRemote && isExtending() && ( storedBlockID == Block.pistonExtension.blockID || Block.isNormalCube( storedBlockID ) || storedBlockID == Block.glass.blockID ) )
+    	{
+	    	FCUtilsBlockPos targetPos = new FCUtilsBlockPos( xCoord, yCoord, zCoord, storedOrientation );
+	    	
+	    	if ( IsLocationSuitableForPacking( targetPos.i, targetPos.j, targetPos.k, Block.GetOppositeFacing( storedOrientation ) ) )
+			{
+	    		AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB((double)targetPos.i, (double)targetPos.j, (double)targetPos.k, 
+	    			(double)targetPos.i + 1D, (double)targetPos.j + 1D, (double)targetPos.k + 1D );
+	    		
+	    		List itemsWithinBox = worldObj.getEntitiesWithinAABB( EntityItem.class, targetBox );
+	    		
+	    		if ( !itemsWithinBox.isEmpty() )
+	    		{
+	                Iterator itemIterator = itemsWithinBox.iterator();
+	
+	                while ( itemIterator.hasNext() )
+	                {
+	        			EntityItem tempItem = (EntityItem)itemIterator.next();
+	        			
+	        			if ( !tempItem.isDead )
+	        			{
+		        			ItemStack tempStack = tempItem.getEntityItem();
+		        			
+		        			if ( IsPackableItem( tempStack ) )
+		        			{
+		        				int iRequiredCount = GetItemCountToPack( tempStack );
+		        				int iCountOfItems = CountItemsOfTypeInList( tempStack, itemsWithinBox );
+		        				
+		        				if ( iCountOfItems >= iRequiredCount )
+		        				{
+		        					RemoveItemsOfTypeFromList( tempStack, iRequiredCount, itemsWithinBox );
+		        					
+		        					CreatePackedBlockOfTypeAtLocation( tempStack, targetPos.i, targetPos.j, targetPos.k );
+		        					
+		        					break;
+		        				}
+		        			}
+	        			}
+	                }
+	    		}
+			}
+    	}
+    }
+    
+    private boolean IsLocationSuitableForPacking( int i, int j, int k, int iPistonDirection )
+	{
+    	if ( worldObj.isAirBlock( i, j, k ) )
+    	{
+	    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
+	    	{
+	    		if ( iTempFacing != iPistonDirection )
+	    		{
+	    			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iTempFacing );
+	    			
+	    			if ( !IsBlockSuitableForPackingToFacing ( tempPos.i, tempPos.j, tempPos.k, Block.GetOppositeFacing( iTempFacing ) ) )
+    				{
+	    				return false;
+    				}
+	    				
+	    		}
+	    	}
+	    	
+	    	return true;
+    	}
+    	
+    	return false;
+	}
+    
+    private boolean IsBlockSuitableForPackingToFacing( int i, int j, int k, int iFacing )
+    {
+    	Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
+    	
+    	if ( block != null )
+    	{
+    		return block.CanContainPistonPackingToFacing( worldObj, i, j, k, iFacing );
+    	}
+    	
+    	return false;    	
+    }
+    
+    private boolean IsPackableItem( ItemStack stack )
+    {
+    	return stack.getItem().IsPistonPackable( stack );    	
+    }
+    
+    private int GetItemCountToPack( ItemStack stack )
+    {
+    	return stack.getItem().GetRequiredItemCountToPistonPack( stack );
+    }
+    
+    private void CreatePackedBlockOfTypeAtLocation( ItemStack stack, int i, int j, int k )
+    {
+    	int iBlockID = stack.getItem().GetResultingBlockIDOnPistonPack( stack );;
+    	int iBlockMetadata = stack.getItem().GetResultingBlockMetadataOnPistonPack( stack );
+    	
+    	worldObj.setBlockAndMetadataWithNotify( i, j, k, iBlockID, iBlockMetadata );
+    	
+        worldObj.playAuxSFX( FCBetterThanWolves.m_iBlockPlaceAuxFXID, i, j, k, iBlockID );                            
+    }
+    
+    private int CountItemsOfTypeInList( ItemStack stack, List list )
+    {
+        Iterator itemIterator = list.iterator();
+        int iCount = 0;
+
+        while ( itemIterator.hasNext() )
+        {
+			EntityItem tempItem = (EntityItem)itemIterator.next();
+			
+			if ( !tempItem.isDead )
+			{
+				ItemStack tempStack = tempItem.getEntityItem();
+				
+				if ( tempStack.itemID == stack.itemID )
+				{
+					iCount += tempStack.stackSize;
+				}
+			}
+        }
+        
+        return iCount;
+    }
+    
+    private void RemoveItemsOfTypeFromList( ItemStack stack, int iCount, List list )
+    {
+        Iterator itemIterator = list.iterator();
+
+        while ( itemIterator.hasNext() )
+        {
+			EntityItem tempItem = (EntityItem)itemIterator.next();
+			
+			if ( !tempItem.isDead )
+			{
+				ItemStack tempStack = tempItem.getEntityItem();
+				
+				if ( tempStack.itemID == stack.itemID )
+				{
+					if ( tempStack.stackSize > iCount )
+					{
+						tempStack.stackSize -= iCount;
+						
+						break;
+					}
+					else
+					{
+						iCount -= tempStack.stackSize;
+						
+						tempStack.stackSize = 0;
+						
+						tempItem.setDead();
+						
+						if ( iCount <= 0 )
+						{
+							break;
+						}
+					}
+				}
+			}
+        }
+        
+    }
+    
+    private boolean DestroyAndDropIfShoveled()
+    {
+    	if ( m_bShoveledBlock )
+    	{
+            Block tempBlock = Block.blocksList[storedBlockID];
+            
+            if ( tempBlock != null && !worldObj.isRemote )
+            {
+            	ItemStack tempStack = null;
+            	
+	        	if ( tempBlock.canSilkHarvest( storedMetadata ) )
+	        	{
+	                tempStack = tempBlock.createStackedBlock( storedMetadata );
+	        	}
+	            else
+	            {
+	            	tempStack = new ItemStack( tempBlock.idDropped( storedMetadata, worldObj.rand, 0 ), 
+	            		tempBlock.quantityDropped( worldObj.rand ), tempBlock.damageDropped( storedMetadata ) );
+	            }
+	        	
+	        	if ( tempStack != null )
+	        	{
+	        		EjectStackOnShoveled( tempStack );
+	        	}
+            }
+        	
+            worldObj.setBlockToAir( xCoord, yCoord, zCoord );
+            worldObj.notifyBlockOfNeighborChange( xCoord, yCoord, zCoord, storedBlockID );
+            
+            return true;
+    	}
+    	
+    	return false;
+    }
+    
+    private void EjectStackOnShoveled( ItemStack stack )
+    {
+    	FCUtilsBlockPos sourcePos = new FCUtilsBlockPos( xCoord, yCoord, zCoord, Block.GetOppositeFacing( storedOrientation ) );
+    	
+    	FCUtilsItem.EjectStackFromBlockTowardsFacing( worldObj, sourcePos.i, sourcePos.j, sourcePos.k, stack, storedOrientation ); 
+    }    
+    
+    private void PreBlockPlaced()
+    {
+        Block tempBlock = Block.blocksList[storedBlockID];
+        
+        if ( tempBlock != null && !worldObj.isRemote )
+        {
+	    	storedMetadata = tempBlock.OnPreBlockPlacedByPiston( worldObj, xCoord, yCoord, zCoord, 
+	    		storedMetadata, GetDirectionMoving() );
+        }
+    }
+    
+    private int GetDirectionMoving()
+    {
+    	if ( !extending )
+    	{
+    		return Block.GetOppositeFacing( storedOrientation );
+    	}
+    	
+		return storedOrientation;
     }
+    // END FCMOD    
 }
diff --git a/minecraft_server/net/minecraft/src/TileEntitySkull.java b/minecraft_server/net/minecraft/src/TileEntitySkull.java
index 3736efe..52c7c82 100644
--- a/minecraft_server/net/minecraft/src/TileEntitySkull.java
+++ b/minecraft_server/net/minecraft/src/TileEntitySkull.java
@@ -79,4 +79,11 @@ public class TileEntitySkull extends TileEntity
     {
         return this.extraType;
     }
+    
+    // FCMOD: Code added
+    public int GetSkullRotationServerSafe()
+    {
+    	return this.skullRotation;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Vec3.java b/minecraft_server/net/minecraft/src/Vec3.java
index 9183b3d..515c88f 100644
--- a/minecraft_server/net/minecraft/src/Vec3.java
+++ b/minecraft_server/net/minecraft/src/Vec3.java
@@ -60,6 +60,13 @@ public class Vec3
         return this;
     }
 
+    // FCMOD: Added (server only) to duplicate client functionality
+    public Vec3 subtract(Vec3 par1Vec3)
+    {
+        return this.myVec3LocalPool.getVecFromPool(par1Vec3.xCoord - this.xCoord, par1Vec3.yCoord - this.yCoord, par1Vec3.zCoord - this.zCoord);
+    }    
+    // END FCMOD
+    
     /**
      * Normalizes the vector to a length of 1 (except if it is the zero vector)
      */
@@ -74,6 +81,13 @@ public class Vec3
         return this.xCoord * par1Vec3.xCoord + this.yCoord * par1Vec3.yCoord + this.zCoord * par1Vec3.zCoord;
     }
 
+    // FCMOD: Added (server only) to duplicate client functionality
+    public Vec3 crossProduct(Vec3 par1Vec3)
+    {
+        return this.myVec3LocalPool.getVecFromPool(this.yCoord * par1Vec3.zCoord - this.zCoord * par1Vec3.yCoord, this.zCoord * par1Vec3.xCoord - this.xCoord * par1Vec3.zCoord, this.xCoord * par1Vec3.yCoord - this.yCoord * par1Vec3.xCoord);
+    }
+    // END FCMOD
+    
     /**
      * Adds the specified x,y,z vector components to this vector and returns the resulting vector. Does not change this
      * vector.
@@ -221,4 +235,184 @@ public class Vec3
         this.yCoord = var6;
         this.zCoord = var8;
     }
+    
+    // FCMOD: Added
+    public static Vec3 createVectorHelper( Vec3 copyVector )
+    {
+        return new Vec3( fakePool, copyVector.xCoord, copyVector.yCoord, copyVector.zCoord );
+    }
+    
+	/**
+	 * Yaws the vector around the J axis. Assumes that initial facing is along the negative K axis (facing 2)
+	 */
+	public void RotateAsBlockPosAroundJToFacing( int iFacing )
+    {
+		if ( iFacing > 2 )
+		{
+	    	if ( iFacing == 5 ) // i + 1
+	    	{
+	    		double tempZ = xCoord;
+	    		
+	    		xCoord = 1D - zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else if ( iFacing == 4 ) // i - 1
+	    	{
+	    		double tempZ = 1D - xCoord;
+	    		
+	    		xCoord = zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else // if ( iFacing == 3 ) // k + 1
+	    	{
+	    		xCoord = 1D - xCoord;
+	    		zCoord = 1D - zCoord;
+	    	}
+		}    	
+    }
+	
+	/**
+	 * Yaws the vector around the J axis. Assumes that initial facing is along the negative K axis (facing 2)
+	 */
+	public void RotateAsVectorAroundJToFacing( int iFacing )
+    {
+		if ( iFacing > 2 )
+		{
+	    	if ( iFacing == 5 ) // i + 1
+	    	{
+	    		double tempZ = xCoord;
+	    		
+	    		xCoord = -zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else if ( iFacing == 4 ) // i - 1
+	    	{
+	    		double tempZ = -xCoord;
+	    		
+	    		xCoord = zCoord;
+	    		zCoord = tempZ;
+	    	}
+	    	else // if ( iFacing == 3 ) // k + 1
+	    	{
+	    		xCoord = -xCoord;
+	    		zCoord = -zCoord;
+	    	}
+		}    	
+    }
+	
+	/**
+	 * "Tilts" the vector towards the desired facingas if it's a local coordinate internal to a block.  Takes the up vector and either yaws or rolls it towards the specified axis.
+	 */	
+	public void TiltAsBlockPosToFacingAlongJ( int iFacing )
+	{
+		if ( iFacing == 0 ) // j - 1
+		{
+			// rotating around k axis here to point downwards
+			
+			yCoord = 1D - yCoord;
+			xCoord = 1D - xCoord;
+		}
+		else if ( iFacing == 2 ) // k - 1
+		{
+			double tempZ = 1D - yCoord;
+			
+			yCoord = zCoord;
+			zCoord = tempZ;
+		}			
+		else if ( iFacing == 3 ) // k + 1
+		{
+			double tempZ = yCoord;
+			
+			yCoord = 1D - zCoord;
+			zCoord = tempZ;
+		}
+		else if ( iFacing == 4 ) // i - 1
+		{
+			double tempY = xCoord;
+			
+			xCoord = 1D - yCoord;
+			yCoord = tempY;
+		}			
+		else if ( iFacing == 5 ) // i + 1
+		{
+			double tempY = 1D - xCoord;
+			
+			xCoord = yCoord;
+			yCoord = tempY;
+		}			
+	}
+	
+	/**
+	 * "Tilts" the vector towards the desired facing as if it's a local coordinate internal to a block.  Takes the up vector and either yaws or rolls it towards the specified axis.
+	 */	
+	public void TiltAsVectorToFacingAlongJ( int iFacing )
+	{
+		if ( iFacing == 0 ) // j - 1
+		{
+			// rotating around k axis here to point downwards
+			
+			yCoord = -yCoord;
+			xCoord = -xCoord;
+		}
+		else if ( iFacing == 2 ) // k - 1
+		{
+			double tempZ = -yCoord;
+			
+			yCoord = zCoord;
+			zCoord = tempZ;
+		}			
+		else if ( iFacing == 3 ) // k + 1
+		{
+			double tempZ = yCoord;
+			
+			yCoord = -zCoord;
+			zCoord = tempZ;
+		}
+		else if ( iFacing == 4 ) // i - 1
+		{
+			double tempY = xCoord;
+			
+			xCoord = -yCoord;
+			yCoord = tempY;
+		}			
+		else if ( iFacing == 5 ) // i + 1
+		{
+			double tempY = -xCoord;
+			
+			xCoord = yCoord;
+			yCoord = tempY;
+		}			
+	}
+	
+	/**
+	 * Alternate name for clarity
+	 */
+    public final Vec3 SubtractFrom( Vec3 vec )
+    {
+    	return subtract( vec );    	
+    }
+    
+    public Vec3 AddVector( Vec3 vec )
+    {
+        return myVec3LocalPool.getVecFromPool( xCoord + vec.xCoord, yCoord + vec.yCoord, zCoord + vec.zCoord );
+    }
+    
+    public void Scale( double dScale )
+    {
+    	xCoord *= dScale;
+    	yCoord *= dScale;
+    	zCoord *= dScale;
+    }
+    
+    /**
+     * Only considers the x and z components
+     */
+    public double DistanceSquareFlat( Vec3 toVec )
+    {
+        double dDeltaX = toVec.xCoord - xCoord;
+        double dDeltaZ = toVec.zCoord - zCoord;
+        
+        return dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/Village.java b/minecraft_server/net/minecraft/src/Village.java
index 6021b76..5885b55 100644
--- a/minecraft_server/net/minecraft/src/Village.java
+++ b/minecraft_server/net/minecraft/src/Village.java
@@ -64,6 +64,8 @@ public class Village
             this.updateNumIronGolems();
         }
 
+        // FCMOD: Code removed to get rid of spawning of iron golems
+        /*
         int var2 = this.numVillagers / 10;
 
         if (this.numIronGolems < var2 && this.villageDoorInfoList.size() > 20 && this.worldObj.rand.nextInt(7000) == 0)
@@ -78,6 +80,8 @@ public class Village
                 ++this.numIronGolems;
             }
         }
+        */
+        // END FCMOD
     }
 
     /**
@@ -391,6 +395,14 @@ public class Village
                 var4.resetDoorOpeningRestrictionCounter();
             }
 
+            // FCMOD: Added to prevent unintentionally loading chunks
+            if ( !worldObj.chunkExists( var4.posX >> 4, var4.posZ >> 4 ) )
+            {
+            	continue;
+            	
+            }
+            // END FCMOD
+
             if (!this.isBlockDoor(var4.posX, var4.posY, var4.posZ) || Math.abs(this.tickCounter - var4.lastActivityTimestamp) > 1200)
             {
                 this.centerHelper.posX -= var4.posX;
@@ -411,7 +423,11 @@ public class Village
     private boolean isBlockDoor(int par1, int par2, int par3)
     {
         int var4 = this.worldObj.getBlockId(par1, par2, par3);
-        return var4 <= 0 ? false : var4 == Block.doorWood.blockID;
+        
+        // FCMOD: Changed
+        //return var4 <= 0 ? false : var4 == Block.doorWood.blockID;
+        return var4 <= 0 ? false : ( var4 == Block.doorWood.blockID || var4 == FCBetterThanWolves.fcBlockDoorWood.blockID );
+    	// END FCMOD
     }
 
     private void updateVillageRadiusAndCenter()
diff --git a/minecraft_server/net/minecraft/src/VillageCollection.java b/minecraft_server/net/minecraft/src/VillageCollection.java
index d3d37ac..2ee9f45 100644
--- a/minecraft_server/net/minecraft/src/VillageCollection.java
+++ b/minecraft_server/net/minecraft/src/VillageCollection.java
@@ -329,7 +329,11 @@ public class VillageCollection extends WorldSavedData
     private boolean isWoodenDoorAt(int par1, int par2, int par3)
     {
         int var4 = this.worldObj.getBlockId(par1, par2, par3);
-        return var4 == Block.doorWood.blockID;
+        
+        // FCMOD: Changed
+        //return var4 == Block.doorWood.blockID;
+        return var4 == Block.doorWood.blockID || var4 == FCBetterThanWolves.fcBlockDoorWood.blockID;
+        // END FCMOD
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/World.java b/minecraft_server/net/minecraft/src/World.java
index 212a769..8efb118 100644
--- a/minecraft_server/net/minecraft/src/World.java
+++ b/minecraft_server/net/minecraft/src/World.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
@@ -9,6 +10,10 @@ import java.util.List;
 import java.util.Random;
 import java.util.Set;
 
+//FCMOD: Added
+import java.util.LinkedList;
+// END FCMOD
+
 public abstract class World implements IBlockAccess
 {
     /**
@@ -85,7 +90,9 @@ public abstract class World implements IBlockAccess
     public boolean findingSpawnPoint;
     public MapStorage mapStorage;
     public final VillageCollection villageCollectionObj;
-    protected final VillageSiege villageSiegeObj = new VillageSiege(this);
+    // FCMOD: Removed
+    //protected final VillageSiege villageSiegeObj = new VillageSiege(this);
+    // END FCMOD
     public final Profiler theProfiler;
 
     /** The world-local pool of vectors */
@@ -105,7 +112,22 @@ public abstract class World implements IBlockAccess
     protected boolean spawnPeacefulMobs = true;
 
     /** populated by chunks that are within 9 chunks of any player */
-    protected Set activeChunkSet = new HashSet();
+    // FCMOD: Changed to use same type as ChunkProviderServer.loadedChunkHashMap, to avoid
+    // duplicate hash values.  Renamed as new type requires existing references to be adapated
+    // appropriately.
+    //protected Set activeChunkSet = new HashSet();
+    /** 
+     * populated by chunks that are within the view distance (default 8 chunks) of any player,
+     * the original spawn, or any other chunk loader
+     */
+    protected LongHashMap m_activeChunksCoordsMap = new LongHashMap();
+    
+    /** 
+     * list of same coords in m_activeChunksCoordsMap
+     */
+    protected LinkedList<ChunkCoordIntPair> m_activeChunksCoordsList = 
+    	new LinkedList<ChunkCoordIntPair>(); 
+    // END FCMOD
 
     /** number of ticks until the next random ambients play */
     private int ambientTickCountdown;
@@ -146,6 +168,11 @@ public abstract class World implements IBlockAccess
 
     public World(ISaveHandler par1ISaveHandler, String par2Str, WorldSettings par3WorldSettings, WorldProvider par4WorldProvider, Profiler par5Profiler, ILogAgent par6ILogAgent)
     {
+        // FCMOD: Added
+    	// function tests internally to make sure this only occurs once
+        FCAddOnHandler.InitializeMods(); 
+        // END FCMOD
+    	
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.lightUpdateBlockList = new int[32768];
         this.isRemote = false;
@@ -293,7 +320,14 @@ public abstract class World implements IBlockAccess
      */
     public boolean isAirBlock(int par1, int par2, int par3)
     {
+    	// FCMOD: Change
+		/*
         return this.getBlockId(par1, par2, par3) == 0;
+		*/
+    	int iBlockID = getBlockId(par1, par2, par3);
+    	
+        return iBlockID == 0 || Block.blocksList[iBlockID].IsAirBlock(); 
+        // END FCMOD
     }
 
     /**
@@ -390,6 +424,10 @@ public abstract class World implements IBlockAccess
      * cause a block update. Flag 2 will send the change to clients (you almost always want this). Flag 4 prevents the
      * block from being re-rendered, if this is a client world. Flags can be added together.
      */
+    /**
+     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
     public boolean setBlock(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -487,6 +525,10 @@ public abstract class World implements IBlockAccess
      * Sets the blocks metadata and if set will then notify blocks that this block changed, depending on the flag. Args:
      * x, y, z, metadata, flag. See setBlock for flag description
      */
+    /**
+     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
     public boolean setBlockMetadata(int par1, int par2, int par3, int par4, int par5)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -987,6 +1029,8 @@ public abstract class World implements IBlockAccess
         return this.rayTraceBlocks_do_do(par1Vec3, par2Vec3, par3, false);
     }
 
+    // FCMOD: Code removed and replaced later
+    /*
     public MovingObjectPosition rayTraceBlocks_do_do(Vec3 par1Vec3, Vec3 par2Vec3, boolean par3, boolean par4)
     {
         if (!Double.isNaN(par1Vec3.xCoord) && !Double.isNaN(par1Vec3.yCoord) && !Double.isNaN(par1Vec3.zCoord))
@@ -1196,6 +1240,8 @@ public abstract class World implements IBlockAccess
             return null;
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Plays a sound at the entity's position. Args: entity, sound, volume (relative to 1.0), and frequency (or pitch,
@@ -1279,15 +1325,53 @@ public abstract class World implements IBlockAccess
     }
 
     /**
-     * Called when an entity is spawned in the world. This includes players.
-     */
-    public boolean spawnEntityInWorld(Entity par1Entity)
-    {
-        int var2 = MathHelper.floor_double(par1Entity.posX / 16.0D);
-        int var3 = MathHelper.floor_double(par1Entity.posZ / 16.0D);
-        boolean var4 = par1Entity.field_98038_p;
-
-        if (par1Entity instanceof EntityPlayer)
+     * Called to place all entities as part of a world
+     */
+    public boolean spawnEntityInWorld(Entity entity) {
+    	return this.spawnEntityInWorld(entity, false);
+    }
+    
+    private boolean spawnEntityInWorld(Entity entity, boolean hasItemBeenReplaced) {
+    	if (entity instanceof EntityItem && !hasItemBeenReplaced && !this.isRemote) {
+    		EntityItem oldEntity = (EntityItem) entity;
+    		Item item = oldEntity.getEntityItem().getItem();
+    		
+    		if (item.hasCustomItemEntity()) {
+				EntityItem newEntity = item.createItemAsEntityInWorld(this, entity.posX, entity.posY, entity.posZ, oldEntity.getEntityItem());
+				
+    			if (newEntity == null) {
+    				Class entityItem = item.getCustomItemEntity();
+    				
+    				try {
+						newEntity = (EntityItem) entityItem.getConstructor(World.class, double.class, double.class, double.class, ItemStack.class).newInstance(this, entity.posX, entity.posY, entity.posZ, item);
+					} catch (InstantiationException e) {
+						e.printStackTrace();
+					} catch (IllegalAccessException e) {
+						e.printStackTrace();
+					} catch (IllegalArgumentException e) {
+						e.printStackTrace();
+					} catch (InvocationTargetException e) {
+						e.printStackTrace();
+					} catch (NoSuchMethodException e) {
+						e.printStackTrace();
+					} catch (SecurityException e) {
+						e.printStackTrace();
+					}
+    			}
+    			
+    			newEntity.motionX = oldEntity.motionX;
+    			newEntity.motionY = oldEntity.motionY;
+    			newEntity.motionZ = oldEntity.motionZ;
+    			
+    			this.spawnEntityInWorld(newEntity, true);
+    		}
+    	}
+    	
+        int var2 = MathHelper.floor_double(entity.posX / 16.0D);
+        int var3 = MathHelper.floor_double(entity.posZ / 16.0D);
+        boolean var4 = entity.field_98038_p;
+
+        if (entity instanceof EntityPlayer)
         {
             var4 = true;
         }
@@ -1298,16 +1382,16 @@ public abstract class World implements IBlockAccess
         }
         else
         {
-            if (par1Entity instanceof EntityPlayer)
+            if (entity instanceof EntityPlayer)
             {
-                EntityPlayer var5 = (EntityPlayer)par1Entity;
+                EntityPlayer var5 = (EntityPlayer)entity;
                 this.playerEntities.add(var5);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            this.getChunkFromChunkCoords(var2, var3).addEntity(par1Entity);
-            this.loadedEntityList.add(par1Entity);
-            this.obtainEntitySkin(par1Entity);
+            this.getChunkFromChunkCoords(var2, var3).addEntity(entity);
+            this.loadedEntityList.add(entity);
+            this.obtainEntitySkin(entity);
             return true;
         }
     }
@@ -1425,18 +1509,29 @@ public abstract class World implements IBlockAccess
         }
 
         double var14 = 0.25D;
-        List var15 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
-
-        for (int var16 = 0; var16 < var15.size(); ++var16)
-        {
-            AxisAlignedBB var13 = ((Entity)var15.get(var16)).getBoundingBox();
+        // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
+		/*
+        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
+		*/
+        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, 2.0, var14));
+        // END FCMOD
+
+        for (int var15 = 0; var15 < var16.size(); ++var15)
+        {
+        	// FCMOD: Code added
+        	if ( !par1Entity.CanCollideWithEntity( (Entity)var16.get( var15 ) ) )
+        	{
+        		continue;
+        	}
+        	// END FCMOD
+            AxisAlignedBB var13 = ((Entity)var16.get(var15)).getBoundingBox();
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
             {
                 this.collidingBoundingBoxes.add(var13);
             }
 
-            var13 = par1Entity.getCollisionBox((Entity)var15.get(var16));
+            var13 = par1Entity.getCollisionBox((Entity)var16.get(var15));
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
             {
@@ -1536,9 +1631,10 @@ public abstract class World implements IBlockAccess
     {
         return this.getChunkFromBlockCoords(par1, par2).getPrecipitationHeight(par1 & 15, par2 & 15);
     }
-
+    
     /**
      * Finds the highest block on the x, z coordinate that is solid and returns its y coord. Args x, z
+     * FCNOTE: Despite name, actually returns the block ABOVE the top one, and does not count liquids
      */
     public int getTopSolidOrLiquidBlock(int par1, int par2)
     {
@@ -1638,6 +1734,21 @@ public abstract class World implements IBlockAccess
         }
 
         this.unloadedEntityList.clear();
+        // FCMOD: Code added to prevent jerkiness when one entity pushes another (like on Platforms)
+        for (int l = 0; l < loadedEntityList.size(); l++)
+        {
+            Entity tempEntity = (Entity)loadedEntityList.get(l);
+            
+            if (!tempEntity.isDead)
+            {
+            	tempEntity.lastTickPosX = tempEntity.posX;
+            	tempEntity.lastTickPosY = tempEntity.posY;
+            	tempEntity.lastTickPosZ = tempEntity.posZ;        
+            	tempEntity.prevRotationYaw = tempEntity.rotationYaw;
+            	tempEntity.prevRotationPitch = tempEntity.rotationPitch;
+            }
+        }        
+        // END FCMOD
         this.theProfiler.endStartSection("regular");
 
         for (var1 = 0; var1 < this.loadedEntityList.size(); ++var1)
@@ -1700,7 +1811,12 @@ public abstract class World implements IBlockAccess
         {
             TileEntity var9 = (TileEntity)var14.next();
 
-            if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
+        	// FCCHUNK: Decide on updates around original spawn
+            // FCMOD: Changed
+            //if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
+            if ( !var9.isInvalid() && var9.func_70309_m() && 
+            	IsBlockPosActive( var9.xCoord, var9.yCoord, var9.zCoord ) )            	            	
+        	// END FCMOD
             {
                 try
                 {
@@ -1798,20 +1914,33 @@ public abstract class World implements IBlockAccess
     /**
      * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
      * Args: entity, forceUpdate
+     * FCNOTE: 2nd parameter is more "bOnlyUpdateInLoadedChunks" rather than what is said above
+     * The "OptionalForce" in the function name refers to forcing the update, not a physical force
      */
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
         int var3 = MathHelper.floor_double(par1Entity.posX);
         int var4 = MathHelper.floor_double(par1Entity.posZ);
-        byte var5 = 32;
-
-        if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
-        {
+        // FCMOD: Changed
+        //byte var5 = 32;
+        int var5 = m_iLoadedChunksUpdateRange;
+        // END FCMOD
+
+    	// FCCHUNK: Decide on updates around original spawn
+        // FCMOD: Changed
+        //if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
+        if ( !par2 || IsBlockPosActive( var3, 0, var4 ) )
+        	// END FCMOD
+        {
+            // FCMOD: Removed and moved to a pre-update loop elsewhere in this file
+            /*
             par1Entity.lastTickPosX = par1Entity.posX;
             par1Entity.lastTickPosY = par1Entity.posY;
             par1Entity.lastTickPosZ = par1Entity.posZ;
             par1Entity.prevRotationYaw = par1Entity.rotationYaw;
             par1Entity.prevRotationPitch = par1Entity.rotationPitch;
+		    */
+		    // END FCMOD
 
             if (par2 && par1Entity.addedToChunk)
             {
@@ -2015,8 +2144,15 @@ public abstract class World implements IBlockAccess
     /**
      * Returns whether or not the given bounding box is on fire or not
      */
-    public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    // FCMOD: Changed
+    //public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    public boolean isBoundingBoxBurning( Entity entity )
+    // END FCMOD
     {
+    	// FCMOD: Added
+    	AxisAlignedBB par1AxisAlignedBB = entity.boundingBox.contract(0.001D, 0.001D, 0.001D);
+    	// END FCMOD
+    	
         int var2 = MathHelper.floor_double(par1AxisAlignedBB.minX);
         int var3 = MathHelper.floor_double(par1AxisAlignedBB.maxX + 1.0D);
         int var4 = MathHelper.floor_double(par1AxisAlignedBB.minY);
@@ -2032,9 +2168,16 @@ public abstract class World implements IBlockAccess
                 {
                     for (int var10 = var6; var10 < var7; ++var10)
                     {
+                        // FCMOD: Changed
+						/*
                         int var11 = this.getBlockId(var8, var9, var10);
 
                         if (var11 == Block.fire.blockID || var11 == Block.lavaMoving.blockID || var11 == Block.lavaStill.blockID)
+                        */
+                        Block block = Block.blocksList[getBlockId(var8, var9, var10)];
+                        
+                        if ( block != null && block.GetDoesFireDamageToEntities( this, var8, var9, var10, entity ) )
+                    	// END FCMOD
                         {
                             return true;
                         }
@@ -2268,7 +2411,12 @@ public abstract class World implements IBlockAccess
 
         if (this.getBlockId(par2, par3, par4) == Block.fire.blockID)
         {
+        	// FCMOD: Code change to fix fizz effect
+        	/*
             this.playAuxSFXAtEntity(par1EntityPlayer, 1004, par2, par3, par4, 0);
+            */
+            playAuxSFX( 1004, par2, par3, par4, 0);
+            // END FCMOD
             this.setBlockToAir(par2, par3, par4);
             return true;
         }
@@ -2426,7 +2574,19 @@ public abstract class World implements IBlockAccess
      */
     public boolean isBlockNormalCube(int par1, int par2, int par3)
     {
-        return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+    	// FCMOD: Changed
+        //return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+    	int iBlockID = getBlockId( par1, par2, par3 );
+
+        Block block = Block.blocksList[iBlockID];
+
+        if( block != null)
+        {
+			return block.IsNormalCube( this, par1, par2, par3 );
+        }
+        
+        return false;
+        // END FCMOD
     }
 
     public boolean func_85174_u(int par1, int par2, int par3)
@@ -2447,20 +2607,28 @@ public abstract class World implements IBlockAccess
     /**
      * Returns true if the block at the given coordinate has a solid (buildable) top surface.
      */
+    // FCMOD: Removed (replaced later)
+    /*
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
         Block var4 = Block.blocksList[this.getBlockId(par1, par2, par3)];
         return this.isBlockTopFacingSurfaceSolid(var4, this.getBlockMetadata(par1, par2, par3));
     }
+    */
+    // END FCMOD
 
     /**
      * Performs check to see if the block is a normal, solid block, or if the metadata of the block indicates that its
      * facing puts its solid side upwards. (inverted stairs, for example)
      */
+    // FCMOD: Removed (deprecated)
+    /*
     public boolean isBlockTopFacingSurfaceSolid(Block par1Block, int par2)
     {
         return par1Block == null ? false : (par1Block.blockMaterial.isOpaque() && par1Block.renderAsNormalBlock() ? true : (par1Block instanceof BlockStairs ? (par2 & 4) == 4 : (par1Block instanceof BlockHalfSlab ? (par2 & 8) == 8 : (par1Block instanceof BlockHopper ? true : (par1Block instanceof BlockSnow ? (par2 & 7) == 7 : false)))));
     }
+    */
+    // END FCMOD
 
     /**
      * Checks if the block is a solid, normal cube. If the chunk does not exist, or is not loaded, it returns the
@@ -2475,7 +2643,12 @@ public abstract class World implements IBlockAccess
             if (var5 != null && !var5.isEmpty())
             {
                 Block var6 = Block.blocksList[this.getBlockId(par1, par2, par3)];
+                // FCMOD: Change so that torches will stick to the appropriate blocks
+                /*
                 return var6 == null ? false : var6.blockMaterial.isOpaque() && var6.renderAsNormalBlock();
+                */
+                return ( var6 != null && isBlockNormalCube( par1, par2, par3 ) );
+                // END FCMOD                
             }
             else
             {
@@ -2506,7 +2679,12 @@ public abstract class World implements IBlockAccess
      */
     public void setAllowedSpawnTypes(boolean par1, boolean par2)
     {
+    	// FCMOD: Code change to remove peaceful difficulty.  If animals can spawn, then so can mobs
+    	/*
         this.spawnHostileMobs = par1;
+        */
+        this.spawnHostileMobs = par2;
+    	// END FCMOD
         this.spawnPeacefulMobs = par2;
     }
 
@@ -2515,7 +2693,15 @@ public abstract class World implements IBlockAccess
      */
     public void tick()
     {
+    	// FCMOD: Added
+    	UpdateActiveChunkMap();
+    	// END FCMOD
+    	
         this.updateWeather();
+        
+        // FCMOD: Added
+        ModSpecificTick();
+        // END FCMOD
     }
 
     /**
@@ -2537,6 +2723,8 @@ public abstract class World implements IBlockAccess
     /**
      * Updates all weather states.
      */
+    // FCMOD: Code removed and replaced later
+    /*
     protected void updateWeather()
     {
         if (!this.provider.hasNoSky)
@@ -2632,6 +2820,8 @@ public abstract class World implements IBlockAccess
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * start precipitation in this world (2 ticks after command posted)
@@ -2643,6 +2833,8 @@ public abstract class World implements IBlockAccess
 
     protected void setActivePlayerChunksAndCheckLight()
     {
+    	// FCMOD: Changed with active chunk functionality replaced elsewhere
+    	/*
         this.activeChunkSet.clear();
         this.theProfiler.startSection("buildList");
         int var1;
@@ -2667,6 +2859,12 @@ public abstract class World implements IBlockAccess
         }
 
         this.theProfiler.endSection();
+        */
+        int var1;
+        EntityPlayer var2;
+        int var3;
+        int var4;    	
+    	// END FCMOD
 
         if (this.ambientTickCountdown > 0)
         {
@@ -2819,10 +3017,16 @@ public abstract class World implements IBlockAccess
         {
             if (par2 >= 0 && par2 < 256 && this.getSavedLightValue(EnumSkyBlock.Block, par1, par2, par3) < 10)
             {
+                // FCMOD: Code change
+                /*
                 int var6 = this.getBlockId(par1, par2 - 1, par3);
                 int var7 = this.getBlockId(par1, par2, par3);
 
                 if (var7 == 0 && Block.snow.canPlaceBlockAt(this, par1, par2, par3) && var6 != 0 && var6 != Block.ice.blockID && Block.blocksList[var6].blockMaterial.blocksMovement())
+                */
+                if ( FCBlockSnowCover.CanSnowCoverReplaceBlock( this, par1, par2, par3 ) && 
+                	Block.snow.canPlaceBlockAt( this, par1, par2, par3 ) )
+            	// END FCMOD
                 {
                     return true;
                 }
@@ -2913,8 +3117,8 @@ public abstract class World implements IBlockAccess
             int var13;
             int var14;
             int var15;
-            int var16;
             int var17;
+            int var16;
 
             if (var8 > var7)
             {
@@ -3053,10 +3257,18 @@ public abstract class World implements IBlockAccess
     public List getEntitiesWithinAABBExcludingEntity(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
         ArrayList var4 = new ArrayList();
+        // FCMOD: Change to increased size of box to be able to handle wind mills extending accross chunk boundaries
+        /*
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        */
+        int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
+        int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
+        int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
+        int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
+        // END FCMOD
 
         for (int var9 = var5; var9 <= var6; ++var9)
         {
@@ -3082,10 +3294,18 @@ public abstract class World implements IBlockAccess
 
     public List selectEntitiesWithinAABB(Class par1Class, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
+        // FCMOD: Increased size of box to be able to handle wind mills extending accross chunk boundaries
+    	/*
         int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        */
+        int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
+        int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
+        int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
+        int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
+    	// END FCMOD
         ArrayList var8 = new ArrayList();
 
         for (int var9 = var4; var9 <= var5; ++var9)
@@ -3146,6 +3366,8 @@ public abstract class World implements IBlockAccess
     /**
      * Counts how many entities of an entity class exist in the world. Args: entityClass
      */
+    // FCMOD: Code removed and replaced by custom function later
+    /*
     public int countEntities(Class par1Class)
     {
         int var2 = 0;
@@ -3162,6 +3384,8 @@ public abstract class World implements IBlockAccess
 
         return var2;
     }
+    */
+    // END FCMOD
 
     /**
      * adds entities to the loaded entities list, and loads thier skins.
@@ -3205,7 +3429,14 @@ public abstract class World implements IBlockAccess
         }
         else
         {
+            // FCMOD: Change
+    		/*
             if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable()))
+            */
+            if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable() ||
+            	var10 == FCBetterThanWolves.fcBlockDetectorLogic || var10 == FCBetterThanWolves.fcBlockDetectorGlowingLogic || 
+            	var10 == FCBetterThanWolves.fcBlockFireStoked ) )
+        	// END FCMOD        	
             {
                 var10 = null;
             }
@@ -3332,6 +3563,22 @@ public abstract class World implements IBlockAccess
     {
         if (this.isBlockNormalCube(par1, par2, par3))
         {
+        	// FCMOD: Code added so solid blocks can act as power sources
+            int iBlockID = getBlockId( par1, par2, par3 );
+            
+        	if ( Block.blocksList[iBlockID].canProvidePower() )
+        	{
+        		int iPowerInput = getBlockPowerInput(par1, par2, par3);
+        		int iPowerProvided = Block.blocksList[iBlockID].isProvidingWeakPower(this, par1, par2, par3, par4);
+        		
+        		if ( iPowerInput > iPowerProvided )
+        		{
+        			return iPowerInput;
+        		}
+        		
+        		return iPowerProvided;
+        	}
+        	// END FCMOD
             return this.getBlockPowerInput(par1, par2, par3);
         }
         else
@@ -3607,8 +3854,15 @@ public abstract class World implements IBlockAccess
         return (double)this.getRainStrength(1.0F) > 0.2D;
     }
 
+    /** 
+     * FCNOTE: Terribly named.  Was actually whether a specific block is currently being rained on
+     * Deprecated through sending message to avoid modifying vanilla classes that use it
+     * while still ensuring that it isn't actually called.
+     */
     public boolean canLightningStrikeAt(int par1, int par2, int par3)
     {
+    	// FCMOD: Changed
+    	/*    	 
         if (!this.isRaining())
         {
             return false;
@@ -3626,6 +3880,18 @@ public abstract class World implements IBlockAccess
             BiomeGenBase var4 = this.getBiomeGenForCoords(par1, par3);
             return var4.getEnableSnow() ? false : var4.canSpawnLightningBolt();
         }
+        */
+    	if ( !m_bCanLightningStrikeAtMessageSent )
+    	{
+	    	FCBetterThanWolves.DebugWarning( (new StringBuilder()).
+	    		append( "Deprecated method World.canLightningStrikeAt() called.  " ).
+	    		append( "Use IsRainingAtPos() or CanLightingStrikeAtPos() instead." ).toString() );
+	    	
+	    	m_bCanLightningStrikeAtMessageSent = true;
+    	}
+    	
+    	return IsRainingAtPos( par1, par2, par3 );
+    	// END FCMOD
     }
 
     /**
@@ -3664,6 +3930,10 @@ public abstract class World implements IBlockAccess
         return this.mapStorage.getUniqueDataId(par1Str);
     }
 
+    /**
+     * FCNOTE: Sends an auxSFX to all players, regardless of distance to the effect.
+     * Good for stuff like long range wolf howls and thunder claps.  
+     */
     public void func_82739_e(int par1, int par2, int par3, int par4, int par5)
     {
         for (int var6 = 0; var6 < this.worldAccesses.size(); ++var6)
@@ -3841,4 +4111,1143 @@ public abstract class World implements IBlockAccess
     {
         return this.worldLogAgent;
     }
+
+    // FCMOD: Added New
+    private boolean m_bCanLightningStrikeAtMessageSent = false;
+    
+    private long m_lTimeOfLastSquidPossessionCapCount = -1;
+    private int m_iLastSquidPossessionCapCount = 0;
+    
+    public static final int m_iLoadedChunksUpdateRange = 32;
+
+    static public boolean InstallationIntegrityTest()
+    {
+    	return true;
+    }
+
+    public void ModSpecificTick()
+    {
+    }
+    
+    public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
+    {   
+        return false;
+    }
+    
+    /** 
+     * Wrapper function for clarity: while ticks are being processed they are not still scheduled,
+     * but are in a separate list for this tick.
+     */
+    public boolean IsUpdatePendingThisTickForBlock( int i, int j, int k, int iBlockID )
+    {   
+        return isBlockTickScheduled( i, j, k, iBlockID );
+    }
+    
+    public boolean setBlockAndMetadataWithNotify( int i, int j, int k, int iBlockID, int iMetadata )
+    {
+        return this.setBlock( i, j, k, iBlockID, iMetadata, 3 );
+    }
+
+    public boolean setBlockWithNotify( int i, int j, int k, int iBlockID )
+    {
+        return this.setBlock( i, j, k, iBlockID, 0, 3 );
+    }
+    
+    /**
+	 * Alias to avoid inconsistent naming between client and server
+     * Bit 1 notify neighbors.  Bit 2 sends change to clients.
+     * Bit 4 seems to prevent a render update when called on client
+     */
+    public boolean SetBlockMetadataWithNotify( int i, int j, int k, int iMetadata, int iNotifyBitField )
+    {
+    	// client
+        //return setBlockMetadataWithNotify( i, j, k, iMetadata, iNotifyBitField );
+    	// server
+        return setBlockMetadata( i, j, k, iMetadata, iNotifyBitField );
+    }
+    
+    public boolean setBlockMetadata( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 0 );
+    }
+
+    public boolean setBlockMetadataWithNotify( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 3 );
+    }
+    
+    public boolean setBlockMetadataWithClient( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 2 );
+    }
+    
+    public boolean setBlockMetadataWithNotifyNoClient( int i, int j, int k, int iMetadata )
+    {
+        return this.setBlockMetadata( i, j, k, iMetadata, 1 );
+    }
+    
+    public boolean setBlockAndMetadata( int i, int j, int k, int iBlockID, int iMetadata )
+    {
+        return this.setBlock( i, j, k, iBlockID, iMetadata, 2 );
+    }
+    
+    public boolean isBlockGettingPowered( int i, int j, int k )
+    {
+    	return getBlockPowerInput( i, j, k ) > 0;
+    }
+
+    
+    public MovingObjectPosition rayTraceBlocks_do_do( Vec3 startVec, Vec3 endVec, boolean bHitFluidSources, boolean bIgnoreNonMovementBlockingBlocks )
+    {
+    	// refactored version of vanilla function to try to optimize and correct errors
+    	
+        if ( !Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord) &&
+        	!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord) )
+        {
+        	Vec3 currentVec = getWorldVec3Pool().getVecFromPool( startVec.xCoord, startVec.yCoord, startVec.zCoord );
+        	
+        	double dTotalDeltaX = endVec.xCoord - startVec.xCoord;
+        	double dTotalDeltaY = endVec.yCoord - startVec.yCoord;
+        	double dTotalDeltaZ = endVec.zCoord - startVec.zCoord;
+        	
+            int iEndPosI = MathHelper.floor_double(endVec.xCoord);
+            int iEndPosJ = MathHelper.floor_double(endVec.yCoord);
+            int iEndPosK = MathHelper.floor_double(endVec.zCoord);
+            
+            int iCurrentPosI = MathHelper.floor_double(currentVec.xCoord);
+            int iCurrentPosJ = MathHelper.floor_double(currentVec.yCoord);
+            int iCurrentPosK = MathHelper.floor_double(currentVec.zCoord);
+            
+            double dProportionOfLengthToNextBlockBoundaryX;
+            double dProportionOfLengthToNextBlockBoundaryY;
+            double dProportionOfLengthToNextBlockBoundaryZ;
+            
+        	int iAxisFinishedCount = 0;
+        	
+        	int iIncrementI = -1;
+        	
+        	double dNextBlockBoundaryX = (double)iCurrentPosI;
+        	double dBlockBoundaryIncrementX = -1D; 
+        	
+        	if ( iEndPosI > iCurrentPosI )
+        	{
+        		iIncrementI = 1;
+        		
+            	dNextBlockBoundaryX += 1D;
+            	dBlockBoundaryIncrementX = 1D;                	
+        	}
+        	else if ( iEndPosI == iCurrentPosI )
+        	{
+        		iIncrementI = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+        	int iIncrementJ = -1;
+        	
+        	double dNextBlockBoundaryY = (double)iCurrentPosJ;
+        	double dBlockBoundaryIncrementY = -1D;
+        	
+        	if ( iEndPosJ > iCurrentPosJ )
+        	{
+        		iIncrementJ = 1;
+        		
+            	dNextBlockBoundaryY += 1D;
+            	dBlockBoundaryIncrementY = 1D; 
+        	}
+        	else if ( iEndPosJ == iCurrentPosJ )
+        	{
+        		iIncrementJ = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+        	int iIncrementK = -1;
+        	
+        	double dNextBlockBoundaryZ = (double)iCurrentPosK;
+        	double dBlockBoundaryIncrementZ = -1D;
+        	
+        	if ( iEndPosK > iCurrentPosK )
+        	{
+        		iIncrementK = 1;
+        		
+            	dNextBlockBoundaryZ += 1D;
+            	dBlockBoundaryIncrementZ = 1D; 
+        	}
+        	else if ( iEndPosK == iCurrentPosK )
+        	{
+        		iIncrementK = 0;
+        		
+        		iAxisFinishedCount++;
+        	}
+        	
+            int iTempCount = 200;
+
+            while ( iTempCount-- >= 0 )
+            {                    
+                int iCurrentBlockID = getBlockId( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
+                
+                if ( iCurrentBlockID > 0 )
+                {
+                    Block currentBlock = Block.blocksList[iCurrentBlockID];
+
+	                if ( !bIgnoreNonMovementBlockingBlocks || currentBlock.getCollisionBoundingBoxFromPool(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK ) != null )
+	                {
+	                    int iFirstBlockMetadata = getBlockMetadata( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
+	                    
+	                	if (  currentBlock.canCollideCheck( iFirstBlockMetadata, bHitFluidSources ) )
+	                	{
+		                    MovingObjectPosition collisionPosition = currentBlock.collisionRayTrace(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK, currentVec, endVec);
+		
+		                    if ( collisionPosition != null )
+		                    {
+		                        return collisionPosition;
+		                    }
+	                	}
+	                }
+                }
+
+                if ( iAxisFinishedCount >= 3 )
+                {
+                    return null;
+                }
+                
+                if ( iIncrementI != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryX = ( dNextBlockBoundaryX - currentVec.xCoord ) / dTotalDeltaX;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryX = 999.0D;
+                }
+                
+                
+                if ( iIncrementJ != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryY = ( dNextBlockBoundaryY - currentVec.yCoord ) / dTotalDeltaY;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryY = 999.0D;
+                }
+                
+                
+                if ( iIncrementK != 0 )
+                {
+                    dProportionOfLengthToNextBlockBoundaryZ = ( dNextBlockBoundaryZ - currentVec.zCoord ) / dTotalDeltaZ;                        
+                }
+                else
+                {
+                	dProportionOfLengthToNextBlockBoundaryZ = 999.0D;
+                }
+                
+                if ( dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryY && 
+                	dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryZ )
+                {
+                    currentVec.xCoord = dNextBlockBoundaryX;
+                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryX;
+                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryX;
+                    
+                    iCurrentPosI += iIncrementI;
+                	dNextBlockBoundaryX += dBlockBoundaryIncrementX;
+                    
+                    if ( iCurrentPosI == iEndPosI )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementI = 0;
+                    }
+                    
+                }
+                else if (dProportionOfLengthToNextBlockBoundaryY < dProportionOfLengthToNextBlockBoundaryZ)
+                {
+                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryY;
+                    currentVec.yCoord = dNextBlockBoundaryY;
+                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryY;
+                    
+                    iCurrentPosJ += iIncrementJ;
+                	dNextBlockBoundaryY += dBlockBoundaryIncrementY;
+                    
+                    if ( iCurrentPosJ == iEndPosJ )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementJ = 0;
+                    }                        
+                }
+                else
+                {
+                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryZ;
+                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryZ;
+                    currentVec.zCoord = dNextBlockBoundaryZ;
+                    
+                    iCurrentPosK += iIncrementK;
+                	dNextBlockBoundaryZ += dBlockBoundaryIncrementZ;
+                	
+                    if ( iCurrentPosK == iEndPosK )
+                    {
+                    	iAxisFinishedCount++;
+                    	iIncrementK = 0;
+                    }                        
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    public MovingObjectPosition MouseOverRayTrace( Vec3 startVec, Vec3 endVec )
+    {
+        if (!Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord))
+        {
+            if (!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord))
+            {
+                int iEndI = MathHelper.floor_double(endVec.xCoord);
+                int iEndJ = MathHelper.floor_double(endVec.yCoord);
+                int iEndK = MathHelper.floor_double(endVec.zCoord);
+                int iTempI = MathHelper.floor_double(startVec.xCoord);
+                int iTempJ = MathHelper.floor_double(startVec.yCoord);
+                int iTempK = MathHelper.floor_double(startVec.zCoord);
+                
+                MovingObjectPosition tempCollisionPos = 
+                	CheckLocationForMouseOverRayTrace( iTempI, iTempJ, iTempK,
+            		startVec, endVec );
+                
+                if ( tempCollisionPos != null )
+                {
+                	return tempCollisionPos;
+                }                    
+
+                int iTempCount = 200;
+
+                while (iTempCount-- >= 0)
+                {
+                    if (Double.isNaN(startVec.xCoord) || Double.isNaN(startVec.yCoord) || Double.isNaN(startVec.zCoord))
+                    {
+                        return null;
+                    }
+
+                    if (iTempI == iEndI && iTempJ == iEndJ && iTempK == iEndK)
+                    {
+                        return null;
+                    }
+
+                    boolean var39 = true;
+                    boolean var40 = true;
+                    boolean var41 = true;
+                    double var15 = 999.0D;
+                    double var17 = 999.0D;
+                    double var19 = 999.0D;
+
+                    if (iEndI > iTempI)
+                    {
+                        var15 = (double)iTempI + 1.0D;
+                    }
+                    else if (iEndI < iTempI)
+                    {
+                        var15 = (double)iTempI + 0.0D;
+                    }
+                    else
+                    {
+                        var39 = false;
+                    }
+
+                    if (iEndJ > iTempJ)
+                    {
+                        var17 = (double)iTempJ + 1.0D;
+                    }
+                    else if (iEndJ < iTempJ)
+                    {
+                        var17 = (double)iTempJ + 0.0D;
+                    }
+                    else
+                    {
+                        var40 = false;
+                    }
+
+                    if (iEndK > iTempK)
+                    {
+                        var19 = (double)iTempK + 1.0D;
+                    }
+                    else if (iEndK < iTempK)
+                    {
+                        var19 = (double)iTempK + 0.0D;
+                    }
+                    else
+                    {
+                        var41 = false;
+                    }
+
+                    double var21 = 999.0D;
+                    double var23 = 999.0D;
+                    double var25 = 999.0D;
+                    double var27 = endVec.xCoord - startVec.xCoord;
+                    double var29 = endVec.yCoord - startVec.yCoord;
+                    double var31 = endVec.zCoord - startVec.zCoord;
+
+                    if (var39)
+                    {
+                        var21 = (var15 - startVec.xCoord) / var27;
+                    }
+
+                    if (var40)
+                    {
+                        var23 = (var17 - startVec.yCoord) / var29;
+                    }
+
+                    if (var41)
+                    {
+                        var25 = (var19 - startVec.zCoord) / var31;
+                    }
+
+                    boolean var33 = false;
+                    byte var42;
+
+                    if (var21 < var23 && var21 < var25)
+                    {
+                        if (iEndI > iTempI)
+                        {
+                            var42 = 4;
+                        }
+                        else
+                        {
+                            var42 = 5;
+                        }
+
+                        startVec.xCoord = var15;
+                        startVec.yCoord += var29 * var21;
+                        startVec.zCoord += var31 * var21;
+                    }
+                    else if (var23 < var25)
+                    {
+                        if (iEndJ > iTempJ)
+                        {
+                            var42 = 0;
+                        }
+                        else
+                        {
+                            var42 = 1;
+                        }
+
+                        startVec.xCoord += var27 * var23;
+                        startVec.yCoord = var17;
+                        startVec.zCoord += var31 * var23;
+                    }
+                    else
+                    {
+                        if (iEndK > iTempK)
+                        {
+                            var42 = 2;
+                        }
+                        else
+                        {
+                            var42 = 3;
+                        }
+
+                        startVec.xCoord += var27 * var25;
+                        startVec.yCoord += var29 * var25;
+                        startVec.zCoord = var19;
+                    }
+
+                    Vec3 var34 = this.getWorldVec3Pool().getVecFromPool(startVec.xCoord, startVec.yCoord, startVec.zCoord);
+                    iTempI = (int)(var34.xCoord = (double)MathHelper.floor_double(startVec.xCoord));
+
+                    if (var42 == 5)
+                    {
+                        --iTempI;
+                        ++var34.xCoord;
+                    }
+
+                    iTempJ = (int)(var34.yCoord = (double)MathHelper.floor_double(startVec.yCoord));
+
+                    if (var42 == 1)
+                    {
+                        --iTempJ;
+                        ++var34.yCoord;
+                    }
+
+                    iTempK = (int)(var34.zCoord = (double)MathHelper.floor_double(startVec.zCoord));
+
+                    if (var42 == 3)
+                    {
+                        --iTempK;
+                        ++var34.zCoord;
+                    }
+
+                    tempCollisionPos = CheckLocationForMouseOverRayTrace( 
+                    	iTempI, iTempJ, iTempK, startVec, endVec );
+                    
+                    if ( tempCollisionPos != null )
+                    {
+                    	return tempCollisionPos;
+                    }                    
+                }
+            }
+        }
+        
+        return null;
+    }
+    
+    public MovingObjectPosition CheckLocationForMouseOverRayTrace( int i, 
+    	int j, int k, Vec3 startVec, Vec3 endVec )
+    {
+    	MovingObjectPosition closestPos = null;
+    	double dClosestDistSq = 0D;
+    	
+    	for ( int iTempJ = j - 1; iTempJ <= j + 1; iTempJ++ )
+    	{
+            int iTempBlockID = getBlockId( i, iTempJ, k );
+
+            if ( iTempBlockID > 0 )
+            {
+                int iTempMetadata = getBlockMetadata( i, iTempJ, k );                    
+                Block tempBlock = Block.blocksList[iTempBlockID];
+
+                if ( tempBlock.canCollideCheck( iTempMetadata, false ) )
+                {
+                    MovingObjectPosition tempCollisionPos = tempBlock.MouseOverRayTrace( 
+                    	this, i, iTempJ, k, startVec, endVec);
+                    
+                    if ( tempCollisionPos != null )
+                    {
+                    	double tempDistSq = tempCollisionPos.hitVec.squareDistanceTo( startVec );
+                    	
+                    	if ( closestPos == null || tempDistSq < dClosestDistSq )
+                    	{
+                    		dClosestDistSq = tempDistSq;
+                    		
+                    		closestPos = tempCollisionPos;
+                    	} 
+                    }
+                }
+            }
+    	}
+    	
+    	return closestPos;
+    }
+    
+    public void playSound(double par1, double par3, double par5, String par7Str, float par8, float par9 ) 
+    {
+        playSound( par1, par3, par5, par7Str, par8, par9, false );    	
+    }
+    
+    public Entity GetClosestEntityMatchingCriteriaWithinRange( double dSourcePosX, double dSourcePosY, double dSourcePosZ, double dRange, FCClosestEntitySelectionCriteria criteria )
+    {
+		int iChunkEntityListMinVerticalIndex = MathHelper.floor_double( ( dSourcePosY - dRange ) / 16.0D );
+		int iChunkEntityListMaxVerticalIndex = MathHelper.floor_double( ( dSourcePosY + dRange ) / 16.0D ) + 1;
+		
+		if ( iChunkEntityListMinVerticalIndex < 0 )
+		{
+			iChunkEntityListMinVerticalIndex = 0;
+			iChunkEntityListMaxVerticalIndex = Math.max( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
+		}
+		
+		if ( iChunkEntityListMaxVerticalIndex > 15 )
+		{
+			iChunkEntityListMaxVerticalIndex = 15;
+			iChunkEntityListMinVerticalIndex = Math.min( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
+		}
+		
+    	FCClosestEntityInfo closestEntityInfo = 
+    		new FCClosestEntityInfo( dSourcePosX, dSourcePosY, dSourcePosZ, dRange * dRange, null, criteria, iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );
+    	
+        int iMinChunkX = MathHelper.floor_double( ( dSourcePosX - dRange ) / 16D  );
+        int iMaxChunkX = MathHelper.floor_double( ( dSourcePosX + dRange ) / 16D  ) + 1;
+        int iMinChunkZ = MathHelper.floor_double( ( dSourcePosZ - dRange ) / 16D  );
+        int iMaxChunkZ = MathHelper.floor_double( ( dSourcePosZ + dRange ) / 16D  ) + 1;
+        
+        for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
+        {
+            for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
+            {
+                if ( chunkExists( iTempChunkX, iTempChunkZ ) )
+                {
+                    getChunkFromChunkCoords( iTempChunkX, iTempChunkZ ).GetClosestEntityMatchingCriteriaWithinRangeSq( closestEntityInfo );
+                }
+            }
+        }
+
+        return closestEntityInfo.m_closestEntity;
+    }
+    
+    public int CountEntitiesThatApplyToSpawnCap( Class classToCount )
+    {
+    	// replacement for CountEntities that is slightly optimized
+    	
+        int iEntityCount = 0;
+
+        for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
+        {
+            Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
+
+            if ( tempEntity.DoesEntityApplyToSpawnCap() && classToCount.isAssignableFrom( tempEntity.getClass() ) )
+            {
+            	// verify that the entity is actually active
+            	
+            	++iEntityCount;
+            }
+        }
+
+        return iEntityCount;
+    }
+    
+    public int GetNumEntitiesThatApplyToSquidPossessionCap()
+    {
+    	long lCurrentTime = getWorldTime();
+    	
+    	if ( lCurrentTime != m_lTimeOfLastSquidPossessionCapCount )
+    	{
+    		m_iLastSquidPossessionCapCount = 0;
+    		m_lTimeOfLastSquidPossessionCapCount = lCurrentTime;
+    		
+            for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
+            {
+                Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
+
+                if ( tempEntity.DoesEntityApplyToSquidPossessionCap() )
+                {
+                	m_iLastSquidPossessionCapCount++;
+                }
+            }            
+    	}
+    	
+		return m_iLastSquidPossessionCapCount;
+    }
+
+	public void NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( EntityPlayer player, Block block, int i, int j, int k )
+	{
+		if ( !isRemote && block.blockMaterial.blocksMovement() && !player.capabilities.isCreativeMode )
+		{
+			double dXBlock = (double)i + 0.5D;
+			double dYBlock = (double)j + 0.5D;
+			double dZBlock = (double)k + 0.5D;
+			
+			AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB( dXBlock - 8D, dYBlock - 4D, dZBlock - 8D, dXBlock + 8D, dYBlock + 4D, dZBlock + 8D );
+			
+	        List animalList = this.getEntitiesWithinAABB( EntityAnimal.class, targetBox );
+	        
+	        Iterator animalIterator = animalList.iterator();
+	
+	        while ( animalIterator.hasNext())
+	        {
+	    		EntityAnimal tempAnimal = (EntityAnimal)animalIterator.next();
+	    		
+		        if ( !tempAnimal.isLivingDead )
+		        {
+		        	tempAnimal.OnNearbyPlayerBlockAddOrRemove( player ); 
+		        }		        
+	        }
+		}
+	}
+	
+    public int GetBlockNaturalLightValue( int i, int j, int k )
+    {
+        return GetBlockNaturalLightValue_do( i, j, k, true, skylightSubtracted );
+    }
+
+    public int GetBlockNaturalLightValueMaximum( int i, int j, int k )
+    {
+        return GetBlockNaturalLightValue_do( i, j, k, true, 0 );
+    }
+
+    public float GetNaturalLightBrightness( int i, int j, int k )
+    {
+        return provider.lightBrightnessTable[GetBlockNaturalLightValue(i, j, k)];
+    }
+
+    private int GetBlockNaturalLightValue_do( int i, int j, int k, boolean bConsiderNeighbors, int iSkylightToSubtract )
+    {
+    	// Version of getBlockLightValue_do modified to only consider natural light    	
+        if ( i >= -30000000 && k >= -30000000 && i < 30000000 && k < 30000000 )
+        {
+            if ( bConsiderNeighbors )
+            {
+                int iBlockID = getBlockId( i, j, k );
+
+                if ( Block.useNeighborBrightness[iBlockID] )
+                {
+                    int iNeighbor1 = GetBlockNaturalLightValue_do( i, j + 1, k, false, iSkylightToSubtract );
+                    int iNeighbor2 = GetBlockNaturalLightValue_do( i + 1, j, k, false, iSkylightToSubtract );
+                    int iNeighbor3 = GetBlockNaturalLightValue_do( i - 1, j, k, false, iSkylightToSubtract );
+                    int iNeighbor4 = GetBlockNaturalLightValue_do( i, j, k + 1, false, iSkylightToSubtract );
+                    int iNeighbor5 = GetBlockNaturalLightValue_do( i, j, k - 1, false, iSkylightToSubtract );
+
+                    if (iNeighbor2 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor2;
+                    }
+
+                    if (iNeighbor3 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor3;
+                    }
+
+                    if (iNeighbor4 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor4;
+                    }
+
+                    if (iNeighbor5 > iNeighbor1)
+                    {
+                        iNeighbor1 = iNeighbor5;
+                    }
+
+                    return iNeighbor1;
+                }
+            }
+
+            if (j < 0)
+            {
+                return 0;
+            }
+            else
+            {
+                if (j >= 256)
+                {
+                    j = 255;
+                }
+
+                Chunk chunk = this.getChunkFromChunkCoords(i >> 4, k >> 4);
+                
+                i &= 15;
+                k &= 15;
+                
+                return chunk.GetBlockNaturalLightValue( i, j, k, iSkylightToSubtract );
+            }
+        }
+        else
+        {
+            return 15;
+        }
+    }
+    
+    // @Override // client only override
+    public boolean doesBlockHaveSolidTopSurface( int i, int j, int k )
+    {
+        Block block = Block.blocksList[this.getBlockId(i, j, k)];
+        
+        return block != null && block.HasLargeCenterHardPointToFacing( this, i, j, k, 1 );
+    }
+    
+    //------------- Hardcore of Darkness Handling ------------//    
+    
+    static private double[] m_dMoonBrightnessByPhase = new double[] { 1.25D, 0.875, 0.75D, 0.5D, 0D, 0.5D, 0.75D, 1.25D }; 
+	
+    public float ComputeOverworldSunBrightnessWithMoonPhases()
+    {
+		// slight modified version of regular moon phase equation so that phase switches over at noon to avoid sudden jump in lighting at dawn
+		long lOffsetWorldTime = worldInfo.getWorldTime() - 12000L;
+		
+		if ( lOffsetWorldTime < 0L )
+		{
+			lOffsetWorldTime = 0L;
+		}
+		
+		int iMoonPhase = (int)( ( lOffsetWorldTime / 24000L ) % 8L );		
+		double dMoonBrightness = m_dMoonBrightnessByPhase[iMoonPhase];
+		
+        float fCelestialAngle = getCelestialAngle( 1F );
+        
+        // slight modifcation from vanilla calc so that gloom starts to set in on moonless nights the moment the sun drops beneath the horizon, and is removed at the moment of rise
+        //float fSunInvertedBrightness = 1.0F - (MathHelper.cos(fCelestialAngle * (float)Math.PI * 2.0F) * 2.0F + 0.2F);
+        float fSunInvertedBrightness = 1.0F - ( ( MathHelper.cos( fCelestialAngle * (float)Math.PI * 2.0F ) * 2.0F ) + 0.25F );
+
+        if ( fSunInvertedBrightness < 0.0F)
+        {
+        	fSunInvertedBrightness = 0.0F;
+        }
+        else if ( fSunInvertedBrightness > 1.0F)
+        {
+        	fSunInvertedBrightness = 1.0F;
+        }
+
+        double dSunBrightness = 1.0D - fSunInvertedBrightness;
+        
+        double dRainBrightnessModifier = ( 1.0D - (double)( getRainStrength( 1F ) * 5.0F ) / 16.0D );
+        double dStormBrightnessModifier = ( 1.0D - (double)( getWeightedThunderStrength( 1F ) * 5.0F ) / 16.0D );
+        
+        dSunBrightness = dSunBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
+
+        double dMinBrightness = 0.2D;
+        
+        dMinBrightness *= dMoonBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
+        
+        // clamp at a value that causes the world to descend into gloom on a new moon during a storm
+        if ( dMinBrightness < 0.05D )
+        {
+        	dMinBrightness = 0D;
+        }            
+    	
+        return (float)( dSunBrightness * ( 1D - dMinBrightness ) + dMinBrightness );
+    }
+    
+    public boolean IsTheEndNigh()
+    {
+    	return false;
+    }
+    
+    //------------- Magnetic Point Handling ------------//
+    
+    protected FCMagneticPointList m_MagneticPointList = new FCMagneticPointList();
+    
+    public FCMagneticPointList GetMagneticPointList()
+    {
+    	return m_MagneticPointList;
+    }
+    
+    //------------- Ender Chest Handling ------------//
+    
+    protected InventoryEnderChest m_localEnderChestInventory = new InventoryEnderChest();
+    protected InventoryEnderChest m_localLowPowerEnderChestInventory = new InventoryEnderChest();
+    
+    public InventoryEnderChest GetLocalEnderChestInventory()
+    {
+    	return m_localEnderChestInventory;
+    }
+    
+    public InventoryEnderChest GetLocalLowPowerEnderChestInventory()
+    {
+    	return m_localLowPowerEnderChestInventory;
+    }
+    
+    //------------- Looting Beacon Handling ------------//
+    
+    protected FCBeaconEffectLocationList m_LootingBeaconLocationList = new FCBeaconEffectLocationList();
+    
+    public FCBeaconEffectLocationList GetLootingBeaconLocationList()
+    {
+    	return m_LootingBeaconLocationList;
+    }
+    
+    public int GetAmbientLootingEffectAtLocation( int iLocI, int iLocJ, int iLocK )
+    {
+    	return m_LootingBeaconLocationList.GetMostPowerfulBeaconEffectForLocation( iLocI, iLocK );
+    }
+    
+    //------------- Spawn Location Handling ------------//
+    
+    protected FCSpawnLocationList m_SpawnLocationList = new FCSpawnLocationList();
+    
+    public FCSpawnLocationList GetSpawnLocationList()
+    {
+    	return m_SpawnLocationList;
+    }    
+    
+    //------------- Explosion Handling ------------//
+    
+    /**
+     * Copy of newExplosion() that suppresses the audio/visual effects
+     */
+    public Explosion NewExplosionNoFX( Entity par1Entity, double dPosX, double dPosY, double dPosZ, 
+    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
+    {
+        Explosion explosion = new Explosion( this, par1Entity, dPosX, dPosY, dPosZ, fExplosionSize );
+        
+        explosion.isFlaming = bCreatesFlames;
+        explosion.isSmoking = bDestroysBlocks;
+        explosion.m_bSuppressFX = true;
+        
+        explosion.doExplosionA();
+        explosion.doExplosionB( false ); // false tells individual block destruction effects not to play
+        
+        return explosion;
+    }
+    
+    //------------- "View Distance" / Chunk Update Handling ------------//
+    
+    /** 
+     * The "view distance" is actually the range at which chunks are loaded, specified as 
+     * a vanilla server parameter (default is 10 chunks). 
+     */
+    public int GetClampedViewDistanceInChunks()
+    {
+    	return 10;
+    }
+    
+    public int GetMobSpawnRangeInChunks()
+    {
+    	return GetClampedViewDistanceInChunks() - 2;
+    }
+    
+    /** 
+     * "Active" chunks handle stuff like random block updates (grass growing, etc.)
+     * and precipitation
+     */
+    public int GetActiveChunkRangeInChunks()
+    {
+    	int iRange = GetClampedViewDistanceInChunks() - 3;
+    	
+    	if ( iRange < 1 )
+    	{
+    		iRange = 1;
+    	}
+    	
+    	return iRange;
+    }
+    
+    protected void UpdateActiveChunkMap()
+    {
+    	ClearActiveChunkMap();
+    	
+        for ( int iTempIndex = 0; iTempIndex < playerEntities.size(); ++iTempIndex )
+        {
+            EntityPlayer tempPlayer = (EntityPlayer)playerEntities.get( iTempIndex );
+            
+            AddEntityToActiveChunkMap( tempPlayer );
+        }
+    }
+    
+    protected void AddEntityToActiveChunkMap( Entity entity )
+    {
+        int iChunkX = MathHelper.floor_double( entity.posX / 16D );
+        int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
+        
+        AddAreaAroundChunkToActiveChunkMap( iChunkX, iChunkZ );
+    }
+    
+    protected void AddAreaAroundChunkToActiveChunkMap( int iChunkX, int iChunkZ )
+    {
+        int iActiveRange = GetActiveChunkRangeInChunks();
+        
+        for ( int iTempChunkX = iChunkX - iActiveRange; 
+        	iTempChunkX <= iChunkX + iActiveRange; iTempChunkX++ )
+        {
+            for ( int iTempChunkZ = iChunkZ - iActiveRange; 
+            	iTempChunkZ <= iChunkZ + iActiveRange; iTempChunkZ++ )
+            {
+            	AddToActiveChunkMap( iTempChunkX, iTempChunkZ );
+            }
+        }
+    }
+    
+    protected void ClearActiveChunkMap()
+    {
+        Iterator<ChunkCoordIntPair> tempIterator = m_activeChunksCoordsList.iterator();
+
+        while ( tempIterator.hasNext() )
+        {
+        	ChunkCoordIntPair coords = tempIterator.next();
+            Long lTempKey = ChunkCoordIntPair.chunkXZ2Int( coords.chunkXPos, coords.chunkZPos );
+            
+            tempIterator.remove();
+            m_activeChunksCoordsMap.remove( lTempKey ); 
+        }
+    }
+    
+    protected void AddToActiveChunkMap( int iChunkX, int iChunkZ )
+    {
+        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
+        
+        if ( !m_activeChunksCoordsMap.containsItem( lCoordKey ) )
+        {
+	    	ChunkCoordIntPair coords = new ChunkCoordIntPair( iChunkX, iChunkZ );
+	    	
+	        m_activeChunksCoordsList.add( coords );
+	        
+	        m_activeChunksCoordsMap.add( lCoordKey, coords );
+        }
+    }
+    
+    public boolean IsChunkActive( int iChunkX, int iChunkZ )
+    {
+        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
+        
+        return m_activeChunksCoordsMap.containsItem( lCoordKey );
+    }
+    
+    public boolean IsBlockPosActive( int i, int j, int k )
+    {    	
+        if ( j >= 0 && j < 256 )
+        {
+        	return IsChunkActive( i >> 4, k >> 4 );
+        }
+        
+        return false;
+    }
+    
+    public LinkedList<ChunkCoordIntPair> GetActiveChunksCoordsList()
+    {
+    	return m_activeChunksCoordsList;
+    }
+    
+    //------------- Weather Handling ------------//
+    
+    protected void updateWeather()
+    {
+    	// replacement for vanilla code to clean up and ensure that storms only start after it's been raining awhile
+    	
+        if ( !provider.hasNoSky )
+        {
+            int iRainTime = worldInfo.getRainTime();
+
+            if ( iRainTime <= 0 )
+            {
+                if ( worldInfo.isRaining() )
+                {
+                    worldInfo.setRainTime( rand.nextInt( 12000 ) + 12000 );
+                }
+                else
+                {
+                    worldInfo.setRainTime( rand.nextInt( 168000 ) + 12000 );
+                }
+            }
+            else
+            {
+                --iRainTime;
+                
+                worldInfo.setRainTime( iRainTime );
+
+                if ( iRainTime <= 0 )
+                {
+                    worldInfo.setRaining( !worldInfo.isRaining() );
+                    
+                    if ( worldInfo.isRaining() && !worldInfo.isThundering() )
+                    {
+                    	// min of a minute when rain starts before storm.  About a 1/5 chance of rain turning into a storm at some point in its duration
+                    	
+                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
+                    }
+                }
+            }
+
+            if ( worldInfo.isRaining() )
+            {
+	            int iThunderTime = worldInfo.getThunderTime();
+	
+	            if ( iThunderTime <= 0 )
+	            {
+	                if ( worldInfo.isThundering() )
+	                {
+	                    worldInfo.setThunderTime( rand.nextInt( 12000 ) + 3600 );
+	                }
+	                else
+	                {
+                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
+	                }
+	            }
+	            else
+	            {
+	                --iThunderTime;
+	                
+	                worldInfo.setThunderTime( iThunderTime );
+	
+	                if ( iThunderTime <= 0 )
+	                {
+	                    worldInfo.setThundering( !worldInfo.isThundering() );
+	                }
+	            }
+            }
+            else if ( worldInfo.isThundering() )
+        	{
+        		worldInfo.setThundering( false );
+        	}
+
+            // update the rain and thunder strength counters
+            
+            prevRainingStrength = rainingStrength;
+
+            if ( worldInfo.isRaining() )
+            {
+                rainingStrength = rainingStrength + 0.01F;
+                
+                if ( rainingStrength > 1F )
+                {
+                    rainingStrength = 1F;
+                }
+            }
+            else
+            {
+                rainingStrength = rainingStrength - 0.01F;
+                
+                if ( rainingStrength < 0F )
+                {
+                    rainingStrength = 0F;
+                }
+            }
+
+            prevThunderingStrength = thunderingStrength;
+
+            if ( worldInfo.isThundering() )
+            {
+                thunderingStrength = thunderingStrength + 0.01F;
+                
+                if ( thunderingStrength > 1F )
+                {
+                    thunderingStrength = 1F;
+                }
+            }
+            else
+            {
+                thunderingStrength = thunderingStrength - 0.01F;
+                
+                if ( thunderingStrength < 0F )
+                {
+                    thunderingStrength = 0F;
+                }
+            }
+        }
+    }
+    
+    public boolean IsRainingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsSnowingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsPrecipitatingAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow() || biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean IsPrecipitatingAtPos( int i, int k )
+    {
+        if ( isRaining() )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.getEnableSnow() || biome.CanRainInBiome();
+        }
+        
+        return false;
+    }
+    
+    public boolean CanLightningStrikeAtPos( int i, int j, int k )
+    {
+        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
+        	j >= getPrecipitationHeight( i, k )  )
+        {
+            BiomeGenBase biome = getBiomeGenForCoords( i, k );
+            
+            return biome.CanLightningStrikeInBiome();
+        }
+        
+        return false;
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/WorldChunkManager.java b/minecraft_server/net/minecraft/src/WorldChunkManager.java
index 7a45f33..d303137 100644
--- a/minecraft_server/net/minecraft/src/WorldChunkManager.java
+++ b/minecraft_server/net/minecraft/src/WorldChunkManager.java
@@ -26,8 +26,10 @@ public class WorldChunkManager
         this.biomesToSpawnIn.add(BiomeGenBase.taiga);
         this.biomesToSpawnIn.add(BiomeGenBase.taigaHills);
         this.biomesToSpawnIn.add(BiomeGenBase.forestHills);
-        this.biomesToSpawnIn.add(BiomeGenBase.jungle);
-        this.biomesToSpawnIn.add(BiomeGenBase.jungleHills);
+        // FCMOD: Removing jungle biomes from the valid spawn locations due to jungle spiders
+        //this.biomesToSpawnIn.add(BiomeGenBase.jungle);
+        //this.biomesToSpawnIn.add(BiomeGenBase.jungleHills);
+        // END FCMOD
     }
 
     public WorldChunkManager(long par1, WorldType par3WorldType)
diff --git a/minecraft_server/net/minecraft/src/WorldGenBigTree.java b/minecraft_server/net/minecraft/src/WorldGenBigTree.java
index 340cca9..70ffdbb 100644
--- a/minecraft_server/net/minecraft/src/WorldGenBigTree.java
+++ b/minecraft_server/net/minecraft/src/WorldGenBigTree.java
@@ -503,7 +503,20 @@ public class WorldGenBigTree extends WorldGenerator
             this.generateLeaves();
             this.generateTrunk();
             this.generateLeafNodeBases();
+            
+            // FCMOD: Added
+            int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+            
+            if ( iTrunkBlockId == Block.wood.blockID )
+            {
+            	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+            	
+        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+            }
+            // END FCMOD
+            
             return true;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/minecraft_server/net/minecraft/src/WorldGenDesertWells.java b/minecraft_server/net/minecraft/src/WorldGenDesertWells.java
index e0c3c0d..3ac09a5 100644
--- a/minecraft_server/net/minecraft/src/WorldGenDesertWells.java
+++ b/minecraft_server/net/minecraft/src/WorldGenDesertWells.java
@@ -89,7 +89,58 @@ public class WorldGenDesertWells extends WorldGenerator
                 par1World.setBlock(par3 + 1, par4 + var7, par5 + 1, Block.sandStone.blockID, 0, 2);
             }
 
+            // FCMOD: Added
+            AddModBlocks( par1World, par3, par4, par5);
+            // END FCMOD
+
             return true;
         }
     }
+    
+    // FCMOD: Added
+    private static FCUtilsRandomItemStack[] m_LootBasketContents = null;
+    
+    private void InitContentsArray()
+    {
+    	m_LootBasketContents = new FCUtilsRandomItemStack[] {
+    		new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemHempSeeds.itemID, 0, 1, 4, 5 ),  
+        	new FCUtilsRandomItemStack( Item.glassBottle.itemID, 0, 2, 8, 10 ),  
+        }; 
+    }
+    
+    private void AddModBlocks( World world, int i, int j, int k )
+    {
+    	int iNumBaskets = world.rand.nextInt( 3 );
+    	
+    	for ( int iTempCount = 0; iTempCount < iNumBaskets; iTempCount++ )
+    	{
+	    	int iBasketI = i + ( world.rand.nextInt( 2 ) == 0 ? -2 : 2 );
+	    	int iBasketJ = j + 2;
+	    	int iBasketK = k + ( world.rand.nextInt( 2 ) == 0 ? -2 : 2 );
+	    	
+	    	AddLootBasket( world, iBasketI, iBasketJ, iBasketK );
+    	}
+    }
+    
+    private void AddLootBasket( World world, int i, int j, int k )
+    {
+    	if ( m_LootBasketContents == null )
+    	{
+    		// only initialize array on first use to ensure referenced mod items are intialized
+    		InitContentsArray();
+    	}
+    	
+        if ( world.getBlockId( i, j, k ) != FCBetterThanWolves.fcBlockBasketWicker.blockID )
+        {
+	    	world.setBlock( i, j, k, FCBetterThanWolves.fcBlockBasketWicker.blockID, world.rand.nextInt( 4 ) | 4, 2 );
+	    	
+	    	FCTileEntityBasketWicker tileEntity = (FCTileEntityBasketWicker)world.getBlockTileEntity( i, j, k );
+	    	
+	    	if ( tileEntity != null )
+	    	{
+	    		tileEntity.SetStorageStack( FCUtilsRandomItemStack.GetRandomStack( world.rand, m_LootBasketContents ) );
+	    	}
+        }	    	
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/WorldGenDungeons.java b/minecraft_server/net/minecraft/src/WorldGenDungeons.java
index e7b174d..369819b 100644
--- a/minecraft_server/net/minecraft/src/WorldGenDungeons.java
+++ b/minecraft_server/net/minecraft/src/WorldGenDungeons.java
@@ -81,7 +81,7 @@ public class WorldGenDungeons extends WorldGenerator
                 {
                     if (var11 < 3)
                     {
-                        label113:
+                        label210:
                         {
                             var12 = par3 + par2Random.nextInt(var7 * 2 + 1) - var7;
                             int var14 = par5 + par2Random.nextInt(var8 * 2 + 1) - var8;
@@ -112,7 +112,12 @@ public class WorldGenDungeons extends WorldGenerator
 
                                 if (var15 == 1)
                                 {
+                                    // FCMOD: Changed
+                                    /*
                                     par1World.setBlock(var12, par4, var14, Block.chest.blockID, 0, 2);
+                                    */
+                                    par1World.setBlock(var12, par4, var14, FCBetterThanWolves.fcBlockChest.blockID, 0, 2);
+                                	// END FCMOD
                                     TileEntityChest var16 = (TileEntityChest)par1World.getBlockTileEntity(var12, par4, var14);
 
                                     if (var16 != null)
@@ -128,7 +133,11 @@ public class WorldGenDungeons extends WorldGenerator
                                         }
                                     }
 
-                                    break label113;
+                                    // FCMOD: Code added
+                                    FilterChestContentsForDepth( par1World, var12, par4, var14 );
+                                    // END FCMOD
+
+                                    break label210;
                                 }
                             }
 
@@ -179,4 +188,62 @@ public class WorldGenDungeons extends WorldGenerator
         int var2 = par1Random.nextInt(4);
         return var2 == 0 ? "Skeleton" : (var2 == 1 ? "Zombie" : (var2 == 2 ? "Zombie" : (var2 == 3 ? "Spider" : "")));
     }
+    
+    // FCMOD: Code added
+    private void FilterChestContentsForDepth( World world, int iChestI, int iChestJ, int iChestK )
+    {
+        TileEntityChest chestEnt = (TileEntityChest)world.getBlockTileEntity( iChestI, iChestJ, iChestK );
+        
+        if ( chestEnt != null )
+        {
+            for ( int iSlot = 0; iSlot < chestEnt.getSizeInventory(); iSlot++ )
+            {
+                ItemStack tempStack = chestEnt.getStackInSlot( iSlot );
+                
+                if ( tempStack != null )
+                {
+                	int iItemID = tempStack.itemID;
+
+                	if ( iItemID == Item.ingotIron.itemID )
+                	{
+                		if ( iChestJ > 36 )
+                		{
+                    		chestEnt.setInventorySlotContents( iSlot, null );
+                		}
+                		else
+                		{
+                			tempStack.stackSize = 1;
+                		}
+                	}
+                	else if ( iItemID == Item.bucketEmpty.itemID )
+                	{
+                		chestEnt.setInventorySlotContents( iSlot, null );
+                	}
+                	else if ( iItemID == Item.gunpowder.itemID )
+                	{
+                		if ( iChestJ > 36 )
+                		{
+                    		chestEnt.setInventorySlotContents( iSlot, null );
+                		}
+                		else
+                		{
+                			tempStack.stackSize = 1;
+                		}
+                	}
+                	else if ( iItemID == Item.redstone.itemID )
+                	{
+                		if ( iChestJ > 24 )
+                		{
+                    		chestEnt.setInventorySlotContents( iSlot, null );
+                		}
+                	}
+                	else if ( iItemID == Item.wheat.itemID )
+                	{
+                		chestEnt.setInventorySlotContents( iSlot, null );
+                	}
+                }
+            }
+        }                	
+    }
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/WorldGenFlowers.java b/minecraft_server/net/minecraft/src/WorldGenFlowers.java
index d1d9852..955588f 100644
--- a/minecraft_server/net/minecraft/src/WorldGenFlowers.java
+++ b/minecraft_server/net/minecraft/src/WorldGenFlowers.java
@@ -20,7 +20,13 @@ public class WorldGenFlowers extends WorldGenerator
             int var8 = par4 + par2Random.nextInt(4) - par2Random.nextInt(4);
             int var9 = par5 + par2Random.nextInt(8) - par2Random.nextInt(8);
 
+            // FCMOD: Change
+            /*
             if (par1World.isAirBlock(var7, var8, var9) && (!par1World.provider.hasNoSky || var8 < 127) && Block.blocksList[this.plantBlockId].canBlockStay(par1World, var7, var8, var9))
+            */
+            if (par1World.isAirBlock(var7, var8, var9) && (!par1World.provider.hasNoSky || var8 < 127) && 
+            	Block.blocksList[this.plantBlockId].CanBlockStayDuringGenerate(par1World, var7, var8, var9))
+        	// END FCMOD
             {
                 par1World.setBlock(var7, var8, var9, this.plantBlockId, 0, 2);
             }
diff --git a/minecraft_server/net/minecraft/src/WorldGenForest.java b/minecraft_server/net/minecraft/src/WorldGenForest.java
index bef9cbb..8785894 100644
--- a/minecraft_server/net/minecraft/src/WorldGenForest.java
+++ b/minecraft_server/net/minecraft/src/WorldGenForest.java
@@ -105,6 +105,24 @@ public class WorldGenForest extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 2 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft_server/net/minecraft/src/WorldGenHugeTrees.java b/minecraft_server/net/minecraft/src/WorldGenHugeTrees.java
index 1f06000..a5d1884 100644
--- a/minecraft_server/net/minecraft/src/WorldGenHugeTrees.java
+++ b/minecraft_server/net/minecraft/src/WorldGenHugeTrees.java
@@ -185,6 +185,13 @@ public class WorldGenHugeTrees extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added
+                    AttemptToPlaceStump( par1World, par3, par4, par5 );
+                    AttemptToPlaceStump( par1World, par3, par4, par5 + 1 );
+                    AttemptToPlaceStump( par1World, par3 + 1, par4, par5 );
+                    AttemptToPlaceStump( par1World, par3 + 1, par4, par5 + 1 );
+                    // END FCMOD
+
                     return true;
                 }
                 else
@@ -199,6 +206,24 @@ public class WorldGenHugeTrees extends WorldGenerator
         }
     }
 
+    // FCMOD: Added
+    private void AttemptToPlaceStump( World world, int i, int j, int k )
+    {
+        int iTrunkBlockId = world.getBlockId( i, j, k );
+        
+        if ( iTrunkBlockId == Block.wood.blockID )
+        {
+        	int iTrunkMetadata = world.getBlockMetadata( i, j, k );
+        	
+        	if ( iTrunkMetadata == woodMetadata )
+        	{
+        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+        		world.setBlockMetadataWithClient( i, j, k, iTrunkMetadata | 12 ); 
+        	}
+        }
+    }
+    // END FCMOD
+    
     private void growLeaves(World par1World, int par2, int par3, int par4, int par5, Random par6Random)
     {
         byte var7 = 2;
diff --git a/minecraft_server/net/minecraft/src/WorldGenMinable.java b/minecraft_server/net/minecraft/src/WorldGenMinable.java
index 0b9336f..e3d6102 100644
--- a/minecraft_server/net/minecraft/src/WorldGenMinable.java
+++ b/minecraft_server/net/minecraft/src/WorldGenMinable.java
@@ -66,7 +66,30 @@ public class WorldGenMinable extends WorldGenerator
 
                                 if (var39 * var39 + var42 * var42 + var45 * var45 < 1.0D && par1World.getBlockId(var38, var41, var44) == this.field_94523_c)
                                 {
+                                	// FCMOD: Code change
+                                	/*
                                     par1World.setBlock(var38, var41, var44, this.minableBlockId, 0, 2);
+                                    */
+                                	int iMetadata = 0;
+                                	Block block = Block.blocksList[minableBlockId];
+                                	
+                                	if ( block.HasStrata() )
+                                	{
+                                		if ( var41 <= 48  + par1World.rand.nextInt( 2 ) )
+                                		{
+                                			int iStrataLevel = 1;
+                                			
+                                			if ( var41 <= 24 + par1World.rand.nextInt( 2 ) )
+                                			{
+                                				iStrataLevel = 2;                                				
+                                			}
+                                			
+                            				iMetadata = block.GetMetadataConversionForStrataLevel( iStrataLevel, 0 );
+                                		}
+                                	}
+                                	
+                                    par1World.setBlock(var38, var41, var44, this.minableBlockId, iMetadata, 2);
+                                    // END FCMOD
                                 }
                             }
                         }
diff --git a/minecraft_server/net/minecraft/src/WorldGenPumpkin.java b/minecraft_server/net/minecraft/src/WorldGenPumpkin.java
index d478b3f..dc262f2 100644
--- a/minecraft_server/net/minecraft/src/WorldGenPumpkin.java
+++ b/minecraft_server/net/minecraft/src/WorldGenPumpkin.java
@@ -6,6 +6,13 @@ public class WorldGenPumpkin extends WorldGenerator
 {
     public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
     {
+    	// FCMOD: Added
+        boolean bIsValidBiome = ( par1World.getBiomeGenForCoords( par3, par5 ) == BiomeGenBase.plains );
+        int iPlacedPumpkinCount = 0;
+        
+        boolean bIsFresh = CheckIfFresh( par1World, par3, par5 );
+        // END FCMOD
+        
         for (int var6 = 0; var6 < 64; ++var6)
         {
             int var7 = par3 + par2Random.nextInt(8) - par2Random.nextInt(8);
@@ -14,10 +21,47 @@ public class WorldGenPumpkin extends WorldGenerator
 
             if (par1World.isAirBlock(var7, var8, var9) && par1World.getBlockId(var7, var8 - 1, var9) == Block.grass.blockID && Block.pumpkin.canPlaceBlockAt(par1World, var7, var8, var9))
             {
+            	// FCMOD: Changed
+            	/*
                 par1World.setBlock(var7, var8, var9, Block.pumpkin.blockID, par2Random.nextInt(4), 2);
+                */
+            	int iFacing = par2Random.nextInt( 4 ); // must be done regardless of whether the block is placed to avoid disrupting the random number generator
+            	
+            	if ( bIsValidBiome && iPlacedPumpkinCount < 3 )
+            	{
+            		if ( bIsFresh )
+            		{
+            			par1World.setBlock(var7, var8, var9, FCBetterThanWolves.fcBlockPumpkinFresh.blockID, iFacing, 2);
+            		}
+            		else
+            		{
+            			par1World.setBlock(var7, var8, var9, Block.pumpkin.blockID, iFacing, 2);
+            		}
+                    
+                    iPlacedPumpkinCount++;
+            	}
+            	// END FCMOD            		
             }
         }
 
         return true;
     }
+    
+	// FCMOD: Added
+    private final static double m_dDistForFreshPumpkins = 2500D;
+    private final static double m_dDistSquaredForFreshPumpkins = ( m_dDistForFreshPumpkins * m_dDistForFreshPumpkins );
+    
+    public boolean CheckIfFresh( World world, int i, int k )
+    {
+    	int iSpawnX = world.getWorldInfo().getSpawnX();
+    	int iSpawnZ = world.getWorldInfo().getSpawnZ();
+    	
+    	double dDeltaX = (double)( iSpawnX - i );
+    	double dDeltaZ = (double)( iSpawnZ - k );
+    	
+    	double dDistSqFromSpawn = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
+    	
+    	return dDistSqFromSpawn > m_dDistSquaredForFreshPumpkins;
+    }    
+    // END FCMOD	
 }
diff --git a/minecraft_server/net/minecraft/src/WorldGenReed.java b/minecraft_server/net/minecraft/src/WorldGenReed.java
index d0fe024..25d14ba 100644
--- a/minecraft_server/net/minecraft/src/WorldGenReed.java
+++ b/minecraft_server/net/minecraft/src/WorldGenReed.java
@@ -6,6 +6,13 @@ public class WorldGenReed extends WorldGenerator
 {
     public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
     {
+    	// FCMOD: Added
+    	BiomeGenBase currentBiome = par1World.getBiomeGenForCoords( par3, par5 );
+    	
+        boolean bIsValidBiome = currentBiome == BiomeGenBase.swampland || 
+        	currentBiome == BiomeGenBase.jungle || currentBiome == BiomeGenBase.jungleHills;
+        // END FCMOD
+        
         for (int var6 = 0; var6 < 20; ++var6)
         {
             int var7 = par3 + par2Random.nextInt(4) - par2Random.nextInt(4);
@@ -15,6 +22,15 @@ public class WorldGenReed extends WorldGenerator
             if (par1World.isAirBlock(var7, par4, var9) && (par1World.getBlockMaterial(var7 - 1, par4 - 1, var9) == Material.water || par1World.getBlockMaterial(var7 + 1, par4 - 1, var9) == Material.water || par1World.getBlockMaterial(var7, par4 - 1, var9 - 1) == Material.water || par1World.getBlockMaterial(var7, par4 - 1, var9 + 1) == Material.water))
             {
                 int var10 = 2 + par2Random.nextInt(par2Random.nextInt(3) + 1);
+                
+                // FCMOD: Added
+                if ( !bIsValidBiome )
+                {
+                	// must occur after all random number generation to avoid messing up world gen
+                	
+                	continue;
+                }
+                // END FCMOD
 
                 for (int var11 = 0; var11 < var10; ++var11)
                 {
diff --git a/minecraft_server/net/minecraft/src/WorldGenSwamp.java b/minecraft_server/net/minecraft/src/WorldGenSwamp.java
index b8e7b25..7065113 100644
--- a/minecraft_server/net/minecraft/src/WorldGenSwamp.java
+++ b/minecraft_server/net/minecraft/src/WorldGenSwamp.java
@@ -144,6 +144,24 @@ public class WorldGenSwamp extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 0 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft_server/net/minecraft/src/WorldGenTaiga1.java b/minecraft_server/net/minecraft/src/WorldGenTaiga1.java
index 63406ef..c448bde 100644
--- a/minecraft_server/net/minecraft/src/WorldGenTaiga1.java
+++ b/minecraft_server/net/minecraft/src/WorldGenTaiga1.java
@@ -104,6 +104,24 @@ public class WorldGenTaiga1 extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 1 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+                    
                     return true;
                 }
                 else
diff --git a/minecraft_server/net/minecraft/src/WorldGenTaiga2.java b/minecraft_server/net/minecraft/src/WorldGenTaiga2.java
index 527392f..cd2a809 100644
--- a/minecraft_server/net/minecraft/src/WorldGenTaiga2.java
+++ b/minecraft_server/net/minecraft/src/WorldGenTaiga2.java
@@ -72,8 +72,8 @@ public class WorldGenTaiga2 extends WorldGenerator
                     var21 = par2Random.nextInt(2);
                     var13 = 1;
                     byte var22 = 0;
-                    int var16;
                     int var17;
+                    int var16;
 
                     for (var15 = 0; var15 <= var8; ++var15)
                     {
@@ -122,6 +122,24 @@ public class WorldGenTaiga2 extends WorldGenerator
                             this.setBlockAndMetadata(par1World, par3, par4 + var16, par5, Block.wood.blockID, 1);
                         }
                     }
+                    
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == 1 )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD                    
 
                     return true;
                 }
diff --git a/minecraft_server/net/minecraft/src/WorldGenTrees.java b/minecraft_server/net/minecraft/src/WorldGenTrees.java
index 15f30a7..3402572 100644
--- a/minecraft_server/net/minecraft/src/WorldGenTrees.java
+++ b/minecraft_server/net/minecraft/src/WorldGenTrees.java
@@ -206,6 +206,24 @@ public class WorldGenTrees extends WorldGenerator
                         }
                     }
 
+                    // FCMOD: Added                    
+                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
+                    {
+                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
+                        
+                        if ( iTrunkBlockId == Block.wood.blockID )
+                        {
+                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
+                        	
+                        	if ( iTrunkMetadata == metaWood )
+                        	{
+                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
+                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
+                        	}
+                        }
+                    }                    
+                    // END FCMOD
+
                     return true;
                 }
                 else
diff --git a/minecraft_server/net/minecraft/src/WorldGeneratorBonusChest.java b/minecraft_server/net/minecraft/src/WorldGeneratorBonusChest.java
index d2cd226..8e077b5 100644
--- a/minecraft_server/net/minecraft/src/WorldGeneratorBonusChest.java
+++ b/minecraft_server/net/minecraft/src/WorldGeneratorBonusChest.java
@@ -50,7 +50,7 @@ public class WorldGeneratorBonusChest extends WorldGenerator
 
                     if (var11 != null && var11 != null)
                     {
-                        WeightedRandomChestContent.generateChestContents(par2Random, this.theBonusChestGenerator, var11, this.itemsToGenerateInBonusChest);
+                        WeightedRandomChestContent.generateChestContents(par2Random, this.theBonusChestGenerator, var11, this.itemsToGenerateInBonusChest);                        
                     }
 
                     if (par1World.isAirBlock(var8 - 1, var9, var10) && par1World.doesBlockHaveSolidTopSurface(var8 - 1, var9 - 1, var10))
diff --git a/minecraft_server/net/minecraft/src/WorldInfo.java b/minecraft_server/net/minecraft/src/WorldInfo.java
index fdc90ab..e47597b 100644
--- a/minecraft_server/net/minecraft/src/WorldInfo.java
+++ b/minecraft_server/net/minecraft/src/WorldInfo.java
@@ -166,6 +166,10 @@ public class WorldInfo
         {
             this.theGameRules.readGameRulesFromNBT(par1NBTTagCompound.getCompoundTag("GameRules"));
         }
+        
+        // FCMOD: Code added
+        LoadModInfoFromNBT( par1NBTTagCompound );
+        // END FCMOD
     }
 
     public WorldInfo(WorldSettings par1WorldSettings, String par2Str)
@@ -213,6 +217,9 @@ public class WorldInfo
         this.allowCommands = par1WorldInfo.allowCommands;
         this.initialized = par1WorldInfo.initialized;
         this.theGameRules = par1WorldInfo.theGameRules;
+        // FCMOD: Code added
+        CopyModInfo( par1WorldInfo );
+        // END FCMOD        
     }
 
     /**
@@ -261,6 +268,10 @@ public class WorldInfo
         par1NBTTagCompound.setBoolean("initialized", this.initialized);
         par1NBTTagCompound.setCompoundTag("GameRules", this.theGameRules.writeGameRulesToNBT());
 
+        // FCMOD: Code added
+        SaveModInfoToNBT( par1NBTTagCompound );
+        // END FCMOD
+
         if (par2NBTTagCompound != null)
         {
             par1NBTTagCompound.setCompoundTag("Player", par2NBTTagCompound);
@@ -320,6 +331,10 @@ public class WorldInfo
         return this.playerTag;
     }
 
+	/** 
+	 * FCNOTE: Be careful calling this function as it can return unexpected results in derived worlds
+	 * You normally want to use world.provider.dimensionId instead
+	 */
     public int getDimension()
     {
         return this.dimension;
@@ -632,4 +647,106 @@ public class WorldInfo
     {
         return par0WorldInfo.allowCommands;
     }
+
+    // FCMOD: Code added
+    private InventoryEnderChest m_globalEnderChestInventory = new InventoryEnderChest();
+
+    public boolean m_bPreviouslyRaining = false;
+    public boolean m_bPreviouslyThundering = false;
+
+    private boolean m_bHasNetherBeenAccessed = false;
+    private boolean m_bHasWitherBeenSummoned = false;
+    private boolean m_bHasEndDimensionBeenAccessed = false;
+
+    public InventoryEnderChest GetGlobalEnderChestInventory()
+    {
+    	return m_globalEnderChestInventory;
+    }
+    
+    private void LoadModInfoFromNBT( NBTTagCompound par1NBTTagCompound )
+    {
+	    if ( par1NBTTagCompound.hasKey( "FCEnderItems" ) )
+	    {
+	        NBTTagList nbttaglist1 = par1NBTTagCompound.getTagList( "FCEnderItems" );
+	        
+	    	m_globalEnderChestInventory.loadInventoryFromNBT( nbttaglist1 );
+	    }	    
+	    
+	    if ( par1NBTTagCompound.hasKey( "FCNetherAccessed" ) )
+	    {
+	    	m_bHasNetherBeenAccessed = par1NBTTagCompound.getBoolean( "FCNetherAccessed" ); 
+	    }
+	    	
+	    if ( par1NBTTagCompound.hasKey( "FCWitherSummoned" ) )
+	    {
+	    	m_bHasWitherBeenSummoned = par1NBTTagCompound.getBoolean( "FCWitherSummoned" ); 
+	    }
+	    	
+	    if ( par1NBTTagCompound.hasKey( "FCEndAccessed" ) )
+	    {
+	    	m_bHasEndDimensionBeenAccessed = par1NBTTagCompound.getBoolean( "FCEndAccessed" ); 
+	    }
+	    	
+	    m_bPreviouslyRaining = raining;
+	    m_bPreviouslyThundering = thundering;
+    }
+    
+    private void SaveModInfoToNBT( NBTTagCompound par1NBTTagCompound )
+    {
+	    if ( m_globalEnderChestInventory != null )
+	    {
+	    	par1NBTTagCompound.setTag( "FCEnderItems", m_globalEnderChestInventory.saveInventoryToNBT() );
+	    }	    
+	    
+        par1NBTTagCompound.setBoolean( "FCNetherAccessed", m_bHasNetherBeenAccessed );	    
+        par1NBTTagCompound.setBoolean( "FCWitherSummoned", m_bHasWitherBeenSummoned );	    
+        par1NBTTagCompound.setBoolean( "FCEndAccessed", m_bHasEndDimensionBeenAccessed );	    
+    }
+    
+    private void CopyModInfo(WorldInfo par1WorldInfo)
+    {
+	    if ( par1WorldInfo.m_globalEnderChestInventory != null )
+	    {
+	        m_globalEnderChestInventory = par1WorldInfo.m_globalEnderChestInventory;
+	    }	    
+	    
+	    m_bHasNetherBeenAccessed = par1WorldInfo.m_bHasNetherBeenAccessed;
+	    m_bHasWitherBeenSummoned = par1WorldInfo.m_bHasWitherBeenSummoned;
+	    m_bHasEndDimensionBeenAccessed = par1WorldInfo.m_bHasEndDimensionBeenAccessed;
+	    
+	    m_bPreviouslyRaining = raining;
+	    m_bPreviouslyThundering = thundering;
+    }
+    
+    public boolean HasNetherBeenAccessed()
+    {
+    	return m_bHasNetherBeenAccessed;
+    }
+    
+    public void SetNetherBeenAccessed()
+    {
+    	m_bHasNetherBeenAccessed = true;
+    }
+    
+    public boolean HasWitherBeenSummoned()
+    {
+    	return m_bHasWitherBeenSummoned;
+    }
+    
+    public void SetWitherHasBeenSummoned()
+    {
+    	m_bHasWitherBeenSummoned = true;
+    }
+    
+    public boolean HasEndDimensionBeenAccessed()
+    {
+    	return m_bHasEndDimensionBeenAccessed;
+    }
+    
+    public void SetEndDimensionHasBeenAccessed()
+    {
+    	m_bHasEndDimensionBeenAccessed = true;
+    }
+    
+    // END FCMOD
 }
diff --git a/minecraft_server/net/minecraft/src/WorldManager.java b/minecraft_server/net/minecraft/src/WorldManager.java
index d98d9e7..b34fac1 100644
--- a/minecraft_server/net/minecraft/src/WorldManager.java
+++ b/minecraft_server/net/minecraft/src/WorldManager.java
@@ -68,7 +68,10 @@ public class WorldManager implements IWorldAccess
      */
     public void markBlockForUpdate(int par1, int par2, int par3)
     {
-        this.theWorldServer.getPlayerManager().markBlockNeedsUpdate(par1, par2, par3);
+    	// FCMOD: Changed
+        //this.theWorldServer.getPlayerManager().markBlockNeedsUpdate(par1, par2, par3);
+        theWorldServer.GetChunkTracker().FlagBlockForClientUpdate( par1, par2, par3 );
+        // END FCMOD
     }
 
     /**
diff --git a/minecraft_server/net/minecraft/src/WorldServer.java b/minecraft_server/net/minecraft/src/WorldServer.java
index b1d21f9..e3baefe 100644
--- a/minecraft_server/net/minecraft/src/WorldServer.java
+++ b/minecraft_server/net/minecraft/src/WorldServer.java
@@ -1,9 +1,15 @@
 package net.minecraft.src;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
@@ -13,7 +19,12 @@ public class WorldServer extends World
 {
     private final MinecraftServer mcServer;
     private final EntityTracker theEntityTracker;
-    private final PlayerManager thePlayerManager;
+    // FCMOD: Changed
+    //private final PlayerManager thePlayerManager;
+    private final FCChunkTracker m_chunkTracker;
+    // END FCMOD
+    
+    // FCNOTE: Contains NextTickListEntry objects with updates scheduled for blocks
     private Set field_73064_N;
 
     /** All work to do in future ticks. */
@@ -48,8 +59,18 @@ public class WorldServer extends World
     {
         super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
         this.mcServer = par1MinecraftServer;
+        
+        // FCMOD: Added
+        saveHandler.LoadModSpecificData( this );
+        // END FCMOD
+        
         this.theEntityTracker = new EntityTracker(this);
-        this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
+        
+        // FCMOD: Changed
+        //this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
+        m_chunkTracker = new FCChunkTracker( this, 
+        	par1MinecraftServer.getConfigurationManager().getViewDistance());
+        // END FCMOD
 
         if (this.entityIdMap == null)
         {
@@ -91,6 +112,12 @@ public class WorldServer extends World
         {
             this.difficultySetting = 3;
         }
+        // FCMOD: Added to eliminate peaceful and easy difficulties
+        else if ( difficultySetting < 2 )
+        {
+        	difficultySetting = 2;
+        }
+        // END FCMOD
 
         this.provider.worldChunkMgr.cleanupCache();
 
@@ -115,7 +142,12 @@ public class WorldServer extends World
 
         if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
         {
+        	// FCMOD: Code change to prevent animal spawning after chunk generation
+        	/*
             SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
+            */
+            SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, false);
+            // END FCMOD
         }
 
         this.theProfiler.endStartSection("chunkSource");
@@ -134,10 +166,15 @@ public class WorldServer extends World
         this.theProfiler.endStartSection("tickTiles");
         this.tickBlocksAndAmbiance();
         this.theProfiler.endStartSection("chunkMap");
-        this.thePlayerManager.updatePlayerInstances();
+        // FCMOD: Changed
+        //this.thePlayerManager.updatePlayerInstances();
+        m_chunkTracker.Update();
+        // END FCMOD
         this.theProfiler.endStartSection("village");
         this.villageCollectionObj.tick();
-        this.villageSiegeObj.tick();
+        // FCMOD: Removed
+        //this.villageSiegeObj.tick();
+        // END FCMOD
         this.theProfiler.endStartSection("portalForcer");
         this.field_85177_Q.removeStalePortalLocations(this.getTotalWorldTime());
         this.theProfiler.endSection();
@@ -234,7 +271,10 @@ public class WorldServer extends World
         super.tickBlocksAndAmbiance();
         int var1 = 0;
         int var2 = 0;
-        Iterator var3 = this.activeChunkSet.iterator();
+        // FCMOD: Changed
+        //Iterator var3 = this.activeChunkSet.iterator();
+        Iterator<ChunkCoordIntPair> var3 = m_activeChunksCoordsList.iterator();
+        // END FCMOD
 
         while (var3.hasNext())
         {
@@ -252,7 +292,10 @@ public class WorldServer extends World
             int var10;
             int var11;
 
-            if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+            // FCMOD: Changed
+            //if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+            if ( rand.nextInt( 50000 ) == 0 && isRaining() && isThundering() )
+        	// END FCMOD 
             {
                 this.updateLCG = this.updateLCG * 3 + 1013904223;
                 var8 = this.updateLCG >> 2;
@@ -260,9 +303,23 @@ public class WorldServer extends World
                 var10 = var6 + (var8 >> 8 & 15);
                 var11 = this.getPrecipitationHeight(var9, var10);
 
-                if (this.canLightningStrikeAt(var9, var11, var10))
+                // FCMOD: Changed
+                //if (this.canLightningStrikeAt(var9, var11, var10))
+                if ( CanLightningStrikeAtPos( var9, var11, var10 ) )
+            	// END FCMOD
                 {
-                    this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
+                	// FCMOD: Changed
+                    //this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
+                	FCUtilsBlockPos strikePos = new FCUtilsBlockPos( var9, var11, var10 );
+            		
+            		AdjustLightningPosForSurroundings( strikePos );
+            		
+                    if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
+                    {
+                        addWeatherEffect( new FCEntityLightningBolt( this, (double)strikePos.i + 0.5D, 
+                        	(double)strikePos.j, (double)strikePos.k + 0.5D ) );
+                    }
+                	// END FCMOD
                 }
             }
 
@@ -286,12 +343,21 @@ public class WorldServer extends World
                 {
                     this.setBlock(var9 + var5, var11, var10 + var6, Block.snow.blockID);
                 }
+                // FCMOD: Added
+                else if (this.isRaining() && this.canSnowAt(var9 + var5, var11 + 1, var10 + var6))
+                {
+                    setBlock(var9 + var5, var11 + 1, var10 + var6, Block.snow.blockID);
+                }
+                // END FCMOD
 
                 if (this.isRaining())
                 {
                     BiomeGenBase var12 = this.getBiomeGenForCoords(var9 + var5, var10 + var6);
 
-                    if (var12.canSpawnLightningBolt())
+                    // FCMOD: Changed for clarity
+                    //if (var12.canSpawnLightningBolt())
+                    if ( var12.CanRainInBiome() )
+                	// END FCMOD
                     {
                         var13 = this.getBlockId(var9 + var5, var11 - 1, var10 + var6);
 
@@ -309,25 +375,30 @@ public class WorldServer extends World
 
             for (var10 = 0; var10 < var9; ++var10)
             {
-                ExtendedBlockStorage var20 = var19[var10];
+                ExtendedBlockStorage var21 = var19[var10];
 
-                if (var20 != null && var20.getNeedsRandomTick())
+                if (var21 != null && var21.getNeedsRandomTick())
                 {
-                    for (int var21 = 0; var21 < 3; ++var21)
+                    for (int var20 = 0; var20 < 3; ++var20)
                     {
                         this.updateLCG = this.updateLCG * 3 + 1013904223;
                         var13 = this.updateLCG >> 2;
                         int var14 = var13 & 15;
                         int var15 = var13 >> 8 & 15;
                         int var16 = var13 >> 16 & 15;
-                        int var17 = var20.getExtBlockID(var14, var16, var15);
+                        int var17 = var21.getExtBlockID(var14, var16, var15);
                         ++var2;
                         Block var18 = Block.blocksList[var17];
 
                         if (var18 != null && var18.getTickRandomly())
                         {
                             ++var1;
-                            var18.updateTick(this, var14 + var5, var16 + var20.getYLocation(), var15 + var6, this.rand);
+                            // FCMOD: Code changed
+                            /*
+                            var18.updateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, this.rand);
+                            */
+                            var18.RandomUpdateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, rand);
+                            // END FCMOD
                         }
                     }
                 }
@@ -335,6 +406,10 @@ public class WorldServer extends World
 
             this.theProfiler.endSection();
         }
+
+        // FCMOD: Added
+        ModUpdateTick();
+        // END FCMOD
     }
 
     /**
@@ -357,13 +432,21 @@ public class WorldServer extends World
     public void func_82740_a(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
-        byte var8 = 0;
+        // FCMOD: Removed
+        //byte var8 = 0;
+        // END FCMOD
 
         if (this.scheduledUpdatesAreImmediate && par4 > 0)
         {
             if (Block.blocksList[par4].func_82506_l())
             {
+            	// FCCHUNK: Decide on updates around original spawn
+            	// FCMOD: Changed
+            	/*
                 if (this.checkChunksExist(var7.xCoord - var8, var7.yCoord - var8, var7.zCoord - var8, var7.xCoord + var8, var7.yCoord + var8, var7.zCoord + var8))
+                */
+                if ( IsBlockPosActive( var7.xCoord, var7.yCoord, var7.zCoord ) )
+            	// END FCMOD
                 {
                     int var9 = this.getBlockId(var7.xCoord, var7.yCoord, var7.zCoord);
 
@@ -379,7 +462,13 @@ public class WorldServer extends World
             par5 = 1;
         }
 
+    	// FCCHUNK: Decide on updates around original spawn
+    	// FCMOD: Changed
+    	/*
         if (this.checkChunksExist(par1 - var8, par2 - var8, par3 - var8, par1 + var8, par2 + var8, par3 + var8))
+        */
+        if ( IsBlockPosActive( par1, par2, par3 ) )
+        // END FCMOD
         {
             if (par4 > 0)
             {
@@ -420,6 +509,8 @@ public class WorldServer extends World
      */
     public void updateEntities()
     {
+    	// FCMOD: Removed pausing of updates when no players in world.  Replaced elsewhere
+    	/*
         if (this.playerEntities.isEmpty())
         {
             if (this.updateEntityTick++ >= 1200)
@@ -431,6 +522,8 @@ public class WorldServer extends World
         {
             this.resetUpdateEntityTick();
         }
+        */
+    	// END FCMOD
 
         super.updateEntities();
     }
@@ -486,9 +579,16 @@ public class WorldServer extends World
             {
                 var4 = (NextTickListEntry)var14.next();
                 var14.remove();
+            	// FCCHUNK: Decide on updates around original spawn
+                // FCMOD: Changed to prevent neighboring chunks inadvertantly being loaded during
+                // updates.  This was causing stuff like fire loading a ton of chunks in the nether.
+                /*
                 byte var5 = 0;
-
+                
                 if (this.checkChunksExist(var4.xCoord - var5, var4.yCoord - var5, var4.zCoord - var5, var4.xCoord + var5, var4.yCoord + var5, var4.zCoord + var5))
+                */
+                if ( IsBlockPosActive( var4.xCoord, var4.yCoord, var4.zCoord ) )
+            	// END FCMOD
                 {
                     int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
 
@@ -518,10 +618,19 @@ public class WorldServer extends World
                         }
                     }
                 }
+            	// FCCHUNK: Decide on updates around original spawn
+                // FCMOD: Removed to reduce unnecessary overhead of recheduling ticks in inactive chunks
+                /*
                 else
                 {
-                    this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
+                	// FCMOD: Changed to not immediately retick on next update to ease on performance
+                    //this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
+                    scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 
+                    	Block.blocksList[var4.blockID].tickRate( this ) );
+                    // END FCMOD
                 }
+                */
+                // END FCMOD
             }
 
             this.theProfiler.endSection();
@@ -600,6 +709,21 @@ public class WorldServer extends World
 
         if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
         {
+            // Added so that creatures in periphery chunks can still despawn
+            int iEntityI = MathHelper.floor_double( par1Entity.posX );
+            int iEntityK = MathHelper.floor_double( par1Entity.posZ );
+            
+            if ( par2 && !IsBlockPosActive( iEntityI, 0, iEntityK ) && par1Entity.addedToChunk  )
+            {
+                if ( par1Entity.ridingEntity == null )
+                {
+                	par1Entity.OutOfUpdateRangeUpdate();
+                }
+                
+                return; // intentionally skip super call
+            }
+            // END FCMOD
+            
             super.updateEntityWithOptionalForce(par1Entity, par2);
         }
     }
@@ -622,6 +746,12 @@ public class WorldServer extends World
         return this.theChunkProviderServer;
     }
 
+    // FCMOD: Added (server only) alias to match client
+    public List getAllTileEntityInBox( int par1, int par2, int par3, int par4, int par5, int par6 )
+    {
+    	return getTileEntityList( par1, par2, par3, par4, par5, par6 );
+    }
+    // END FCMOD
     /**
      * get a list of tileEntity's
      */
@@ -730,7 +860,10 @@ public class WorldServer extends World
      */
     protected void createBonusChest()
     {
-        WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
+    	// FCMOD: Changed
+        //WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
+        FCWorldGeneratorBonusBasket var1 = new FCWorldGeneratorBonusBasket();
+    	// END FCMOD
 
         for (int var2 = 0; var2 < 10; ++var2)
         {
@@ -773,6 +906,10 @@ public class WorldServer extends World
             }
 
             this.chunkProvider.saveChunks(par1, par2IProgressUpdate);
+
+            // FCMOD: Added
+            saveHandler.SaveModSpecificData( this );
+            // END FCMOD
         }
     }
 
@@ -845,7 +982,19 @@ public class WorldServer extends World
     {
         if (super.addWeatherEffect(par1Entity))
         {
-            this.mcServer.getConfigurationManager().sendPacketToPlayersAroundPoint(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+        	// FCMOD: Changed to avoid modding Packet71Weather        	
+            //this.mcServer.getConfigurationManager().sendPacketToPlayersAroundPoint(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+        	Packet71Weather packet = new Packet71Weather( par1Entity );
+        	
+        	if ( par1Entity instanceof FCEntityLightningBolt )
+        	{
+        		packet.isLightningBolt = 1;
+        	}
+        	
+            this.mcServer.getConfigurationManager().sendPacketToPlayersAroundPoint(
+            	par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, provider.dimensionId, 
+            	packet );
+            // END FCMOD
             return true;
         }
         else
@@ -962,6 +1111,8 @@ public class WorldServer extends World
     /**
      * Updates all weather states.
      */
+    // FCMOD: Removed and replaced later
+    /*
     protected void updateWeather()
     {
         boolean var1 = this.isRaining();
@@ -979,6 +1130,8 @@ public class WorldServer extends World
             }
         }
     }
+    */
+    // END FCMOD
 
     /**
      * Gets the MinecraftServer.
@@ -996,13 +1149,460 @@ public class WorldServer extends World
         return this.theEntityTracker;
     }
 
+    // FCMOD: Removed
+    /*
     public PlayerManager getPlayerManager()
     {
         return this.thePlayerManager;
     }
+    */
+    // END FCMOD
 
     public Teleporter getDefaultTeleporter()
     {
         return this.field_85177_Q;
     }
+
+    // FCMOD: Added
+    private boolean m_bHasTicked = false;
+    
+    protected LinkedList<ChunkCoordIntPair> m_chunksToCheckForUnloadList = 
+    	new LinkedList<ChunkCoordIntPair>();
+    
+    private long m_lNoPlayersOnServerTickCount = 0;
+    
+    // MinecraftServer loads out to 192 blocks, or 12 chunks. One more for wiggle.
+    
+    private final int m_iChunksAroundSpawnToCheckForUnload = 13;  
+    
+    @Override
+    public void ModSpecificTick()
+    {
+    	if ( !m_bHasTicked )
+    	{
+    		m_bHasTicked = true;
+
+    		MarkChunksAroundSpawnToCheckForUnload();
+    	}    	    	
+    	
+		CheckChunksToUnloadList();
+    }    
+    
+    public void AddChunkToCheckForUnloadList( int iChunkX, int iChunkZ )
+    {
+    	m_chunksToCheckForUnloadList.add( new ChunkCoordIntPair( iChunkX, iChunkZ ) );
+    }
+    
+    public void AddChunkRangeToCheckForUnloadList( int iMinChunkX, int iMinChunkZ, 
+    	int iMaxChunkX, int iMaxChunkZ )
+    {
+    	for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
+    	{
+        	for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
+        	{
+        		AddChunkToCheckForUnloadList( iTempChunkX, iTempChunkZ );
+        	}
+    	}
+    }
+    
+    private void CheckChunksToUnloadList()
+    {
+    	if ( !m_chunksToCheckForUnloadList.isEmpty() )
+    	{
+        	Iterator<ChunkCoordIntPair> tempIterator = m_chunksToCheckForUnloadList.iterator();
+        	
+        	while ( tempIterator.hasNext() )
+        	{
+        		ChunkCoordIntPair tempCoord = tempIterator.next();
+        		
+        		if ( CheckChunkShouldBeUnloaded( tempCoord.chunkXPos, tempCoord.chunkZPos ) )
+        		{
+        			theChunkProviderServer.ForceAddToChunksToUnload( 
+        				tempCoord.chunkXPos, tempCoord.chunkZPos );
+        		}
+        	}
+    		
+    		m_chunksToCheckForUnloadList.clear();
+    	}
+    }
+    
+    private boolean CheckChunkShouldBeUnloaded( int iChunkX, int iChunkZ )
+    {
+    	return chunkExists( iChunkX, iChunkZ ) && 
+    		!m_chunkTracker.IsChunkBeingWatched( iChunkX, iChunkZ  )&&
+    		!theChunkProviderServer.IsSpawnChunk( iChunkX, iChunkZ );
+    }
+    
+    private void MarkChunksAroundSpawnToCheckForUnload()
+    {
+    	// this function cleans up extra useless overworld chunks loaded by 
+    	// MinecraftServer.initialWorldChunkLoad()
+    	
+		if ( provider.canRespawnHere() )
+		{
+			int iSpawnChunkX = worldInfo.getSpawnX() >> 4;
+			int iSpawnChunkZ = worldInfo.getSpawnZ() >> 4;
+            
+            AddChunkRangeToCheckForUnloadList( 
+            	iSpawnChunkX - m_iChunksAroundSpawnToCheckForUnload, 
+            	iSpawnChunkZ - m_iChunksAroundSpawnToCheckForUnload,
+            	iSpawnChunkX + m_iChunksAroundSpawnToCheckForUnload, 
+            	iSpawnChunkZ + m_iChunksAroundSpawnToCheckForUnload );        
+		}
+    }
+
+    @Override
+    public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
+    {
+        NextTickListEntry tempEntry = new NextTickListEntry( i, j, k, iBlockID );
+        
+        return field_73064_N.contains( tempEntry );
+    }
+
+    @Override
+    protected void updateWeather()
+    {
+    	// Vanilla code replaced to fix storms not relaying state to clients and a couple of other little oddities like the state
+    	// changes for weather not being communicated immeditately
+    	
+        super.updateWeather();
+
+        if ( worldInfo.m_bPreviouslyRaining != worldInfo.isRaining() )
+        {
+            if ( worldInfo.isRaining() )
+            {
+                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 1, 0 ) );
+            }
+            else
+            {
+                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 2, 0 ) );
+            }
+            
+            worldInfo.m_bPreviouslyRaining = worldInfo.isRaining();
+        }
+        
+        if ( worldInfo.m_bPreviouslyThundering != worldInfo.isThundering() )
+        {
+            if ( worldInfo.isThundering() )
+            {
+                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 7, 0 ) );
+            }
+            else
+            {
+                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 8, 0 ) );
+            }
+            
+            worldInfo.m_bPreviouslyThundering = worldInfo.isThundering();
+        }
+    }
+    
+    private void ModUpdateTick()
+    {
+    	ValidateMagneticPointList();
+    	
+    	ValidateLootingBeaconList();
+    	
+    	ValidateSpawnLocationList();
+    }
+    
+    private void ValidateMagneticPointList()
+    {
+    	// periodically check the magnetic point list for dead points
+    	
+    	int iTimeFactor = (int)getWorldTime();
+    	
+    	if ( ( iTimeFactor & 15 ) == 0 )
+    	{
+    		int iListLength = m_MagneticPointList.m_MagneticPoints.size();
+    		
+    		if ( iListLength > 0 )
+    		{
+        		iTimeFactor = iTimeFactor >> 4;
+                
+    			int iTempIndex = (int)( iTimeFactor % iListLength );
+    			
+    			FCMagneticPoint tempPoint = (FCMagneticPoint)m_MagneticPointList.m_MagneticPoints.get( iTempIndex );
+    			
+    	        if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
+    	        {
+    	        	// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
+    	        	
+    	        	if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
+    	        	{
+    	        		m_MagneticPointList.m_MagneticPoints.remove( iTempIndex );
+    	        		
+    	        	}
+    	        }    			
+    		}
+    	}
+    }
+    
+    private void ValidateLootingBeaconList()
+    {
+    	// periodically check the looting beacon list for dead points
+    	
+    	int iTimeFactor = (int)getWorldTime();
+    	
+    	if ( ( iTimeFactor & 15 ) == 0 )
+    	{
+    		int iListLength = m_LootingBeaconLocationList.m_EffectLocations.size();
+    		
+    		if ( iListLength > 0 )
+    		{
+        		iTimeFactor = iTimeFactor >> 4;
+                
+    			int iTempIndex = (int)( iTimeFactor % iListLength );
+    			
+    			FCBeaconEffectLocation tempPoint = (FCBeaconEffectLocation)m_LootingBeaconLocationList.m_EffectLocations.get( iTempIndex );
+    			
+    	        if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
+    	        {
+    	        	// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
+    	        	
+    	        	if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
+    	        	{
+    	        		m_LootingBeaconLocationList.m_EffectLocations.remove( iTempIndex );
+    	        		
+    	        	}
+    	        }    			
+    		}
+    	}
+    }
+    
+    private void ValidateSpawnLocationList()
+    {
+    	// periodically check the list for dead points
+    	
+    	long lWorldTime = getWorldTime();
+    	
+    	if ( ( lWorldTime & 15 ) == 0 )
+    	{
+        	Iterator tempIterator = m_SpawnLocationList.m_SpawnLocations.iterator();
+        	
+        	while ( tempIterator.hasNext() )
+        	{
+        		FCSpawnLocation tempPoint = (FCSpawnLocation)tempIterator.next();
+        		
+        		if ( lWorldTime < tempPoint.m_lSpawnTime || lWorldTime - tempPoint.m_lSpawnTime > FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
+        		{        			
+        			tempIterator.remove();
+        		}        		
+        	}
+    	}
+    }
+    
+    protected void AdjustLightningPosForSurroundings( FCUtilsBlockPos strikePos )
+    {
+    	int iHighJ = strikePos.j;
+    	
+    	// store bounds variables since strikePos changes during search
+    	
+    	int iMinI = strikePos.i - 16;
+    	int iMinK = strikePos.k - 16;
+    	
+    	int iMaxI = strikePos.i + 16;
+    	int iMaxK = strikePos.k + 16;
+    	
+    	for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
+    	{
+        	for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
+        	{
+                int iTempJ = getPrecipitationHeight( iTempI, iTempK );
+                
+                if ( iTempJ > iHighJ )
+                {
+                    if ( CanLightningStrikeAtPos( iTempI, iTempJ, iTempK ) )
+                    {
+	                	strikePos.i = iTempI;
+	                	iHighJ = strikePos.j = iTempJ;
+	                	strikePos.k = iTempK;
+                    }
+                }
+        	}
+    	}    	
+    	
+    	// check entities
+    	
+        List<Entity> entityList = getEntitiesWithinAABB( Entity.class, AxisAlignedBB.getAABBPool().getAABB( 
+        	iMinI, iHighJ, iMinK, iMaxI + 1D, 256D, iMaxK + 1D ) );
+    	
+        Iterator<Entity> entityIterator = entityList.iterator();
+
+        while ( entityIterator.hasNext() )
+        {
+            Entity tempEntity = entityIterator.next();
+            
+            if ( tempEntity.isEntityAlive() && tempEntity.AttractsLightning() )
+            {
+            	int iEntityMaxJ = (int)tempEntity.boundingBox.maxY + 1;
+            	
+            	if ( iEntityMaxJ > iHighJ )
+            	{            	
+	            	int iEntityI = MathHelper.floor_double( tempEntity.posX );
+	            	int iEntityK = MathHelper.floor_double( tempEntity.posZ );
+	            	
+	                int iPrecipitationJ = getPrecipitationHeight( iEntityI, iEntityK );
+	                
+	                if ( iPrecipitationJ <= iEntityMaxJ &&
+	                	CanLightningStrikeAtPos( iEntityI, iPrecipitationJ, iEntityK ) )
+	                {
+	                	strikePos.i = iEntityI;
+	                	iHighJ = strikePos.j = iPrecipitationJ;
+	                	strikePos.k = iEntityK;
+	                }	                
+            	}                
+            }
+        }
+
+        // secondary search for lightning rods in a larger area around new strike pos
+        
+        if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
+        {
+        	iMinI = strikePos.i - 16;
+        	iMinK = strikePos.k - 16;
+        	
+        	iMaxI = strikePos.i + 16;
+        	iMaxK = strikePos.k + 16;
+        	
+        	for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
+        	{
+            	for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
+            	{
+                    int iTempJ = getPrecipitationHeight( iTempI, iTempK );
+                    
+                    if ( iTempJ > iHighJ && getBlockId( iTempI, iTempJ - 1, iTempK ) == 
+                    	FCBetterThanWolves.fcBlockLightningRod.blockID )
+                    {
+                    	// intentionally don't test CanLightningStrikeAtPos() so that
+                    	// rods in non-lightning biomes can still attract lightning to them
+                    	
+	                	strikePos.i = iTempI;
+	                	iHighJ = strikePos.j = iTempJ;
+	                	strikePos.k = iTempK;
+                    }
+            	}
+        	}        	
+        }
+    }
+    
+    @Override
+    public int GetClampedViewDistanceInChunks()
+    {
+    	int iRange = getMinecraftServer().getConfigurationManager().getViewDistance();
+    	
+    	return MathHelper.clamp_int( iRange, 3, 15 );
+    }
+    
+    @Override
+    protected void UpdateActiveChunkMap()
+    {
+    	super.UpdateActiveChunkMap();
+    	
+    	UpdateServerIdleState();    	
+    	
+    	// FCCHUNK: Decide on updates around original spawn
+    	
+    	if ( provider.dimensionId == 0 && !IsServerIdle() )
+    	{
+	        ChunkCoordinates originalSpawn = getSpawnPoint();
+	        
+	        AddAreaAroundChunkToActiveChunkMap( originalSpawn.posX >> 4, 
+	        	originalSpawn.posZ >> 4 );
+    	}
+    }
+    
+    public FCChunkTracker GetChunkTracker()
+    {
+        return m_chunkTracker;
+    }    
+
+    protected void UpdateServerIdleState()
+    {
+        if ( !AreAnyPlayersOnServer() )
+        {
+        	m_lNoPlayersOnServerTickCount++;
+        }
+        else
+        {
+        	m_lNoPlayersOnServerTickCount = 0;
+        }
+    }
+    
+    protected boolean IsServerIdle()
+    {
+        return m_lNoPlayersOnServerTickCount >= 1200L;
+    }
+    
+    protected boolean AreAnyPlayersOnServer()
+    {
+    	return mcServer.getCurrentPlayerCount() > 0;
+    }
+
+	//------------ Addon Data Handling -----------//
+
+	private Map<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> addonWorldDataMap = new HashMap();
+
+	public void saveWorldDataToNBT(File dimensionDirectory) {
+		for (Map.Entry<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> entry : addonWorldDataMap.entrySet()) {
+			NBTTagCompound modData = new NBTTagCompound();
+	        
+			entry.getValue().saveWorldDataToNBT(this, modData);
+	        
+	        NBTTagCompound fileData = new NBTTagCompound();
+	        
+	        fileData.setTag( "Data", modData );
+
+	        try {
+	            File modSaveFile = new File(dimensionDirectory, entry.getValue().getFilename() + ".dat");
+	            
+	            if (modSaveFile.exists()) {
+	            	modSaveFile.delete();
+	            }
+	            
+	            CompressedStreamTools.writeCompressed( fileData, new FileOutputStream(modSaveFile) );
+
+	        }
+	        catch (Exception e) {
+	            e.printStackTrace();
+	        }
+		}
+	}
+
+	public void loadWorldDataFromNBT(File dimensionDirectory) {
+		addonWorldDataMap = FCAddOnHandler.initWorldDataForAddon();
+		
+		for (Map.Entry<Class<? extends FCAddOn>, FCAddOnUtilsWorldData> entry : addonWorldDataMap.entrySet()) {
+			File modSaveFile = null;
+			
+			try {
+				modSaveFile = new File(dimensionDirectory, entry.getValue().getFilename() + ".dat");
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+
+			if (modSaveFile != null && modSaveFile.exists()) {
+				try {
+					NBTTagCompound fileTag = CompressedStreamTools.readCompressed( new FileInputStream(modSaveFile));
+					NBTTagCompound dataTag = fileTag.getCompoundTag("Data");
+
+					entry.getValue().loadWorldDataFromNBT(this, dataTag);
+				}
+				catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	public FCAddOnUtilsWorldData getWorldDataForMod(Class<? extends FCAddOn> mod) {
+		if (addonWorldDataMap.containsKey(mod))
+			return addonWorldDataMap.get(mod);
+		else
+			return null;
+	}
+
+	public void setWorldDataForMod(Class<? extends FCAddOn> mod, FCAddOnUtilsWorldData data) {
+		addonWorldDataMap.put(mod, data);
+	}
+    // END FCMOD
 }
